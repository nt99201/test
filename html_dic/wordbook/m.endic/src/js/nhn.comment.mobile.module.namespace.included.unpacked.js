/**
 * Jindo2 Framework
 * @type desktop
 * @version 2.0.1
 * NHN_Library:Jindo-2.0.1;JavaScript Framework;
 */
//-!namespace.default start!-//
/**
 * @fileOverview	$() 함수, $Jindo() 객체, $Class() 객체를 정의한 파일.
 */
if (typeof window != 'undefined' && window.nhn === undefined) {
	window.nhn = {};
}

if (window.nhn.comment === undefined) {
	window.nhn.comment = {};
}

if (window.nhn.comment.mobile === undefined) {
	window.nhn.comment.mobile = {};
}

if (window.nhn.comment.mobile.jindo === undefined) {
	window.nhn.comment.mobile.jindo = {};
}

var MobileCommentJindo = window.nhn.comment.mobile.jindo;

/**

 *	@description agent의 dependency를 없애기 위해 별로도 설정.
 *	@ignore

 **/
var _j_ag = navigator.userAgent;
var _JINDO_IS_IE = _j_ag.indexOf("MSIE") > -1;
var _JINDO_IS_FF = _j_ag.indexOf("Firefox") > -1;
var _JINDO_IS_OP = _j_ag.indexOf("Opera") > -1;
var _JINDO_IS_SP = _j_ag.indexOf("Safari") > -1;
var _JINDO_IS_SF = _j_ag.indexOf("Apple") > -1;
var _JINDO_IS_CH = _j_ag.indexOf("Chrome") > -1;
var _JINDO_IS_WK = _j_ag.indexOf("WebKit") > -1;
var _JINDO_IS_MO = /(iPad|Mobile|Android|Nokia|webOS|BlackBerry|Opera Mini)/.test(_j_ag);
//-!namespace.default end!-//

//-!MobileCommentJindo.$Jindo.default start!-//
/**

 * @class $Jindo 객체는 프레임워크에 대한 정보와 유틸리티 함수를 제공한다.
 * @constructor
 * @description $Jindo() 객체를 생성한다. $Jindo 객체는 프레임웍에 대한 정보와 유틸리티 함수를 제공한다. 다음은 Jindo 프레임워크 정보를 담고 있는 객체의 속성을 설명한 표이다.<br>
<table>
	<caption>Jindo 프레임워크 정보 객체 속성</caption>
	<thead>
		<tr>
			<th scope="col">이름</th>
			<th scope="col">타입</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>version</td>
			<td>Number</td>
			<td>Jindo 프레임워크의 버전을 저장한다.</td>
		</tr>
 </table>

 */
MobileCommentJindo.$Jindo = function() {
	//-@@$Jindo.default-@@//
	var cl=arguments.callee;
	var cc=cl._cached;

	if (cc) return cc;
	if (!(this instanceof cl)) return new cl();
	if (!cc) cl._cached = this;

	this.version = "2.0.1";
};
/**

 * @description 호환 모드를 설정하거 반환하는 함수.
 * @ignore
 * @name $Jindo#compatible
 * @param {Boolean} bType
 * @return {Boolean} [true|false]

 */
MobileCommentJindo.$Jindo.compatible = function(){
	return false;
};

var _objToString = Object.prototype.toString;
var _slice = Array.prototype.slice;

MobileCommentJindo.$Error = function(sMessage,sMethod){
	this.message = "\tmethod : "+sMethod+"\n\tmessage : "+sMessage;
	this.type = "Jindo Custom Error";
	this.toString = function(){
		return this.message+"\n\t"+this.type;
	}
};

MobileCommentJindo.$Except = {
	CANNOT_USE_OPTION:"해당 옵션은 사용할 수 없습니다.",
	PARSE_ERROR:"파싱중 에러가 발생했습니다.",
	NOT_FOUND_ARGUMENT:"파라메터가 없습니다.",
	NOT_STANDARD_QUERY:"css셀렉터가 정상적이지 않습니다.",
	INVALID_DATE:"날짜 포멧이 아닙니다.",
	REQUIRE_AJAX:"가 없습니다.",
	NOT_FOUND_ELEMENT:"엘리먼트가 없습니다.",
	HAS_FUNCTION_FOR_GROUP:"그룹으로 지우지 않는 경우 detach할 함수가 있어야 합니다.",
	NONE_ELEMENT:"에 해당하는 엘리먼트가 없습니다.",
	NOT_SUPPORT_SELECTOR:"는 지원하지 않는 selector입니다.",
	NOT_SUPPORT_METHOD:"desktop에서 지원하지 않는 메서드 입니다.",
	JSON_MUST_HAVE_ARRAY_HASH:"get메서드는 json타입이 hash나 array타입만 가능합니다.",
	MUST_APPEND_DOM : "document에 붙지 않은 엘리먼트를 기준 엘리먼트로 사용할 수 없습니다.",
	NOT_USE_CSS : "는 css를 사용 할수 없습니다.",
	NOT_WORK_DOMREADY : "domready이벤트는 iframe안에서 사용할 수 없습니다."
};

/**
 * @ignore
 */
function _toArray(aArray){
	return _slice.apply(aArray);
}

try{
	_slice.apply(document.documentElement.childNodes);
}catch(e){
	_toArray = function(aArray){
		var returnArray = [];
		var leng = aArray.length;
		for ( var i = 0; i < leng; i++ ) {
			returnArray.push( aArray[i] );
		}
		return returnArray;
	}
}
/**

 * @description 파라메터가 Function인지 확인하는 함수.
 * @static
 * @function
 * @name $Jindo#isFunction
 * @since 2.0.0
 * @param {Variant} oObj
 * @return {Boolean} [true|false]

 */

/**

 * @description 파라메터가 Array인지 확인하는 함수.
 * @static
 * @function
 * @name $Jindo#isArray
 * @since 2.0.0
 * @param {Variant} oObj
 * @return {Boolean} [true|false]

 */

/**

 * @description 파라메터가 String인지 확인하는 함수.
 * @static
 * @function
 * @name $Jindo#isString
 * @since 2.0.0
 * @param {Variant} oObj
 * @return {Boolean} [true|false]

 */

/**

 * @description 파라메터가 Numeric인지 확인하는 함수.
 * @static
 * @function
 * @name $Jindo#isNumeric
 * @since 2.0.0
 * @param {Variant} oObj
 * @return {Boolean} [true|false]

 */
MobileCommentJindo.$Jindo.isNumeric = function(nNum){
	return !isNaN(parseFloat(nNum)) && !MobileCommentJindo.$Jindo.isArray(nNum) &&isFinite( nNum );
};
/**

 * @description 파라메터가 Boolean인지 확인하는 함수.
 * @static
 * @function
 * @name $Jindo#isBoolean
 * @since 2.0.0
 * @param {Variant} oObj
 * @return {Boolean} [true|false]

 */
/**

 * @description 파라메터가 Date인지 확인하는 함수.
 * @static
 * @function
 * @name $Jindo#isDate
 * @since 2.0.0
 * @param {Variant} oObj
 * @return {Boolean} [true|false]

 */
/**

 * @description 파라메터가 Regexp인지 확인하는 함수.
 * @static
 * @function
 * @name $Jindo#isRegexp
 * @since 2.0.0
 * @param {Variant} oObj
 * @return {Boolean} [true|false]

 */
/**

 * @description 파라메터가 Element인지 확인하는 함수.
 * @static
 * @function
 * @name $Jindo#isElement
 * @since 2.0.0
 * @param {Variant} oObj
 * @return {Boolean} [true|false]

 */
/**

 * @description 파라메터가 Document인지 확인하는 함수.
 * @static
 * @function
 * @name $Jindo#isDocument
 * @since 2.0.0
 * @param {Variant} oObj
 * @return {Boolean} [true|false]

 */
(function(){
	var oType = {"Element" : 1,"Document" : 9};
	for(var i in oType){
		MobileCommentJindo.$Jindo["is"+i] = (function(sType,nNodeNumber){
			return function(oObj){
				if(new RegExp(sType).test(_objToString.call(oObj))){
					return true;
				}else if(_objToString.call(oObj) == "[object Object]"&&oObj !== null&&oObj !== undefined&&oObj.nodeType==nNodeNumber){
					return true;
				}
				return false;
			}
		})(i,oType[i])
	}
	var _$type = ["Function","Array","String","Boolean","Date","RegExp"];
	for(var i = 0, l = _$type.length; i < l ;i++){
		MobileCommentJindo.$Jindo["is"+_$type[i]] = (function(type){
			return function(oObj){
				return _objToString.call(oObj) == "[object "+type+"]";
			}
		})(_$type[i]);
	}
})();

/**

 * @description 파라메터가 Node인지 확인하는 함수.
 * @static
 * @function
 * @since 2.0.0
 * @param {Variant} oObj
 * @return {Boolean} [true|false]

 */
MobileCommentJindo.$Jindo.isNode = function(eEle){
	try{
		return !!(eEle&&eEle.nodeType);
	}catch(e){
		return false;
	}
};

/**

 * @description 파라메터가 Hash인지 확인하는 함수.
 * @static
 * @function
 * @name $Jindo#isHash
 * @since 2.0.0
 * @param {Variant} oObj
 * @return {Boolean} [true|false]

 */
MobileCommentJindo.$Jindo.isHash = function(oObj){
	return _objToString.call(oObj) == "[object Object]"&&oObj !== null&&oObj !== undefined&&!!!oObj.nodeType&&!MobileCommentJindo.$Jindo.isWindow(oObj);
};

/**

 * @description 파라메터가 Null인지 확인하는 함수.
 * @function
 * @name $Jindo#isNull
 * @since 2.0.0
 * @param {Variant} oObj
 * @return {Boolean} [true|false]

 */
MobileCommentJindo.$Jindo.isNull = function(oObj){
	return oObj === null;
};
/**

 * @description 파라메터가 Undefined인지 확인하는 함수.
 * @static
 * @function
 * @name $Jindo#isUndefined
 * @since 2.0.0
 * @param {Variant} oObj
 * @return {Boolean} [true|false]

 */
MobileCommentJindo.$Jindo.isUndefined = function(oObj){
	return oObj === undefined;
};

/**

 * @description 파라메터가 Window인지 확인하는 함수.
 * @static
 * @function
 * @since 2.0.0
 * @param {Variant} oObj
 * @return {Boolean} [true|false]

 */
MobileCommentJindo.$Jindo.isWindow = function(oObj){
	return oObj == window || oObj == window.top;
};
/**
 * @ignore
 */
MobileCommentJindo.$Jindo.Break = function(){
	if (!(this instanceof arguments.callee)) throw new arguments.callee;
};
/**
 * @ignore
 */
MobileCommentJindo.$Jindo.Continue = function(){
	if (!(this instanceof arguments.callee)) throw new arguments.callee;
};

/**

 * @description 함수 파라미터가 원하는 규칙에 맞는지 검사한다.
 * @param {Array} aArgs 파라미터 목록
 * @param {Hash} oRules 규칙 목록
 * @param {String} sFuncName 에러메시지를 보여줄때 사용할 함수명
 * @return {Object}
 * @ignore

 */
MobileCommentJindo.$Jindo._F = function(sKeyType) {
	return sKeyType;
};

MobileCommentJindo.$Jindo._warn = function(nCurrentLength, nMaxLength, sMessage) {
	if(nCurrentLength > nMaxLength) window.console && ( (console.warn && console.warn('추가적인 파라메터가 있습니다. : '+sMessage), true) || (console.log && console.log('추가적인 파라메터가 있습니다. : '+sMessage), true) );
};

MobileCommentJindo.$Jindo.checkVarType = function(aArgs, oRules, sFuncName) {

	var sFuncName = sFuncName || aArgs.callee.name || 'anonymous';

	var $Jindo = MobileCommentJindo.$Jindo;
	var bCompat = $Jindo.compatible();

	var fpChecker = aArgs.callee['_checkVarType_' + bCompat];
	if (fpChecker) { return fpChecker(aArgs, oRules, sFuncName); }

	var aPrependCode = [];
	aPrependCode.push('var nArgsLen = aArgs.length;');
	aPrependCode.push('var $Jindo = MobileCommentJindo.$Jindo;');

	if (bCompat) {
		aPrependCode.push('var nMatchScore;');
		aPrependCode.push('var nMaxMatchScore = -1;');
		aPrependCode.push('var oFinalRet = null;');
	}

	var aBodyCode = [];
	var nMaxRuleLen = 0;

	for (var sType in oRules) if (oRules.hasOwnProperty(sType)) {
		nMaxRuleLen = Math.max(oRules[sType].length, nMaxRuleLen);
	}

	for (var sType in oRules) if (oRules.hasOwnProperty(sType)) {

		// console.log(sType);

		var aRule = oRules[sType];
		var nRuleLen = aRule.length;

		var aBodyPrependCode = [];
		var aBodyIfCode = [];
		var aBodyThenCode = [];

		if (!bCompat) {
			if (nRuleLen < nMaxRuleLen) { aBodyIfCode.push('nArgsLen === ' + nRuleLen); }
			else { aBodyIfCode.push('nArgsLen >= ' + nRuleLen); }
		}

		aBodyThenCode.push('var oRet = new MobileCommentJindo.$Jindo._varTypeRetObj();');

		var nTypeCount = nRuleLen;

		for (var i = 0; i < nRuleLen; ++i) {

			/^([^:]+):([^\+]*)(\+?)$/.test(aRule[i]);

			var sVarName = RegExp.$1;
			var sVarType = RegExp.$2;
			var bAutoCast = RegExp.$3 ? true : false;

			// 모든 타입을 허용하면
			if (sVarType === 'Variant') {

				if (bCompat) {
					aBodyIfCode.push(i + ' in aArgs');
				}

				aBodyThenCode.push('oRet["' + sVarName + '"] = aArgs[' + i + '];');
				nTypeCount--;

			// 사용자 정의 타입이면
			} else if (MobileCommentJindo.$Jindo._varTypeList[sVarType]) {

				var vVar = 'tmp' + sVarType + '_' + i;

				aBodyPrependCode.push('var ' + vVar + ' = MobileCommentJindo.$Jindo._varTypeList.' + sVarType + '(aArgs[' + i + '], ' + bAutoCast + ');');
				aBodyIfCode.push(vVar + ' !== MobileCommentJindo.$Jindo.VARTYPE_NOT_MATCHED');
				aBodyThenCode.push('oRet["' + sVarName + '"] = ' + vVar + ';');

			// Jindo 랩핑 타입이면
			} else if (/^\$/.test(sVarType) && MobileCommentJindo[sVarType]) {

				var sOR = '';
				var sNativeVarType;

				if (bAutoCast) {
					sNativeVarType = ({ $Fn : 'Function', $S : 'String', $A : 'Array', $H : 'Hash', $ElementList : 'Array' })[sVarType] || sVarType.replace(/^\$/, '');
					if ($Jindo['is' + sNativeVarType]) {
						sOR = ' || MobileCommentJindo.$Jindo.is' + sNativeVarType + '(vNativeArg_' + i + ')';
					}
				}

				aBodyIfCode.push('(aArgs[' + i + '] instanceof MobileCommentJindo.' + sVarType + sOR + ')');
				aBodyThenCode.push('oRet["' + sVarName + '"] = MobileCommentJindo.' + sVarType + '(aArgs[' + i + ']);');

			// 기타 Native 타입이면
			} else if ($Jindo['is' + sVarType]) {

				var sOR = '';
				var sWrapedVarType;

				if (bAutoCast) {
					sWrapedVarType = ({ 'Function' : '$Fn', 'String' : '$S', 'Array' : '$A', 'Hash' : '$H' })[sVarType] || '$' + sVarType;
					if (MobileCommentJindo[sWrapedVarType]) {
						sOR = ' || aArgs[' + i + '] instanceof MobileCommentJindo.' + sWrapedVarType;
					}
				}

				aBodyIfCode.push('(MobileCommentJindo.$Jindo.is' + sVarType + '(aArgs[' + i + '])' + sOR + ')');
				aBodyThenCode.push('oRet["' + sVarName + '"] = vNativeArg_' + i + ';');

			// 없는 타입이면
			} else {

				throw new Error('VarType(' + sVarType + ') Not Found');

			}

		}

		aBodyThenCode.push('oRet.__type = "' + sType + '";');

		if (bCompat) {
			aBodyThenCode.push('nMatchScore = ' + (nRuleLen * 1000 + nTypeCount * 10) + ' + (nArgsLen === ' + nRuleLen + ' ? 1 : 0);');
			aBodyThenCode.push('if (nMatchScore > nMaxMatchScore) {');
			aBodyThenCode.push('	nMaxMatchScore = nMatchScore;');
			aBodyThenCode.push('	oFinalRet = oRet;');
			aBodyThenCode.push('}');
		} else {
			aBodyThenCode.push('return oRet;');
		}

		aBodyCode.push(aBodyPrependCode.join('\n'));

		if (aBodyIfCode.length) { aBodyCode.push('if (' + aBodyIfCode.join(' && ') + ') {'); }
		aBodyCode.push(aBodyThenCode.join('\n'));
		if (aBodyIfCode.length) { aBodyCode.push('}'); }

	}

	aPrependCode.push('	MobileCommentJindo.$Jindo._warn(nArgsLen,'+nMaxRuleLen+',"'+sFuncName+'");');

	for (var i = 0; i < nMaxRuleLen; ++i) {
		var sArg = 'aArgs[' + i + ']';
		aPrependCode.push([ 'var vNativeArg_', i, ' = ', sArg, ' && ', sArg, '.$value ? ', sArg, '.$value() : ', sArg + ';' ].join(''));
	}

	if (!bCompat) {
		aBodyCode.push('MobileCommentJindo.$Jindo.checkVarType._throwException(aArgs, oRules, sFuncName);');
	}

	aBodyCode.push('return oFinalRet;');

	// if (bCompat) { console.log(aPrependCode.join('\n') + aBodyCode.join('\n')); }

	aArgs.callee['_checkVarType_' + bCompat] = fpChecker = new Function('aArgs,oRules,sFuncName', aPrependCode.join('\n') + aBodyCode.join('\n'));

	return fpChecker(aArgs, oRules, sFuncName);

};

MobileCommentJindo.$Jindo._varTypeRetObj = function() {};
MobileCommentJindo.$Jindo._varTypeRetObj.prototype.toString = function() { return this.__type; };

MobileCommentJindo.$Jindo.checkVarType._throwException = function(aArgs, oRules, sFuncName) {

	var fpGetType = function(vArg) {

		for (var sKey in MobileCommentJindo) if (MobileCommentJindo.hasOwnProperty(sKey)) {
			var oConstructor = MobileCommentJindo[sKey];
			if (typeof oConstructor !== 'function') { continue; }
			if (vArg instanceof oConstructor) { return sKey; }
		}

		var $Jindo = MobileCommentJindo.$Jindo;

		for (var sKey in MobileCommentJindo.$Jindo) if (MobileCommentJindo.$Jindo.hasOwnProperty(sKey)) {
			if (!/^is(.+)$/.test(sKey)) { continue; }
			var sType = RegExp.$1;
			var fpMethod = MobileCommentJindo.$Jindo[sKey];
			if (fpMethod(vArg)) { return sType; }
		}

		return 'Unknown';

	};

	var fpErrorMessage = function(sUsed, aSuggs, sURL) {

		var aMsg = [ '잘못된 파라미터입니다.', '' ];

		if (sUsed) {
			aMsg.push('호출한 형태 :');
			aMsg.push('\t' + sUsed);
			aMsg.push('');
		}

		if (aSuggs.length) {
			aMsg.push('사용 가능한 형태 :');
			for (var i = 0, nLen = aSuggs.length; i < nLen; i++) {
				aMsg.push('\t' + aSuggs[i]);
			}
			aMsg.push('');
		}

		if (sURL) {
			aMsg.push('매뉴얼 페이지 :');
			aMsg.push('\t' + sURL);
			aMsg.push('');
		}

		aMsg.unshift();

		return aMsg.join('\n');

	};

	var aArgName = [];

	for (var i = 0, ic = aArgs.length; i < ic; ++i) {
		try { aArgName.push(fpGetType(aArgs[i])); }
		catch(e) { aArgName.push('Unknown'); }
	}

	var sUsed = sFuncName + '(' + aArgName.join(', ') + ')';
	var aSuggs = [];

	for (var sKey in oRules) if (oRules.hasOwnProperty(sKey)) {
		var aRule = oRules[sKey];
		aSuggs.push('' + sFuncName + '(' + aRule.join(', ').replace(/(^|,\s)[^:]+:/g, '$1') + ')');
	}

	var sURL;

	if (/(\$\w+)(#\w+)?/.test(sFuncName)) {
		sURL = 'http://jindo.dev.naver.com/docs/jindo/2.0.1/@type@/@lang@/symbols/' + encodeURIComponent(RegExp.$1) + '.html' + RegExp.$2;
	}

	throw new TypeError(fpErrorMessage(sUsed, aSuggs, sURL));

};

/**

 * @description checkVarType 를 수행할때 사용할 타입을 설정한다.
 *
 * @param1 {String+} sTypeName 타입 이름
 * @param1 {Function+} fpFunc 타입을 검사하는 규칙을 구현하는 함수
 * @return1 {$Jindo}
 * @ignore
 *
 * checkVarType 를 수행할때 사용할 여러개의 타입들을 한번에 설정한다.
 * @param2 {Hash+} oTypeLists 타입 규칙을 담은 객체
 * @return2 {$Jindo}
 * @ignore
 *
 * checkVarType 를 수행할때 사용하고 있는 타입을 얻는다.
 * @param3 {String+} sTypeName 타입 이름
 * @return3 {Function} 타입을 검사하는 규칙을 구현하는 함수
 * @ignore

 */
MobileCommentJindo.$Jindo.varType = function() {

	var oArgs = this.checkVarType(arguments, {
		's4str' : [ 'sTypeName:String+', 'fpFunc:Function+' ],
		's4obj' : [ 'oTypeLists:Hash+' ],
		'g' : [ 'sTypeName:String+' ]
	});

	var sDenyTypeListComma = MobileCommentJindo.$Jindo._denyTypeListComma;

	switch (oArgs+"") {
	case 's4str':
		var sTypeNameComma = ',' + oArgs.sTypeName.replace(/\+$/, '') + ',';
		if (sDenyTypeListComma.indexOf(sTypeNameComma) > -1) {
			throw new Error('Not allowed Variable Type');
		}

		this._varTypeList[oArgs.sTypeName] = oArgs.fpFunc;
		return this;

	case 's4obj':
		var oTypeLists = oArgs.oTypeLists;
		for (var sTypeName in oTypeLists) if (oTypeLists.hasOwnProperty(sTypeName)) {
			fpFunc = oTypeLists[sTypeName];
			arguments.callee.call(this, sTypeName, fpFunc);
		}
		return this;

	case 'g':
		return this._varTypeList[oArgs.sTypeName];
	}

};

/**

 * varType 에 등록한 타입 체크 함수에서 타입이 매칭되지 않음을 알리고 싶을때 사용한다.
 * @ignore

 */
MobileCommentJindo.$Jindo.VARTYPE_NOT_MATCHED = {};

(function() {

	var oVarTypeList = MobileCommentJindo.$Jindo._varTypeList = {};
	var ___jindo = MobileCommentJindo.$Jindo;
	var ___notMatched = ___jindo.VARTYPE_NOT_MATCHED;
	oVarTypeList['Numeric'] = function(v) {
		if (___jindo.isNumeric(v)) { return v * 1; }
		return ___notMatched;
	};

	oVarTypeList['Hash'] = function(val, bAutoCast){
		if (bAutoCast && MobileCommentJindo.$H && val instanceof MobileCommentJindo.$H) {
			return val.$value();
		} else if (___jindo.isHash(val)) {
			return val;
		}
		return ___notMatched;
	};

	oVarTypeList['$Class'] = function(val, bAutoCast){
		if ((!___jindo.isFunction(val))||!val.extend) {
			return ___notMatched;
		}
		return val;
	};

	var aDenyTypeList = [];

	for (var sTypeName in ___jindo) if (___jindo.hasOwnProperty(sTypeName)) {
		if (/^is(.+)$/.test(sTypeName)) { aDenyTypeList.push(RegExp.$1); }
	}

	___jindo._denyTypeListComma = aDenyTypeList.join(',');

	___jindo.varType("ArrayStyle",function(val, bAutoCast){
		if(!val) { return ___notMatched; }
		if (
		    /(Arguments|NodeList|HTMLCollection|global|Window)/.test(_objToString.call(val)) ||
			/Object/.test(_objToString.call(val))&&___jindo.isNumeric(val.length)) {
			return _toArray(val);
		}
		return ___notMatched;
	});

	___jindo.varType("Form",function(val, bAutoCast){
		if(!val) { return ___notMatched; }
		if(bAutoCast&&val.$value){
			val = val.$value();
		}
		if (val.tagName&&val.tagName.toUpperCase()=="FORM") {
			return val
		}
		return ___notMatched;
	});
//	___jindo.varType("FormId",function(val, bAutoCast){
//		if(___jindo.isString(val)){
//			val = jindo.$(val);
//			if (val.tagName&&val.tagName.toUpperCase()=="FORM") {
//				return val;
//			}
//		}
//		return ___notMatched;
//	});
//
//	___jindo.varType("PrimativeStyle",function(val, bAutoCast){
//		if(
//		___jindo.isNumeric(val) ||
//		___jindo.isString(val) ||
//		___jindo.isBoolean(val)
//		){
//			return val;
//		}
//		return ___notMatched;
//
//	});
//
})();

//-!MobileCommentJindo.$Jindo.default end!-//

//-!MobileCommentJindo.$ start(MobileCommentJindo._createEle)!-//
/**

 * @function
 * @description $() 함수는 DOM 에서 특정 요소를 조작할 수 있게 가져오거나, 요소를 생성한다.
 * <ul>
 * 	<li>ID를 사용하여 DOM 요소(Element)를 가져온다. 파라미터를 두 개 이상 지정하면 DOM 요소를 원소로하는 배열을 반환한다.</li>
 *  <li>또한 "&lt;tagName&gt;" 과 같은 형식의 문자열을 입력하면 tagName 요소를 가지는 객체를 생성한다.</li>
 * </ul>
 * @param {String+} sID1 가져올 첫 번째 DOM 요소의 ID 또는 생성할 DOM 요소
 * @param {String+} […] …
 * @param {String+} [sIDN] 가져올 N 번째 DOM 요소의 ID(Jindo 1.4.6 버전부터 마지막 파라미터에 document 요소을 지정할 수 있다.).
 * @return {Variant} ID 값으로 지정한 DOM 요소(Element) 혹은 DOM 요소를 원소로 가지는 배열(Array)을 반환한다. 만약 ID에 해당하는 요소가가 없으면 null 값을 반환한다. 요소를 생성한 경우는 객체(Object) 형태로 반환한다.
 * @throws {MobileCommentJindo.$Except.NOT_FOUND_ARGUMENT} 파라메터가 없을 경우.
 * @example
// ID를 이용하여 객체를 리턴한다.
<div id="div1"></div>

var el = $("div1");

// ID를 이용하여 여러개의 객체를 리턴한다.
<div id="div1"></div>
<div id="div2"></div>

var els = $("div1","div2"); // [$("div1"),$("div2")]와 같은 결과를 리턴한다.

// tagName과 같은 형식의 문자열을 이용하여 객체를 생성한다.
var el = $("<DIV>");
var els = $("<DIV id='div1'><SPAN>hello</SPAN></DIV>");

//IE는 iframe에 추가할 엘리먼트를 생성하려고 할 때는 document를 반드시 지정해야 한다.(1.4.6 부터 지원)
var els = $("<div>" , iframe.contentWindow.document);
//위와 같을 경우 div태그가 iframe.contentWindow.document기준으로 생김.

 */
MobileCommentJindo.$ = function(sID/*, id1, id2*/) {
	//-@@$-@@//
	if(!arguments.length) throw new MobileCommentJindo.$Error(MobileCommentJindo.$Except.NOT_FOUND_ARGUMENT,"$");

	var ret = [], arg = arguments, nArgLeng = arg.length, lastArgument = arg[nArgLeng-1],doc = document,el  = null;
	var reg = /^<([a-z]+|h[1-5])>$/i;
	var reg2 = /^<([a-z]+|h[1-5])(\s+[^>]+)?>/i;
	if (nArgLeng > 1 && typeof lastArgument != "string" && lastArgument.body) {
        /*

마지막 인자가 document일때.

         */
		arg = Array.prototype.slice.apply(arg,[0,nArgLeng-1]);
		doc = lastArgument;
	}

	for(var i=0; i < nArgLeng; i++) {
		el = arg[i] && arg[i].$value ? arg[i].$value() : arg[i];
		if (MobileCommentJindo.$Jindo.isString(el)||MobileCommentJindo.$Jindo.isNumeric(el)) {
			el += "";
			el = el.replace(/^\s+|\s+$/g, "");

			if (el.indexOf("<")>-1) {
				if (reg.test(el)) {
					el = doc.createElement(RegExp.$1);
				}else if (reg2.test(el)) {
					var p = { thead:'table', tbody:'table', tr:'tbody', td:'tr', dt:'dl', dd:'dl', li:'ul', legend:'fieldset',option:"select" };
					var tag = RegExp.$1.toLowerCase();

					var ele = MobileCommentJindo._createEle(p[tag],el,doc);
					for (var i=0,leng = ele.length; i < leng ; i++) {
						ret.push(ele[i]);
					};
					el = null;

				}
			}else {
				el = doc.getElementById(el);
			}
		}
		if (el&&el.nodeType) ret[ret.length] = el;
	}
	return ret.length>1?ret:(ret[0] || null);
};
//-!MobileCommentJindo.$ end!-//

//-!MobileCommentJindo._createEle.hidden start!-//
MobileCommentJindo._createEle = function(sParentTag,sHTML,oDoc,bWantParent){
	//-@@_createEle.hidden-@@//
	var sId = 'R' + new Date().getTime() + parseInt(Math.random() * 100000,10);

	var oDummy = oDoc.createElement("div");
	switch (sParentTag) {
		case 'select':
		case 'table':
		case 'dl':
		case 'ul':
		case 'fieldset':
			oDummy.innerHTML = '<' + sParentTag + ' class="' + sId + '">' + sHTML + '</' + sParentTag + '>';
			break;
		case 'thead':
		case 'tbody':
		case 'col':
			oDummy.innerHTML = '<table><' + sParentTag + ' class="' + sId + '">' + sHTML + '</' + sParentTag + '></table>';
			break;
		case 'tr':
			oDummy.innerHTML = '<table><tbody><tr class="' + sId + '">' + sHTML + '</tr></tbody></table>';
			break;
		default:
			oDummy.innerHTML = '<div class="' + sId + '">' + sHTML + '</div>';
	}
	var oFound;
	for (oFound = oDummy.firstChild; oFound; oFound = oFound.firstChild){
		if (oFound.className==sId) break;
	}

	return bWantParent? oFound : oFound.childNodes;
};
//-!MobileCommentJindo._createEle.hidden end!-//

//-!MobileCommentJindo.$Class start!-//
/**

 * @class $Class() 객체는 Jindo 프레임워크를 사용하여 객체 지향 프로그래밍 방식으로 애플리케이션을 구현할 수 있도록 지원한다.
 * @extends core
 * @description 클래스($Class() 객체)를 생성한다. 파라미터로 클래스화할 객체를 입력한다. 해당 객체에 $init 이름으로 메서드를 등록하면 클래스 인스턴스를 생성하는 생성자 함수를 정의할 수 있다. 또한 $static 키워드를 사용하면 인스턴스를 생성하지 않아도 사용할 수 있는 메서드를 등록할 수 있다.
 * @param {Hash+} oDef 클래스를 정의하는 객체. 클래스의 생성자, 속성, 메서드 등을 정의한다.
 * @return {$Class} 생성된 클래스($Class() 객체).
 * @example
var CClass = $Class({
    prop : null,
    $init : function() {
         this.prop = $Ajax();
         ...
    },
	$static : {
		static_method : function(){ return 1;}
	}
});

var c1 = new CClass();
var c2 = new CClass();
// c1과 c2는 서로 다른 $Ajax 객체를 각각 가진다.

CClass.static_method(); // 1

 */

MobileCommentJindo.$Class = function(oDef) {
	//-@@$Class-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4obj' : [ 'oDef:Hash+' ]
	},"$Class");

	function typeClass() {
		var t = this;
		var a = [];

		var superFunc = function(m, superClass, func) {

			if(m!='constructor' && func.toString().indexOf("$super")>-1 ){

				var funcArg = func.toString().replace(/function\s*\(([^\)]*)[\w\W]*/g,"$1").split(",");
				// var funcStr = func.toString().replace(/function\s*\(.*\)\s*\{/,"").replace(/this\.\$super/g,"this.$super.$super");
				var funcStr = func.toString().replace(/function[^{]*{/,"").replace(/(\w|\.?)(this\.\$super|this)/g,function(m,m2,m3){
                           if(!m2){
								return m3+".$super"
                           }
                           return m;
                });
				funcStr = funcStr.substr(0,funcStr.length-1);
				func = superClass[m] = eval("false||function("+funcArg.join(",")+"){"+funcStr+"}");
			}

			return function() {
				var f = this.$this[m];
				var t = this.$this;
				var r = (t[m] = func).apply(t, arguments);
				t[m] = f;

				return r;
			};
		}

		while(t._$superClass !== undefined) {

			t.$super = new Object;
			t.$super.$this = this;

			for(var x in t._$superClass.prototype) {

				if (t._$superClass.prototype.hasOwnProperty(x)){
					if (this[x] === undefined && x !="$init") this[x] = t._$superClass.prototype[x];
					if (x!='constructor' && x!='_$superClass' && typeof t._$superClass.prototype[x] == "function") {
						t.$super[x] = superFunc(x, t._$superClass, t._$superClass.prototype[x]);
					} else {

						t.$super[x] = t._$superClass.prototype[x];
					}
				}
			}

			if (typeof t.$super.$init == "function") a[a.length] = t;
			t = t.$super;
		}

		for(var i=a.length-1; i > -1; i--) a[i].$super.$init.apply(a[i].$super, arguments);

		if (typeof this.$init == "function") this.$init.apply(this,arguments);
	}

	if (oDef.$static !== undefined) {
		var i=0, x;
		for(x in oDef){
			if (oDef.hasOwnProperty(x)) {
				x=="$static"||i++;
			}
		}
		for(x in oDef.$static){
			if (oDef.$static.hasOwnProperty(x)) {
				typeClass[x] = oDef.$static[x];
			}
		}

		if (!i) return oDef.$static;
		delete oDef.$static;
	}

	// if (oDef.$destroy === undefined) {
	// 	oDef.$destroy = function(){
	// 		if(this.$super&&(arguments.callee==this.$super.$destroy)){this.$super.$destroy();}
	// 	}
	// } else {
	// 	oDef.$destroy = eval("false||"+oDef.$destroy.toString().replace(/\}$/,"console.log(this.$super);console.log(arguments.callee!=this.$super.$destroy);if(this.$super&&(arguments.callee==this.$destroy)){this.$super.$destroy();}}"));
	// }
	//
	typeClass.prototype = oDef;
	typeClass.prototype.constructor = typeClass;
	typeClass.prototype.kindOf = function(oClass){
		return _kindOf(this.constructor.prototype, oClass.prototype);
	};
	typeClass.extend = MobileCommentJindo.$Class.extend;

	return typeClass;
};

/**

 @description 자신이 어떤 클래스의 종류인지 확인하는 메서드.
 @name $Class#kindOf
 @since 2.0.0
 @param $Class
 @return {Boolean}
 @type $Class
 @example
	var Parent = $Class ({});
	var Parent2 = $Class ({});
	var Child = $Class ({}).extend (Parent);

	var child = new Child();
	child.kindOf(Parent);// true
	child.kindOf(Parent2);// false

 */
function _kindOf(oThis, oClass){
	if(oThis != oClass){
		if(oThis._$superClass){
			return _kindOf(oThis._$superClass.prototype,oClass);
		}else{
			return false;
		}
	}else{
		return true;
	}
}
 /**

 * @description extend() 메서드는 특정 클래스($Class() 객체)를 상속한다. 상속할 부모 클래스(Super Class)를 지정한다.
 * @name $Class#extend
 * @type $Class
 * @function
 * @param {$Class} superClass 상속할 부모 클래스($Class() 객체).
 * @return {$Class} 상속된 클래스($Class() 객체).
 * @example
var ClassExt = $Class(classDefinition);
ClassExt.extend(superClass);
// ClassExt는 SuperClass를 상속받는다.

 */
MobileCommentJindo.$Class.extend = function(superClass) {
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4obj' : [ 'oDef:$Class' ]
	},"<static> $Class#extend");

	this.prototype._$superClass = superClass;


	// inherit static methods of parent
	for(var x in superClass) {
		if (superClass.hasOwnProperty(x)) {
			if (x == "prototype") continue;
			this[x] = superClass[x];
		}
	}
	return this;
};
/**

 @description $super 속성은 부모 클래스의 메서드에 접근할 때 사용한다. 하위 클래스는 this.$super.method 로 상위 클래스의 메서드에 접근할 수 있으나, this.$super.$super.method 와 같이 한 단계 이상의 상위 클래스는 접근할 수 없다. 또한 부모 클래스와 자식클래스가 같은 이름의 메서드를 가지고 있을 때 자식클래스에서 $super로 같은 이름의 메서드를 호출하면, 부모 클래스의 메서드를 호출한다.
 @name $Class#$super
 @type $Class
 @example
	var Parent = $Class ({
		a: 100,
		b: 200,
		c: 300,
		sum2: function () {
			var init = this.sum();
			return init;
		},
		sum: function () {
			return this.a + this.b
		}
	});

	var Child = $Class ({
		a: 10,
		b: 20,
		sum2 : function () {
			var init = this.sum();
			return init;
		},
		sum: function () {
			return this.b;
		}
	}).extend (Parent);

	var oChild = new Child();
	var oParent = new Parent();

	oChild.sum();           // 20
	oChild.sum2();          // 20
	oChild.$super.sum();    // 30 -> 부모 클래스의 100(a)과 200(b)대신 자식 클래스의 10(a)과 20(b)을 더한다.
	oChild.$super.sum2();   // 20 -> 부모 클래스의 sum2 메서드에서 부모 클래스의 sum()이 아닌 자식 클래스의 sum()을 호출한다.

*/
//-!MobileCommentJindo.$Class end!-//



//-!MobileCommentJindo.cssquery start!-//
/**

 * @fileOverview CSS 셀렉터를 사용한 엘리먼트 선택 엔진
 * @name cssquery.js
 * @author  AjaxUI lab

 */

/**

 * @class
 * @description $$() 함수(cssquery)는 CSS 선택자(CSS Selector)를 사용하여 객체를 탐색한다. $$() 함수 대신 cssquery() 함수를 사용해도 된다. CSS 선택자로 사용할 수 있는 패턴은 표준 패턴과 비표준 패턴이 있다. 표준 패턴은 CSS Level3 명세서에 있는 패턴을 지원한다. 선택자의 패턴에 대한 설명은 다음 표와 See Also 항목을 참고한다.<br>
<table>
	<caption>요소, ID, 클래스 선택자</caption>
	<thead>
		<tr>
			<th scope="col">패턴</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>*</td>
			<td>모든 요소.
				<textarea name="code" class="js:nocontrols">
				$$("*");
				// 문서의 모든 요소.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>HTML Tagname</td>
			<td>지정된 HTML 태그 요소.
				<textarea name="code" class="js:nocontrols">
				$$("div");
				// 문서의 모든 &lt;div&gt; 요소.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>#id</td>
			<td>ID가 지정된 요소.
				<textarea name="code" class="js:nocontrols">
				$$("#application")
				// ID가 application인 요소.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>.classname</td>
			<td>클래스가 지정된 요소.
				<textarea name="code" class="js:nocontrols">
				$$(".img");
				// 클래스가 img인 요소.
				</textarea>
			</td>
		</tr>
	</tbody>
</table>

<table>
	<caption>속성 선택자</caption>
	<thead>
		<tr>
			<th scope="col">패턴</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>[type]</td>
			<td>지정된 속성을 갖고 있는 요소.
				<textarea name="code" class="js:nocontrols">
				$$("input[type]");
				// type 속성을 갖는 &lt;input&gt; 요소.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>[type=value]</td>
			<td>속성과 값이 일치하는 요소.
				<textarea name="code" class="js:nocontrols">
				$$("input[type=text]");
				// type 속성 값이 text인 &lt;input&gt; 요소.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>[type^=value]</td>
			<td>속성의 값이 특정 값으로 시작하는 요소.
				<textarea name="code" class="js:nocontrols">
				$$("input[type^=hid]");
				//type 속성 값이 hid로 시작하는 &lt;input&gt; 요소.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>[type$=value]</td>
			<td>속성의 값이 특정 값으로 끝나는 요소.
				<textarea name="code" class="js:nocontrols">
				$$("input[type$=en]");
				//type 속성 값이 en으로 끝나는 &lt;input&gt; 요소.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>[type~=value]</td>
			<td>속성 값에 공백으로 구분된 여러 개의 값이 존재하는 경우, 각각의 값 중 한가지 값을 갖는 요소.
				<textarea name="code" class="js:nocontrols">
				&lt;img src="..." alt="welcome to naver"&gt;
				$$("img[alt~=welcome]");  // 있음.
				$$("img[alt~=naver]");  // 있음.
				$$("img[alt~=wel]");  // 없음.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>[type*=value]</td>
			<td>속성 값 중에 일치하는 값이 있는 요소.
				<textarea name="code" class="js:nocontrols">
				$$("img[alt*=come]");  // 있음.
				$$("img[alt*=nav]");  // 있음.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>[type!=value]</td>
			<td>값이 지정된 값과 일치하지 않는 요소.
				<textarea name="code" class="js:nocontrols">
				$$("input[type!=text]");
				// type 속성 값이 text가 아닌 요소.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>[@type]</td>
			<td>cssquery 전용으로 사용하는 선택자로서 요소의 속성이 아닌 요소의 스타일 속성을 사용한다. CSS 속성 선택자의 특성을 모두 적용해 사용할 수 있다.
				<textarea name="code" class="js:nocontrols">
				$$("div[@display=block]");
				// &lt;div&gt; 요소 중에 display 스타일 속성의 값이 block인 요소.
				</textarea>
			</td>
		</tr>
	</tbody>
</table>

<table>
	<caption>가상 클래스 선택자</caption>
	<thead>
		<tr>
			<th scope="col">패턴</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>:nth-child(n)</td>
			<td>n번째 자식인지 여부로 해당 요소를 선택한다.
				<textarea name="code" class="js:nocontrols">
				$$("div:nth-child(2)");
				// 두 번째 자식 요소인 &lt;div&gt; 요소.

				$$("div:nth-child(2n)");
				$$("div:nth-child(even)");
				// 짝수 번째 자식 요소인 모든 &lt;div&gt; 요소.

				$$("div:nth-child(2n+1)");
				$$("div:nth-child(odd)");
				// 홀수 번째 자식 요소인 모든 &lt;div&gt; 요소.

				$$("div:nth-child(4n)");
				// 4의 배수 번째 자식 요소인 모든 &lt;div&gt; 요소.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>:nth-last-child(n)</td>
			<td>nth-child와 동일하나, 뒤에서부터 요소를 선택한다.
				<textarea name="code" class="js:nocontrols">
				$$("div:nth-last-child(2)");
				// 뒤에서 두 번째 자식 요소인 모든 &lt;div&gt; 요소.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>:last-child</td>
			<td>마지막 자식인지 여부로 요소를 선택한다.
				<textarea name="code" class="js:nocontrols">
				$$("div:last-child");
				// 마지막 자식 요소인 모든 &lt;div&gt; 요소.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>:nth-of-type(n)</td>
			<td>n번째로 발견된 요소를 선택한다.
				<textarea name="code" class="js:nocontrols">
				&lt;div&gt;
					&lt;p&gt;1&lt;/p&gt;
					&lt;span&gt;2&lt;/span&gt;
					&lt;span&gt;3&lt;/span&gt;
				&lt;/div&gt;
				</textarea>
				위와 같은 DOM이 있을 때, $$("span:nth-child(1)")은 &lt;span&gt; 요소가 firstChild인 요소는 없기 때문에 결과 값을 반환하지 않는다 하지만 $$("span:nth-of-type(1)")는 &lt;span&gt; 요소 중에서 첫 번째 &lt;span&gt; 요소인 &lt;span&gt;2&lt;/span&gt;를 얻어오게 된다.<br>nth-child와 마찬가지로 짝수/홀수 등의 수식을 사용할 수 있다.
			</td>
		</tr>
		<tr>
			<td>:first-of-type</td>
			<td>같은 태그 이름을 갖는 형제 요소 중에서 첫 번째 요소를 선택한다.<br>nth-of-type(1)과 같은 결과 값을 반환한다.</td>
		</tr>
		<tr>
			<td>:nth-last-of-type</td>
			<td>nth-of-type과 동일하나, 뒤에서부터 요소를 선택한다.</td>
		</tr>
		<tr>
			<td>:last-of-type</td>
			<td>같은 태그 이름을 갖는 형제 요소 중에서 마지막 요소를 선택한다.<br>nth-last-of-type(1)과 같은 결과 값을 반환한다.</td>
		</tr>
		<tr>
			<td>:contains</td>
			<td>텍스트 노드에 특정 문자열을 포함하고 있는지 여부로 해당 요소를 선택한다.
				<textarea name="code" class="js:nocontrols">
				$$("span:contains(Jindo)");
				// "Jindo" 문자열를 포함하고 있는 &lt;span&gt; 요소.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>:only-child</td>
			<td>형제가 없는 요소를 선택한다.
				<textarea name="code" class="js:nocontrols">
				&lt;div&gt;
					&lt;p&gt;1&lt;/p&gt;
					&lt;span&gt;2&lt;/span&gt;
					&lt;span&gt;3&lt;/span&gt;
				&lt;/div&gt;
				</textarea>
				위의 DOM에서 $$("div:only-child")만 반환 값이 있고, $$("p:only-child") 또는 $$("span:only-child")는 반환 값이 없다. 즉, 형제 노드가 없는 &lt;div&gt; 요소만 선택된다.
			</td>
		</tr>
		<tr>
			<td>:empty</td>
			<td>비어있는 요소를 선택한다.
				<textarea name="code" class="js:nocontrols">
				$$("span:empty");
				// 텍스트 노드 또는 하위 노드가 없는 &lt;span&gt; 요소.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>:not</td>
			<td>선택자의 조건과 반대인 요소를 선택한다.
				<textarea name="code" class="js:nocontrols">
				$$("div:not(.img)");
				// img 클래스가 없는 &lt;div&gt; 요소.
				</textarea>
			</td>
		</tr>
	</tbody>
</table>

<table>
	<caption>콤비네이터 선택자</caption>
	<thead>
		<tr>
			<th scope="col">패턴</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>공백 (space)</td>
			<td>하위의 모든 요소를 의미한다.
				<textarea name="code" class="js:nocontrols">
				$$("body div");
				// &lt;body&gt; 요소 하위에 속한 모든 &lt;div&gt; 요소.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>&gt;</td>
			<td>자식 노드에 속하는 모든 요소를 의미한다.
				<textarea name="code" class="js:nocontrols">
				$$("div &gt; span");
				// &lt;div&gt; 요소의 자식 요소 중 모든 &lt;span&gt; 요소.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>+</td>
			<td>지정한 요소의 바로 다음 형제 노드에 속하는 모든 요소를 의미한다.
				<textarea name="code" class="js:nocontrols">
				$$("div + p");
				// &lt;div&gt; 요소의 nextSibling에 해당하는 모든 &lt;p&gt; 요소.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>~</td>
			<td>+ 패턴과 동일하나, 바로 다음 형제 노드뿐만 아니라 지정된 노드 이후에 속하는 모든 요소를 의미한다.
				<textarea name="code" class="js:nocontrols">
				$$("div ~ p");
				// &lt;div&gt; 요소 이후의 형제 노드에 속하는 모든 &lt;p&gt; 요소.
				</textarea>
			</td>
		</tr>
		<tr>
			<td>!</td>
			<td>cssquery 전용으로, 콤비네이터의 반대 방향으로 탐색을 시작해 요소를 검색한다.
				<textarea name="code" class="js:nocontrols">
				$$("span ! div");
				// &lt;span&gt; 요소의 상위에 있는 모든 &lt;div&gt; 요소.
				</textarea>
			</td>
		</tr>
	</tbody>
</table>
 *
 * @param1 {String+} sSelector CSS 선택자. CSS 선택자로 사용할 수 있는 패턴은 표준 패턴과 비표준 패턴이 있다. 표준 패턴은 CSS Level3 명세서에 있는 패턴을 지원한다.
 *
 * @param2 {String+} sSelector CSS 선택자. CSS 선택자로 사용할 수 있는 패턴은 표준 패턴과 비표준 패턴이 있다. 표준 패턴은 CSS Level3 명세서에 있는 패턴을 지원한다.
 * @param2 {Element+} elBaseElement 탐색 대상이 되는 DOM 요소. 지정한 요소의 하위 노드에서만 객체를 탐색한다.
 *
 * @param3 {String+} sSelector CSS 선택자. CSS 선택자로 사용할 수 있는 패턴은 표준 패턴과 비표준 패턴이 있다. 표준 패턴은 CSS Level3 명세서에 있는 패턴을 지원한다.
 * @param3 {String+} sBaseElement 탐색 대상이 되는 DOM 요소의 ID 문자열. 지정한 요소의 하위 노드에서만 객체를 탐색한다.
 *
 * @return {Array} 조건에 해당하는 요소를 배열 형태로 반환한다.
 *
 * @see $Document#queryAll
 * @see <a href="http://www.w3.org/TR/css3-selectors/">CSS Level3 명세서</a> - W3C
 * @example
 // 문서에서 IMG 태그를 찾는다.
 var imgs = $$('IMG');

 // div 요소 하위에서 IMG 태그를 찾는다.
 var imgsInDiv = $$('IMG', $('div'));

 // 문서에서 IMG 태그 중 가장 첫 요소를 찾는다.
 var firstImg = $$.getSingle('IMG');

 */
MobileCommentJindo.$$ = MobileCommentJindo.cssquery = (function() {
	/*

querySelector 설정.

	 */
	var sVersion = '3.0';

	var debugOption = { repeat : 1 };

	/*

빠른 처리를 위해 노드마다 유일키 값 셋팅

	 */
	var UID = 1;

	var cost = 0;
	var validUID = {};

	var bSupportByClassName = document.getElementsByClassName ? true : false;
	var safeHTML = false;

	var getUID4HTML = function(oEl) {

		var nUID = safeHTML ? (oEl._cssquery_UID && oEl._cssquery_UID[0]) : oEl._cssquery_UID;
		if (nUID && validUID[nUID] == oEl) return nUID;

		nUID = UID++;
		oEl._cssquery_UID = safeHTML ? [ nUID ] : nUID;

		validUID[nUID] = oEl;
		return nUID;

	};
	function GEBID(oBase,sId,oDoc){
		if(oBase.nodeType===9||oBase.parentNode&&oBase.parentNode.tagName){
 			return oDoc.getElementById(sId);
		}else{
			var aEle = oBase.getElementsByTagName("*");
			for(var i = 0,l = aEle.length; i < l; i++){
				if(aEle[i].id === sId){
					return aEle[i]
				};
			}
		}
	}
	var getUID4XML = function(oEl) {

		var oAttr = oEl.getAttribute('_cssquery_UID');
		var nUID = safeHTML ? (oAttr && oAttr[0]) : oAttr;

		if (!nUID) {
			nUID = UID++;
			oEl.setAttribute('_cssquery_UID', safeHTML ? [ nUID ] : nUID);
		}

		return nUID;

	};

	var getUID = getUID4HTML;

	var uniqid = function(sPrefix) {
		return (sPrefix || '') + new Date().getTime() + parseInt(Math.random() * 100000000,10);
	};

	function getElementsByClass(searchClass,node,tag) {
        var classElements = new Array();
        if ( node == null )
                node = document;
        if ( tag == null )
                tag = '*';
        var els = node.getElementsByTagName(tag);
        var elsLen = els.length;
        var pattern = new RegExp("(^|\\s)"+searchClass+"(\\s|$)");
        for (i = 0, j = 0; i < elsLen; i++) {
                if ( pattern.test(els[i].className) ) {
                        classElements[j] = els[i];
                        j++;
                }
        }
        return classElements;
	}

	var getChilds_dontShrink = function(oEl, sTagName, sClassName) {
		if (bSupportByClassName && sClassName) {
			if(oEl.getElementsByClassName)
				return oEl.getElementsByClassName(sClassName);
			if(oEl.querySelectorAll)
				return oEl.querySelectorAll(sClassName);
			return getElementsByClass(sClassName, oEl, sTagName);
		}else if (sTagName == '*') {
			return oEl.all || oEl.getElementsByTagName(sTagName);
		}
		return oEl.getElementsByTagName(sTagName);
	};

	var clearKeys = function() {
		 backupKeys._keys = {};
	};

	var oDocument_dontShrink = document;

	var bXMLDocument = false;

	/*

따옴표, [] 등 파싱에 문제가 될 수 있는 부분 replace 시켜놓기

	 */
	var backupKeys = function(sQuery) {

		var oKeys = backupKeys._keys;

		/*

작은 따옴표 걷어내기

		 */
		sQuery = sQuery.replace(/'(\\'|[^'])*'/g, function(sAll) {
			var uid = uniqid('QUOT');
			oKeys[uid] = sAll;
			return uid;
		});

		/*

큰 따옴표 걷어내기

		 */
		sQuery = sQuery.replace(/"(\\"|[^"])*"/g, function(sAll) {
			var uid = uniqid('QUOT');
			oKeys[uid] = sAll;
			return uid;
		});

		/*

[ ] 형태 걷어내기

		 */
		sQuery = sQuery.replace(/\[(.*?)\]/g, function(sAll, sBody) {
			if (sBody.indexOf('ATTR') == 0) return sAll;
			var uid = '[' + uniqid('ATTR') + ']';
			oKeys[uid] = sAll;
			return uid;
		});

		/*

( ) 형태 걷어내기

		 */
		var bChanged;

		do {

			bChanged = false;

			sQuery = sQuery.replace(/\(((\\\)|[^)|^(])*)\)/g, function(sAll, sBody) {
				if (sBody.indexOf('BRCE') == 0) return sAll;
				var uid = '_' + uniqid('BRCE');
				oKeys[uid] = sAll;
				bChanged = true;
				return uid;
			});

		} while(bChanged);

		return sQuery;

	};

	/*

replace 시켜놓은 부분 복구하기

	 */
	var restoreKeys = function(sQuery, bOnlyAttrBrace) {

		var oKeys = backupKeys._keys;

		var bChanged;
		var rRegex = bOnlyAttrBrace ? /(\[ATTR[0-9]+\])/g : /(QUOT[0-9]+|\[ATTR[0-9]+\])/g;

		do {

			bChanged = false;

			sQuery = sQuery.replace(rRegex, function(sKey) {

				if (oKeys[sKey]) {
					bChanged = true;
					return oKeys[sKey];
				}

				return sKey;

			});

		} while(bChanged);

		/*

( ) 는 한꺼풀만 벗겨내기

		 */
		sQuery = sQuery.replace(/_BRCE[0-9]+/g, function(sKey) {
			return oKeys[sKey] ? oKeys[sKey] : sKey;
		});

		return sQuery;

	};

	/*

replace 시켜놓은 문자열에서 Quot 을 제외하고 리턴

	 */
	var restoreString = function(sKey) {

		var oKeys = backupKeys._keys;
		var sOrg = oKeys[sKey];

		if (!sOrg) return sKey;
		return eval(sOrg);

	};

	var wrapQuot = function(sStr) {
		return '"' + sStr.replace(/"/g, '\\"') + '"';
	};

	var getStyleKey = function(sKey) {

		if (/^@/.test(sKey)) return sKey.substr(1);
		return null;

	};

	var getCSS = function(oEl, sKey) {

		if (oEl.currentStyle) {

			if (sKey == "float") sKey = "styleFloat";
			return oEl.currentStyle[sKey] || oEl.style[sKey];

		} else if (window.getComputedStyle) {

			return oDocument_dontShrink.defaultView.getComputedStyle(oEl, null).getPropertyValue(sKey.replace(/([A-Z])/g,"-$1").toLowerCase()) || oEl.style[sKey];

		}

		if (sKey == "float" && _JINDO_IS_IE) sKey = "styleFloat";
		return oEl.style[sKey];

	};

	var oCamels = {
		'accesskey' : 'accessKey',
		'cellspacing' : 'cellSpacing',
		'cellpadding' : 'cellPadding',
		'class' : 'className',
		'colspan' : 'colSpan',
		'for' : 'htmlFor',
		'maxlength' : 'maxLength',
		'readonly' : 'readOnly',
		'rowspan' : 'rowSpan',
		'tabindex' : 'tabIndex',
		'valign' : 'vAlign'
	};

	var getDefineCode = function(sKey) {
		var sVal;
		var sStyleKey;

		if (bXMLDocument) {

			sVal = 'oEl.getAttribute("' + sKey + '",2)';

		} else {

			if (sStyleKey = getStyleKey(sKey)) {

				sKey = '$$' + sStyleKey;
				sVal = 'getCSS(oEl, "' + sStyleKey + '")';

			} else {

				switch (sKey) {
				case 'checked':
					sVal = 'oEl.checked + ""';
					break;

				case 'disabled':
					sVal = 'oEl.disabled + ""';
					break;

				case 'enabled':
					sVal = '!oEl.disabled + ""';
					break;

				case 'readonly':
					sVal = 'oEl.readOnly + ""';
					break;

				case 'selected':
					sVal = 'oEl.selected + ""';
					break;

				default:
					if (oCamels[sKey]) {
						sVal = 'oEl.' + oCamels[sKey];
					} else {
						sVal = 'oEl.getAttribute("' + sKey + '",2)';
					}
				}

			}

		}

		return '_' + sKey.replace(/\-/g,"_") + ' = ' + sVal;
	};

	var getReturnCode = function(oExpr) {

		var sStyleKey = getStyleKey(oExpr.key);

		var sVar = '_' + (sStyleKey ? '$$' + sStyleKey : oExpr.key);
		sVar = sVar.replace(/\-/g,"_");
		var sVal = oExpr.val ? wrapQuot(oExpr.val) : '';

		switch (oExpr.op) {
		case '~=':
			return '(' + sVar + ' && (" " + ' + sVar + ' + " ").indexOf(" " + ' + sVal + ' + " ") > -1)';
		case '^=':
			return '(' + sVar + ' && ' + sVar + '.indexOf(' + sVal + ') == 0)';
		case '$=':
			return '(' + sVar + ' && ' + sVar + '.substr(' + sVar + '.length - ' + oExpr.val.length + ') == ' + sVal + ')';
		case '*=':
			return '(' + sVar + ' && ' + sVar + '.indexOf(' + sVal + ') > -1)';
		case '!=':
			return '(' + sVar + ' != ' + sVal + ')';
		case '=':
			return '(' + sVar + ' == ' + sVal + ')';
		}

		return '(' + sVar + ')';

	};

	var getNodeIndex = function(oEl) {
		var nUID = getUID(oEl);
		var nIndex = oNodeIndexes[nUID] || 0;

		/*

노드 인덱스를 구할 수 없으면

		 */
		if (nIndex == 0) {

			for (var oSib = (oEl.parentNode || oEl._IE5_parentNode).firstChild; oSib; oSib = oSib.nextSibling) {

				if (oSib.nodeType != 1){
					continue;
				}
				nIndex++;

				setNodeIndex(oSib, nIndex);

			}

			nIndex = oNodeIndexes[nUID];

		}

		return nIndex;

	};

	/*

몇번째 자식인지 설정하는 부분

	 */
	var oNodeIndexes = {};

	var setNodeIndex = function(oEl, nIndex) {
		var nUID = getUID(oEl);
		oNodeIndexes[nUID] = nIndex;
	};

	var unsetNodeIndexes = function() {
		setTimeout(function() { oNodeIndexes = {}; }, 0);
	};

	/*

가상 클래스

	 */
	var oPseudoes_dontShrink = {

		'contains' : function(oEl, sOption) {
			return (oEl.innerText || oEl.textContent || '').indexOf(sOption) > -1;
		},

		'last-child' : function(oEl, sOption) {
			for (oEl = oEl.nextSibling; oEl; oEl = oEl.nextSibling){
				if (oEl.nodeType == 1)
					return false;
			}


			return true;
		},

		'first-child' : function(oEl, sOption) {
			for (oEl = oEl.previousSibling; oEl; oEl = oEl.previousSibling){
				if (oEl.nodeType == 1)
					return false;
			}


			return true;
		},

		'only-child' : function(oEl, sOption) {
			var nChild = 0;

			for (var oChild = (oEl.parentNode || oEl._IE5_parentNode).firstChild; oChild; oChild = oChild.nextSibling) {
				if (oChild.nodeType == 1) nChild++;
				if (nChild > 1) return false;
			}

			return nChild ? true : false;
		},

		'empty' : function(oEl, _) {
			return oEl.firstChild ? false : true;
		},

		'nth-child' : function(oEl, nMul, nAdd) {
			var nIndex = getNodeIndex(oEl);
			return nIndex % nMul == nAdd;
		},

		'nth-last-child' : function(oEl, nMul, nAdd) {
			var oLast = (oEl.parentNode || oEl._IE5_parentNode).lastChild;
			for (; oLast; oLast = oLast.previousSibling){
				if (oLast.nodeType == 1) break;
			}


			var nTotal = getNodeIndex(oLast);
			var nIndex = getNodeIndex(oEl);

			var nLastIndex = nTotal - nIndex + 1;
			return nLastIndex % nMul == nAdd;
		},
		'checked' : function(oEl){
			return !!oEl.checked;
		},
		'selected' : function(oEl){
			return !!oEl.selected;
		},
		'enabled' : function(oEl){
			return !oEl.disabled;
		},
		'disabled' : function(oEl){
			return !!oEl.disabled;
		}
	};

	/*

단일 part 의 body 에서 expression 뽑아냄

	 */
	var getExpression = function(sBody) {

		var oRet = { defines : '', returns : 'true' };

		var sBody = restoreKeys(sBody, true);

		var aExprs = [];
		var aDefineCode = [], aReturnCode = [];
		var sId, sTagName;

		/*

유사클래스 조건 얻어내기

		 */
		var sBody = sBody.replace(/:([\w-]+)(\(([^)]*)\))?/g, function(_1, sType, _2, sOption) {

			switch (sType) {
			case 'not':
                /*

괄호 안에 있는거 재귀파싱하기

                 */
				var oInner = getExpression(sOption);

				var sFuncDefines = oInner.defines;
				var sFuncReturns = oInner.returnsID + oInner.returnsTAG + oInner.returns;

				aReturnCode.push('!(function() { ' + sFuncDefines + ' return ' + sFuncReturns + ' })()');
				break;

			case 'nth-child':
			case 'nth-last-child':
				sOption =  restoreString(sOption);

				if (sOption == 'even'){
					sOption = '2n';
				}else if (sOption == 'odd') {
					sOption = '2n+1';
				}

				var nMul, nAdd;
				var matchstr = sOption.match(/([0-9]*)n([+-][0-9]+)*/);
				if (matchstr) {
					nMul = matchstr[1] || 1;
					nAdd = matchstr[2] || 0;
				} else {
					nMul = Infinity;
					nAdd = parseInt(sOption,10);
				}
				aReturnCode.push('oPseudoes_dontShrink[' + wrapQuot(sType) + '](oEl, ' + nMul + ', ' + nAdd + ')');
				break;

			case 'first-of-type':
			case 'last-of-type':
				sType = (sType == 'first-of-type' ? 'nth-of-type' : 'nth-last-of-type');
				sOption = 1;

			case 'nth-of-type':
			case 'nth-last-of-type':
				sOption =  restoreString(sOption);

				if (sOption == 'even') {
					sOption = '2n';
				}else if (sOption == 'odd'){
					sOption = '2n+1';
				}

				var nMul, nAdd;

				if (/([0-9]*)n([+-][0-9]+)*/.test(sOption)) {
					nMul = parseInt(RegExp.$1,10) || 1;
					nAdd = parseInt(RegExp.$2,20) || 0;
				} else {
					nMul = Infinity;
					nAdd = parseInt(sOption,10);
				}

				oRet.nth = [ nMul, nAdd, sType ];
				break;

			default:
				sOption = sOption ? restoreString(sOption) : '';
				aReturnCode.push('oPseudoes_dontShrink[' + wrapQuot(sType) + '](oEl, ' + wrapQuot(sOption) + ')');
			}

			return '';

		});

		/*

[key=value] 형태 조건 얻어내기

		 */
		var sBody = sBody.replace(/\[(@?[\w-]+)(([!^~$*]?=)([^\]]*))?\]/g, function(_1, sKey, _2, sOp, sVal) {
			sKey = restoreString(sKey);
			sVal = restoreString(sVal);

			if (sKey == 'checked' || sKey == 'disabled' || sKey == 'enabled' || sKey == 'readonly' || sKey == 'selected') {

				if (!sVal) {
					sOp = '=';
					sVal = 'true';
				}

			}
			aExprs.push({ key : sKey, op : sOp, val : sVal });
			return '';

		});

		var sClassName = null;

		/*

클래스 조건 얻어내기

		 */
		var sBody = sBody.replace(/\.([\w-]+)/g, function(_, sClass) {
			aExprs.push({ key : 'class', op : '~=', val : sClass });
			if (!sClassName) sClassName = sClass;
			return '';
		});

		/*

id 조건 얻어내기

		 */
		var sBody = sBody.replace(/#([\w-]+)/g, function(_, sIdValue) {
			if (bXMLDocument) {
				aExprs.push({ key : 'id', op : '=', val : sIdValue });
			}else{
				sId = sIdValue;
			}
			return '';
		});

		sTagName = sBody == '*' ? '' : sBody;

		/*

match 함수 코드 만들어 내기

		 */
		var oVars = {};

		for (var i = 0, oExpr; oExpr = aExprs[i]; i++) {

			var sKey = oExpr.key;

			if (!oVars[sKey]) aDefineCode.push(getDefineCode(sKey));
            /*

유사클래스 조건 검사가 맨 뒤로 가도록 unshift 사용

             */
			aReturnCode.unshift(getReturnCode(oExpr));
			oVars[sKey] = true;

		}

		if (aDefineCode.length) oRet.defines = 'var ' + aDefineCode.join(',') + ';';
		if (aReturnCode.length) oRet.returns = aReturnCode.join('&&');

		oRet.quotID = sId ? wrapQuot(sId) : '';
		oRet.quotTAG = sTagName ? wrapQuot(bXMLDocument ? sTagName : sTagName.toUpperCase()) : '';

		if (bSupportByClassName) oRet.quotCLASS = sClassName ? wrapQuot(sClassName) : '';

		oRet.returnsID = sId ? 'oEl.id == ' + oRet.quotID + ' && ' : '';
		oRet.returnsTAG = sTagName && sTagName != '*' ? 'oEl.tagName == ' + oRet.quotTAG + ' && ' : '';

		return oRet;

	};

	/*

쿼리를 연산자 기준으로 잘라냄

	 */
	var splitToParts = function(sQuery) {

		var aParts = [];
		var sRel = ' ';

		var sBody = sQuery.replace(/(.*?)\s*(!?[+>~ ]|!)\s*/g, function(_, sBody, sRelative) {

			if (sBody) aParts.push({ rel : sRel, body : sBody });

			sRel = sRelative.replace(/\s+$/g, '') || ' ';
			return '';

		});

		if (sBody) aParts.push({ rel : sRel, body : sBody });

		return aParts;

	};

	var isNth_dontShrink = function(oEl, sTagName, nMul, nAdd, sDirection) {

		var nIndex = 0;
		for (var oSib = oEl; oSib; oSib = oSib[sDirection]){
			if (oSib.nodeType == 1 && (!sTagName || sTagName == oSib.tagName))
					nIndex++;
		}


		return nIndex % nMul == nAdd;

	};

	/*

잘라낸 part 를 함수로 컴파일 하기

	 */
	var compileParts = function(aParts) {
		var aPartExprs = [];
		/*

잘라낸 부분들 조건 만들기

		 */
		for (var i = 0, oPart; oPart = aParts[i]; i++)
			aPartExprs.push(getExpression(oPart.body));

		//////////////////// BEGIN

		var sFunc = '';
		var sPushCode = 'aRet.push(oEl); if (oOptions.single) { bStop = true; }';

		for (var i = aParts.length - 1, oPart; oPart = aParts[i]; i--) {

			var oExpr = aPartExprs[i];
			var sPush = (debugOption.callback ? 'cost++;' : '') + oExpr.defines;


			var sReturn = 'if (bStop) {' + (i == 0 ? 'return aRet;' : 'return;') + '}';

			if (oExpr.returns == 'true') {
				sPush += (sFunc ? sFunc + '(oEl);' : sPushCode) + sReturn;
			}else{
				sPush += 'if (' + oExpr.returns + ') {' + (sFunc ? sFunc + '(oEl);' : sPushCode ) + sReturn + '}';
			}

			var sCheckTag = 'oEl.nodeType != 1';
			if (oExpr.quotTAG) sCheckTag = 'oEl.tagName != ' + oExpr.quotTAG;

			var sTmpFunc =
				'(function(oBase' +
					(i == 0 ? ', oOptions) { var bStop = false; var aRet = [];' : ') {');

			if (oExpr.nth) {
				sPush =
					'if (isNth_dontShrink(oEl, ' +
					(oExpr.quotTAG ? oExpr.quotTAG : 'false') + ',' +
					oExpr.nth[0] + ',' +
					oExpr.nth[1] + ',' +
					'"' + (oExpr.nth[2] == 'nth-of-type' ? 'previousSibling' : 'nextSibling') + '")) {' + sPush + '}';
			}

			switch (oPart.rel) {
			case ' ':
				if (oExpr.quotID) {

					sTmpFunc +=
						// 'var oEl = oDocument_dontShrink.getElementById(' + oExpr.quotID + ');' +
						'var oEl = GEBID(oBase,' + oExpr.quotID + ',oDocument_dontShrink);' +
						'var oCandi = oEl;' +
						'for (; oCandi; oCandi = (oCandi.parentNode || oCandi._IE5_parentNode)) {' +
							'if (oCandi == oBase) break;' +
						'}' +
						'if (!oCandi || ' + sCheckTag + ') return aRet;' +
						sPush;

				} else {

					sTmpFunc +=
						'var aCandi = getChilds_dontShrink(oBase, ' + (oExpr.quotTAG || '"*"') + ', ' + (oExpr.quotCLASS || 'null') + ');' +
						'for (var i = 0, oEl; oEl = aCandi[i]; i++) {' +
							(oExpr.quotCLASS ? 'if (' + sCheckTag + ') continue;' : '') +
							sPush +
						'}';

				}

				break;

			case '>':
				if (oExpr.quotID) {

					sTmpFunc +=
						// 'var oEl = oDocument_dontShrink.getElementById(' + oExpr.quotID + ');' +
						'var oEl = GEBID(oBase,' + oExpr.quotID + ',oDocument_dontShrink);' +
						'if ((oEl.parentNode || oEl._IE5_parentNode) != oBase || ' + sCheckTag + ') return aRet;' +
						sPush;

				} else {

					sTmpFunc +=
						'for (var oEl = oBase.firstChild; oEl; oEl = oEl.nextSibling) {' +
							'if (' + sCheckTag + ') { continue; }' +
							sPush +
						'}';

				}

				break;

			case '+':
				if (oExpr.quotID) {

					sTmpFunc +=
						// 'var oEl = oDocument_dontShrink.getElementById(' + oExpr.quotID + ');' +
						'var oEl = GEBID(oBase,' + oExpr.quotID + ',oDocument_dontShrink);' +
						'var oPrev;' +
						'for (oPrev = oEl.previousSibling; oPrev; oPrev = oPrev.previousSibling) { if (oPrev.nodeType == 1) break; }' +
						'if (!oPrev || oPrev != oBase || ' + sCheckTag + ') return aRet;' +
						sPush;

				} else {

					sTmpFunc +=
						'for (var oEl = oBase.nextSibling; oEl; oEl = oEl.nextSibling) { if (oEl.nodeType == 1) break; }' +
						'if (!oEl || ' + sCheckTag + ') { return aRet; }' +
						sPush;

				}

				break;

			case '~':

				if (oExpr.quotID) {

					sTmpFunc +=
						// 'var oEl = oDocument_dontShrink.getElementById(' + oExpr.quotID + ');' +
						'var oEl = GEBID(oBase,' + oExpr.quotID + ',oDocument_dontShrink);' +
						'var oCandi = oEl;' +
						'for (; oCandi; oCandi = oCandi.previousSibling) { if (oCandi == oBase) break; }' +
						'if (!oCandi || ' + sCheckTag + ') return aRet;' +
						sPush;

				} else {

					sTmpFunc +=
						'for (var oEl = oBase.nextSibling; oEl; oEl = oEl.nextSibling) {' +
							'if (' + sCheckTag + ') { continue; }' +
							'if (!markElement_dontShrink(oEl, ' + i + ')) { break; }' +
							sPush +
						'}';

				}

				break;

			case '!' :

				if (oExpr.quotID) {

					sTmpFunc +=
						// 'var oEl = oDocument_dontShrink.getElementById(' + oExpr.quotID + ');' +
						'var oEl = GEBID(oBase,' + oExpr.quotID + ',oDocument_dontShrink);' +
						'for (; oBase; oBase = (oBase.parentNode || oBase._IE5_parentNode)) { if (oBase == oEl) break; }' +
						'if (!oBase || ' + sCheckTag + ') return aRet;' +
						sPush;

				} else {

					sTmpFunc +=
						'for (var oEl = (oBase.parentNode || oBase._IE5_parentNode); oEl; oEl = (oEl.parentNode || oEl._IE5_parentNode)) {'+
							'if (' + sCheckTag + ') { continue; }' +
							sPush +
						'}';

				}

				break;

			case '!>' :

				if (oExpr.quotID) {

					sTmpFunc +=
						// 'var oEl = oDocument_dontShrink.getElementById(' + oExpr.quotID + ');' +
						'var oEl = GEBID(oBase,' + oExpr.quotID + ',oDocument_dontShrink);' +
						'var oRel = (oBase.parentNode || oBase._IE5_parentNode);' +
						'if (!oRel || oEl != oRel || (' + sCheckTag + ')) return aRet;' +
						sPush;

				} else {

					sTmpFunc +=
						'var oEl = (oBase.parentNode || oBase._IE5_parentNode);' +
						'if (!oEl || ' + sCheckTag + ') { return aRet; }' +
						sPush;

				}

				break;

			case '!+' :

				if (oExpr.quotID) {

					sTmpFunc +=
						// 'var oEl = oDocument_dontShrink.getElementById(' + oExpr.quotID + ');' +
						'var oEl = GEBID(oBase,' + oExpr.quotID + ',oDocument_dontShrink);' +
						'var oRel;' +
						'for (oRel = oBase.previousSibling; oRel; oRel = oRel.previousSibling) { if (oRel.nodeType == 1) break; }' +
						'if (!oRel || oEl != oRel || (' + sCheckTag + ')) return aRet;' +
						sPush;

				} else {

					sTmpFunc +=
						'for (oEl = oBase.previousSibling; oEl; oEl = oEl.previousSibling) { if (oEl.nodeType == 1) break; }' +
						'if (!oEl || ' + sCheckTag + ') { return aRet; }' +
						sPush;

				}

				break;

			case '!~' :

				if (oExpr.quotID) {

					sTmpFunc +=
						// 'var oEl = oDocument_dontShrink.getElementById(' + oExpr.quotID + ');' +
						'var oEl = GEBID(oBase,' + oExpr.quotID + ',oDocument_dontShrink);' +
						'var oRel;' +
						'for (oRel = oBase.previousSibling; oRel; oRel = oRel.previousSibling) { ' +
							'if (oRel.nodeType != 1) { continue; }' +
							'if (oRel == oEl) { break; }' +
						'}' +
						'if (!oRel || (' + sCheckTag + ')) return aRet;' +
						sPush;

				} else {

					sTmpFunc +=
						'for (oEl = oBase.previousSibling; oEl; oEl = oEl.previousSibling) {' +
							'if (' + sCheckTag + ') { continue; }' +
							'if (!markElement_dontShrink(oEl, ' + i + ')) { break; }' +
							sPush +
						'}';

				}

			}

			sTmpFunc +=
				(i == 0 ? 'return aRet;' : '') +
			'})';

			sFunc = sTmpFunc;

		}
		eval('var fpCompiled = ' + sFunc + ';');
		return fpCompiled;

	};

	/*

쿼리를 match 함수로 변환

	 */
	var parseQuery = function(sQuery) {
		var sCacheKey = sQuery;

		var fpSelf = arguments.callee;
		var fpFunction = fpSelf._cache[sCacheKey];

		if (!fpFunction) {

			sQuery = backupKeys(sQuery);

			var aParts = splitToParts(sQuery);

			fpFunction = fpSelf._cache[sCacheKey] = compileParts(aParts);
			fpFunction.depth = aParts.length;

		}

		return fpFunction;

	};

	parseQuery._cache = {};

	/*

test 쿼리를 match 함수로 변환

	 */
	var parseTestQuery = function(sQuery) {

		var fpSelf = arguments.callee;

		var aSplitQuery = backupKeys(sQuery).split(/\s*,\s*/);
		var aResult = [];

		var nLen = aSplitQuery.length;
		var aFunc = [];

		for (var i = 0; i < nLen; i++) {

			aFunc.push((function(sQuery) {

				var sCacheKey = sQuery;
				var fpFunction = fpSelf._cache[sCacheKey];

				if (!fpFunction) {

					sQuery = backupKeys(sQuery);
					var oExpr = getExpression(sQuery);

					eval('fpFunction = function(oEl) { ' + oExpr.defines + 'return (' + oExpr.returnsID + oExpr.returnsTAG + oExpr.returns + '); };');

				}

				return fpFunction;

			})(restoreKeys(aSplitQuery[i])));

		}
		return aFunc;

	};

	parseTestQuery._cache = {};

	var distinct = function(aList) {

		var aDistinct = [];
		var oDummy = {};

		for (var i = 0, oEl; oEl = aList[i]; i++) {

			var nUID = getUID(oEl);
			if (oDummy[nUID]) continue;

			aDistinct.push(oEl);
			oDummy[nUID] = true;
		}

		return aDistinct;

	};

	var markElement_dontShrink = function(oEl, nDepth) {

		var nUID = getUID(oEl);
		if (cssquery._marked[nDepth][nUID]) return false;

		cssquery._marked[nDepth][nUID] = true;
		return true;

	};

	var oResultCache = null;
	var bUseResultCache = false;
	var bExtremeMode = false;

	var old_cssquery = function(sQuery, oParent, oOptions) {
		var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
			'4str'   : [ 'sQuery:String+'],
			'4var'  : [ 'sQuery:String+', 'oParent:Variant' ],
			'4var2' : [ 'sQuery:String+', 'oParent:Variant', 'oOptions:Variant' ]
		},"cssquery");
		oParent = oParent && oParent.$value ? oParent.$value() : oParent;
		oOptions = oOptions && oOptions.$value ? oOptions.$value() : oOptions;

		if(MobileCommentJindo.$Jindo.isString(oParent)){
			try{
				oParent = document.getElementById(oParent);
			}catch(e){
				oParent = document;
			}
		}
		//-@@cssquery-@@//
		if(!oParent){
			oParent = document;
		}
        oParent = oParent || oParent.ownerDocument || oParent.document;

		if (typeof sQuery == 'object') {

			var oResult = {};

			for (var k in sQuery){
				if(sQuery.hasOwnProperty(k))
					oResult[k] = arguments.callee(sQuery[k], oParent, oOptions);
			}

			return oResult;
		}

		cost = 0;

		var executeTime = new Date().getTime();
		var aRet;

		for (var r = 0, rp = debugOption.repeat; r < rp; r++) {

			aRet = (function(sQuery, oParent, oOptions) {

				if(oOptions){
					if(!oOptions.oneTimeOffCache){
						oOptions.oneTimeOffCache = false;
					}
				}else{
					oOptions = {oneTimeOffCache:false};
				}
				cssquery.safeHTML(oOptions.oneTimeOffCache);

				if (!oParent) oParent = document;

				/*

ownerDocument 잡아주기

				 */
				oDocument_dontShrink = oParent.ownerDocument || oParent.document || oParent;

				/*

브라우저 버젼이 IE5.5 이하

				 */
				if (/\bMSIE\s([0-9]+(\.[0-9]+)*);/.test(_j_ag) && parseFloat(RegExp.$1,10) < 6) {
					try { oDocument_dontShrink.location; } catch(e) { oDocument_dontShrink = document; }

					oDocument_dontShrink.firstChild = oDocument_dontShrink.getElementsByTagName('html')[0];
					oDocument_dontShrink.firstChild._IE5_parentNode = oDocument_dontShrink;
				}

				/*

XMLDocument 인지 체크

				 */
				bXMLDocument = (typeof XMLDocument !== 'undefined') ? (oDocument_dontShrink.constructor === XMLDocument) : (!oDocument_dontShrink.location);
				getUID = bXMLDocument ? getUID4XML : getUID4HTML;

				clearKeys();
				/*

쿼리를 쉼표로 나누기

				 */
				var aSplitQuery = backupKeys(sQuery).split(/\s*,\s*/);
				var aResult = [];

				var nLen = aSplitQuery.length;

				for (var i = 0; i < nLen; i++)
					aSplitQuery[i] = restoreKeys(aSplitQuery[i]);

				/*

쉼표로 나눠진 쿼리 루프

				 */
				for (var i = 0; i < nLen; i++) {

					var sSingleQuery = aSplitQuery[i];
					var aSingleQueryResult = null;

					var sResultCacheKey = sSingleQuery + (oOptions.single ? '_single' : '');

					/*

결과 캐쉬 뒤짐

					 */
					var aCache = bUseResultCache ? oResultCache[sResultCacheKey] : null;
					if (aCache) {

						/*

캐싱되어 있는게 있으면 parent 가 같은건지 검사한후 aSingleQueryResult 에 대입

						 */
						for (var j = 0, oCache; oCache = aCache[j]; j++) {
							if (oCache.parent == oParent) {
								aSingleQueryResult = oCache.result;
								break;
							}
						}

					}

					if (!aSingleQueryResult) {

						var fpFunction = parseQuery(sSingleQuery);

						cssquery._marked = [];
						for (var j = 0, nDepth = fpFunction.depth; j < nDepth; j++)
							cssquery._marked.push({});

						// console.log(fpFunction.toSource());
						aSingleQueryResult = distinct(fpFunction(oParent, oOptions));

						/*

결과 캐쉬를 사용중이면 캐쉬에 저장

						 */
						if (bUseResultCache&&!oOptions.oneTimeOffCache) {
							if (!(oResultCache[sResultCacheKey] instanceof Array)) oResultCache[sResultCacheKey] = [];
							oResultCache[sResultCacheKey].push({ parent : oParent, result : aSingleQueryResult });
						}

					}

					aResult = aResult.concat(aSingleQueryResult);

				}
				unsetNodeIndexes();

				return aResult;

			})(sQuery, oParent, oOptions);

		}

		executeTime = new Date().getTime() - executeTime;

		if (debugOption.callback) debugOption.callback(sQuery, cost, executeTime);

		return aRet;

	};
	var cssquery;
	if (document.querySelectorAll) {
		function _isNonStandardQueryButNotException(sQuery){
			return /\[\s*(?:checked|selected|disabled)/.test(sQuery)
		}
		function _commaRevise (sQuery,sChange) {
			return sQuery.replace(/\,/gi,sChange);
		}
		function _startCombinator (sQuery) {
			return /^[~>+]/.test(sQuery);
		}
		var _div = document.createElement("div");

		/**

		 */
		cssquery = function(sQuery, oParent, oOptions){
			var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
				'4str'   : [ 'sQuery:String+'],
				'4var'  : [ 'sQuery:String+', 'oParent:Variant' ],
				'4var2' : [ 'sQuery:String+', 'oParent:Variant', 'oOptions:Variant' ]
			},"cssquery");
			oParent = oParent && oParent.$value ? oParent.$value() : oParent;
			oOptions = oOptions && oOptions.$value ? oOptions.$value() : oOptions;

			//-@@cssquery-@@//
			if(MobileCommentJindo.$Jindo.isString(oParent)){
				oParent = document.getElementById(oParent);
			}
			var sTempId, aRet;
			if(!oParent){
				oParent = document;
			}

			oParent = oParent || oParent.ownerDocument || oParent.document ;
			var nNodeType = oParent.nodeType;
			var oldID, oOldParent, id, _clone;

			try{
				if(_isNonStandardQueryButNotException(sQuery)){
					return old_cssquery(sQuery, oParent, oOptions);
				}
				if(nNodeType!==9){
					if(nNodeType === 11){
						//documentFragment일 때 는 복사해서 찾음.
						oParent = oParent.cloneNode(true);
						_clone = _div.cloneNode(true);
						_clone.appendChild(oParent);
						oParent = _clone;
						_clone = null;
					}
					if(oParent.id){ oldID = oParent.id;}
					oParent.setAttribute("id",('C' + new Date().getTime() + Math.floor(Math.random() * 1000000)));
					if(oParent.tagName.toUpperCase()==="BODY"||MobileCommentJindo.$Element._contain((oParent.ownerDocument || oParent.document).body,oParent)){
						//돔이 붙은 경우는 상위 엘리먼트를 기준으로
						id = oParent.id;
						var _parent = oParent.parentNode;
						oOldParent = oParent;
						oParent = _parent;
					}else{
						//돔이 떨어진 경우에는 상위 엘리먼트를 만들어서 탐색.
						_clone = _div.cloneNode(true);
						id = oParent.id;
						oOldParent = oParent;
						_clone.appendChild(oOldParent);
						oParent = _clone;
					}
					sQuery = _commaRevise("#"+id+" "+sQuery,", #"+id);
				}else{
					if(_startCombinator(sQuery)) return [];
				}

				if (oOptions&&oOptions.single) {
					aRet = [oParent.querySelector(sQuery)];
				}else{
					aRet =  _toArray(oParent.querySelectorAll(sQuery));
				}

			}catch(e){
				aRet =  old_cssquery(sQuery, oParent, oOptions);
			}
			if(oOldParent){
				if(oldID) {
					oOldParent.id = oldID;
				}else{
					oOldParent.removeAttribute("id");
				}
				_clone = null;
			}
			return aRet;
		}
	}else{
		cssquery = old_cssquery;
	}
	/**

 * @function
 * @name $$.test
 * @description test() 메서드는 특정 요소가 해당 CSS 선택자(CSS Selector)에 부합하는 요소인지 판단하여 Boolean 형태로 반환한다. CSS 선택자에 연결자는 사용할 수 없음에 유의한다. 선택자의 패턴에 대한 설명은 $$() 함수와 See Also 항목을 참고한다.
 * @param {Element+} element	검사하고자 하는 요소
 * @param {String+} sCSSSelector	CSS 선택자. CSS 선택자로 사용할 수 있는 패턴은 표준 패턴과 비표준 패턴이 있다. 표준 패턴은 CSS Level3 명세서에 있는 패턴을 지원한다.
 * @return {Boolean} 조건에 부합하면 true, 부합하지 않으면 false를 반환한다.
 * @see $$
 * @see <a href="http://www.w3.org/TR/css3-selectors/">CSS Level3 명세서</a> - W3C
 * @example
// oEl 이 div 태그 또는 p 태그, 또는 align 속성이 center로 지정된 요소인지 검사한다.
if (cssquery.test(oEl, 'div, p, [align=center]'))
alert('해당 조건 만족');

	 */
	cssquery.test = function(oEl, sQuery) {
		clearKeys();
		try{
			var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
				'4ele' : [ 'oEl:Element+', 'sQuery:String+' ],
				'4doc' : [ 'oEl:Document+', 'sQuery:String+' ]
			},"<static> cssquery#test");
			eEl = oArgs.oEl;
			sQuery = oArgs.sQuery;
		}catch(e){
			return false;
		}
		var aFunc = parseTestQuery(sQuery);
		for (var i = 0, nLen = aFunc.length; i < nLen; i++){
			if (aFunc[i](oEl)) return true;
		}


		return false;

	};

	/**

 * @function
 * @name $$.useCache
 * @description useCache() 메서드는 $$() 함수(cssquery)를 사용할 때 캐시를 사용할 것인지 설정한다. 캐시를 사용하면 동일한 선택자로 탐색하는 경우 탐색하지 않고 기존 탐색 결과를 반환한다. 따라서 사용자가 변수 캐시를 신경쓰지 않고 편하고 빠르게 사용할 수 있는 장점이 있지만 신뢰성을 위해 DOM 구조가 동적으로 변하지 않을 때만 사용해야 한다.
 * @param {Boolean} [bFlag] 캐시 사용 여부를 지정한다. 이 파라미터를 생략하면 캐시 사용 상태만 반환한다.
 * @return {Boolean} 캐시 사용 상태를 반환한다.
 * @see <a href="#.$$.clearCache">$$.clearCache</a>

	 */
	cssquery.useCache = function(bFlag) {

		if (bFlag !== undefined) {
			bUseResultCache = bFlag;
			cssquery.clearCache();
		}

		return bUseResultCache;

	};

	/**

 * @function
 * @name $$.clearCache
 * @description clearCache() 메서드는 $$() 함수(cssquery)에서 캐시를 사용할 때 캐시를 비울 때 사용한다. DOM 구조가 동적으로 바껴 기존의 캐시 데이터가 신뢰성이 없을 때 사용한다.
 * @return {Void}
 * @see <a href="#.$$.useCache">$$.useCache</a>

	 */
	cssquery.clearCache = function() {
		oResultCache = {};
	};

	/**

 * @function
 * @name $$.getSingle
 * @description getSingle() 메서드는 CSS 선택자를 사용에서 조건을 만족하는 첫 번째 요소를 가져온다. 반환하는 값은 배열이 아닌 객채 또는 null이다. 조건을 만족하는 요소를 찾으면 바로 탐색 작업을 중단하기 때문에 결과가 하나라는 보장이 있을 때 빠른 속도로 결과를 가져올 수 있다.
 $$() 함수(cssquery)에서 캐시를 사용할 때 캐시를 비울 때 사용한다. DOM 구조가 동적으로 바껴 기존의 캐시 데이터가 신뢰성이 없을 때 사용한다.
 *
 * @param1 {String+} sSelector CSS 선택자(CSS Selector). CSS 선택자로 사용할 수 있는 패턴은 표준 패턴과 비표준 패턴이 있다. 표준 패턴은 CSS3 Level3 명세서에 있는 패턴을 지원한다. 선택자의 패턴에 대한 설명은 $$() 함수와 See Also 항목을 참고한다.
 * @param1 {Element+} [oBaseElement] 탐색 대상이 되는 DOM 요소. 지정한 요소의 하위 노드에서만 객체를 탐색한다. 생략될 경우 문서를 대상으로 찾는다.
 * @param1 {Hash+} [oOption] 옵션 객체에 onTimeOffCache 속성을 true로 설정하면 탐색할 때 캐시를 사용하지 않는다.
 *
 * @param2 {String+} sSelector CSS 선택자(CSS Selector). CSS 선택자로 사용할 수 있는 패턴은 표준 패턴과 비표준 패턴이 있다. 표준 패턴은 CSS3 Level3 명세서에 있는 패턴을 지원한다. 선택자의 패턴에 대한 설명은 $$() 함수와 See Also 항목을 참고한다.
 * @param2 {String+} [sBaseElement] 탐색 대상이 되는 DOM 요소의 ID. 지정한 요소의 하위 노드에서만 객체를 탐색한다. 생략될 경우 문서를 대상으로 찾는다.  id을 넣을 수 있다.
 * @param2 {Hash+} [oOption] 옵션 객체에 onTimeOffCache 속성을 true로 설정하면 탐색할 때 캐시를 사용하지 않는다.
 *
 * @return {Element} 선택된 요소. 결과가 없으면 null을 반환한다.
 * @see $Document#query
 * @see <a href="#.$$.useCache">$$.useCache</a>
 * @see $$
 * @see <a href="http://www.w3.org/TR/css3-selectors/">CSS Level3 명세서</a> - W3C

	 */
	cssquery.getSingle = function(sQuery, oParent, oOptions) {

		oOptions = oOptions && oOptions.$value ? oOptions.$value() : oOptions;

		return cssquery(sQuery, oParent, {
			single : true ,
			oneTimeOffCache:oOptions?(!!oOptions.oneTimeOffCache):false
		})[0] || null;
	};


	/**

 * @function
 * @name $$.xpath
 * @description xpath() 메서드는 XPath 문법을 만족하는 요소를 가져온다. 지원하는 문법이 제한적이므로 특수한 경우에만 사용할 것을 권장한다.
 *
 * @param1 {String+} sXPath XPath 값.
 * @return1 {Array} XPath 문법을 만족하는 요소를 원소로 하는 배열. 결과가 없으면 null을 반환한다.
 *
 * @param2 {String+} sXPath XPath 값.
 * @param2 {Element} [elBaseElement] 탐색 대상이 되는 DOM 요소. 지정한 요소의 하위 노드에서만 객체를 탐색한다.
 * @return2 {Array} XPath 문법을 만족하는 요소를 원소로 하는 배열. 결과가 없으면 null을 반환한다.
 *
 * @see $Document#xpathAll
 * @see <a href="http://www.w3.org/standards/techs/xpath#w3c_all">XPath 문서</a> - W3C

	 */
	cssquery.xpath = function(sXPath, oParent) {

		sXPath = sXPath && sXPath.$value ? sXPath.$value() : sXPath;

		sXPath = sXPath.replace(/\/(\w+)(\[([0-9]+)\])?/g, function(_1, sTag, _2, sTh) {
			sTh = sTh || '1';
			return '>' + sTag + ':nth-of-type(' + sTh + ')';
		});

		return old_cssquery(sXPath, oParent);

	};

	/**

 * @function
 * @name $$.debug
 * @description debug() 메서드는 $$() 함수(cssquery)를 사용할 때 성능을 측정하기 위한 기능을 제공하는 함수이다. 파라미터로 입력한 콜백 함수를 사용하여 성능을 측정한다.
 * @param1 {Function} fCallback 선택자 실행에 소요된 비용과 시간을 점검하는 함수. 이 파라미터에 함수 대신 false를 입력하면 성능 측정 모드(debug)를 사용하지 않는다. 이 콜백 함수는 파라미터로 query, cost, executeTime을 갖는다.<br>
 <ul>
	<li>query는 실행에 사용된 선택자이다.</li>
	<li>index는 탐색에 사용된 비용이다(루프 횟수).</li>
	<li>executeTime 탐색에 소요된 시간이다.</li>
 * @return1 {Void}
 *
 * @param2 {Function} fCallback 선택자 실행에 소요된 비용과 시간을 점검하는 함수. 이 파라미터에 함수 대신 false를 입력하면 성능 측정 모드(debug)를 사용하지 않는다. 이 콜백 함수는 파라미터로 query, cost, executeTime을 갖는다.<br>
 <ul>
	<li>query는 실행에 사용된 선택자이다.</li>
	<li>index는 탐색에 사용된 비용이다(루프 횟수).</li>
	<li>executeTime 탐색에 소요된 시간이다.</li>
 * @param2 {Numeric} [nRepeat] 하나의 선택자를 반복 수행할 횟수. 인위적으로 실행 속도를 늦추기 위해 사용할 수 있다.
 * @return2 {Void}
 *
 * @example
cssquery.debug(function(sQuery, nCost, nExecuteTime) {
	if (nCost > 5000)
		console.warn('5000이 넘는 비용이? 확인 -> ' + sQuery + '/' + nCost);
	else if (nExecuteTime > 200)
		console.warn('0.2초가 넘게 실행을? 확인 -> ' + sQuery + '/' + nExecuteTime);
}, 20);

....

cssquery.debug(false);

	 */
	cssquery.debug = function(fpCallback, nRepeat) {

		var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
			'4fun'   : [ 'fpCallback:Function+'],
			'4fun2'  : [ 'fpCallback:Function+', 'nRepeat:Numeric' ]
		},"<static> cssquery#debug");

		debugOption.callback = oArgs.fpCallback;
		debugOption.repeat = oArgs.nRepeat || 1;

	};

	/**

 * @function
 * @name $$.safeHTML
 * @description safeHTML() 메서드는 인터넷 익스플로러에서 innerHTML 속성을 사용할 때 _cssquery_UID 값이 나오지 않게 하는 함수이다. true로 설정하면 탐색하는 노드의 innerHTML 속성에 _cssquery_UID가 나오지 않게 할 수 있지만 탐색 속도는 느려질 수 있다.
 * @param {Boolean} bFlag _cssquery_UID의 표시 여부를 지정한다. true로 설정하면 _cssquery_UID가 나오지 않는다.
 * @return {Boolean} _cssquery_UID 표시 여부 상태를 반환한다. _cssquery_UID를 표시하는 상태이면 true를 반환하고 그렇지 않으면 false를 반환한다.

	 */
	cssquery.safeHTML = function(bFlag) {

		if (arguments.length > 0)
			safeHTML = bFlag && _JINDO_IS_IE;

		return safeHTML || !_JINDO_IS_IE;

	};

	/**

 * @field
 * @name $$.version
 * @description version 속성은 cssquery의 버전 정보를 담고 있는 문자열이다.

	 */
	cssquery.version = sVersion;

	/**

	 * IE에서 validUID,cache를 사용했을때 메모리 닉이 발생하여 삭제하는 모듈 추가.

	 */
	cssquery.release = function() {
		if(_JINDO_IS_IE){

			delete validUID;
			validUID = {};

			if(bUseResultCache){
				cssquery.clearCache();
			}
		}
	};
	/**

	 * cache가 삭제가 되는지 확인하기 위해 필요한 함수
	 * @ignore

	 */
	cssquery._getCacheInfo = function(){
		return {
			uidCache : validUID,
			eleCache : oResultCache
		}
	}
	/**

	 * 테스트를 위해 필요한 함수
	 * @ignore

	 */
	cssquery._resetUID = function(){
		UID = 0
	}
	/**

	 * querySelector가 있는 브라우져에서 extreme을 실행시키면 querySelector을 사용할수 있는 커버리지가 높아져 전체적으로 속도가 빨리진다.
	 * 하지만 ID가 없는 엘리먼트를 기준 엘리먼트로 넣었을 때 기준 엘리먼트에 임의의 아이디가 들어간다.
	 * @param {Boolean} bExtreme true

	 */
	cssquery.extreme = function(bExtreme){
		if(arguments.length == 0){
			bExtreme = true;
		}
		bExtremeMode = bExtreme;
	}

	return cssquery;

})();
//-!MobileCommentJindo.cssquery end!-//
//-!MobileCommentJindo.$$.hidden start(MobileCommentJindo.cssquery)!-//
//-!MobileCommentJindo.$$.hidden end!-//


/**
 *

 * @fileOverview $Agent() 객체의 생성자 및 메서드를 정의한 파일
 * @author AjaxUI lab

 */

//-!MobileCommentJindo.$Agent start!-//
/**

 * @class $Agent() 객체는 운영체제, 브라우저를 비롯한 사용자 시스템 정보를 제공한다.
 * @constructor
 * @description $Agent() 객체를 생성한다. $Agent() 객체는 사용자 시스템의 운영 체제 정보와 브라우저 정보를 제공한다.

 */
MobileCommentJindo.$Agent = function() {
	//-@@$Agent-@@//
	var cl = arguments.callee;
	var cc = cl._cached;

	if (cc) return cc;
	if (!(this instanceof cl)) return new cl;
	if (!cc) cl._cached = this;

	this._navigator = navigator;
	this._dm = document.documentMode;
}
//-!MobileCommentJindo.$Agent end!-//

//-!MobileCommentJindo.$Agent.prototype.navigator start!-//
/**

 * @description navigator() 메서드는 사용자 브라우저 정보를 담고 있는 객체를 반환한다. 브라우저 정보를 저장하는 객체는 브라우저 이름과 버전을 속성으로 가진다. 브라우저 이름은 영어 소문자로 표시하며, 사용자의 브라우저와 일치하는 브라우저 속성은 true 값을 가진다. 또한, 사용자의 브라우저 이름을 확인할 수 있도록 메서드를 제공한다. 다음은 사용자 브라우저 정보를 담고 있는 객체의 속성과 메서드를 설명한 표이다.<br>
 <table>
	<caption>브라우저 정보 객체 속성</caption>
	<thead>
		<tr>
			<th scope="col">이름</th>
			<th scope="col">타입</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>camino</td>
			<td>Boolean</td>
			<td>카미노(Camino) 브라우저 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>chrome</td>
			<td>Boolean</td>
			<td>구글 크롬(Chrome) 브라우저 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>firefox</td>
			<td>Boolean</td>
			<td>파이어폭스(Firefox) 브라우저 사용 여부를 불리언 형태로 저장한다. </td>
		</tr>
		<tr>
			<td>icab</td>
			<td>Boolean</td>
			<td>iCab 브라우저 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>ie</td>
			<td>Boolean</td>
			<td>인터넷 익스플로러(Internet Explorer) 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>konqueror</td>
			<td>Boolean</td>
			<td>Konqueror 브라우저 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>mie</td>
			<td>Boolean</td>
			<td>인터넷 익스플로러 모바일(Internet Explorer Mobile) 브라우저 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>mobile</td>
			<td>Boolean</td>
			<td>모바일 브라우저 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>mozilla</td>
			<td>Boolean</td>
			<td>모질라(Mozilla) 계열의 브라우저 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>msafari</td>
			<td>Boolean</td>
			<td>Mobile 버전 Safari 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>nativeVersion</td>
			<td>Number</td>
			<td>인터넷 익스플로러 호환 모드의 브라우저를 사용할 경우 실제 브라우저를 저장한다.</td>
		</tr>
		<tr>
			<td>netscape</td>
			<td>Boolean</td>
			<td>넷스케이프(Netscape) 브라우저 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>omniweb</td>
			<td>Boolean</td>
			<td>OmniWeb 브라우저 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>opera</td>
			<td>Boolean</td>
			<td>오페라(Opera) 브라우저 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>safari</td>
			<td>Boolean</td>
			<td>Safari 브라우저 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>version</td>
			<td>Number</td>
			<td>사용자가 사용하고 있는 브라우저의 버전 정보를 저장한다. 실수(Float) 형태로 버전 정보를 저장하며 버전 정보가 없으면 -1 값을 가진다.</td>
		</tr>
		<tr>
			<td>webkit</td>
			<td>WebKit 계열 부라우저 사용 여부를 불리언 형태로 저장한다. </td>
		</tr>
	</tbody>
</table>
<table>
	<caption>브라우저 정보 객체 메서드</caption>
	<thead>
		<tr>
			<th scope="col">이름</th>
			<th scope="col">반환 타입</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>getName()</td>
			<td>String</td>
			<td>사용자가 사용하고 있는 브라우저의 이름을 반환한다. 반환하는 브라우저의 이름은 속성 이름과 동일하다.</td>
		</tr>
	</tbody>
 </table>
 * @return {Object} 브라우저 정보를 저장하는 객체.
 * @since 1.4.3 버전부터 mobile,msafari,mopera,mie 사용 가능.<br>1.4.5 버전부터 ipad에서 mobile은 false를 반환한다.
 * @example
oAgent = $Agent().navigator(); // 사용자가 파이어폭스 3를 사용한다고 가정한다.

oAgent.camino  // false
oAgent.firefox  // true
oAgent.konqueror // false
oAgent.mozilla  //true
oAgent.netscape  // false
oAgent.omniweb  //false
oAgent.opera  //false
oAgent.webkit  /false
oAgent.safari  //false
oAgent.ie  //false
oAgent.chrome  //false
oAgent.icab  //false
oAgent.version  //3
oAgent.nativeVersion //-1 (1.4.2부터 사용 가능, IE8에서 호환 모드 사용시 nativeVersion은 8로 나옴.)

oAgent.getName() // firefox

 */
MobileCommentJindo.$Agent.prototype.navigator = function() {
	//-@@$Agent.navigator-@@//
	var info = {};
	var ver  = -1;
	var nativeVersion = -1;
	var u    = this._navigator.userAgent;
	var v    = this._navigator.vendor || "";
	var dm    = this._dm;

	function f(s,h){ return ((h||"").indexOf(s) > -1) };

	info.getName = function(){
		var name = "";
		for(x in info){
			if(typeof info[x] == "boolean" && info[x]&&info.hasOwnProperty(x))
				name = x;
		}
		return name;
	}

	info.webkit		= f("WebKit",u);
	info.opera     = (window.opera !== undefined) || f("Opera",u);
	info.ie        = !info.opera && f("MSIE",u);
	info.chrome    = info.webkit && f("Chrome",u);
	info.safari    = info.webkit && !info.chrome && f("Apple",v);
	info.firefox   = f("Firefox",u);
	info.mozilla   = f("Gecko",u) && !info.safari && !info.chrome && !info.firefox;
	info.camino    = f("Camino",v);
	info.netscape  = f("Netscape",u);
	info.omniweb   = f("OmniWeb",u);
	info.icab      = f("iCab",v);
	info.konqueror = f("KDE",v);
	info.mobile	   = (f("Mobile",u)||f("Android",u)||f("Nokia",u)||f("webOS",u)||f("Opera Mini",u)||f("BlackBerry",u)||(f("Windows",u)&&f("PPC",u))||f("Smartphone",u)||f("IEMobile",u))&&!f("iPad",u);
	info.msafari   = (!f("IEMobile",u) && f("Mobile",u))||(f("iPad",u)&&f("Safari",u));
	info.mopera    = f("Opera Mini",u);
	info.mie       = f("PPC",u)||f("Smartphone",u)||f("IEMobile",u);

	try {

		if (info.ie) {
			if(dm > 0){
				ver = dm;
				if (u.match(/(?:Trident)\/([0-9.]+)/)){
					var nTridentNum = parseInt(RegExp.$1,10);
					if(nTridentNum > 3){
						nativeVersion = nTridentNum + 4;
					}
				}else{
					nativeVersion = ver;
				}
			}else{
				nativeVersion = ver = u.match(/(?:MSIE) ([0-9.]+)/)[1];
			}
		} else if (info.safari||info.msafari) {

			ver = parseFloat(u.match(/Safari\/([0-9.]+)/)[1],10);
			if (ver == 100) {
				ver = 1.1;
			} else {
				if(u.match(/Version\/([0-9.]+)/)){
					ver = RegExp.$1;
				}else{
					ver = [1.0,1.2,-1,1.3,2.0,3.0][Math.floor(ver/100)];

				}
			}
		} else if(info.mopera){
			ver = u.match(/(?:Opera\sMini)\/([0-9.]+)/)[1];
		} else if (info.firefox||info.opera||info.omniweb) {
			ver = u.match(/(?:Firefox|Opera|OmniWeb)\/([0-9.]+)/)[1];
		} else if (info.mozilla) {
			ver = u.match(/rv:([0-9.]+)/)[1];
		} else if (info.icab) {
			ver = u.match(/iCab[ \/]([0-9.]+)/)[1];
		} else if (info.chrome) {
			ver = u.match(/Chrome[ \/]([0-9.]+)/)[1];
		}

		info.version = parseFloat(ver,10);
		info.nativeVersion = parseFloat(nativeVersion,10);
		if (isNaN(info.version)) info.version = -1;
	} catch(e) {
		info.version = -1;
	}

	this.navigator = function() {
		return info;
	};

	return info;
};
//-!MobileCommentJindo.$Agent.prototype.navigator end!-//

//-!MobileCommentJindo.$Agent.prototype.os start!-//
/**

 * @description os() 메서드는 사용자 운영체제 정보를 담고 있는 객체를 반환한다. 운영체제 정보를 저장하는 객체는 운영체제 이름을 속성으로 가진다. 운영 체제 속성은 영어 소문자로 표시하며, 사용자의 운영체제와 일치하는 운영체제의 속성은 true 값을 가진다. 또한 사용자의 운영체제 이름을 확인할 수 있도록 메서드를 제공한다.<br> 다음은 사용자 운영체제 정보를 담고 있는 객체의 속성과 메서드를 설명한 표이다.<br>
<table>
	<caption>운영체제 정보 객체 속성</caption>
	<thead>
		<tr>
			<th scope="col">이름</th>
			<th scope="col">타입</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>android</td>
			<td>Boolean</td>
			<td>Android 운영체제 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>blackberry</td>
			<td>Boolean</td>
			<td>Blackberry 운영체제 사용 여부를 불리언 형태로 저장한다. </td>
		</tr>
		<tr>
			<td>iphone</td>
			<td>Boolean</td>
			<td>iPhone 운영체제 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>linux</td>
			<td>Boolean</td>
			<td>Linux운영체제 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>mac</td>
			<td>Boolean</td>
			<td>Mac운영체제 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>mwin</td>
			<td>Boolean</td>
			<td>Window Mobile 운영체제 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>nokia</td>
			<td>Boolean</td>
			<td>Nokia 운영체제 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>vista</td>
			<td>Boolean</td>
			<td>Windows Vista 운영체제 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>webos</td>
			<td>Boolean</td>
			<td>webOS 운영체제 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>win</td>
			<td>Boolean</td>
			<td>Windows계열 운영체제 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>win2000</td>
			<td>Boolean</td>
			<td>Windows 2000운영체제 사용 여부 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>win7</td>
			<td>Boolean</td>
			<td>Windows 7 운영체제 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>winxp</td>
			<td>Boolean</td>
			<td>Windows XP 운영체제 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>xpsp2</td>
			<td>Boolean</td>
			<td>Windows XP SP 2 운영체제 사용 여부를 불리언 형태로 저장한다.</td>
		</tr>
	</tbody>
</table>
<table>
	<caption>운영체제 정보 객체 메서드</caption>
	<thead>
		<tr>
			<th scope="col">이름</th>
			<th scope="col">반환 타입</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>getName()</td>
			<td>String</td>
			<td>사용자가 사용하고 있는 운영체제의 이름을 반환한다. 반환하는 운영체제의 이름은 속성 이름과 동일하다.</td>
		</tr>
	</tbody>
 </table>
 * @return {Object} 운영체제 정보를 저장하는 객체.
 * @since 1.4.3 버전부터 iphone,android,nokia,webos,blackberry,mwin 사용 가능.<br>1.4.5 버전부터 ipad 사용가능.
 * @example
oOS = $Agent().os();  // 사용자의 운영체제가 Windows XP라고 가정한다.
oOS.linux  // false
oOS.mac  // false
oOS.vista  // false
oOS.win  // true
oOS.win2000  // false
oOS.winxp  // true
oOS.xpsp2  // false
oOS.win7  // false
oOS.getName() // winxp

 */
MobileCommentJindo.$Agent.prototype.os = function() {
	//-@@$Agent.os-@@//
	var info = {};
	var u    = this._navigator.userAgent;
	var p    = this._navigator.platform;
	var f    = function(s,h){ return (h.indexOf(s) > -1) };

	info.getName = function(){
		var name = "";
		for(x in info){
			if(info[x]===true&&info.hasOwnProperty(x))
				name = x;
		}
		return name;
	}

	info.win     = f("Win",p)
	info.mac     = f("Mac",p);
	info.linux   = f("Linux",p);
	info.win2000 = info.win && (f("NT 5.0",u) || f("2000",u));
	info.winxp   = info.win && f("NT 5.1",u);
	info.xpsp2   = info.winxp && f("SV1",u);
	info.vista   = info.win && f("NT 6.0",u);
	info.win7  = info.win && f("NT 6.1",u);
	info.ipad = f("iPad",u);
	info.iphone = f("iPhone",u) && !info.ipad;
	info.android = f("Android",u);
	info.nokia =  f("Nokia",u);
	info.webos = f("webOS",u);
	info.blackberry = f("BlackBerry",u);
	info.mwin = f("PPC",u)||f("Smartphone",u)||f("IEMobile",u);


	this.os = function() {
		return info;
	};

	return info;
};
//-!MobileCommentJindo.$Agent.prototype.os end!-//

//-!MobileCommentJindo.$Agent.prototype.flash start!-//
/**

 * @description flash() 메서드는 사용자의 Flash Player 정보를 담고 있는 객체를 반환한다. Flash Player 정보를 저장하는 객체는 Flash Player 설치 여부와 설치된 Flash Player의 버전 정보를 제공한다. 다음은 Flash Player의 정보를 담고 있는 객체의 속성을 설명한 표이다.<br>
 <table>
	<caption>Flash Player 정보 객체 속성</caption>
	<thead>
		<tr>
			<th scope="col">이름</th>
			<th scope="col">타입</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>installed</td>
			<td>Boolean</td>
			<td>Flash Player 설치 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>version</td>
			<td>Number</td>
			<td>사용자가 사용하고 있는 Flash Player의 버전 정보를 저장한다. 실수(Float) 형태로 버전 정보를 저장하며, Flash Player가 설치되지 않은 경우 -1을 저장한다. </td>
		</tr>
	</tbody>
 </table>
 * @return {Object} Flash Player 정보를 저장하는 객체.
 * @see <a href="http://www.adobe.com/products/flashplayer/">Flash Player 공식 페이지</a>
 * @example
var oFlash = $Agent.flash();
oFlash.installed  // 플래시 플레이어를 설치했다면 true
oFlash.version  // 플래시 플레이어의 버전.

 */
MobileCommentJindo.$Agent.prototype.flash = function() {
	//-@@$Agent.flash-@@//
	var info = {};
	var p    = this._navigator.plugins;
	var m    = this._navigator.mimeTypes;
	var f    = null;

	info.installed = false;
	info.version   = -1;

	if (!MobileCommentJindo.$Jindo.isUndefined(p)&& p.length) {
		f = p["Shockwave Flash"];
		if (f) {
			info.installed = true;
			if (f.description) {
				info.version = parseFloat(f.description.match(/[0-9.]+/)[0],10);
			}
		}

		if (p["Shockwave Flash 2.0"]) {
			info.installed = true;
			info.version   = 2;
		}
	} else if (!MobileCommentJindo.$Jindo.isUndefined(m) && m.length) {
		f = m["application/x-shockwave-flash"];
		info.installed = (f && f.enabledPlugin);
	} else {
		for(var i=10; i > 1; i--) {
			try {
				f = new ActiveXObject("ShockwaveFlash.ShockwaveFlash."+i);
				info.installed = true;
				info.version   = i;
				break;
			} catch(e) {}
		}
	}

	this.flash = function() {
		return info;
	};
    /*

하위호환을 위해 일단 남겨둔다.

     */
	this.info = this.flash;

	return info;
};
//-!MobileCommentJindo.$Agent.prototype.flash end!-//

//-!MobileCommentJindo.$Agent.prototype.silverlight start!-//
/**

 * silverlight() 메서드는 사용자의 실버라이트(Silverlight) 정보를 담고 있는 객체를 반환한다.
 * @description 실버라이트 정보를 저장하는 객체는 실버라이트 설치 여부와 설치된 실버라이트의 버전 정보를 제공한다. 다음은 실버라이트 정보를 담고 있는 객체의 속성을 설명한 표이다.<br>
  <table>
	<caption>실버라이트 정보 객체 속성</caption>
	<thead>
		<tr>
			<th scope="col">이름</th>
			<th scope="col">타입</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>installed</td>
			<td>Boolean</td>
			<td>실버라이트 설치 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>version</td>
			<td>Number</td>
			<td>사용자가 사용하고 있는 실버라이트의 버전 정보를 저장한다. 실수(Float) 형태로 버전 정보를 저장하며, 실버라이트가 설치되지 않은 경우 -1을 저장한다. </td>
		</tr>
	</tbody>
 </table>
 * @return {Object} 실버라이트 정보를 저장하는 객체.
 * @see <a href="http://www.microsoft.com/silverlight/">실버라이트 공식 페이지</a>
 * @example
var oSilver = $Agent.silverlight();
oSilver.installed  // Silverlight 플레이어를 설치했다면 true
oSilver.version  // Silverlight 플레이어의 버전.

 */
MobileCommentJindo.$Agent.prototype.silverlight = function() {
	//-@@$Agent.silverlight-@@//
	var info = new Object;
	var p    = this._navigator.plugins;
	var s    = null;

	info.installed = false;
	info.version   = -1;

	if (!MobileCommentJindo.$Jindo.isUndefined(p) && p.length) {
		s = p["Silverlight Plug-In"];
		if (s) {
			info.installed = true;
			info.version = parseInt(s.description.split(".")[0],10);
			if (s.description == "1.0.30226.2") info.version = 2;
		}
	} else {
		try {
			s = new ActiveXObject("AgControl.AgControl");
			info.installed = true;
			if(s.isVersionSupported("3.0")){
				info.version = 3;
			}else if (s.isVersionSupported("2.0")) {
				info.version = 2;
			} else if (s.isVersionSupported("1.0")) {
				info.version = 1;
			}
		} catch(e) {}
	}

	this.silverlight = function() {
		return info;
	};

	return info;
};
//-!MobileCommentJindo.$Agent.prototype.silverlight end!-//



//-!MobileCommentJindo.$A start!-//
/**

 * @fileOverview $A() 객체의 생성자 및 메서드를 정의한 파일
 * @name array.js
 * @author  AjaxUI lab

 */

/**

 * @class $A() 객체는 배열(Array)을 좀 더 편리하게 다룰 수 있도록 메서드를 제공한다. $A() 객체를 생성할 때 원본 배열 객체를 래핑(warpping)하여 생성한다. 여기서 래핑이란 자바스크립트의 함수를 감싸 본래 함수의 기능에 새로운 확장 기능을 추가하는 것을 말한다.
 * @extends core
 * @constructor
 * @description $A() 객체를 생성한다.
 * @param {Void|Null|Undefined|Array+|ArrayStyle} [vArray] 없거나 null, undefined인 경우는 빈배열이 할당됨.
 * @example
var zoo = ["zebra", "giraffe", "bear", "monkey"];
var waZoo = $A(zoo); // ["zebra", "giraffe", "bear", "monkey"]를 래핑한 $A 객체를 생성하여 반환

 */
MobileCommentJindo.$A = function(array) {
	//-@@$A-@@//
	var cl = arguments.callee;

	if (array instanceof cl) {
		return array;
	}
	if (!(this instanceof cl)){
		try {
			MobileCommentJindo.$Jindo._warn(arguments.length, 1,"$A");
			return new cl(array);
		} catch(e) {
			if (e instanceof TypeError) { return null; }
			throw e;
		}
	}

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4voi' : [ ],
		'4arr' : ['aPram:Array+'],
		'4nul' : [ 'oNull:Null' ],
		'4und' : [ 'oUndefined:Undefined' ],
		'arrt' : [ 'aPram:ArrayStyle' ]
	},"$A");
	if(oArgs == null) array = [];
	switch(oArgs+"") {
	case 'arrt':
	case '4arr':
		array = oArgs.aPram;
		break;
	case '4nul':
	case '4und':
	case '4voi':
	    array = [];

	}



	this._array = [];
	for(var i=0; i < array.length; i++) {
		this._array[this._array.length] = array[i];
	}
};
MobileCommentJindo.$A.checkVarTypeObj ={
	'4fun' : [ 'fCallback:Function+'],
	'4thi' : [ 'fCallback:Function+', 'oThis:Variant']
};
//-!MobileCommentJindo.$A end!-//

//-!MobileCommentJindo.$A.prototype.toString start!-//
/**

* @description toString() 메서드는 내부 배열을 문자열로 변환한다. 자바스크립트의 Array.toString() 메서드를 사용한다.
 * @return {String} 내부 배열을 변환한 문자열.
 * @See <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/toString">array.toString()</a> - MDN Docs
 * @example
var zoo = ["zebra", "giraffe", "bear", "monkey"];
$A(zoo).toString();
// 결과 : zebra,giraffe,bear,monkey

 */
MobileCommentJindo.$A.prototype.toString = function() {
	//-@@$A.toString-@@//
	return this._array.toString();
};
//-!MobileCommentJindo.$A.prototype.toString end!-//

//-!MobileCommentJindo.$A.prototype.get start!-//
/**

 * @description get() 메서드는 파라미터로 지정한 인덱스로 내부 배열의 원소 값을 조회한다.
 * @param {Numeric} nIndex 조회할 원소의 인덱스. 인덱스는 0부터 시작한다.
 * @return {Variant} 배열에서의 해당 인덱스의 원소 값.
 * @since 1.4.2
 * @example
var zoo = ["zebra", "giraffe", "bear", "monkey"];
var waZoo = $A(zoo);

// 원소 값 조회
waZoo.get(1); // 결과 : giraffe
waZoo.get(3); // 결과 : monkey

 */
MobileCommentJindo.$A.prototype.get = function(nIndex){
	//-@@$A.get-@@//
	 MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4num' : [ 'nIndex:Numeric' ]
	},"$A#get");
	return this._array[nIndex];
};
//-!MobileCommentJindo.$A.prototype.get end!-//

//-!MobileCommentJindo.$A.prototype.set start!-//
/**

 * @description set() 메서드는 인덱스와 값을 지정하여 값을 셋팅한다.
 * @param {Numeric} nIndex 인덱스
 * @param {Variant} vValue 다양한 값.
 * @return {$A} 인스턴스
 * @since 2.0.0
 * @example
var zoo = ["zebra", "giraffe", "bear", "monkey"];
var waZoo = $A(zoo);

// 값 셋팅
waZoo.set(1,"pig"); // 결과 : $A(["zebra", "pig", "bear", "monkey"]);

 */
MobileCommentJindo.$A.prototype.set = function(nIndex,vValue){
	//-@@$A.set-@@//
	MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4num' : [ 'nIndex:Numeric' ,'vValue:Variant']

	},"$A#set");

	this._array[nIndex] = vValue;
	return this;
};
//-!MobileCommentJindo.$A.prototype.set end!-//

//-!MobileCommentJindo.$A.prototype.length start!-//
/**

 * @description length() 메서드는 네이티브 length의 속성과 같이 내부 배열 크기를 지정한다.
 *
 * @param1 {Void}
 * @return1	{Number} 현재 내부 배열의 크기(Number)를 반환한다.
 *
 * @param2 	{Numeric} nLen 지정할 배열의 크기.지정할 배열의 크기. nLen이 기존 배열의 크기보다 크면 적용되지 않는다. nLen 이 기존 배열의 크기보다 작으면 nLen번째 이후의 원소는 제거한다.
 * @return2	{$A} $A() 객체를 반환한다.
 *
 * @param3 	{Numeric} nLen 지정할 배열의 크기. nLen이 기존 배열의 크기보다 크면 추가된 배열의 공간에 vValue 파라미터의 값으로 채운다. nLen 이 기존 배열의 크기보다 작으면 nLen번째 이후의 원소는 제거한다.
 * @param3	{Variant} vValue 새로운 원소를 추가할 때 사용할 초기 값.
 * @return3 	{$A} $A() 객체를 반환한다.
 *
 * @example
var zoo = ["zebra", "giraffe", "bear", "monkey"];

// 배열의 크기 지정 (원소가 삭제되는 경우)
$A(zoo).length(2);
// 결과 : ["zebra", "giraffe"]
 * @example
// 배열의 크기 지정 (원소가 추가되는 경우)
$A(zoo).length(6, "(Empty)");
// 결과 : ["zebra", "giraffe", "bear", "monkey", "(Empty)", "(Empty)"]
$A(zoo).length(5, birds);
// 결과 : ["zebra", "giraffe", "bear", "monkey", ["parrot", "sparrow", "dove"]]
 * @example
// 배열의 크기 조회
$A(zoo).length(); // 결과 : 4

 */
MobileCommentJindo.$A.prototype.length = function(nLen, oValue) {
	//-@@$A.length-@@//

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4num' : [ MobileCommentJindo.$Jindo._F('nLen:Numeric')],
		'sv' : [ 'nLen:Numeric', 'vValue:Variant'],
		'4voi' : [ ]
	},"$A#length");

	switch(oArgs+"") {
		case '4num':
			this._array.length = oArgs.nLen;
			return this;

		case 'sv':
		    var l = this._array.length;
			this._array.length = oArgs.nLen;
			for(var i=l; i < nLen; i++) {
				this._array[i] = oArgs.vValue;
			}
			return this;

		case '4voi':
		    return this._array.length;

	}
};
//-!MobileCommentJindo.$A.prototype.length end!-//

//-!MobileCommentJindo.$A.prototype.has start(MobileCommentJindo.$A.prototype.indexOf)!-//
/**

 * @description has() 메서드는 내부 배열에서 특정 값을 갖는 원소의 유무를 Boolean 형태로 반환한다.
 * @param {Variant} vValue 검색할 값.
 * @return {Boolean} 배열에서 매개 변수의 값과 동일한 원소를 찾으면 true를, 찾지 못하면 false를 반환한다.
 * @see $A#indexOf
 * @example
var arr = $A([1,2,3]);

// 값 검색
arr.has(3); // 결과 : true
arr.has(4); // 결과 : false

 */
MobileCommentJindo.$A.prototype.has = function(oValue) {
	//-@@$A.has-@@//
	return (this.indexOf(oValue) > -1);
};
//-!MobileCommentJindo.$A.prototype.has end!-//

//-!MobileCommentJindo.$A.prototype.indexOf start!-//
/**

 * @description indexOf() 메서드는 내부 배열에서 특정 값을 갖는 원소를 검색하고 검색된 원소의 인덱스를 반환한다.
 * @param {Variant} vValue 검색할 값.
 * @return {Numeric} 검색된 원소의 인덱스. 인덱스는 0부터 시작한다. 파라미터와 같은 값을 가진 원소를 찾지 못하면 -1을 반환한다.
 * @see $A#has
 * @example
var zoo = ["zebra", "giraffe", "bear"];
va  r waZoo = $A(zoo);

  // 값 검색 후 인덱스 리턴
  waZoo.indexOf("giraffe"); // 1
  waZoo.indexOf("monkey"); // -1

 */
MobileCommentJindo.$A.prototype.indexOf = function(oValue) {
	//-@@$A.indexOf-@@//
	if (this._array.indexOf) {
		MobileCommentJindo.$A.prototype.indexOf = function(oValue) {
			return this._array.indexOf(oValue);
		}
	}else{
		MobileCommentJindo.$A.prototype.indexOf = function(oValue) {
			for(var i=0; i < this._array.length; i++) {
				if (this._array[i] == oValue) return i;
			}
			return -1;
		}
	}

	return this.indexOf(oValue);
};
//-!MobileCommentJindo.$A.prototype.indexOf end!-//

//-!MobileCommentJindo.$A.prototype.$value start!-//
/**

 * @description $value() 메서드는 내부 배열을 반환한다.
 * @return {Array} 원본 배열
 * @example
var waNum = $A([1, 2, 3]);
waNum.$value(); // 원래의 배열인 [1, 2, 3]이 반환된다.

 */
MobileCommentJindo.$A.prototype.$value = function() {
	//-@@$A.$value-@@//
	return this._array;
};
//-!MobileCommentJindo.$A.prototype.$value end!-//

//-!MobileCommentJindo.$A.prototype.push start!-//
/**

 * @description push() 메서드는 내부 배열에 하나 이상의 원소를 추가하고 배열의 크기를 반환한다.
 * @param {Variant} vValue1 추가할 첫 번째 원소의 값.
 * @param {Variant} […] …
 * @param {Variant} [vValueN] 추가할 N 번째 원소의 값.
 * @return {Numeric} 원소를 추가한 후 배열의 크기.
 * @see $A#pop
 * @see $A#shift
 * @see $A#unshift
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push">array.push()</a> - MDN Docs
 * @example
var arr = $A([1,2,3]);

// 원소 추가
arr.push(4);	// 결과 : 4 반환, 내부 배열은 [1,2,3,4]로 변경 됨
arr.push(5,6);	// 결과 : 6 반환, 내부 배열은 [1,2,3,4,5,6]로 변경 됨

 */
MobileCommentJindo.$A.prototype.push = function(oValue1/*, ...*/) {
	//-@@$A.push-@@//
	return this._array.push.apply(this._array, _toArray(arguments));
};
//-!MobileCommentJindo.$A.prototype.push end!-//

//-!MobileCommentJindo.$A.prototype.pop start!-//
/**

 * @description pop() 메서드는 내부 배열의 마지막 원소를 삭제한다.
 * @return {Variant} 삭제한 원소.
 * @see $A#push
 * @see $A#shift
 * @see $A#unshift
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop">array.pop()</a> - MDN Docs
 * @example
var arr = $A([1,2,3,4,5]);

arr.pop(); // 결과 : 5 반환, 내부 배열은 [1,2,3,4]로 변경 됨

 */
MobileCommentJindo.$A.prototype.pop = function() {
	//-@@$A.pop-@@//
	return this._array.pop();
};
//-!MobileCommentJindo.$A.prototype.pop end!-//

//-!MobileCommentJindo.$A.prototype.shift start!-//
/**

 * @description shift() 메서드는 내부 배열의 모든 원소를 앞으로 한 칸씩 이동시킨다. 내부 배열의 첫 번째 원소는 삭제된다.
 * @return {Variant} 삭제한 첫 번째 원소.
 * @see $A#pop
 * @see $A#push
 * @see $A#unshift
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/shift">array.shift()</a> - MDN Docs
 * @example
var arr  = $A(['Melon','Grape','Apple','Kiwi']);

arr.shift(); // 결과 : 'Melon' 반환, 내부 배열은 ["Grape", "Apple", "Kiwi"]로 변경 됨.

 */
MobileCommentJindo.$A.prototype.shift = function() {
	//-@@$A.shift-@@//
	return this._array.shift();
};
//-!MobileCommentJindo.$A.prototype.shift end!-//

//-!MobileCommentJindo.$A.prototype.unshift start!-//
/**

 * @description unshift() 메서드는 내부 배열의 맨 앞에 하나 이상의 원소를 삽입한다.
 * @param {Variant} vValue1 삽입할 첫 번째 값.
 * @param {Variant} […] …
 * @param {Variant} [vValueN] 삽입할 N 번째 값.
 * @return {Numeric} 원소를 추가한 후 배열의 크기
 * @see $A#pop
 * @see $A#push
 * @see $A#shift
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift">array.unshift()</a> - MDN Docs
 * @example
var arr = $A([4,5]);

arr.unshift('c');		// 결과 : 3 반환, 내부 배열은 ["c", 4, 5]로 변경 됨.
arr.unshift('a', 'b');	// 결과 : 5 반환, 내부 배열은 ["a", "b", "c", 4, 5]로 변경 됨.

 */
MobileCommentJindo.$A.prototype.unshift = function(oValue1/*, ...*/) {
	//-@@$A.unshift-@@//
	this._array.unshift.apply(this._array, _toArray(arguments));

	return this._array.length;
};
//-!MobileCommentJindo.$A.prototype.unshift end!-//

//-!MobileCommentJindo.$A.prototype.forEach start(MobileCommentJindo.$A.Break,MobileCommentJindo.$A.Continue)!-//
/**

 * @description forEach() 메서드는 내부 배열의 모든 원소를 순회하면서 콜백 함수를 실행한다.
 *
 * @param1 {Function+} fCallback 배열을 순회하면서 실행할 콜백 함수. 콜백 함수는 파라미터로 value, index, array를 갖는다.$A.Break()와 $A.Continue()을 사용할 수 있다.<br>
 <ul>
 <li>value는 배열이 가진 원소의 값이다.</li>
 <li>index는 해당 원소의 인덱스이다.</li>
 <li>array는 배열 그 자체를 가리킨다.</li>
 </ul>
 * @return1 {$A}	$A() 객체.
 *
 * @param2 {Function+} fCallback 배열을 순회하면서 실행할 콜백 함수. 콜백 함수는 파라미터로 value, index, array를 갖는다.$A.Break()와 $A.Continue()을 사용할 수 있다.<br>
 <ul>
 <li>value는 배열이 가진 원소의 값이다.</li>
 <li>index는 해당 원소의 인덱스이다.</li>
 <li>array는 배열 그 자체를 가리킨다.</li>
 </ul>
 * @param2 {Variant} oThis 콜백 함수가 객체의 메서드일 때 콜백 함수 내부에서 this 키워드의 실행 문맥(Execution Context)으로 사용할 객체.
 * @return2 {$A}	$A() 객체.
 * @import core.$A[Break, Continue]
 * @see $A#map
 * @see $A#filter
 * @example
var waZoo = $A(["zebra", "giraffe", "bear", "monkey"]);

waZoo.forEach(function(value, index, array) {
	document.writeln((index+1) + ". " + value);
});

// 결과 :
// 1. zebra
// 2. giraffe
// 3. bear
// 4. monkey

 * @example
var waArray = $A([1, 2, 3]);

waArray.forEach(function(value, index, array) {
	array[index] += 10;
});

document.write(waArray.$value());
// 결과 : 11, 12, 13 (내부 배열에 10씩 더해짐)

 */
MobileCommentJindo.$A.prototype.forEach = function(fCallback, oThis) {
	//-@@$A.forEach-@@//
	function forEachBody(fpEach){
		return function(fCallback, oThis){
			var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, MobileCommentJindo.$A.checkVarTypeObj,"$A#forEach");
			var that = this;
			function f(v,i,a) {
				try {
					fCallback.apply(oThis, _slice.call(arguments));
				} catch(e) {
					if (!(e instanceof that.constructor.Continue)) throw e;
				}
			};

			fpEach(this, f);
			return this;
		}
	}
	if (this._array.forEach) {
		MobileCommentJindo.$A.prototype.forEach = forEachBody(function(scope, fp){
			try {
				scope._array.forEach(fp);
			} catch(e) {
				if (!(e instanceof scope.constructor.Break)) throw e;
			}
		});
	}else{
		MobileCommentJindo.$A.prototype.forEach = forEachBody(function(scope, fp){
			var arr = scope._array;
			for(var i=0,l=arr.length; i < l; i++) {
				try {
					fp(arr[i], i, arr);
				} catch(e) {
					if (e instanceof scope.constructor.Break) break;
					throw e;
				}
			}
		});
	}
	return this.forEach.apply(this,_slice.call(arguments));
};
//-!MobileCommentJindo.$A.prototype.forEach end!-//

//-!MobileCommentJindo.$A.prototype.slice start!-//
/**

 * @description slice() 메서드는 내부 배열의 일부분을 추출한다.
 * @param {Numeric} nStart 배열에서 추출할 부분의 시작 원소 인덱스. 인덱스는 0부터 시작한다.
 * @param {Numeric} nEnd 배열에서 추출할 부분의 마지막 원소 바로 다음 인덱스.
 * @return {$A} 내부 배열의 일부를 추출한 새로운 $A() 객체.<br>nStart 값이 0보다 작거나 nStart 값이 nEnd보다 크거나 같으면 빈 배열을 가진 $A() 객체를 반환한다.
 * @example
var arr = $A([12, 5, 8, 130, 44]);
var newArr = arr.slice(1,3);
// 잘라낸 배열인 [5, 8]를 래핑한 $A 객체를 리턴한다. (원래의 배열은 변화 없음)

 * @example
var arr = $A([12, 5, 8, 130, 44]);
var newArr = arr.slice(3,3);
// []를 래핑한 $A 객체를 리턴한다.

 */
MobileCommentJindo.$A.prototype.slice = function(nStart, nEnd) {
	//-@@$A.slice-@@//
	var a = this._array.slice.call(this._array, nStart, nEnd);
	return MobileCommentJindo.$A(a);
};
//-!MobileCommentJindo.$A.prototype.slice end!-//

//-!MobileCommentJindo.$A.prototype.splice start!-//
/**

 * @description splice() 메서드는 내부 배열의 일부분을 삭제한다.
 * @param {Numeric} nIndex	배열에서 삭제할 부분의 시작 원소 인덱스. 인덱스는 0부터 시작한다.
 * @param {Numeric} [nHowMany] 시작 원소부터 삭제할 원소의 개수.<br>
 * 이 값과 vValue1, ..., vValueN 파라미터를 생략하면 nIndex 번째 원소부터 배열의 마지막 원소까지 삭제한다.<br>
 * 이 값을 0으로 지정하거나 지정하지 않고 vValue1, ..., vValueN 파라미터에 값을 지정하면 nIndex 번째 위치에 지정한 vValue1, ..., vValueN 값을 추가한다.
 * @param {Variant} [vValue1] 삭제한 배열에 추가할 첫 번째 값. nIndex 인덱스에 지정한 값이 추가된다.
 * @param {Variant} […] …
 * @param {Variant} [vValueN] 삭제한 배열에 추가할 N 번째 값. nIndex + N 인덱스에 지정한 값이 추가된다.
 * @return {$A} 삭제한 원소를 래핑하는 새로운 $A() 객체.<br>삭제한 원소가 없을 경우 빈 배열을 가진 $A() 객체를 반환한다.
 * @example
var arr = $A(["angel", "clown", "mandarin", "surgeon"]);

var removed = arr.splice(2, 0, "drum");
// arr의 내부 배열은 ["angel", "clown", "drum", "mandarin", "surgeon"]로 인덱스 2에 drum이 추가 됨
// removed의 내부 배열은 []로 삭제된 원소가 없음

removed = arr.splice(3, 1);
// arr의 내부 배열은 ["angel", "clown", "drum", "surgeon"]로 mandarin이 삭제 됨
// removed의 내부 배열은 삭제된 원소 ["mandarin"]를 가짐

removed = arr.splice(2, 1, "trumpet", "parrot");
// arr의 내부 배열은 ["angel", "clown", "trumpet", "parrot", "surgeon"]로 drum이 삭제되고 새로운 원소가 추가 됨
// removed의 내부 배열은 삭제된 원소 ["drum"]을 가짐

removed = arr.splice(3);
// arr의 내부 배열은 ["angel", "clown", "trumpet"]로 인덱스 3부터 마지막 원소가 삭제되었음
// removed의 내부 배열은 삭제된 원소 ["parrot", "surgeon"]을 가짐

 */
MobileCommentJindo.$A.prototype.splice = function(nIndex, nHowMany/*, oValue1,...*/) {
	//-@@$A.splice-@@//
	var a = this._array.splice.apply(this._array, _toArray(arguments));

	return MobileCommentJindo.$A(a);
};
//-!MobileCommentJindo.$A.prototype.splice end!-//

//-!MobileCommentJindo.$A.prototype.shuffle start!-//
/**

 * @description shuffle() 메서드는 배열 원소의 순서를 무작위로 섞는다.
 * @return {$A} 배열이 섞여진 $A() 객체
 * @see $A#reverse
 * @example
var dice = $A([1,2,3,4,5,6]);

dice.shuffle();
document.write("You get the number " + dice.get(0));
// 결과 : 1부터 6까지의 숫자 중 랜덤한 숫자

 */
MobileCommentJindo.$A.prototype.shuffle = function() {
	//-@@$A.shuffle-@@//
	this._array.sort(function(a,b){ return Math.random()>Math.random()?1:-1 });

	return this;
};
//-!MobileCommentJindo.$A.prototype.shuffle end!-//

//-!MobileCommentJindo.$A.prototype.reverse start!-//
/**

 * @description reverse() 메서드는 배열 원소의 순서를 거꾸로 뒤집는다.
 * @return {$A} 원소 순서를 뒤집은 $A() 객체
 * @see $A#shuffle
 * @example
var arr = $A([1, 2, 3, 4, 5]);

arr.reverse(); // 결과 : [5, 4, 3, 2, 1]

 */
MobileCommentJindo.$A.prototype.reverse = function() {
	//-@@$A.reverse-@@//
	this._array.reverse();

	return this;
};
//-!MobileCommentJindo.$A.prototype.reverse end!-//

//-!MobileCommentJindo.$A.prototype.empty start!-//
/**

 * @description empty() 메서드는 배열의 모든 원소를 제거하고, 빈 배열로 만든다.
 * @return {$A} 배열의 원소가 제거된 $A() 객체
 * @example
var arr = $A([1, 2, 3]);

arr.empty(); // 결과 : []

 */
MobileCommentJindo.$A.prototype.empty = function() {
	//-@@$A.empty-@@//
	this._array.length = 0;
	return this;
};
//-!MobileCommentJindo.$A.prototype.empty end!-//

//-!MobileCommentJindo.$A.Break start!-//
/**

 * @description Break() 메서드는 forEach(), filter(), map() 메서드의 루프를 중단한다. 내부적으로는 강제로 예외를 발생시키는 구조이므로, try - catch 영역에서 이 메서드를 실행하면 정상적으로 동작하지 않을 수 있다.
 * @see $A#Continue
 * @see $A#forEach
 * @see $A#filter
 * @see $A#map
 * @example
$A([1,2,3,4,5]).forEach(function(value,index,array) {
   // 값이 4보다 크면 종료
  if (value > 4) $A.Break();
   ...
});

 */
MobileCommentJindo.$A.Break = MobileCommentJindo.$Jindo.Break;
//-!MobileCommentJindo.$A.Break end!-//

//-!MobileCommentJindo.$A.Continue start!-//
/**

 * @description Continue() 메서드는 forEach(), filter(), map() 메서드의 루프에서 나머지 명령을 실행하지 않고 다음 루프로 건너뛴다. 내부적으로는 강제로 예외를 발생시키는 구조이므로, try - catch 영역에서 이 메서드를 실행하면 정상적으로 동작하지 않을 수 있다.
 * @see $A#Break
 * @see $A#forEach
 * @see $A#filter
 * @see $A#map
 * @example
$A([1,2,3,4,5]).forEach(function(value,index,array) {
   // 값이 짝수면 처리를 하지 않음
  if (value%2 == 0) $A.Continue();
   ...
});

 */
MobileCommentJindo.$A.Continue = MobileCommentJindo.$Jindo.Continue;
//-!MobileCommentJindo.$A.Continue end!-//


//-!MobileCommentJindo.$A.prototype.map start(MobileCommentJindo.$A.Break,MobileCommentJindo.$A.Continue)!-//
/**

 * @fileOverview $A() 객체의 확장 메서드를 정의한 파일
 * @name array.extend.js

 */

/**

 * @description map() 메서드는 배열의 모든 원소를 순회하면서 콜백 함수를 실행하고 콜백 함수의 실행 결과를 배열의 원소에 설정한다.
 *
 * @param1 {Function+} fCallback 배열을 순회하면서 실행할 콜백 함수. 콜백 함수에서 반환하는 값을 해당 원소의 값으로 재설정한다. 콜백 함수는 파라미터로 value, index, array를 갖는다.$A.Break()와 $A.Continue()을 사용할 수 있다.<br>
 <ul>
 <li>value는 배열이 가진 원소의 값이다.</li>
 <li>index는 해당 원소의 인덱스이다.</li>
 <li>array는 배열 그 자체를 가리킨다.</li>
 </ul>
 * @return1 {$A} 콜백 함수의 수행 결과를 반영한 $A() 객체

 * @param2 {Function+} fCallback 배열을 순회하면서 실행할 콜백 함수. 콜백 함수에서 반환하는 값을 해당 원소의 값으로 재설정한다. 콜백 함수는 파라미터로 value, index, array를 갖는다.$A.Break()와 $A.Continue()을 사용할 수 있다.<br>
 <ul>
 <li>value는 배열이 가진 원소의 값이다.</li>
 <li>index는 해당 원소의 인덱스이다.</li>
 <li>array는 배열 그 자체를 가리킨다.</li>
 </ul>
 * @param2 {Variant} oThis 콜백 함수가 객체의 메서드일 때 콜백 함수 내부에서 this 키워드의 실행 문맥(Execution Context) 사용할 객체.
 * @return2 {$A} 콜백 함수의 수행 결과를 반영한 $A() 객체
 *
 * @import core.$A[Break, Continue]
 * @see $A#forEach
 * @see $A#filter
 * @example
var waZoo = $A(["zebra", "giraffe", "bear", "monkey"]);

waZoo.map(function(value, index, array) {
	return (index+1) + ". " + value;
});
// 결과 : [1. zebra, 2. giraffe, 3. bear, 4. monkey]

 * @example
var waArray = $A([1, 2, 3]);

waArray.map(function(value, index, array) {
	return value + 10;
});
 * @example
var waArray = $A([1, 2, 3]);
var Callback = {
	"key" : 1,
	"test" : function(value, index, array){
		return this.value + this.key;
	}
}

waArray.map(Callback.test, Callback);

document.write(waArray.$value());
// 결과 : 1, 2, 3 (this객체를 지정한 경우)

 */
MobileCommentJindo.$A.prototype.map = function(fCallback, oThis) {
	//-@@$A.map-@@//
	function mapBody(fpEach){
		return function(fCallback, oThis) {
			var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, MobileCommentJindo.$A.checkVarTypeObj,"$A#map");
			if(oArgs == null){ return this; }

			var returnArr	= [];
			var that = this;
			function f(v,i,a) {
				try {
					returnArr.push(fCallback.apply(oThis, _toArray(arguments)));
				} catch(e) {
					if (e instanceof that.constructor.Continue){
						returnArr.push(v);
					} else{
						throw e;
					}
				}
			};
			fpEach(this, f);
			return MobileCommentJindo.$A(returnArr);
		}
	}
	if (this._array.map) {
		MobileCommentJindo.$A.prototype.map = mapBody(function(scope,fp){
			scope.forEach(fp);
		});
	}else{
		MobileCommentJindo.$A.prototype.map = mapBody(function(scope,fp){
			var arr = scope._array;
			for(var i=0,l=scope._array.length; i < l; i++) {
				try {
					fp(arr[i], i, arr);
				} catch(e) {
					if (e instanceof scope.constructor.Break){
						break;
					}else{
						throw e;
					}
				}
			}
		});
	}
	return this.map.apply(this,_toArray(arguments));
};
//-!MobileCommentJindo.$A.prototype.map end!-//

//-!MobileCommentJindo.$A.prototype.filter start(MobileCommentJindo.$A.prototype.forEach)!-//
/**

 * @description filter() 메서드는 배열의 모든 원소를 순회하면서 콜백 함수를 실행하고 콜백 함수가 true 값을 반환하는 원소만 모아 새로운 $A() 객체를 반환한다.
 *
 * @param1 {Function+} fCallback 배열을 순회하면서 실행할 콜백 함수. 콜백 함수는 Boolean 형태로 값을 반환해야 한다. true 값을 반환하는 원소는 새로운 배열의 원소가 된다.$A.Break()와 $A.Continue()을 사용할 수 있다.<br>
 <ul>
 <li>value는 배열이 가진 원소의 값이다.</li>
 <li>index는 해당 원소의 인덱스이다.</li>
 <li>array는 배열 그 자체를 가리킨다.</li>
 </ul>
 * @return1 {$A}	콜백 함수의 반환 값이 true인 원소로 이루어진 새로운 $A() 객체
 *
 * @param2 {Function+} fCallback 배열을 순회하면서 실행할 콜백 함수. 콜백 함수는 Boolean 형태로 값을 반환해야 한다. true 값을 반환하는 원소는 새로운 배열의 원소가 된다.$A.Break()와 $A.Continue()을 사용할 수 있다.<br>
 <ul>
 <li>value는 배열이 가진 원소의 값이다.</li>
 <li>index는 해당 원소의 인덱스이다.</li>
 <li>array는 배열 그 자체를 가리킨다.</li>
 </ul>
 * @param2 {Variant} oThis 콜백 함수가 객체의 메서드일 때 콜백 함수 내부에서 this 키워드의 실행 문맥(Execution Context) 사용할 객체.
 * @return2 {$A}	콜백 함수의 반환 값이 true인 원소로 이루어진 새로운 $A() 객체
 *
 * @import core.$A[Break, Continue]
 * @see $A#forEach
 * @see $A#map
 * @example
var arr = $A([1,2,3,4,5]);

// 필터링 함수
function filterFunc(value, index, array) {
	if (value > 2) {
		return true;
	} else {
		return false;
	}
}

var newArr = arr.filter(filterFunc);

document.write(arr.$value()); 		// 결과 : [1,2,3,4,5]
document.write(newArr.$value()); 	// 결과 : [3,4,5]
 * @example
var waArray = $A([1, 2, 3]);
var Callback = {
	"key" : 1,
	"test" : function(value, index, array){
		return this.value > this.key;
	}
}

waArray.filter(Callback.test, Callback);

document.write(waArray.$value());
// 결과 :  2, 3 (this객체를 지정한 경우)

 */
MobileCommentJindo.$A.prototype.filter = function(fCallback, oThis) {
	//-@@$A.filter-@@//
	function filterBody(fpEach){
		return function(fCallback, oThis) {
			var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, MobileCommentJindo.$A.checkVarTypeObj,"$A#filter");
			if(oArgs == null){ return this; }

			var returnArr	= [];
			var that = this;
			function f(v,i,a) {
				try {
					if(fCallback.apply(oThis, _toArray(arguments))) returnArr.push(v);
				} catch(e) {
					if (!(e instanceof that.constructor.Continue)){
						throw e;
					}
				}
			};
			fpEach(this, f);
			return MobileCommentJindo.$A(returnArr);
		}
	}
	if (this._array.filter) {
		MobileCommentJindo.$A.prototype.filter = filterBody(function(scope,fp){
			try {
				scope.forEach(fp);
			} catch(e) {
				if(!(e instanceof scope.constructor.Break)) throw e;
			}
		});
	}else{
		MobileCommentJindo.$A.prototype.filter = filterBody(function(scope,fp){
			var arr = scope._array;
			for(var i=0,l=scope._array.length; i < l; i++) {
				try {
					fp(arr[i], i, arr);
				} catch(e) {
					if (e instanceof scope.constructor.Break){
						break;
					}else{
						throw e;
					}
				}
			}
		});
	}
	return this.filter.apply(this,_toArray(arguments));
};

//-!MobileCommentJindo.$A.prototype.filter end!-//

//-!MobileCommentJindo.$A.prototype.every start(MobileCommentJindo.$A.prototype.forEach)!-//
/**

 * @description every() 메서드는 배열을 순회하면서 배열의 모든 원소가 콜백 함수에 설정한 조건을 만족하는지 검사한다. 모든 원소가 콜백 함수에서 true 값을 반환하면 true 값을 반환하고 그렇지 않으면 false 값을 반환한다.  콜백 함수가 수행 도중 한번이라도 false를 반환하면 바로 false 값을 반환한다.
 *
 * @param1 {Function+} fCallback 배열을 순회하면서 실행할 콜백 함수. 콜백 함수는 Boolean 형태로 값을 반환해야 한다.$A.Break()와 $A.Continue()을 사용할 수 없다. 대신 반환 값으로 반복문을 멈출 수 있다.<br>
 <ul>
 <li>value는 배열이 가진 원소의 값이다.</li>
 <li>index는 해당 원소의 인덱스이다.</li>
 <li>array는 배열 그 자체를 가리킨다.</li>
 </ul>
 * @return1 {Boolean}	콜백 함수의 반환 값이 모두 true이면 true를 반환하고 그렇지 않으면 false를 반환한다.
 *
 * @param2 {Function+} fCallback 배열을 순회하면서 실행할 콜백 함수. 콜백 함수는 Boolean 형태로 값을 반환해야 한다.$A.Break()와 $A.Continue()을 사용할 수 없다. 대신 반환 값으로 반복문을 멈출 수 있다.<br>
 <ul>
 <li>value는 배열이 가진 원소의 값이다.</li>
 <li>index는 해당 원소의 인덱스이다.</li>
 <li>array는 배열 그 자체를 가리킨다.</li>
 </ul>
 * @param2 {Variant} oThis 콜백 함수가 객체의 메서드일 때 콜백 함수 내부에서 this 키워드의 실행 문맥(Execution Context)으로 사용할 객체.
 * @return2 {Boolean}	콜백 함수의 반환 값이 모두 true이면 true를 반환하고 그렇지 않으면 false를 반환한다.
 *
 * @see $A#some
 * @example
function isBigEnough(value, index, array) {
		return (value >= 10);
	}

var try1 = $A([12, 5, 8, 130, 44]).every(isBigEnough);		// 결과 : false
var try2 = $A([12, 54, 18, 130, 44]).every(isBigEnough);	// 결과 : true
 * @example
var waArray = $A([1, 2, 3]);
var Callback = {
	"key" : 1,
	"test" : function(value, index, array){
		return this.value > this.key;
	}
}

waArray.every(Callback.test, Callback);
// 결과 :  false (this객체를 지정한 경우)

 */
MobileCommentJindo.$A.prototype.every = function(fCallback, oThis) {
	//-@@$A.every-@@//
	var ___checkVarType = MobileCommentJindo.$Jindo.checkVarType;
	var ___checkObj = MobileCommentJindo.$A.checkVarTypeObj;
	if (this._array.every) {
		MobileCommentJindo.$A.prototype.every = function(fCallback, oThis) {
			___checkVarType(arguments, ___checkObj,"$A#every");
			return this._array.every(fCallback, oThis);
		}
	}else{
		MobileCommentJindo.$A.prototype.every = function(fCallback, oThis) {
			___checkVarType(arguments, ___checkObj,"$A#every");

			var result = true;
			var arr = this._array;

			for(var i=0,l=arr.length; i < l; i++) {
				if(fCallback.call(oThis,arr[i], i, arr) === false){
					result = false;
					break;
				}
			}

			return result;
		}
	}
	return this.every.apply(this,_toArray(arguments));
};
//-!MobileCommentJindo.$A.prototype.every end!-//

//-!MobileCommentJindo.$A.prototype.some start(MobileCommentJindo.$A.prototype.forEach)!-//
/**

 * @description some() 메서드는 배열을 순회하면서 콜백 함수에 설정한 조건을 만족하는 원소가 있는지 검사한다. 조건을 만족하는 원소가 하나라도 있으면 true 값을 반환하고 그렇지 않으면 false 값을 반환한다.  콜백 함수가 수행 도중 한번이라도 true를 반환하면 바로 true 값을 반환한다.
 *
 * @param1 {Function+} fCallback 배열을 순회하면서 실행할 콜백 함수. 콜백 함수는 Boolean 형태로 값을 반환해야 한다.$A.Break()와 $A.Continue()을 사용할 수 없다. 대신 반환 값으로 반복문을 멈출 수 있다.<br>
 <ul>
 <li>value는 배열이 가진 원소의 값이다.</li>
 <li>index는 해당 원소의 인덱스이다.</li>
 <li>array는 배열 그 자체를 가리킨다.</li>
 </ul>
 * @return1 {Boolean} 콜백 함수의 반환 값이 모두 false이면 false를 반환하고 그렇지 않으면 true를 반환한다.
 *
 * @param2 {Function+} fCallback 배열을 순회하면서 실행할 콜백 함수. 콜백 함수는 Boolean 형태로 값을 반환해야 한다.$A.Break()와 $A.Continue()을 사용할 수 없다. 대신 반환 값으로 반복문을 멈출 수 있다.<br>
 <ul>
 <li>value는 배열이 가진 원소의 값이다.</li>
 <li>index는 해당 원소의 인덱스이다.</li>
 <li>array는 배열 그 자체를 가리킨다.</li>
 </ul>
 * @param2 {Variant} oThis 콜백 함수가 객체의 메서드일 때 콜백 함수 내부에서 this 키워드의 실행 문맥(Execution Context)으로 사용할 객체.
 * @return2 {Boolean} 콜백 함수의 반환 값이 모두 false이면 false를 반환하고 그렇지 않으면 true를 반환한다.
 *
 * @see $A#every
 * @example
function twoDigitNumber(value, index, array) {
	return (value >= 10 && value < 100);
}

var try1 = $A([12, 5, 8, 130, 44]).some(twoDigitNumber);	// 결과 : true
var try2 = $A([1, 5, 8, 130, 4]).some(twoDigitNumber);		// 결과 : false
 * @example
var waArray = $A([1, 2, 3]);
var Callback = {
	"key" : 1,
	"test" : function(value, index, array){
		return this.value > this.key;
	}
}

waArray.some(Callback.test, Callback);
// 결과 :  true (this객체를 지정한 경우)

 */
MobileCommentJindo.$A.prototype.some = function(fCallback, oThis) {
	//-@@$A.some-@@//
	var ___checkVarType = MobileCommentJindo.$Jindo.checkVarType;
	var ___checkObj = MobileCommentJindo.$A.checkVarTypeObj;
	if (this._array.some) {
		MobileCommentJindo.$A.prototype.some = function(fCallback, oThis) {
			___checkVarType(arguments, ___checkObj,"$A#some");
			return this._array.some(fCallback, oThis);
		}
	}else{
		MobileCommentJindo.$A.prototype.some = function(fCallback, oThis) {
			___checkVarType(arguments, ___checkObj,"$A#some");
			var result = false;
			var arr = this._array;

			for(var i=0,l=arr.length; i < l; i++) {
				if(fCallback.call(oThis,arr[i], i, arr) === true){
					result = true;
					break;
				}
			}

			return result;
		}
	}
	return this.some.apply(this,_toArray(arguments));
};
//-!MobileCommentJindo.$A.prototype.some end!-//

//-!MobileCommentJindo.$A.prototype.refuse start(MobileCommentJindo.$A.prototype.filter, MobileCommentJindo.$A.prototype.indexOf)!-//
/**

 * @description refuse() 메서드는 배열에서 입력한 파라미터와 같은 값을 제외하여 새로운 $A() 객체를 생성한다. 제외할 값을 여러 개 지정할 수 있다.
 * @param {Variant} vValue1 배열에서 제거할 첫 번째 값.
 * @param {Variant} […] …
 * @param {Variant} [vValueN] 배열에서 제거할 N 번째 값.
 * @return {$A}	배열에서 특정 값을 제외한 새로운 $A() 객체
 * @example
var arr = $A([12, 5, 8, 130, 44]);

var newArr1 = arr.refuse(12);

document.write(arr);		// 결과 : [12, 5, 8, 130, 44]
document.write(newArr1);	// 결과 : [5, 8, 130, 44]

var newArr2 = newArr1.refuse(8, 44, 130);

document.write(newArr1);	// 결과 : [5, 8, 130, 44]
document.write(newArr2);	// 결과 : [5]

 */
MobileCommentJindo.$A.prototype.refuse = function(oValue1/*, ...*/) {
	//-@@$A.refuse-@@//
	var a = MobileCommentJindo.$A(_slice.apply(arguments));
	return this.filter(function(v,i) {return !(a.indexOf(v) > -1) });
};
//-!MobileCommentJindo.$A.prototype.refuse end!-//
//-!MobileCommentJindo.$A.prototype.unique start!-//
/**

 * @description unique() 메서드는 배열에서 중복되는 원소를 삭제한다.
 * @return {$A} 중복되는 원소를 제거한 $A() 객체
 * @example
var arr = $A([10, 3, 2, 5, 4, 3, 7, 4, 11]);

arr.unique(); // 결과 : [10, 3, 2, 5, 4, 7, 11]

 */
MobileCommentJindo.$A.prototype.unique = function() {
	//-@@$A.unique-@@//
	var a = this._array, b = [], l = a.length;
	var i, j;

	/*

  중복되는 원소 제거

	 */
	for(i = 0; i < l; i++) {
		for(j = 0; j < b.length; j++) {
			if (a[i] == b[j]) break;
		}

		if (j >= b.length) b[j] = a[i];
	}

	this._array = b;

	return this;
};
//-!MobileCommentJindo.$A.prototype.unique end!-//


/**

 * @fileOverview $Ajax() 객체의 생성자 및 메서드를 정의한 파일
 * @name Ajax.js
 * @author AjaxUI lab

 */

//-!MobileCommentJindo.$Ajax start(MobileCommentJindo.$Json.prototype.toString)!-//
/**

 * @class $Ajax() 객체는 다양한 개발 환경에서 Ajax 요청과 응답을 쉽게 구현하기 위한 메서드를 제공한다.<br>
 * @extends core
 * @constructor
 * @description $Ajax() 객체는 서버와 브라우저 사이의 비동기 통신, 즉 Ajax 통신을 지원한다. $Ajax() 객체는 XHR 객체(XMLHTTPRequest)를 사용한 기본적인 방식과 함께 다른 도메인 사이의 통신을 위한 여러 방식을 제공한다. $Ajax() 객체의 기본적인 초기화 방식은 다음과 같다.
 <textarea name="code" class="js:nocontrols">
 var oAjax = new $Ajax('server.php', {
    type : 'xhr',
    method : 'get',     // GET 방식으로 통신
    onload : function(res){ // 요청이 완료되면 실행될 콜백 함수
      $('list').innerHTML = res.text();
    },
    timeout : 3,      // 3초 이내에 요청이 완료되지 않으면 ontimeout 실행 (생략 시 0)
    ontimeout : function(){ // 타임 아웃이 발생하면 실행될 콜백 함수, 생략 시 타임 아웃이 되면 아무 처리도 하지 않음
      alert("Timeout!");
    },
    async : true      // 비동기로 호출하는 경우, 생략하면 true
  });
  oAjax.request();
}
</textarea>
 * @param {String+} sUrl Ajax 요청을 보낼 서버의 URL.
 * @param {Hash+} oOption $Ajax()에서 사용하는 콜백 함수, 통신 방식 등과 같은 다양한 정보를 정의한다. oOption 객체의 프로퍼티와 사용법에 대한 설명은 다음 표와 같다.<br>
 * @throws {MobileCommentJindo.$Except.REQUIRE_AJAX} 사용하는 타입의 ajax가 없는 경우.
 * @throws {MobileCommentJindo.$Except.CANNOT_USE_OPTION} 사용하지 못하는 옵션을 사용할 경우.
<table>
	<caption>oOption 객체의 속성</caption>
	<thead>
		<th>속성</th>
		<th>타입</th>
		<th>설명</th>
	</thead>
	<tbody>
		<tr>
			<td style="font-weight:bold;">type</td>
			<td>String</td>
			<td>
				Ajax 요청 방식. 생략하면 기본 값은 xhr이다.
				<ul>
					<li><strong>xhr</strong><br>
						브라우저에 내장된 XMLHttpRequest 객체를 이용하여 Ajax 요청을 처리한다. text, xml, json 형식의 응답 데이터를 처리할 수 있다. 요청 실패 시 HTTP 응답 코드를 통해 원인 파악이 가능하다. 단, 크로스 도메인(Cross-Domain) 상황에서 사용할 수 없다.
					</li>
					<li><strong>iframe</strong><br>
						iframe 요소를 프록시로 사용하여 Ajax 요청을 처리한다. 크로스 도메인 상황에서 사용할 수 있다. iframe 요청 방식은 다음과 같이 동작한다.
						<ol>
							<li>로컬(요청 하는 쪽)과 원격(요청 받는 쪽)에 모두 프록시용 HTML 파일을 만든다.</li>
							<li>로컬 프록시에서 원격 프록시로 데이터를 요청한다.</li>
							<li>원격 프록시가 원격 도메인에 XHR 방식으로 다시 Ajax 요청한다.</li>
							<li>응답을 받은 원격 프록시에서 로컬 프록시로 데이터를 전달한다.</li>
							<li>로컬 프록시에서 최종적으로 콜백 함수(onload)를 호출하여 처리한다.</li>
						</ol>
						<br>
						로컬 프록시 파일과 원격 프록시 파일은 다음과 같이 작성할 수 있다.
						<ul type="disc">
							<li>원격 프록시 파일 : ajax_remote_callback.html</li>
							<li>로컬 프록시 파일 : ajax_local_callback.html</li>
						</ul>
						※ iframe 요소를 사용한 방식은 인터넷 익스플로러에서 "딱딱"하는 페이지 이동음이 발생할 수 있다(요청당 2회).
					</li>
					<li><strong>jsonp</strong><br>
							JSON 형식과 &lt;script&gt; 태그를 사용하여 사용하여 Ajax 요청을 처리한다. 크로스 도메인 상황에서 사용할 수 있다. jsonp 요청 방식은 다음과 같이 동작한다.<br>
							<ol>
								<li>&lt;script&gt; 태그를 동적으로 생성한다. 이때 요청할 원격 페이지를 src 속성으로 입력하여 GET 방식으로 요청을 전송한다.</li>
								<li>요청 시에 콜백 함수를 매개 변수로 넘기면, 원격 페이지에서 전달받은 콜백 함수명으로 아래와 같이 응답을 보낸다.
									<ul type="disc">
										<li>function_name(...결과 값...)</li>
									</ul>
								</li>
								<li>응답은 콜백 함수(onload)에서 처리된다.</li>
							</ol>
							※ GET 방식만 가능하므로, 전송 데이터의 길이는 URL에서 허용하는 길이로 제한된다.
					</li>
					<li><strong>flash</strong><br>
						플래시 객체를 사용하여 Ajax 요청을 처리한다. 크로스 도메인 상황에에서 사용할 수 있다. 이 방식을 사용할 때 원격 서버의 웹 루트 디렉터리에 crossdomain.xml 파일이 존재해야 하며 해당 파일에 접근 권한이 설정되어 있어야 한다. 모든 통신은 플래시 객체를 통하여 주고 받으며 Ajax 요청을 시도하기 전에 반드시 플래시 객체를 초기화해야 한다. $Ajax.SWFRequest.write() 메서드를 사용하여 플래시 객체를 초기화하며 해당 메서드는 &lt;body&gt; 요소 안에 작성한다.
						만약 https에서 https 쪽으로 호출할 경우 &lt;allow-access-from domain="*" secure="true" /&gt; 처럼 secure을 true로 설정해야 하며 그 이외에는 false로 설정한다.
					</li>
				</ul>
			</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">method</td>
			<td>String</td>
			<td>
				HTTP 요청 방식으로 post, get, put, delete 방식을 지원한다.
				<ul>
					<li><strong>post</strong><br>
					post 방식으로 http 요청을 전달한다. 기본 값이다.</li>
					<li><strong>get</strong><br>
					get 방식으로 http 요청을 전달한다. type 속성이 "jsonp" 방식으로 지정되면 HTTP 요청 방식은 "get"으로 설정된다.</li>
					<li><strong>put</strong><br>
					put 방식으로 http 요청을 전달한다. 1.4.2 부터 사용 가능하다.</li>
					<li><strong>delete</strong><br>
					delete 방식으로 http 요청을 전달한다. 1.4.2 부터 사용 가능하다.</li>
				</ul>
			</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">timeout</td>
			<td>Number</td>
			<td>
				요청 타임 아웃 시간(초 단위).<br>
				기본 값은 0으로 타임 아웃을 적용하지 않는다. 타임 아웃 시간 안에 요청이 완료되지 않으면 Ajax 요청을 중지한다. 비동기 호출인 경우에만 사용 가능하다.
			</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">onload</td>
			<td>Function</td>
			<td>
				요청이 완료되면 실행할 콜백 함수.<br>
				반드시 지정해야 하며 콜백 함수의 파라미터로 응답 객체인 {@link $Ajax.Response} 객체가 전달된다.
			</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">onerror</td>
			<td>Function</td>
			<td>
				요청이 실패하면 실행할 콜백 함수.<br>
				생략하면 오류가 발생해도 onload 속성에 지정한 콜백 함수를 실행한다.
			</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">ontimeout</td>
			<td>Function</td>
			<td>
				타임 아웃이 되었을 때 실행할 콜백 함수.<br>
				생략하면 타임 아웃 발생해도 아무런 처리를 하지 않는다.
			</td>
		</tr>
		<tr>
		<td style="font-weight:bold;">proxy</td>
			<td>String</td>
			<td>
				로컬 프록시 파일의 경로.<br>
				type 속성이 "iframe"일 때 사용하며 반드시 지정해야 한다.
			</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">jsonp_charset</td>
			<td>String</td>
			<td>
				요청 시 사용할 &lt;script&gt; 인코딩 방식.<br>
				type 속성이 "jsonp"일 때 사용한다. 생략하면 "utf-8"이 기본값이다(0.4.2 버전부터 지원).
			</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">callbackid</td>
			<td>String</td>
			<td>
				콜백 함수 이름에 사용할 ID.<br>
				type 속성이 "jsonp"일 때 사용한다(1.3.0 부터 지원). 생략하면 랜덤한 ID 값이 생성된다.<br>
				jsonp 방식에서 Ajax 요청할 때 콜백 함수 이름에 랜덤한 ID 값을 덧붙여 만든 콜백 함수 이름을 서버로 전달한다. 이때 랜덤한 값을 ID로 사용하여 넘기므로 요청 URL이 매번 새롭게 생성되어 캐쉬 서버가 아닌 서버로 직접 데이터를 요청하게 된다. 따라서 ID 값을 지정하면 랜덤한 아이디 값으로 콜백 함수 이름을 생성하지 않으므로 캐쉬 서버를 사용하여 그에 대한 히트율을 높이고자 할 때 ID를 지정하여 사용할 수 있다.
			</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">callbackname</td>
			<td>String</td>
			<td>
				콜백 함수 이름.<br>
				type 속성이 "jsonp"일 때 사용하며, 서버에 요청할 콜백 함수의 이름을 지정할 수 있다. 기본 값은 "_callback"이다(1.3.8 부터 지원).
			</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">sendheader</td>
			<td>Boolean</td>
			<td>
				요청 헤더를 전송할지 여부.<br>
				type 속성이 "flash"일 때 사용하며, 서버에서 접근 권한을 설정하는 crossdomain.xml에 allow-header가 없는 경우에 false 로 설정해야 한다.<br>
				플래시 9에서는 allow-header가 false인 경우 get 방식으로만 ajax 통신이 가능하다.<br>
				플래시 10에서는 allow-header가 false인 경우 get,post 둘다 ajax 통신이 안된다.<br>
				allow-header가 설정되어 있지 않다면 반드시 false로 설정해야 한다. 기본 값은 true 이다(1.3.4부터 지원).
			</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">async</td>
			<td>Boolean</td>
			<td>
				비동기 호출 여부.<br>
				type 속성이 "xhr"일 때 이 속성 값이 유효하다. 기본 값은 true 이다(1.3.7부터 지원).
			</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">decode</td>
			<td>Boolean</td>
			<td>
				type 속성이 "flash"일 때 사용하며, 요청한 데이터 안에 utf-8 이 아닌 다른 인코딩이 되어 있을때 false 로 지정한다. 기본 값은 true 이다(1.4.0부터 지원).
			</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">postBody</td>
			<td>Boolean</td>
			<td>
				Ajax 요청 시 서버로 전달할 데이터를 Body 요소에 전달할 지의 여부.<br>
				type 속성이 "xhr"이고 method가 "get"이 아니어야 유효하며 REST 환경에서 사용된다. 기본값은 false 이다(1.4.2부터 지원).
			</td>
		</tr>
	</tbody>
</table>

 * @see $Ajax.Response
 * @see <a href="http://dev.naver.com/projects/jindo/wiki/cross%20domain%20ajax">Cross Domain Ajax 이해</a>
 * @example
// 'Get List' 버튼 클릭 시, 서버에서 데이터를 받아와 리스트를 구성하는 예제
// (1) 서버 페이지와 서비스 페이지가 같은 도메인에 있는 경우 - xhr

// [client.html]
<!DOCTYPE html>
<html>
	<head>
		<title>Ajax Sample</title>
		<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
		<script type="text/javascript" language="javascript" src="lib/jindo.all.js"></script>
		<script type="text/javascript" language="javascript">
			function getList() {
				var oAjax = new $Ajax('server.php', {
					type : 'xhr',
					method : 'get',			// GET 방식으로 통신
					onload : function(res){	// 요청이 완료되면 실행될 콜백 함수
						$('list').innerHTML = res.text();
					},
					timeout : 3,			// 3초 이내에 요청이 완료되지 않으면 ontimeout 실행 (생략 시 0)
					ontimeout : function(){	// 타임 아웃이 발생하면 실행될 콜백 함수, 생략 시 타임 아웃이 되면 아무 처리도 하지 않음
						alert("Timeout!");
					},
					async : true			// 비동기로 호출하는 경우, 생략하면 true
				});
				oAjax.request();
			}
		</script>
	</head>
	<body>
		<button onclick="getList(); return false;">Get List</button>

		<ul id="list">

		</ul>
	</body>
</html>

// [server.php]
<?php
	echo "<li>첫번째</li><li>두번째</li><li>세번째</li>";
?>

 * @example
// 'Get List' 버튼 클릭 시, 서버에서 데이터를 받아와 리스트를 구성하는 예제
// (2) 서버 페이지와 서비스 페이지가 같은 도메인에 있는 경우 - iframe

// [http://local.com/some/client.html]
<!DOCTYPE html>
<html>
	<head>
		<title>Ajax Sample</title>
		<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
		<script type="text/javascript" language="javascript" src="lib/jindo.all.js"></script>
		<script type="text/javascript" language="javascript">
			function getList() {
				var oAjax = new $Ajax('http://server.com/some/some.php', {
					type : 'iframe',
					method : 'get',			// GET 방식으로 통신
											// POST로 지정하면 원격 프록시 파일에서 some.php 로 요청 시에 POST 방식으로 처리
					onload : function(res){	// 요청이 완료되면 실행될 콜백 함수
						$('list').innerHTML = res.text();
					},
					// 로컬 프록시 파일의 경로.
					// 반드시 정확한 경로를 지정해야 하며, 로컬 도메인의 경로라면 어디에 두어도 상관 없음
					// (※ 원격 프록시 파일은 반드시  원격 도메인 서버의 도메인 루트 상에 두어야 함)
					proxy : 'http://local.naver.com/some/ajax_local_callback.html'
				});
				oAjax.request();
			}

		</script>
	</head>
	<body>
		<button onclick="getList(); return false;">Get List</button>

		<ul id="list">

		</ul>
	</body>
</html>

// [http://server.com/some/some.php]
<?php
	echo "<li>첫번째</li><li>두번째</li><li>세번째</li>";
?>

 * @example
// 'Get List' 버튼 클릭 시, 서버에서 데이터를 받아와 리스트를 구성하는 예제
// (3) 서버 페이지와 서비스 페이지가 같은 도메인에 있는 경우 - jsonp

// [http://local.com/some/client.html]
<!DOCTYPE html>
<html>
	<head>
		<title>Ajax Sample</title>
		<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
		<script type="text/javascript" language="javascript" src="lib/jindo.all.js"></script>
		<script type="text/javascript" language="javascript">
			function getList(){
				var oAjax = new $Ajax('http://server.com/some/some.php', {
					type: 'jsonp',
					method: 'get',			// type 이 jsonp 이면 get 으로 지정하지 않아도 자동으로 get 으로 처리함 (생략가능)
					jsonp_charset: 'utf-8',	// 요청 시 사용할 <script> 인코딩 방식 (생략 시 utf-8)
					onload: function(res){	// 요청이 완료되면 실행될 콜백 함수
						var response = res.json();
						var welList = $Element('list').empty();

						for (var i = 0, nLen = response.length; i < nLen; i++) {
							welList.append($("<li>" + response[i] + "</li>"));
						}
					},
					callbackid: '12345',				// 콜백 함수 이름에 사용할 아이디 값 (생략가능)
					callbackname: 'ajax_callback_fn'	// 서버에서 사용할 콜백 함수이름을 가지는 매개 변수 이름 (생략 시 '_callback')
				});
				oAjax.request();
			}
		</script>
	</head>
	<body>
		<button onclick="getList(); return false;">Get List</button>

		<ul id="list">

		</ul>
	</body>
</html>

// [http://server.com/some/some.php]
<?php
	$callbackName = $_GET['ajax_callback_fn'];
	echo $callbackName."(['첫번째','두번째','세번째'])";
?>

 * @example
// 'Get List' 버튼 클릭 시, 서버에서 데이터를 받아와 리스트를 구성하는 예제
// (4) 서버 페이지와 서비스 페이지가 같은 도메인에 있는 경우 - flash

// [http://local.com/some/client.html]
<!DOCTYPE html>
<html>
	<head>
		<title>Ajax Sample</title>
		<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
		<script type="text/javascript" language="javascript" src="lib/jindo.all.js"></script>
		<script type="text/javascript" language="javascript">
			function getList(){
				var oAjax = new $Ajax('http://server.com/some/some.php', {
					type : 'flash',
					method : 'get',			// GET 방식으로 통신
					sendheader : false,		// 요청 헤더를 전송할지 여부. (생략 시 true)
					decode : true,			// 요청한 데이터 안에 utf-8 이 아닌 다른 인코딩이 되어 있을때 false. (생략 시 true)
					onload : function(res){	// 요청이 완료되면 실행될 콜백 함수
						$('list').innerHTML = res.text();
					},
				});
				oAjax.request();
			}
		</script>
	</head>
	<body>
		<script type="text/javascript">
			$Ajax.SWFRequest.write("swf/ajax.swf");	// Ajax 호출을 하기 전에 반드시 플래시 객체를 초기화
		</script>
		<button onclick="getList(); return false;">Get List</button>

		<ul id="list">

		</ul>
	</body>
</html>

// [http://server.com/some/some.php]
<?php
	echo "<li>첫번째</li><li>두번째</li><li>세번째</li>";
?>

<table>
	<caption>타입에 따른 옵션의 사용 가능 여부</caption>
	<thead>
		<th>옵션</th>
		<th>xhr</th>
		<th>jsonp</th>
		<th>flash</th>
		<th>iframe</th>
	</thead>
	<tbody>
		<tr>
			<td style="font-weight:bold;">method(get, post, put, delete)</td>
			<td>O</td>
			<td>get</td>
			<td>get, post</td>
			<td>iframe</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">onload</td>
			<td>O</td>
			<td>O</td>
			<td>O</td>
			<td>O</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">timeout</td>
			<td>O</td>
			<td>O</td>
			<td>O</td>
			<td>X</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">ontimeout</td>
			<td>O</td>
			<td>O</td>
			<td>O</td>
			<td>X</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">onerror</td>
			<td>O</td>
			<td>O</td>
			<td>O</td>
			<td>X</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">async</td>
			<td>O</td>
			<td>X</td>
			<td>X</td>
			<td>X</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">postBody</td>
			<td>method가 post, put, delete만 가능</td>
			<td>X</td>
			<td>X</td>
			<td>X</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">jsonp_charset</td>
			<td>X</td>
			<td>O</td>
			<td>X</td>
			<td>X</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">callbackid</td>
			<td>X</td>
			<td>O</td>
			<td>X</td>
			<td>X</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">callbackname</td>
			<td>X</td>
			<td>O</td>
			<td>X</td>
			<td>X</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">setheader</td>
			<td>O</td>
			<td>X</td>
			<td>O</td>
			<td>X</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">decode</td>
			<td>X</td>
			<td>X</td>
			<td>O</td>
			<td>X</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">proxy</td>
			<td>X</td>
			<td>X</td>
			<td>X</td>
			<td>O</td>
		</tr>
	</tbody>
</table>


<table>
	<caption>타입에 따른 메서드의 사용 가능 여부</caption>
	<thead>
		<th>메서드</th>
		<th>xhr</th>
		<th>jsonp</th>
		<th>flash</th>
		<th>iframe</th>
	</thead>
	<tbody>
		<tr>
			<td style="font-weight:bold;">abort</td>
			<td>O</td>
			<td>O</td>
			<td>O</td>
			<td>O</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">isIdle</td>
			<td>O</td>
			<td>O</td>
			<td>O</td>
			<td>O</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">option</td>
			<td>O</td>
			<td>O</td>
			<td>O</td>
			<td>O</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">request</td>
			<td>O</td>
			<td>O</td>
			<td>O</td>
			<td>O</td>
		</tr>
		<tr>
			<td style="font-weight:bold;">header</td>
			<td>O</td>
			<td>X</td>
			<td>O</td>
			<td>O</td>
		</tr>
	</tbody>
</table>

 */
MobileCommentJindo.$Ajax = function (url, option) {
	var cl = arguments.callee;

	if (!(this instanceof cl)){
		try {
			MobileCommentJindo.$Jindo._warn(arguments.length, 2,"$Ajax");
			return new cl(url, option||{});
		} catch(e) {
			if (e instanceof TypeError) { return null; }
			throw e;
		}
	}
	var ___ajax = MobileCommentJindo.$Ajax;
	var ___error = MobileCommentJindo.$Error;
	var ___except = MobileCommentJindo.$Except;
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str' : [ 'sURL:String+' ],
		'4obj' : [ 'sURL:String+', 'oOption:Hash+' ]
	},"$Ajax");

	if(oArgs+"" == "for_string"){
		oArgs.oOption = {};
	}

	function _getXHR() {
		if (window.XMLHttpRequest) {
			return new XMLHttpRequest();
		} else if (ActiveXObject) {
			try {
				return new ActiveXObject('MSXML2.XMLHTTP');
			}catch(e) {
				return new ActiveXObject('Microsoft.XMLHTTP');
			}
			return null;
		}
	}

	var loc    = location.toString();
	var domain = '';
	try { domain = loc.match(/^https?:\/\/([a-z0-9_\-\.]+)/i)[1]; } catch(e) {}

	this._status = 0;
	this._url = oArgs.sURL;
	this._headers  = {};
	this._options = {
		type   :"xhr",
		method :"post",
		proxy  :"",
		timeout:0,
		onload :function(req){},
		onerror :null,
		ontimeout:function(req){},
		jsonp_charset : "utf-8",
		callbackid : "",
		callbackname : "",
		sendheader : true,
		async : true,
		decode :true,
		postBody :false
	};

	this._options = ___ajax._setProperties(oArgs.oOption,this);
	___ajax._validationOption(this._options,"$Ajax");

	/*

테스트를 위해 우선 적용가능한 설정 객체가 존재하면 적용

	 */
	if(___ajax.CONFIG){
		this.option(___ajax.CONFIG);
	}

	var _opt = this._options;

	_opt.type   = _opt.type.toLowerCase();
	_opt.method = _opt.method.toLowerCase();

	if (window.__jindo2_callback === undefined) {
		window.__jindo2_callback = [];
	}

	var t = this;
	switch (_opt.type) {
		case "put":
		case "delete":
		case "get":
		case "post":
			_opt.method = _opt.type;
		case "xhr":
			//-@@$Ajax.xhr-@@//
			this._request = _getXHR();
			break;
		case "flash":
			//-@@$Ajax.flash-@@//
			if(!___ajax.SWFRequest) throw new ___error('MobileCommentJindo.$Ajax.SWFRequest'+___except.REQUIRE_AJAX, "$Ajax");

			this._request = new ___ajax.SWFRequest( function(name,value){return t.option.apply(t, arguments);} );
			break;
		case "jsonp":
			//-@@$Ajax.jsonp-@@//
			if(!___ajax.JSONPRequest) throw new ___error('MobileCommentJindo.$Ajax.JSONPRequest'+___except.REQUIRE_AJAX, "$Ajax");
			this._request = new ___ajax.JSONPRequest( function(name,value){return t.option.apply(t, arguments);} );
			break;
		case "iframe":
			//-@@$Ajax.iframe-@@//
			if(!___ajax.FrameRequest) throw new ___error('MobileCommentJindo.$Ajax.FrameRequest'+___except.REQUIRE_AJAX, "$Ajax");
			this._request = new ___ajax.FrameRequest( function(name,value){return t.option.apply(t, arguments);} );

	}
};
MobileCommentJindo.$Ajax._setProperties = function(option){
	option = option||{};
	var type;
	type = option.type = option.type||"xhr";
	option.onload = option.onload||function(){};
	option.method = option.method ||"post";
	if(type != "iframe"){
		option.timeout = option.timeout||0;
		option.ontimeout = option.ontimeout||function(){};
		option.onerror = option.onerror||function(){};
	}
	if(type == "xhr"){
		option.async = option.async === undefined?true:option.async;
		option.postBody = option.postBody === undefined?false:option.postBody;
		option.sendheader = option.sendheader === undefined ? true : option.sendheader;
	}else if(type == "jsonp"){
		option.method = "get";
		option.jsonp_charset = option.jsonp_charset ||"utf-8";
		option.callbackid = option.callbackid ||"";
		option.callbackname = option.callbackname ||"";
	}else if(type == "flash"){
		option.sendheader =  option.sendheader === undefined ? true : option.sendheader;
		option.decode =  option.decode === undefined ? true : option.decode;
	}else if(type == "iframe"){
		option.proxy = option.proxy||"";
	}
	return option;
};
MobileCommentJindo.$Ajax._validationOption = function(oOption,sMethod){
	var ___error = MobileCommentJindo.$Error;
	var ___except = MobileCommentJindo.$Except;
	var sType = oOption.type;
	if(sType === "jsonp"){
		if(oOption["method"] !== "get") throw new ___error(___except.CANNOT_USE_OPTION,sMethod);
	}else if(sType === "flash"){
		if(!(oOption["method"] === "get" || oOption["method"] === "post")) throw new ___error(___except.CANNOT_USE_OPTION,sMethod,sMethod);
	}

	if(oOption["postBody"]){
		if(!(sType === "xhr" && (oOption["method"]!=="get"))){
			throw new ___error(___except.CANNOT_USE_OPTION,sMethod);
		}
	}

	var oTypeProperty = {
			"xhr": "onload|timeout|ontimeout|onerror|async|method|postBody|sendheader|type" ,
			"jsonp": "onload|timeout|ontimeout|onerror|jsonp_charset|callbackid|callbackname|method|type",
			"flash": "onload|timeout|ontimeout|onerror|sendheader|decode|method|type",
			"iframe": "onload|proxy|method|type"
	}
	var aName = [];
	var i = 0;
	for(aName[i++] in oOption){}
	var sProperty = oTypeProperty[sType];

	for(var i = 0 ,l = aName.length; i < l ; i++){
		if(sProperty.indexOf(aName[i]) == -1) throw new ___error(___except.CANNOT_USE_OPTION,sMethod);
	}
};
/**
 * @ignore
 */
MobileCommentJindo.$Ajax.prototype._onload = (function(isIE) {
	var ___ajax = MobileCommentJindo.$Ajax;
	var ___jindo = MobileCommentJindo.$Jindo;
	if(isIE){
		return function(){
			var bSuccess = this._request.readyState == 4 && this._request.status == 200;
			var oResult;
			if (this._request.readyState == 4) {
				  try {
						if (this._request.status != 200 && ___jindo.isFunction(this._options.onerror)){
							if(!this._request.status == 0){
								this._options.onerror(new ___ajax.Response(this._request));
							}
						}else{
							if(!this._is_abort){
								oResult = this._options.onload(new ___ajax.Response(this._request));
							}
						}
				}finally{
					if(___jindo.isFunction(this._oncompleted)){
						this._oncompleted(bSuccess, oResult);
					}
					if (this._options.type == "xhr" ){
						this.abort();
						try { delete this._request.onload; } catch(e) { this._request.onload =undefined;}
					}
					delete this._request.onreadystatechange;

				}
			}
		}
	}else{
		return function(){
			var bSuccess = this._request.readyState == 4 && this._request.status == 200;
			var oResult;
			if (this._request.readyState == 4) {
				  try {

						if (this._request.status != 200 && ___jindo.isFunction(this._options.onerror)){
							this._options.onerror(new ___ajax.Response(this._request));
						}else{
							oResult = this._options.onload(new ___ajax.Response(this._request));
						}
				}finally{
					this._status--;
					if(___jindo.isFunction(this._oncompleted)){
						this._oncompleted(bSuccess, oResult);
					}
				}
			}
		}
	}
})(_JINDO_IS_IE);


/**

 * @description request() 메서드는 Ajax 요청을 서버에 전송한다. 요청에 사용할 파라미터는 $Ajax() 객체 생성자에서 설정하거나 option() 메서드를 사용하여 변경할 수 있다. 요청 타입(type)이 "flash"면 이 메소드를 실행하기 전에 body 요소에서 {@link $Ajax.SWFRequest.write}() 메서드를 반드시 실행해야 한다.
 *
 * @param1 {Void}
 * @return1 {$Ajax} $Ajax() 객체.
 *
 * @param2 {String+} oData 서버로 전송할 데이터. (postbody가 true, type이 xhr, method가 get이 아닌 경우만 사용가능)
 * @return2 {$Ajax} $Ajax() 객체.
 *
 * @param3 {Hash+} oData 서버로 전송할 데이터.
 * @return3 {$Ajax} $Ajax() 객체.
 *
 * @see $Ajax#option
 * @see $Ajax.SWFRequest.write
 * @example
var ajax = $Ajax("http://www.remote.com", {
   onload : function(res) {
      // onload 핸들러
   }
});

ajax.request( {key1:"value1", key2:"value2"} );	// 서버에 전송할 데이터를 매개변수로 넘긴다.
ajax.request( );

 * @example
var ajax2 = $Ajax("http://www.remote.com", {
   type : "xhr",
   method : "post",
   postBody : true

});

ajax2.request({key1:"value1", key2:"value2"});
ajax2.request("{key1:\"value1\", key2:\"value2\"}");


 */
MobileCommentJindo.$Ajax.prototype.request = function(oData) {
	var ___jindo = MobileCommentJindo.$Jindo;
	var oArgs = ___jindo.checkVarType(arguments, {
		'4voi' : [ ],
		'4obj' : [ ___jindo._F('oData:Hash+') ],
		'4str' : [ 'sData:String+' ]
	},"$Ajax#request");

	this._status++;
	var t   = this;
	var req = this._request;
	var opt = this._options;
	var data, v,a = [], data = "";
	var _timer = null;
	var url = this._url;
	this._is_abort = false;
	var sUpType = opt.type.toUpperCase();
	var sUpMethod = opt.method.toUpperCase();
	if (opt.postBody && sUpType == "XHR" && sUpMethod != "GET") {
		if(oArgs+"" == "4str"){
			data = oArgs.sData;
		}else if(oArgs+"" == "4obj"){
			data = MobileCommentJindo.$Json(oArgs.oData).toString();
		}else{
			data = null;
		}
	}else{
		switch(oArgs+""){
			case "4voi" :
				data = null;
				break;
			case "4obj":
				var oData = oArgs.oData;
				for(var k in oData) {
					if(oData.hasOwnProperty(k)){
						v = oData[k];
						if (___jindo.isFunction(v)) v = v();

						if (___jindo.isArray(v) || (MobileCommentJindo.$A && v instanceof MobileCommentJindo.$A)) {
							if(v instanceof MobileCommentJindo.$A) v = v._array;

							for(var i=0; i < v.length; i++) {
								a[a.length] = k+"="+encodeURIComponent(v[i]);
							}
						} else {
							a[a.length] = k+"="+encodeURIComponent(v);
						}
					}
				}
				data = a.join("&");
		}
	}

	/*

XHR GET 방식 요청인 경우 URL에 파라미터 추가

	 */
	if(data && sUpType=="XHR" && sUpMethod=="GET"){
		if(url.indexOf('?')==-1){
			url += "?";
		} else {
			url += "&";
		}
		url += data;
		data = null;
	}

	if(sUpType=="XHR"&&opt.async){
		req.open(sUpMethod, url, opt.async);
	}else if(sUpType=="XHR"){
		req.open(sUpMethod, url, false);
	}else{
		req.open(sUpMethod, url);
	}
	if(sUpType=="XHR"&&sUpMethod=="GET"&&_JINDO_IS_IE){
		/*

xhr인 경우 IE에서는 GET으로 보낼 때 브라우져에서 자체 cache하여 cache을 안되게 수정.

		 */
		req.setRequestHeader("If-Modified-Since", "Thu, 1 Jan 1970 00:00:00 GMT");
	}
	if (opt.sendheader) {
		if(!this._headers["Content-Type"]){
			req.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=utf-8");
		}
		req.setRequestHeader("charset", "utf-8");
		for (var x in this._headers) {
			if(this._headers.hasOwnProperty(x)){
				if (typeof this._headers[x] == "function")
					continue;
				req.setRequestHeader(x, String(this._headers[x]));
			}
		}
	}
	if(req.addEventListener&&!_JINDO_IS_OP&&!_JINDO_IS_IE){
		/*

 * opera 10.60에서 XMLHttpRequest에 addEventListener기 추가되었지만 정상적으로 동작하지 않아 opera는 무조건 dom1방식으로 지원함.
 * IE9에서도 opera와 같은 문제가 있음.

		 */
		if(this._loadFunc){ req.removeEventListener("load", this._loadFunc, false); }
		this._loadFunc = function(rq){
			clearTimeout(_timer);
			_timer = undefined;
			t._onload(rq);
		}
		req.addEventListener("load", this._loadFunc, false);
	}else{
		if (req.onload !== undefined) {
			req.onload = function(rq){
				if(req.readyState == 4 && !t._is_abort){
					clearTimeout(_timer);
					_timer = undefined;
					t._onload(rq);
				}
			};
		} else {
            /*

 * IE6에서는 onreadystatechange가 동기적으로 실행되어 timeout이벤트가 발생안됨.
 * 그래서 interval로 체크하여 timeout이벤트가 정상적으로 발생되도록 수정. 비동기 방식일때만

             */
			if(_j_ag.match(/(?:MSIE) ([0-9.]+)/)[1]==6&&opt.async){
				var onreadystatechange = function(rq){
					if(req.readyState == 4 && !t._is_abort){
						if(_timer){
							clearTimeout(_timer);
							_timer = undefined;
						}
						t._onload(rq);
						clearInterval(t._interval);
						t._interval = undefined;
					}
				};
				this._interval = setInterval(onreadystatechange,300);

			}else{
				req.onreadystatechange = function(rq){
					if(req.readyState == 4){
						clearTimeout(_timer);
						_timer = undefined;
						t._onload(rq);
					}
				};
			}
		}
	}
	if (opt.timeout > 0) {

//		if(this._interval)clearInterval(this._interval);
		if(this._timer) clearTimeout(this._timer);

		_timer = setTimeout(function(){
			t._is_abort = true;
			if(t._interval){
				clearInterval(t._interval);
				t._interval = undefined;
			}
			try{ req.abort(); }catch(e){};

			opt.ontimeout(req);
			if(___jindo.isFunction(t._oncompleted)) t._oncompleted(false);
		}, opt.timeout * 1000 );
		this._timer = _timer;
	}
	/*

 * test을 하기 위한 url

	 */
	this._test_url = url;
	req.send(data);

	return this;
};

/**

 * @description isIdle() 메서드는 $Ajax() 객체가 현재 요청 대기 상태인지 확인한다.
 * @since 1.3.5
 * @return {Boolean} 현재 대기 중이면 true 를, 그렇지 않으면 false를 리턴한다.
 * @example
 var ajax = $Ajax("http://www.remote.com",{
     onload : function(res){
         // onload 핸들러
     }
});

if(ajax.isIdle()) ajax.request();

 */
MobileCommentJindo.$Ajax.prototype.isIdle = function(){
	return this._status==0;
};

/**

 * @description abort() 메서드는 서버로 전송한 Ajax 요청을 취소한다. Ajax 요청의 응답 시간이 길거나 강제로 Ajax 요청을 취소할 경우 사용한다.
 * @caution type이 jsonp일 경우 abort를 해도 요청을 멈추진 않는다.
 * @return {$Ajax} 전송을 취소한 $Ajax() 객체
 * @example
var ajax = $Ajax("http://www.remote.com", {
	timeout : 3,
	ontimeout : function() {
		stopRequest();
	}
	onload : function(res) {
		// onload 핸들러
	}
}).request( {key1:"value1", key2:"value2"} );

function stopRequest() {
    ajax.abort();
}

 */
MobileCommentJindo.$Ajax.prototype.abort = function() {
	try {
		if(this._interval) clearInterval(this._interval);
		if(this._timer) clearTimeout(this._timer);
		this._interval = undefined;
		this._timer = undefined;
		this._is_abort = true;
		this._request.abort();
	}finally{
		this._status--;
	}

	return this;
};

/**

 * @description url()메서드는 url을 변경하거나 반환한다.
 *
 * @param1 {Void}
 * @return1 {String} URL의 값.
 *
 * @param2 {String+} url
 * @return2 {$Ajax} $Ajax() 객체 자신.
 *
 * @since 2.0.0

 */
MobileCommentJindo.$Ajax.prototype.url = function(sURL){
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'g' : [ ],
		's' : [ 'sURL:String+' ]
	},"$Ajax#url");

	switch(oArgs+"") {
		case 'g':
	    	return this._url;
		case 's':
	    	this._url = oArgs.sURL;
			return this;

	}
};
/**

 * @description option() 메서드는 $Ajax() 객체의 옵션 객체(oOption) 속성에 정의된 Ajax 요청 옵션에 대한 정보를 가져오거나 혹은 설정한다. Ajax 요청 옵션을 설정하려면 이름과 값을, 혹은 이름과 값을 원소로 가지는 하나의 객체를 파라미터로 입력한다. 이름과 값을 원소로 가지는 객체를 입력하면 하나 이상의 정보를 한 번에 설정할 수 있다.
 * @memberOf $Ajax#
 *
 * @param1 {String+} sName 옵션 객체의 속성 이름
 * @param1 {Variant} vValue 새로 설정할 옵션 속성의 값.
 * @return1 {$Ajax} $Ajax() 객체를 반환한다.
 *
 * @param2 {Hash+} oOption 속성 값이 정의된 객체.
 * @return2 {$Ajax} $Ajax() 객체를 반환한다.
 *
 * @param3 {String+} sName 옵션 객체의 속성 이름
 * @return3 {Variant} 해당 옵션에 해당하는 값.
 *
 * @throws {MobileCommentJindo.$Except.CANNOT_USE_OPTION} 해당 타입에 적절한 옵션이 아닌 경우.
 * @example
var ajax = $Ajax("http://www.remote.com", {
	type : "xhr",
	method : "get",
	onload : function(res) {
		// onload 핸들러
	}
});

var request_type = ajax.option("type");					// type 인 xhr 을 리턴한다.
ajax.option("method", "post");							// method 를 post 로 설정한다.
ajax.option( { timeout : 0, onload : handler_func } );	// timeout 을 으로, onload 를 handler_func 로 설정한다.

 */

MobileCommentJindo.$Ajax.prototype.option = function(name, value) {
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		's4var' : [ 'sKey:String+', 'vValue:Variant' ],
		's4obj' : [ 'oOption:Hash+'],
		'g' : [ 'sKey:String+']
	},"$Ajax#option");

	switch(oArgs+"") {
		case "s4var":
			this._options[oArgs.sKey] = oArgs.vValue;
			break;
		case "s4obj":
			var oOption = oArgs.oOption;
			try {
				for (var x in oOption) {
					if (oOption.hasOwnProperty(x))
						this._options[x] = oOption[x];
				}
			}catch (e) {};
			break;
		case 'g':
			return this._options[oArgs.sKey];

	}

	MobileCommentJindo.$Ajax._validationOption(this._options,"$Ajax#option");
	return this;
};

/**

 * @description header() 메서드는 Ajax 요청에서 사용할 HTTP 요청 헤더를 가져오거나 설정한다. 헤더를 설정하려면 헤더의 이름과 값을 각각 파라미터로 입력하거나 헤더의 이름과 값을 원소로 가지는 객체를 파라미터로 입력한다. 객체를 파라미터로 입력하면 하나 이상의 헤더를 한 번에 설정할 수 있다. 헤더에서 특정 속성 값을 가져오려면 속성의 이름을 파라미터로 입력한다.
 * @memberOf $Ajax#
 *
 * @param1 {String+} sName 헤더 이름
 * @param1 {String+} sValue 설정할 헤더 값.
 * @return1 {$Ajax} $Ajax() 객체를 반환한다.
 *
 * @param2 {Hash+} oHeader 하나 이상의 헤더 값이 정의된 객체
 * @return2 {$Ajax}$Ajax() 객체를 반환한다.
 *
 * @param3 {String+} vName 헤더 이름
 * @return3 {String} 문자열을 반환한다.
 *
 * @throws {MobileCommentJindo.$Except.CANNOT_USE_OPTION} jsonp 타입일 경우 header메서드를 사용시 할 때.
 * @example
var customheader = ajax.header("myHeader"); 		// HTTP 요청 헤더에서 myHeader 의 값
ajax.header( "myHeader", "someValue" );				// HTTP 요청 헤더의 myHeader 를 someValue 로 설정한다.
ajax.header( { anotherHeader : "someValue2" } );	// HTTP 요청 헤더의 anotherHeader 를 someValue2 로 설정한다.

 */
MobileCommentJindo.$Ajax.prototype.header = function(name, value) {
	if(this._options["type"]==="jsonp"){throw new MobileCommentJindo.$Error(MobileCommentJindo.$Except.CANNOT_USE_OPTION,"$Ajax#header");}

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		's4str' : [ 'sKey:String+', 'sValue:String+' ],
		's4obj' : [ 'oOption:Hash+' ],
		'g' : [ 'sKey:String+' ]
	},"$Ajax#option");

	switch(oArgs+"") {
		case 's4str':
			this._headers[oArgs.sKey] = oArgs.sValue;
			break;
		case 's4obj':
			var oOption = oArgs.oOption;
			try {
				for (var x in oOption) {
					if (oOption.hasOwnProperty(x))
						this._headers[x] = oOption[x];
				}
			}catch (e) {};
			break;
		case 'g':
			return this._headers[oArgs.sKey];

	}

	return this;
};

/**

 * @class $Ajax.Response 객체를 생성한다. $Ajax.Response 객체는 $Ajax() 객체에서 request() 메서드의 요청 처리 완료한 후 생성된다. $Ajax() 객체를 생성할 때 onload 속성에 설정한 콜백 함수의 파라미터로 $Ajax.Response 객체가 전달된다.
 * @constructor
 * @description Ajax 응답 객체를 래핑하여 응답 데이터를 가져오거나 활용하는데 유용한 기능을 제공한다.
 * @param {Hash+} oReq 요청 객체
 * @see $Ajax

 */
MobileCommentJindo.$Ajax.Response  = function(req) {
	this._response = req;
	this._regSheild = /^for\(;;\);/;
};

/**

 * @description xml() 메서드는 응답을 XML 객체로 반환한다. XHR의 responseXML 속성과 유사하다.
 * @return {Object} 응답 XML 객체.
 * @see <a href="https://developer.mozilla.org/en/XMLHttpRequest">XMLHttpRequest</a> - MDN Docs
 * @example
// some.xml
<?xml version="1.0" encoding="utf-8"?>
<data>
	<li>첫번째</li>
	<li>두번째</li>
	<li>세번째</li>
</data>

// client.html
var oAjax = new $Ajax('some.xml', {
	type : 'xhr',
	method : 'get',
	onload : function(res){
		var elData = cssquery.getSingle('data', res.xml());	// 응답을 XML 객체로 리턴한다
		$('list').innerHTML = elData.firstChild.nodeValue;
	},
}).request();

 */
MobileCommentJindo.$Ajax.Response.prototype.xml = function() {
	return this._response.responseXML;
};

/**

 * @description text() 메서드는 응답을 문자열(String)로 반환한다. XHR의 responseText 와 유사하다.
 * @return {String} 응답 문자열.
 * @see <a href="https://developer.mozilla.org/en/XMLHttpRequest">XMLHttpRequest</a> - MDN Docs
 * @example
// some.php
<?php
	echo "<li>첫번째</li><li>두번째</li><li>세번째</li>";
?>

// client.html
var oAjax = new $Ajax('some.xml', {
	type : 'xhr',
	method : 'get',
	onload : function(res){
		$('list').innerHTML = res.text();	// 응답을 문자열로 리턴한다
	},
}).request();

 */
MobileCommentJindo.$Ajax.Response.prototype.text = function() {
	return this._response.responseText.replace(this._regSheild, '');
};

/**

 * @description status() 메서드는 HTTP 응답 코드를 반환한다. HTTP 응답 코드표를 참고한다.
 * @return {Numeric} 응답 코드.
 * @see <a href="http://www.w3.org/Protocols/HTTP/HTRESP.html">HTTP Status codes</a> - W3C
 * @example
var oAjax = new $Ajax('some.php', {
	type : 'xhr',
	method : 'get',
	onload : function(res){
		if(res.status() == 200){	// HTTP 응답 코드를 확인한다.
			$('list').innerHTML = res.text();
		}
	},
}).request();

 */
MobileCommentJindo.$Ajax.Response.prototype.status = function() {
	return this._response.status;
};

/**

 * @description readyState() 메서드는 응답 상태(readyState)를 반환한다. readyState 속성 값에 대한 설명은 다음 표와 같다.<br>
 <tabel>
	<caption>readyState 속성 설명</caption>
	<thead>
		<tr>
			<th>값</th>
			<th>설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>0(UNINITIALIZED)</td>
			<td>요청이 초기화되지 않은 상태.</td>
		</tr>
		<tr>
			<td>1(LOADING)</td>
			<td>요청 옵션을 설정했으나, 요청하지 않은 상태</td>
		</tr>
		<tr>
			<td>2(LOADED)</td>
			<td>요청을 보내고 처리 중인 상태. 이 상태에서 응답 헤더를 얻을 수 있다.</td>
		</tr>
		<tr>
			<td>3(INTERACTIVE)</td>
			<td>요청이 처리 중이며, 부분적인 응답 데이터를 받은 상태.</td>
		</tr>
		<tr>
			<td>4(COMPLETED)</td>
			<td>응답 데이터를 모두 받아 통신을 완료한 상태.</td>
		</tr>
	</tbody>
</table>
 * @return {Numeric}  readyState 값.
 * @see open
 * @see send
 * @example
var oAjax = new $Ajax('some.php', {
	type : 'xhr',
	method : 'get',
	onload : function(res){
		if(res.readyState() == 4){	// 응답의 readyState 를 확인한다.
			$('list').innerHTML = res.text();
		}
	},
}).request();

 */
MobileCommentJindo.$Ajax.Response.prototype.readyState = function() {
	return this._response.readyState;
};

/**

 * @description json() 메서드는 응답을 JSON 객체로 반환한다. 응답 문자열을 자동으로 JSON 객체로 변환하여 반환한다. 변환 과정에서 오류가 발생하면 빈 객체를 반환한다.
 * @return {Object} JSON 객체.
 * @throw {MobileCommentJindo.$Except.PARSE_ERROR} json파싱할 때 에러 발생한 경우.
 * @example
// some.php
<?php
	echo "['첫번째', '두번째', '세번째']";
?>

// client.html
var oAjax = new $Ajax('some.php', {
	type : 'xhr',
	method : 'get',
	onload : function(res){
		var welList = $Element('list').empty();
		var jsonData = res.json();	// 응답을 JSON 객체로 리턴한다

		for(var i = 0, nLen = jsonData.length; i < nLen; i++){
			welList.append($("<li>" + jsonData[i] + "</li>"));
		}
	},
}).request();

 */
MobileCommentJindo.$Ajax.Response.prototype.json = function() {
	if (this._response.responseJSON) {
		return this._response.responseJSON;
	} else if (this._response.responseText) {
		try {
			return eval("("+this.text()+")");
		} catch(e) {
			throw new MobileCommentJindo.$Error(MobileCommentJindo.$Except.PARSE_ERROR,"$Ajax#json");
		}
	}

	return {};
};

/**

 * @description header() 메서드는 응답 헤더를 가져온다. 파라미터를 입력하지 않으면 헤더 전체를 반환한다.
 * @memberOf $Ajax.Response#
 *
 * @param1 {Void}
 * @return1 {Object} 헤더 전체(Object)를 반환한다.
 *
 * @param2 {String+} sName 가져올 응답 헤더의 이름.
 * @return2 {String} 해당하는 헤더 값(String)
 *
 * @example
var oAjax = new $Ajax('some.php', {
	type : 'xhr',
	method : 'get',
	onload : function(res){
		res.header("Content-Length")	// 응답 헤더에서 "Content-Length" 의 값을 리턴한다.
	},
}).request();

 */
MobileCommentJindo.$Ajax.Response.prototype.header = function(name) {
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str' : [ 'name:String+' ],
		'4voi' : [ ]
	},"$Ajax.Response#header");

	switch (oArgs+"") {
	case '4str':
		return this._response.getResponseHeader(name);
	case '4voi':
		return this._response.getAllResponseHeaders();
	}
};
//-!MobileCommentJindo.$Ajax end!-//



/**

 * @fileOverview $Ajax의 확장 메서드를 정의한 파일
 * @name Ajax.extend.js

 */

//-!MobileCommentJindo.$Ajax.RequestBase start(MobileCommentJindo.$Class,MobileCommentJindo.$Ajax)!-//
/**

 * @class Ajax 요청 객체의 기본 객체이다.
 * @description Ajax 요청 타입 별로 Ajax 요청 객체를 생성할 때 Ajax 요청 객체를 생성하기 위한 상위 객체로 사용한다.
 * @ignore
 * @see $Ajax

 */
MobileCommentJindo.$Ajax.RequestBase = MobileCommentJindo.$Class({
	_respHeaderString : "",
	callbackid:"",
	callbackname:"",
	responseXML  : null,
	responseJSON : null,
	responseText : "",
	status : 404,
	readyState : 0,
	$init  : function(fpOption){},
	onload : function(){},
	abort  : function(){},
	open   : function(){},
	send   : function(){},
	setRequestHeader  : function(sName, sValue) {
		MobileCommentJindo.$Jindo.checkVarType(arguments, {
			'4str' : [ 'sName:String+', 'sValue:String+' ]
		},"$Ajax.RequestBase#setRequestHeader");
		this._headers[sName] = sValue;
	},
	getResponseHeader : function(sName) {
		MobileCommentJindo.$Jindo.checkVarType(arguments, {
			'4str' : [ 'sName:String+']
		},"$Ajax.RequestBase#getResponseHeader");
		return this._respHeaders[sName] || "";
	},
	getAllResponseHeaders : function() {
		return this._respHeaderString;
	},
	_getCallbackInfo : function() {
		var id = "";
		if(this.option("callbackid")!="") {
			var idx = 0;
			do {
				id = "_" + this.option("callbackid") + "_"+idx;
				idx++;
			} while (window.__jindo2_callback[id]);
		}else{
			do {
				id = "_" + Math.floor(Math.random() * 10000);
			} while (window.__jindo2_callback[id]);
		}

		if(this.option("callbackname") == ""){
			this.option("callbackname","_callback");
		}
		return {callbackname:this.option("callbackname"),id:id,name:"window.__jindo2_callback."+id};
	}
});
//-!MobileCommentJindo.$Ajax.RequestBase end!-//

//-!MobileCommentJindo.$Ajax.JSONPRequest start(MobileCommentJindo.$Class,MobileCommentJindo.$Ajax,MobileCommentJindo.$Agent.prototype.navigator,MobileCommentJindo.$Ajax.RequestBase)!-//
/**

 * @class Ajax 요청 타입이 jsonp인 요청 객체를 생성하며, $Ajax() 객체에서 Ajax 요청 객체를 생성할 때 사용한다.
 * @extends $Ajax.RequestBase
 * @description $Ajax.JSONPRequest 객체를 생성한다. 이때, $Ajax.JSONPRequest 객체는 $Ajax.RequestBase 객체를 상속한다.
 * @ignore
 * @see $Ajax
 * @see $Ajax.RequestBase

 */
MobileCommentJindo.$Ajax.JSONPRequest = MobileCommentJindo.$Class({
	_headers : {},
	_respHeaders : {},
	_script : null,
	_onerror : null,
	$init  : function(fpOption){
		this.option = fpOption;
	},
	/**
	 * @ignore
	 */
	_callback : function(data) {

		if (this._onerror) {
			clearTimeout(this._onerror);
			this._onerror = null;
		}

		var self = this;

		this.responseJSON = data;
		this.onload(this);
		setTimeout(function(){ self.abort() }, 10);
	},
	abort : function() {
		if (this._script) {
			try {
				this._script.parentNode.removeChild(this._script);
			}catch(e){
			};
		}
	},
	open  : function(method, url) {
		MobileCommentJindo.$Jindo.checkVarType(arguments, {
			'4str' : [ 'method:String+','url:String+']
		},"$Ajax.JSONPRequest#open");
		this.responseJSON = null;
		this._url = url;
	},
	send  : function(data) {
		var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
			'4voi' : [],
			'4nul' : ["data:Null"],
			'4str' : ["data:String+"]
		},"$Ajax.JSONPRequest#send");
		var t    = this;
		var info = this._getCallbackInfo();
		var head = document.getElementsByTagName("head")[0];
		this._script = document.createElement("script");
		this._script.type    = "text/javascript";
		this._script.charset = this.option("jsonp_charset");

		if (head) {
			head.appendChild(this._script);
		} else if (document.body) {
			document.body.appendChild(this._script);
		}

		window.__jindo2_callback[info.id] = function(data){
			try {
				t.readyState = 4;
				t.status = 200;
				t._callback(data);
			} finally {
				delete window.__jindo2_callback[info.id];
			}
		};

		var agent = MobileCommentJindo.$Agent(navigator);
		var _loadCallback = function(){
			if (!t.responseJSON) {
				t.readyState = 4;
				t.status = 404;
				t._onerror = setTimeout(function(){t._callback(null);}, 200);
			}
		};
		if (agent.navigator().ie || agent.navigator().opera) {
			this._script.onreadystatechange = function(){
				if (this.readyState == 'loaded'){
					_loadCallback();
					this.onreadystatechange = null;
				}
			};
		} else {
			this._script.onload =
			this._script.onerror = function(){
				_loadCallback();
				this.onerror = null;
				this.onload = null;
			};
		}
		var delimiter = "&";
		if(this._url.indexOf('?')==-1){
			delimiter = "?";
		}
		switch(oArgs+""){
			case "4voi":
			case "4nul":
				data = "";
				break;
			case "4str":
				data = "&" + data;


		}
		//test url for spec.
		this._test_url = this._script.src = this._url+delimiter+info.callbackname+"="+info.name+data;

	}
}).extend(MobileCommentJindo.$Ajax.RequestBase);
//-!MobileCommentJindo.$Ajax.JSONPRequest end!-//

//-!MobileCommentJindo.$Ajax.SWFRequest start(MobileCommentJindo.$Class,MobileCommentJindo.$Ajax,MobileCommentJindo.$Agent.prototype.navigator,MobileCommentJindo.$Ajax.RequestBase)!-//
/**

 * @class Ajax 요청 타입이 flash인 요청 객체를 생성하며, $Ajax() 객체에서 Ajax 요청 객체를 생성할 때 사용한다.
 * @extends $Ajax.RequestBase
 * @description $Ajax.SWFRequest 객체를 생성한다. 이때, $Ajax.SWFRequest 객체는 $Ajax.RequestBase 객체를 상속한다.
 * @ignore
 * @see $Ajax
 * @see $Ajax.RequestBase

 */
MobileCommentJindo.$Ajax.SWFRequest = MobileCommentJindo.$Class({
	$init  : function(fpOption){
		this.option = fpOption;
	},
	_headers : {},
	_respHeaders : {},
	_getFlashObj : function(){
		var _tmpId = MobileCommentJindo.$Ajax.SWFRequest._tmpId;
		var navi = MobileCommentJindo.$Agent(window.navigator).navigator();
		var obj;
		if (navi.ie&&navi.version==9) {
			obj = document.getElementById(_tmpId);
		}else{
			obj = window.document[_tmpId];
		}
		return(this._getFlashObj =  function(){
			return obj;
		})();

	},
	_callback : function(status, data, headers){
		this.readyState = 4;
        /*

 하위 호환을 위해 status가 boolean 값인 경우도 처리

         */

		if( MobileCommentJindo.$Jindo.isNumeric(status)){
			this.status = status;
		}else{
			if(status==true) this.status=200;
		}
		if (this.status==200) {
			if (MobileCommentJindo.$Jindo.isString(data)) {
				try {
					this.responseText = this.option("decode")?decodeURIComponent(data):data;
					if(!this.responseText || this.responseText=="") {
						this.responseText = data;
					}
				} catch(e) {
                    /*

 데이터 안에 utf-8이 아닌 다른 인코딩일때 디코딩을 안하고 바로 text에 저장.

                     */

					if(e.name == "URIError"){
						this.responseText = data;
						if(!this.responseText || this.responseText=="") {
							this.responseText = data;
						}
					}
				}
			}
            /*

 콜백코드는 넣었지만, 아직 SWF에서 응답헤더 지원 안함

             */
			if(MobileCommentJindo.$Jindo.isHash(headers)){
				this._respHeaders = headers;
			}
		}

		this.onload(this);
	},
	open : function(method, url) {
		MobileCommentJindo.$Jindo.checkVarType(arguments, {
			'4str' : [ 'method:String+','url:String+']
		},"$Ajax.SWFRequest#open");
		var re  = /https?:\/\/([a-z0-9_\-\.]+)/i;

		this._url    = url;
		this._method = method;
	},
	send : function(data) {
		var _jjindo = MobileCommentJindo.$Jindo;
		var oArgs = _jjindo.checkVarType(arguments, {
			'4voi' : [],
			'4nul' : ["data:Null"],
			'4str' : ["data:String+"]
		},"$Ajax.SWFRequest#send");
		this.responseXML  = false;
		this.responseText = "";

		var t    = this;
		var dat  = {};
		var info = this._getCallbackInfo();
		var swf  = this._getFlashObj()

		function f(arg) {
			switch(typeof arg){
				case "string":
					return '"'+arg.replace(/\"/g, '\\"')+'"';

				case "number":
					return arg;

				case "object":
					var ret = "", arr = [];
					if (_jjindo.isArray(arg)) {
						for(var i=0; i < arg.length; i++) {
							arr[i] = f(arg[i]);
						}
						ret = "["+arr.join(",")+"]";
					} else {
						for(var x in arg) {
							if(arg.hasOwnProperty(x)){
								arr[arr.length] = f(x)+":"+f(arg[x]);
							}
						}
						ret = "{"+arr.join(",")+"}";
					}
					return ret;
				default:
					return '""';
			}
		}

		data = (data || "").split("&");
		var oEach;
		for(var i=0; i < data.length; i++) {
			oEach = data[i];
			pos = oEach.indexOf("=");
			key = oEach.substring(0,pos);
			val = oEach.substring(pos+1);

			dat[key] = decodeURIComponent(val);
		}
		this._current_callback_id = info.id
		window.__jindo2_callback[info.id] = function(success, data){
			try {
				t._callback(success, data);
			} finally {
				delete window.__jindo2_callback[info.id];
			}
		};

		var oData = {
			url  : this._url,
			type : this._method,
			data : dat,
			charset  : "UTF-8",
			callback : info.name,
			header_json : this._headers
		};

		swf.requestViaFlash(f(oData));
	},
	abort : function(){

		if(this._current_callback_id){
			window.__jindo2_callback[this._current_callback_id] = function(){
				delete window.__jindo2_callback[info.id];
			}
		}
	}
}).extend(MobileCommentJindo.$Ajax.RequestBase);

/**

 * @description write() 메서드는 플래시 객체를 초기화하는 메서드로서 write() 메서드를 호출하면 통신을 위한 플래시 객체를 문서 내에 추가한다. Ajax 요청 타입이 flash이면 플래시 객체를 통해 통신한다. 따라서 $Ajax() 객체의 request 메서드가 호출되기 전에 write() 메서드를 반드시 한 번 실행해야 하며, <body> 요소에 작성되어야 한다. 두 번 이상 실행해도 문제가 발생한다.
 * @param {String+} [sSWFPath] Ajax 통신에 사용할 플래시 파일. 기본 값은 "./ajax.swf" 이다.
 * @see $Ajax#request
 * @example
<body>
    <script type="text/javascript">
        $Ajax.SWFRequest.write("/path/swf/ajax.swf");
    </script>
</body>

 */
MobileCommentJindo.$Ajax.SWFRequest.write = function(swf_path) {
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4voi' : [],
		'4str' : ["data:String+"]
	},"<static> $Ajax.SWFRequest#write");
	switch(oArgs+""){
		case "4voi":
			swf_path = "./ajax.swf";

	}
	var ajax = MobileCommentJindo.$Ajax;
	ajax.SWFRequest._tmpId = 'tmpSwf'+(new Date()).getMilliseconds()+Math.floor(Math.random()*100000);
	var activeCallback = "MobileCommentJindo.$Ajax.SWFRequest.loaded";
	var protocol = (location.protocol == "https:")?"https:":"http:";

	ajax._checkFlashLoad();
	document.write('<div style="position:absolute;top:-1000px;left:-1000px"><object id="'+ajax.SWFRequest._tmpId+'" width="1" height="1" classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="'+protocol+'//download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0"><param name="movie" value="'+swf_path+'"><param name = "FlashVars" value = "activeCallback='+activeCallback+'" /><param name = "allowScriptAccess" value = "always" /><embed name="'+ajax.SWFRequest._tmpId+'" src="'+swf_path+'" type="application/x-shockwave-flash" pluginspage="'+protocol+'://www.macromedia.com/go/getflashplayer" width="1" height="1" allowScriptAccess="always" swLiveConnect="true" FlashVars="activeCallback='+activeCallback+'"></embed></object></div>');

};

/**
 * @ignore
 */
MobileCommentJindo.$Ajax._checkFlashLoad = function(){
	MobileCommentJindo.$Ajax._checkFlashKey = setTimeout(function(){
		MobileCommentJindo.$Ajax.SWFRequest.onerror();
	},5000);
	MobileCommentJindo.$Ajax._checkFlashLoad = function(){}
};
/**

 * @description 플래시 객체 로딩 여부를 저장한 변수. 로딩된 경우 true를 반환하고 로딩되지 않은 경우 false를 반환한다. 플래시 객체가 로딩되었는지 확인할 때 사용할 수 있다.
 * @see $Ajax.SWFRequest.write

 */
MobileCommentJindo.$Ajax.SWFRequest.activeFlash = false;

/**
 *
 * @description flash가 정상적으로 load가 완료된 후 실행되는 함수.
 * @see $Ajax.SWFRequest.onerror
 * @since 2.0.0
 * @example
    <script type="text/javascript">
		var oSWFAjax = $Ajax("http://naver.com/api/test.json",{
			"type" : "flash"
		});
        $Ajax.SWFRequest.onload = function(){
			oSWFAjax.request();
		}
    </script>

 */
MobileCommentJindo.$Ajax.SWFRequest.onload = function(){
};

/**
 *
 * @description flash가 정상적으로 load가 완료되지 않을때 실행되는 함수.
 * @see $Ajax.SWFRequest.onerror
 * @since 2.0.0
 * @example
    <script type="text/javascript">
		var oSWFAjax = $Ajax("http://naver.com/api/test.json",{
			"type" : "flash"
		});
        $Ajax.SWFRequest.onerror = function(){
			alert("flash로드 실패.다시 로드하세요!");
		}
    </script>

 */
MobileCommentJindo.$Ajax.SWFRequest.onerror = function(){
};

/**

 * flash에서 로딩 후 실행 시키는 함수.
 * @ignore

 */
MobileCommentJindo.$Ajax.SWFRequest.loaded = function(){
	clearTimeout(MobileCommentJindo.$Ajax._checkFlashKey);
	MobileCommentJindo.$Ajax.SWFRequest.activeFlash = true;
	MobileCommentJindo.$Ajax.SWFRequest.onload();
};
//-!MobileCommentJindo.$Ajax.SWFRequest end!-//

//-!MobileCommentJindo.$Ajax.FrameRequest start(MobileCommentJindo.$Class,MobileCommentJindo.$Ajax,MobileCommentJindo.$Ajax.RequestBase)!-//
/**

 * @class Ajax 요청 타입이 iframe인 요청 객체를 생성하며, $Ajax() 객체에서 Ajax 요청 객체를 생성할 때 사용한다.
 * @extends $Ajax.RequestBase
 * @description $Ajax.FrameRequest 객체를 생성한다. 이때, $Ajax.FrameRequest 객체는 $Ajax.RequestBase 객체를 상속한다.
 * @ignire
 * @see $Ajax
 * @see $Ajax.RequestBase

 */
MobileCommentJindo.$Ajax.FrameRequest = MobileCommentJindo.$Class({
	_headers : {},
	_respHeaders : {},
	_frame  : null,
	_domain : "",
	$init  : function(fpOption){
		this.option = fpOption;
	},
	_callback : function(id, data, header) {
		var self = this;

		this.readyState   = 4;
		this.status = 200;
		this.responseText = data;

		this._respHeaderString = header;
		header.replace(/^([\w\-]+)\s*:\s*(.+)$/m, function($0,$1,$2) {
			self._respHeaders[$1] = $2;
		});

		this.onload(this);

		setTimeout(function(){ self.abort() }, 10);
	},
	abort : function() {
		if (this._frame) {
			try {
				this._frame.parentNode.removeChild(this._frame);
			} catch(e) {
			}
		}
	},
	open : function(method, url) {
		MobileCommentJindo.$Jindo.checkVarType(arguments, {
			'4str' : [ 'method:String+','url:String+']
		},"$Ajax.FrameRequest#open");

		var re  = /https?:\/\/([a-z0-9_\-\.]+)/i;
		var dom = document.location.toString().match(re);

		this._method = method;
		this._url    = url;
		this._remote = String(url).match(/(https?:\/\/[a-z0-9_\-\.]+)(:[0-9]+)?/i)[0];
		this._frame = null;
		this._domain = (dom[1] != document.domain)?document.domain:"";
	},
	send : function(data) {
		var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
			'4voi' : [],
			'4nul' : ["data:Null"],
			'4str' : ["data:String+"]
		},"$Ajax.FrameRequest#send");

		this.responseXML  = "";
		this.responseText = "";

		var t      = this;
		var re     = /https?:\/\/([a-z0-9_\-\.]+)/i;
		var info   = this._getCallbackInfo();
		var url;
		var _aStr = [];
		_aStr.push(this._remote+"/ajax_remote_callback.html?method="+this._method);
		var header = [];

		window.__jindo2_callback[info.id] = function(id, data, header){
			try {
				t._callback(id, data, header);
			} finally {
				delete window.__jindo2_callback[info.id];
			}
		};

		for(var x in this._headers) {
			if(this._headers.hasOwnProperty(x)){
				header[header.length] = "'"+x+"':'"+this._headers[x]+"'";
			}

		}

		header = "{"+header.join(",")+"}";


		_aStr.push("&id="+info.id);
		_aStr.push("&header="+encodeURIComponent(header));
		_aStr.push("&proxy="+encodeURIComponent(this.option("proxy")));
		_aStr.push("&domain="+this._domain);
		_aStr.push("&url="+encodeURIComponent(this._url.replace(re, "")));
		_aStr.push("#"+encodeURIComponent(data));

		var fr = this._frame = document.createElement("iframe");
		var style = fr.style;
		style.position = "absolute";
		style.visibility = "hidden";
		style.width = "1px";
		style.height = "1px";

		var body = document.body || document.documentElement;
		if (body.firstChild){
			body.insertBefore(fr, body.firstChild);
		}else{
			body.appendChild(fr);
		}
		fr.src = _aStr.join("");
	}
}).extend(MobileCommentJindo.$Ajax.RequestBase);
//-!MobileCommentJindo.$Ajax.FrameRequest end!-//

//-!MobileCommentJindo.$Ajax.Queue start(MobileCommentJindo.$Ajax)!-//
/**

 * @class Ajax 요청을 큐에 담아 큐에 들어온 순서대로 요청을 처리한다.
 * @constructor
 * @description $Ajax() 객체를 순서대로 호출할 수 있도록 기능을 제공한다.
 * @param {Hash+} oOption $Ajax.Queue 객체가 서버로 통신을 요청할 때 사용하는 정보를 정의한다.
	<ul>
		<li>async : 비동기/동기 요청 방식을 설정한다. 비동기 요청 방식이면 true, 동기 요청 방식이면 false를 설정한다. 기본 값은 false 이다.</li>
		<li>useResultAsParam : 이전 요청 결과를 다음 요청의 파라미터로 전달할지 결정한다. 이전 요청 결과를 파라미터로 전달하려면 true, 그렇게 하지 않을 경우 false를 설정한다. 기본 값은 false 이다.</li>
		<li>stopOnFailure : 이전 요청이 실패할 경우 다음 요청 중단 여부를 설정한다. 다음 요청을 중단하려면 true, 계속 실행하려면 false를 설정한다. 기본 값은 false 이다.</li>
	</ul>
 * @since 1.3.7
 * @see $Ajax
 * @example
// $Ajax 요청 큐를 생성한다.
var oAjaxQueue = new $Ajax.Queue({
	useResultAsParam : true
});

 */
MobileCommentJindo.$Ajax.Queue = function (option) {
	//-@@$Ajax.Queue-@@//
	var cl = arguments.callee;
	if (!(this instanceof cl)){ return new cl(option||{});}

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4voi' : [],
		'4obj' : ["option:Hash+"]
	},"$Ajax.Queue");
	option = oArgs.option;
	this._options = {
		async : false,
		useResultAsParam : false,
		stopOnFailure : false
	};

	this.option(option);

	this._queue = [];
};

/**

 * @description option() 메서드는 $Ajax.Queue 객체에 설정한 옵션 값을 키와 값으로 설정한다.
 *
 * @param1 {String+} sName 옵션의 이름(String)
 * @param1 {Variant} vValue 설정할 옵션의 값. 설정할 옵션을 vName에 지정한 경우에만 입력한다.
 * @return1 {$Ajax.Queue} 입력한 옵션을 설정한 $Ajax.Queue 객체를 반환한다.
 *
 * @param2 {Hash+} oOption 옵션의 이름(String) 또는 하나 이상의 옵션을 설정한 객체(Object).
 * @return2 {$Ajax.Queue} 입력한 옵션을 설정한 $Ajax.Queue 객체를 반환한다.
 *
 * @param3 {String+} vName 옵션의 이름
 * @return3 {Variant} 입력한 옵션을 반환한다.
 *
 * @see $Ajax.Queue
 * @example
var oAjaxQueue = new $Ajax.Queue({
	useResultAsParam : true
});

oAjaxQueue.option("async", true);		// async 옵션을 true 로 설정한다.

 * @example

oAjaxQueue.option("useResultAsParam");	// useResultAsParam 옵션 값인 true 를 리턴한다.

 */
MobileCommentJindo.$Ajax.Queue.prototype.option = function(name, value) {

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		's4str' : [ 'sKey:String+', 'sValue:Variant' ],
		's4obj' : [ 'oOption:Hash+' ],
		'g' : [ 'sKey:String+' ]
	},"$Ajax.Queue#option");

	switch(oArgs+"") {
		case 's4str':
			this._options[oArgs.sKey] = oArgs.sValue;
			break;
		case 's4obj':
			var oOption = oArgs.oOption;
			try {
				for (var x in oOption) {
					if (oOption.hasOwnProperty(x))
						this._options[x] = oOption[x];
				}
			}catch (e) {};
			break;
		case 'g':
			return this._options[oArgs.sKey];
	}

	return this;
};

/**

 * @description add() 메서드는 $Ajax.Queue에 Ajax 요청($Ajax() 객체)을 추가한다.
 *
 * @param1 {$Ajax} oAjax 추가할 $Ajax() 객체.
 * @return1 {$Ajax.Queue} $Ajax.Queue객체
 *
 *
 * @param2 {$Ajax} oAjax 추가할 $Ajax() 객체.
 * @param2 {Hash+} oParam Ajax 요청 시 전송할 파라미터 객체.
 * @return2 {$Ajax.Queue} $Ajax.Queue객체
 *
 * @example
var oAjax1 = new $Ajax('ajax_test.php',{
	onload :  function(res){
		// onload 핸들러
	}
});
var oAjax2 = new $Ajax('ajax_test.php',{
	onload :  function(res){
		// onload 핸들러
	}
});
var oAjax3 = new $Ajax('ajax_test.php',{
	onload :  function(res){
		// onload 핸들러
	}

});

var oAjaxQueue = new $Ajax.Queue({
	async : true,
	useResultAsParam : true,
	stopOnFailure : false
});

// Ajax 요청을 큐에 추가한다.
oAjaxQueue.add(oAjax1);

// Ajax 요청을 큐에 추가한다.
oAjaxQueue.add(oAjax1,{seq:1});
oAjaxQueue.add(oAjax2,{seq:2,foo:99});
oAjaxQueue.add(oAjax3,{seq:3});

oAjaxQueue.request();

 */
MobileCommentJindo.$Ajax.Queue.prototype.add = function (oAjax, oParam) {
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4obj' : ['oAjax:Hash+'],
		'4obj2' : ['oAjax:Hash+','oPram:Hash+']
	},"$Ajax.Queue");
	switch(oArgs+""){
		case "4obj2":
			oParam = oArgs.oPram;
	}

	this._queue.push({obj:oAjax, param:oParam});
	return this;
};

/**

 * @description request() 메서드는 $Ajax.Queue에 있는 Ajax 요청을 서버로 보낸다.
 * @return {$Ajax.Queue} $Ajax.Queue객체
 * @example
var oAjaxQueue = new $Ajax.Queue({
	useResultAsParam : true
});
oAjaxQueue.add(oAjax1,{seq:1});
oAjaxQueue.add(oAjax2,{seq:2,foo:99});
oAjaxQueue.add(oAjax3,{seq:3});

// 서버에 Ajax 요청을 보낸다.
oAjaxQueue.request();

 */
MobileCommentJindo.$Ajax.Queue.prototype.request = function () {
	this._requestAsync.apply(this,this.option('async')?[]:[0]);
	return this;
};

MobileCommentJindo.$Ajax.Queue.prototype._requestSync = function (nIdx, oParam) {
	var t = this;
	var queue = this._queue;
	if (queue.length > nIdx+1) {
		queue[nIdx].obj._oncompleted = function(bSuccess, oResult){
			if(!t.option('stopOnFailure') || bSuccess) t._requestSync(nIdx + 1, oResult);
		};
	}
	var _oParam = queue[nIdx].param||{};
	if(this.option('useResultAsParam') && oParam){
		try { for(var x in oParam) if(_oParam[x] === undefined && oParam.hasOwnProperty(x)) _oParam[x] = oParam[x] } catch(e) {};
	}
	queue[nIdx].obj.request(_oParam);
};

MobileCommentJindo.$Ajax.Queue.prototype._requestAsync = function () {
	for( var i=0; i<this._queue.length; i++)
		this._queue[i].obj.request(this._queue[i].param||{});
};
//-!MobileCommentJindo.$Ajax.Queue end!-//


/**

 * @fileOverview $H() 객체의 생성자 및 메서드를 정의한 파일
 * @name hash.js
 * @author AjaxUI lab

 */

//-!MobileCommentJindo.$H start!-//
/**

 * @class $H() 객체는 키(key)와 값(value)을 원소로 가지는 열거형 배열인 해시(Hash)를 구현하고, 해시를 다루기 위한 여러 가지 위한 메서드를 제공한다.
 * @constructor
 * @description $H() 객체를 생성한다.
 * @param {Hash+} oHashObject 해시로 만들 객체.
 * @example
var h = $H({one:"first", two:"second", three:"third"})


 */
MobileCommentJindo.$H = function(hashObject) {
	//-@@$H-@@//
	var cl = arguments.callee;
	if (hashObject instanceof cl) return hashObject;

	if (!(this instanceof cl)){
		try {
			MobileCommentJindo.$Jindo._warn(arguments.length, 1,"$H");
			return new cl(hashObject||{});
		} catch(e) {
			if (e instanceof TypeError) { return null; }
			throw e;
		}
	}

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4obj' : ['oObj:Hash+'],
		'4vod' : []
	},"$H");

	this._table = {};
	for(var k in hashObject) {
		if(hashObject.hasOwnProperty(k)){
			this._table[k] = hashObject[k];
		}
	}
};
//-!MobileCommentJindo.$H end!-//

//-!MobileCommentJindo.$H.prototype.$value start!-//
/**

 * @description $value() 메서드는 해시(Hash)를 객체로 반환한다.
 * @return {Object} 해시가 저장된 객체.

 */
MobileCommentJindo.$H.prototype.$value = function() {
	//-@@$H.$value-@@//
	return this._table;
};
//-!MobileCommentJindo.$H.prototype.$value end!-//

//-!MobileCommentJindo.$H.prototype.$ start!-//
/**

 * @description $() 메서드는 키(key)와 값(value)을 설정하거나 키에 해당하는 값을 반환한다. 파라미터로 키만 입력한 경우 해당 키의 값을 반환하고 키와 값을 모두 입력한 경우 해당 키의 값을 지정한 값으로 설정한다.
 *
 * @param1 {String+|Numeric} sKey 해시의 키.
 * @param1 {Variant} vValue 설정할 값.
 * @return1 {$H} $H()객체.
 *
 * @param2 {String+|Numeric} sKey 해시의 키.
 * @return2 {Variant} 키에 해당하는 값.
 *
 * @param3 {Hash+} key와 value로된 오브젝트
 * @return3 {$H} $H()객체.
 *
 * @example
var woH = $H({one:"first", two:"second"});

// 값을 설정할 때
woH.$("three", "third");

// woH => {one:"first", two:"second", three:"third"}

// 값을 반환할 때
var three = woH.$("three");
// three = "third"

 */
MobileCommentJindo.$H.prototype.$ = function(key, value) {
	//-@@$H.$-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		's4var' : [ MobileCommentJindo.$Jindo._F('key:String+'), 'value:Variant' ],
		's4var2' : [ 'key:Numeric', 'value:Variant' ],
		'g4str' : [ 'key:String+' ],
		's4obj' : [ 'oObj:Hash+'],
		'g4num' : [ 'key:Numeric' ]
	},"$H#$");

	switch(oArgs+""){
		case "s4var":
		case "s4var2":
			this._table[key] = value;
			return this;
		case "s4obj":
			var obj = oArgs.oObj;
			for(var i in obj){
				this._table[i] = obj[i];
			}
			return this;
		default:
			return this._table[key];
	}

};
//-!MobileCommentJindo.$H.prototype.$ end!-//

//-!MobileCommentJindo.$H.prototype.length start!-//
/**

 * @description length() 메서드는 해시 객체의 크기를 반환한다.
 * @return {Numeric} 해시의 크기.
 * @example
 var woH = $H({one:"first", two:"second"});
 woH.length();
 // 2

 */
MobileCommentJindo.$H.prototype.length = function() {
	//-@@$H.length-@@//
	var i = 0;
	for(var k in this._table) {
		if(this._table.hasOwnProperty(k)){
			if (Object.prototype[k] !== undefined && Object.prototype[k] === this._table[k]) continue;
			i++;
		}
	}

	return i;
};
//-!MobileCommentJindo.$H.prototype.length end!-//

//-!MobileCommentJindo.$H.prototype.forEach start(MobileCommentJindo.$H.Break,MobileCommentJindo.$H.Continue)!-//
/**

 * @description forEach() 메서드는 해시의 모든 원소를 순회하면서 콜백 함수를 실행한다. 이때 해시 객체의 키와 값 그리고 원본 해시 객체가 콜백 함수의 파라미터로 입력된다. $A() 객체의 forEach() 메서드와 유사하다.$H.Break()와 $H.Continue()을 사용할 수 있다.
 *
 * @param1 {Function+} fCallback 해시를 순회하면서 실행할 콜백 함수. 콜백 함수는 파라미터로 key, value, object를 갖는다.<br>
 * value는 해당 원소의 값이다.<br>
 * key는 해당 원소의 키이다.<br>
 * object는 해시 그 자체를 가리킨다.
 * @return1 {$H}	$H() 객체.
 *
 * @param2 {Function+} fCallback 해시를 순회하면서 실행할 콜백 함수. 콜백 함수는 파라미터로 key, value, object를 갖는다.<br>
 * value는 해당 원소의 값이다.<br>
 * key는 해당 원소의 키이다.<br>
 * object는 해시 그 자체를 가리킨다.
 * @param2 {Variant} oThis 콜백 함수가 객체의 메서드일 때 콜백 함수 내부에서 this 키워드의 실행 문맥(Execution Context)으로 사용할 객체.
 * @return2 {$H}	$H() 객체.
 *
 * @see $H#map
 * @see $H#filter
 * @see $A#forEach
 * @example
function printIt(value, key, object) {
   document.write(key+" => "+value+" <br>");
}
$H({one:"first", two:"second", three:"third"}).forEach(printIt);

 */
MobileCommentJindo.$H.prototype.forEach = function(callback, thisObject) {
	//-@@$H.forEach-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4fun' : [ 'callback:Function+'],
		'4obj' : [ 'callback:Function+', "thisObject:Variant"]
	},"$H#forEach");
	var t = this._table;
	var h = this.constructor;

	for(var k in t) {
		if (t.hasOwnProperty(k)) {
			if (!t.propertyIsEnumerable(k)) continue;
			try {
				callback.call(thisObject, t[k], k, t);
			} catch(e) {
				if (e instanceof h.Break) break;
				if (e instanceof h.Continue) continue;
				throw e;
			}
		}
	}
	return this;
};
//-!MobileCommentJindo.$H.prototype.forEach end!-//

//-!MobileCommentJindo.$H.prototype.filter start(MobileCommentJindo.$H.prototype.forEach)!-//
/**

 * @description filter() 메서드는 해시의 모든 원소를 순회하면서 콜백 함수를 실행하고 콜백 함수가 true 값을 반환하는 원소만 모아 새로운 $H() 객체를 반환한다. $A() 객체의 filter() 메서드와 유사하다.$H.Break()와 $H.Continue()을 사용할 수 있다.
 *
 * @param1 {Function+} fCallback 해시를 순회하면서 실행할 콜백 함수. 콜백 함수는 Boolean 형태로 값을 반환해야 한다. true 값을 반환하는 원소는 새로운 해시의 원소가 된다. 콜백 함수는 파라미터로 value, key, object를 갖는다.<br>
 * value는 해당 원소의 값이다.<br>
 * key는 해당 원소의 키이다.<br>
 * object는 해시 그 자체를 가리킨다.
 * @return1 {$H}	콜백 함수의 반환 값이 true인 원소로 이루어진 새로운 $H() 객체.
 *
 * @param2 {Function+} fCallback 해시를 순회하면서 실행할 콜백 함수. 콜백 함수는 Boolean 형태로 값을 반환해야 한다. true 값을 반환하는 원소는 새로운 해시의 원소가 된다. 콜백 함수는 파라미터로 value, key, object를 갖는다.<br>
 * value는 해당 원소의 값이다.<br>
 * key는 해당 원소의 키이다.<br>
 * object는 해시 그 자체를 가리킨다.
 * @param2 {Variant} oThis 콜백 함수가 객체의 메서드일 때 콜백 함수 내부에서 this 키워드의 실행 문맥(Execution Context) 사용할 객체.
 * @return2 {$H}	콜백 함수의 반환 값이 true인 원소로 이루어진 새로운 $H() 객체.
 *
 * @see $H#forEach
 * @see $H#map
 * @see $A#filter
 * @example
var ht=$H({one:"first", two:"second", three:"third"})

ht.filter(function(value, key, object){
	return value.length < 5;
})
// one:"first", three:"third"

 */
MobileCommentJindo.$H.prototype.filter = function(callback, thisObject) {
	//-@@$H.filter-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4fun' : [ 'callback:Function+'],
		'4obj' : [ 'callback:Function+', "thisObject:Variant"]
	},"$H#filter");
	var h = MobileCommentJindo.$H();
	var t = this._table;
	var hCon = this.constructor;

	for(var k in t) {
		if (t.hasOwnProperty(k)) {
			if (!t.propertyIsEnumerable(k)) continue;
			try {
				if(callback.call(thisObject, t[k], k, t)){
					h.add(k,t[k]);
				}
			} catch(e) {
				if (e instanceof hCon.Break) break;
				if (e instanceof hCon.Continue) continue;
				throw e;
			}
		}
	}
	return h;
};
//-!MobileCommentJindo.$H.prototype.filter end!-//

//-!MobileCommentJindo.$H.prototype.map start(MobileCommentJindo.$H.prototype.forEach)!-//
/**

 * @description map() 메서드는 해시의 모든 원소를 순회하면서 콜백 함수를 실행하고 콜백 함수의 실행 결과를 배열의 원소에 설정한다. $A() 객체의 map() 메서드와 유사하다.$H.Break()와 $H.Continue()을 사용할 수 있다.
 *
 * @param1 {Function+} fCallback 해시를 순회하면서 실행할 콜백 함수. 콜백 함수에서 반환하는 값을 해당 원소의 값으로 재설정한다. 콜백 함수는 파라미터로 value, key, object를 갖는다.<br>
 * value는 해당 원소의 값이다.<br>
 * key는 해당 원소의 키이다.<br>
 * object는 해시 그 자체를 가리킨다.
 * @return1 {$H} 콜백 함수의 수행 결과를 반영한 새로운 $H() 객체.
 *
 * @param2 {Function+} fCallback 해시를 순회하면서 실행할 콜백 함수. 콜백 함수에서 반환하는 값을 해당 원소의 값으로 재설정한다. 콜백 함수는 파라미터로 value, key, object를 갖는다.<br>
 * value는 해당 원소의 값이다.<br>
 * key는 해당 원소의 키이다.<br>
 * object는 해시 그 자체를 가리킨다.
 * @param2 {Variant} oThis 콜백 함수가 객체의 메서드일 때 콜백 함수 내부에서 this 키워드의 실행 문맥(Execution Context) 사용할 객체.
 * @return2 {$H} 콜백 함수의 수행 결과를 반영한 새로운 $H() 객체.
 *
 * @see $H#forEach
 * @see $H#filter
 * @see $H#map
 * @example
function callback(value, key, object) {
   var r = key+"_"+value;
   document.writeln (r + "<br />");
   return r;
}

$H({one:"first", two:"second", three:"third"}).map(callback);

 */

MobileCommentJindo.$H.prototype.map = function(callback, thisObject) {
	//-@@$H.map-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4fun' : [ 'callback:Function+'],
		'4obj' : [ 'callback:Function+', "thisObject:Variant"]
	},"$H#map");
	var h = MobileCommentJindo.$H();
	var t = this._table;
	var hCon = this.constructor;

	for(var k in t) {
		if (t.hasOwnProperty(k)) {
			if (!t.propertyIsEnumerable(k)) continue;
			try {
				h.add(k,callback.call(thisObject, t[k], k, t));
			} catch(e) {
				if (e instanceof hCon.Break) break;
				if (e instanceof hCon.Continue){
					h.add(k,t[k]);
				}else{
					throw e;
				}
			}
		}
	}

	return h;
};
//-!MobileCommentJindo.$H.prototype.map end!-//

//-!MobileCommentJindo.$H.prototype.add start!-//
/**

 * @description add() 메서드는 해시에 값을 추가한다. 파라미터로 값을 추가할 키를 지정한다. 지정한 키에 이미 값이 있다면 지정한 값으로 변경한다.
 * @param {String+|Numeric} sKey 값을 추가하거나 변경할 키.
 * @param {Variant} vValue 해당 키에 추가할 값.
 * @return {$H} 값을 추가한 해시 객체.
 * @see $H#remove
 * @example
 var woH = $H();
// 키가 'foo'이고 값이 'bar'인 원소를 추가
woH.add('foo', 'bar');

// 키가 'foo'인 원소의 값을 'bar2'로 변경
woH.add('foo', 'bar2');

 */
MobileCommentJindo.$H.prototype.add = function(key, value) {
	//-@@$H.add-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str' : [ 'key:String+',"value:Variant"],
		'4num' : [ 'key:Numeric',"value:Variant"]
	},"$H#add");
	this._table[key] = value;

	return this;
};
//-!MobileCommentJindo.$H.prototype.add end!-//

//-!MobileCommentJindo.$H.prototype.remove start!-//
/**

 * @description remove() 메서드는 지정한 키의 원소를 제거한다. 해당하는 원소가 없으면 아무 일도 수행하지 않는다.
 * @param {String+|Numeric} sKey 제거할 원소의 키.
 * @return {Variant} 제거한 값.
 * @see $H#add
 * @example
var h = $H({one:"first", two:"second", three:"third"});
h.remove ("two");
// h의 해시 테이블은 {one:"first", three:"third"}

 */
MobileCommentJindo.$H.prototype.remove = function(key) {
	//-@@$H.remove-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str' : [ 'key:String+'],
		'4num' : [ 'key:Numeric']
	},"$H#remove");

	if (this._table[key] === undefined) return null;
	var val = this._table[key];
	delete this._table[key];

	return val;
};
//-!MobileCommentJindo.$H.prototype.remove end!-//

//-!MobileCommentJindo.$H.prototype.search start!-//
/**

 * @description search() 메서드는 해시에서 파라미터로 지정한 값을 가지는 원소의 키를 반환한다.
 * @param {Variant} sValue 검색할 값.
 * @return {Variant} 해당 값을 가지고 있는 원소의 키(String). 지정한 값을 가진 원소가 없다면 false를 반환한다.
 * @example
var h = $H({one:"first", two:"second", three:"third"});
h.search ("second");
// two

h.search ("fist");
// false

 */
MobileCommentJindo.$H.prototype.search = function(value) {
	//-@@$H.search-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str' : [ 'value:Variant']
	},"$H#search");
	var result = false;
	var t = this._table;

	for(var k in t) {
		if (t.hasOwnProperty(k)) {
			if (!t.propertyIsEnumerable(k)) continue;
			var v = t[k];
			if (v === value) {
				result = k;
				break;
			}
		}
	}

	return result;
};
//-!MobileCommentJindo.$H.prototype.search end!-//

//-!MobileCommentJindo.$H.prototype.hasKey start!-//
/**

 * @description hasKey() 메서드는 해시에 파라미터로 입력한 키가 있는지 확인한다.
 * @param {String+|Numeric} sKey 검색할 키.
 * @return {Boolean} 키의 존재 여부. 존재하면 true 없으면 false를 반환한다.
 * @example
var h = $H({one:"first", two:"second", three:"third"});
h.hasKey("four"); // false
h.hasKey("one"); // true

 */
MobileCommentJindo.$H.prototype.hasKey = function(key) {
	//-@@$H.hasKey-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str' : [ 'key:String+'],
		'4num' : [ 'key:Numeric']
	},"$H#hasKey");
	return this._table[key] !== undefined;
};
//-!MobileCommentJindo.$H.prototype.hasKey end!-//

//-!MobileCommentJindo.$H.prototype.hasValue start(MobileCommentJindo.$H.prototype.search)!-//
/**

 * @description hasValue() 메서드는 해시에 파라미터로로 입력한 값이 있는지 확인한다.
 * @param {Variant} vValue 해시에서 검색할 값.
 * @return {Boolean} 값의 존재 여부. 존재하면 true 없으면 false를 반환한다.

 */
MobileCommentJindo.$H.prototype.hasValue = function(value) {
	//-@@$H.hasValue-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str' : [ 'value:Variant']
	},"$H#hasValue");
	return (this.search(value) !== false);
};
//-!MobileCommentJindo.$H.prototype.hasValue end!-//

//-!MobileCommentJindo.$H.prototype.sort start(MobileCommentJindo.$H.prototype.search)!-//
/**

 * @description sort() 메서드는 값을 기준으로 해시의 원소를 오름차순 정렬한다.
 * @return {$H} 원소를 정렬한 해시 객체.
 * @see $H#ksort
 * @example
var h = $H({one:"하나", two:"둘", three:"셋"});
h.sort ();
// {two:"둘", three:"셋", one:"하나"}

 */
MobileCommentJindo.$H.prototype.sort = function() {
	//-@@$H.sort-@@//
	var o = new Object;
	var a = [];
	for(var k in this._table) {
		if(this._table.hasOwnProperty(k))
			a[a.length] = this._table[k];
	}
	var k = false;

	a.sort();

	for(var i=0; i < a.length; i++) {
		k = this.search(a[i]);

		o[k] = a[i];
		delete this._table[k];
	}

	this._table = o;

	return this;
};
//-!MobileCommentJindo.$H.prototype.sort end!-//

//-!MobileCommentJindo.$H.prototype.ksort start(MobileCommentJindo.$H.prototype.keys)!-//
/**

 * @description ksort() 메서드는 키를 기준으로 해시의 원소를 오름차순 정렬한다.
 * @return {$H} 원소를 정렬한 해시 객체.
 * @see $H#sort
 * @example
var h = $H({one:"하나", two:"둘", three:"셋"});
h.sort ();
// h => {one:"하나", three:"셋", two:"둘"}

 */
MobileCommentJindo.$H.prototype.ksort = function() {
	//-@@$H.ksort-@@//
	var o = new Object;
	var a = this.keys();

	a.sort();

	for(var i=0; i < a.length; i++) {
		o[a[i]] = this._table[a[i]];
	}

	this._table = o;

	return this;
};
//-!MobileCommentJindo.$H.prototype.ksort end!-//

//-!MobileCommentJindo.$H.prototype.keys start!-//
/**

 * @description keys() 메서드는 해시의 키를 배열로 반환한다.
 * @return {Array} 해시 키의 배열.
 * @see $H#values
 * @example
var h = $H({one:"first", two:"second", three:"third"});
h.keys ();
// ["one", "two", "three"]

 */
MobileCommentJindo.$H.prototype.keys = function() {
	//-@@$H.keys-@@//
	var keys = new Array;
	for(var k in this._table) {
		if(this._table.hasOwnProperty(k))
			keys.push(k);
	}

	return keys;
};
//-!MobileCommentJindo.$H.prototype.keys end!-//

//-!MobileCommentJindo.$H.prototype.values start!-//
/**

 * @description values() 메서드는 해시의 값을 배열로 반환한다.
 * @return {Array} 해시 값의 배열.
 * @example
var h = $H({one:"first", two:"second", three:"third"});
h.values();
// ["first", "second", "third"]

 */
MobileCommentJindo.$H.prototype.values = function() {
	//-@@$H.values-@@//
	var values = [];
	for(var k in this._table) {
		if(this._table.hasOwnProperty(k))
			values[values.length] = this._table[k];
	}

	return values;
};
//-!MobileCommentJindo.$H.prototype.values end!-//

//-!MobileCommentJindo.$H.prototype.toQueryString start!-//
/**

 * @description toQueryString은 해시를 쿼리 스트링(Query String) 형태로 만든다.
 * @return {String} 해시를 변환한 쿼리 스트링.
 * @see <a href="http://en.wikipedia.org/wiki/Querystring">Query String</a> - Wikipedia
 * @example
var h = $H({one:"first", two:"second", three:"third"});
h.toQueryString();
// "one=first&two=second&three=third"

 */
MobileCommentJindo.$H.prototype.toQueryString = function() {
	//-@@$H.toQueryString-@@//
	var buf = [], val = null, idx = 0;
	for(var k in this._table) {
		if (this._table.hasOwnProperty(k)) {
			val = this._table[k];
			if (MobileCommentJindo.$Jindo.isArray(val)) {
				for(i=0; i < val.length; i++) {
					buf[buf.length] = encodeURIComponent(k)+"[]="+encodeURIComponent(val[i]+"");
				}
			} else {
				buf[buf.length] = encodeURIComponent(k)+"="+encodeURIComponent(this._table[k]+"");
			}
		}
	}

	return buf.join("&");
};
//-!MobileCommentJindo.$H.prototype.toQueryString end!-//

//-!MobileCommentJindo.$H.prototype.empty start!-//
/**

 * @description empty() 메서드는 해시를 비운다.
 * @return {$H} 비워진 $H() 객체.
 * @example
var hash = $H({a:1, b:2, c:3});
// hash => {a:1, b:2, c:3}

hash.empty();
// hash => {}

 */
MobileCommentJindo.$H.prototype.empty = function() {
	//-@@$H.empty-@@//
	this._table = {};

	return this;
};
//-!MobileCommentJindo.$H.prototype.empty end!-//

//-!MobileCommentJindo.$H.Break start!-//
/**

 * @description Break() 메서드는 forEach(), filter(), map() 메서드의 루프를 중단한다. 내부적으로는 강제로 예외를 발생시키는 구조이므로, try - catch 영역에서 이 메서드를 실행하면 정상적으로 동작하지 않을 수 있다.
 * @see $H.Continue
 * @see $H#forEach
 * @see $H#filter
 * @see $H#map
 * @see $H.Continue
 * @example
$H({a:1, b:2, c:3}).forEach(function(v,k,o) {
   ...
   if (k == "b") $H.Break();
   ...
});

 */
MobileCommentJindo.$H.Break = MobileCommentJindo.$Jindo.Break;
//-!MobileCommentJindo.$H.Break end!-//

//-!MobileCommentJindo.$H.Continue start!-//
/**

 * @description Continue() 메서드는 forEach(), filter(), map() 메서드의 루프에서 나머지 명령을 실행하지 않고 다음 루프로 건너뛴다. 내부적으로는 강제로 예외를 발생시키는 구조이므로, try - catch 영역에서 이 메서드를 실행하면 정상적으로 동작하지 않을 수 있다.
 * @see $H.Break
 * @see $H#forEach
 * @see $H#filter
 * @see $H#map
 * @see $H.Break
 * @example
$H({a:1, b:2, c:3}).forEach(function(v,k,o) {
   ...
   if (v % 2 == 0) $H.Continue();
   ...
});

 */
MobileCommentJindo.$H.Continue  = MobileCommentJindo.$Jindo.Continue;
//-!MobileCommentJindo.$H.Continue end!-//



/**

 * @fileOverview $Json의 생성자 및 메서드를 정의한 파일
 * @name json.js
 * @author AjaxUI lab

 */

//-!MobileCommentJindo.$Json start(MobileCommentJindo.$Json._oldMakeJSON)!-//
/**

 * @class $Json 객체는 JSON(JavaScript Object Notation)을 다루기 위한 다양한 기능을 제공한다. 생성자에 파라미터로 객체나 문자열을 입력한다. XML 형태의 문자열로 $Json() 객체를 생성하려면 fromXML() 메서드를 사용한다.
 * @constructor
 * @description $Json() 객체를 생성한다.
 * @param {Varaint} 다양한 타입
 * @return {$Json} 인수를 인코딩한 $Json() 객체.
 * @see $Json#fromXML
 * @see <a href="http://www.json.org/json-ko.html">json.org</a>
 * @example
var oStr = $Json ('{ zoo: "myFirstZoo", tiger: 3, zebra: 2}');

var d = {name : 'nhn', location: 'Bundang-gu'}
var oObj = $Json (d);

 */

MobileCommentJindo.$Json = function (sObject) {
	//-@@$Json-@@//
	var cl = arguments.callee;
	if (sObject instanceof cl) return sObject;

	if (!(this instanceof cl)){
		try {
			MobileCommentJindo.$Jindo._warn(arguments.length, 1,"$Json");
			return new cl(arguments.length?sObject:{});
		} catch(e) {
			if (e instanceof TypeError) { return null; }
			throw e;
		}
	}

	MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4var' : ['oObject:Variant']
	},"$Json");
	this._object = sObject;
};
//-!MobileCommentJindo.$Json end!-//
/*

native json의 parse의 성능이 보다 좋지 못해 native json은 사용하지 않음.

MobileCommentJindo.$Json._makeJson = function(sObject){
	if (window.JSON&&window.JSON.parse) {
		MobileCommentJindo.$Json._makeJson = function(sObject){
			if (typeof sObject == "string") {
				try{
					return JSON.parse(sObject);
				}catch(e){
					return MobileCommentJindo.$Json._oldMakeJSON(sObject);
				}
			}
			return sObject;
		}
	}else{
		MobileCommentJindo.$Json._makeJson = function(sObject){
			if (typeof sObject == "string") {
				return MobileCommentJindo.$Json._oldMakeJSON(sObject);
			}
			return sObject;
		}
	}
	return MobileCommentJindo.$Json._makeJson(sObject);
};
*/
//-!MobileCommentJindo.$Json._oldMakeJSON.hidden start!-//
MobileCommentJindo.$Json._oldMakeJSON = function(sObject,sType){
	try {
		if(MobileCommentJindo.$Jindo.isString(sObject)&&/^(?:\s*)[\{\[]/.test(sObject)){
			sObject = eval("("+sObject+")");
		}else{
			return sObject;
		}
	} catch(e) {
		throw new MobileCommentJindo.$Error(MobileCommentJindo.$Except.PARSE_ERROR,sType);
	}
	return sObject;
};
//-!MobileCommentJindo.$Json._oldMakeJSON.hidden end!-//

//-!MobileCommentJindo.$Json.fromXML start!-//
/**

 * @description fromXML() 메서드는 XML 형태의 문자열을 $Json() 객체로 인코딩한다. XML 형식의 문자열에 XML 요소가 속성을 포함하고 있을 경우 해당 요소의 정보에 해당하는 내용을 하위 객체로 표현한다. 이때 요소가 CDATA 값을 가질 경우 $cdata 속성으로 값을 저장한다.
 * @param {String+} sXML XML 형태의 문자열.
 * @return {$Json} $Json() 객체.
 * @throws {MobileCommentJindo.$Except.PARSE_ERROR} json객체를 파싱하다가 에러발생할 때.
 * @example
var j1 = $Json.fromXML('<data>only string</data>');

// 결과 :
// {"data":"only string"}

var j2 = $Json.fromXML('<data><id>Faqh%$</id><str attr="123">string value</str></data>');

// 결과:
// {"data":{"id":"Faqh%$","str":{"attr":"123","$cdata":"string value"}}}

  */
MobileCommentJindo.$Json.fromXML = function(sXML) {
	//-@@$Json.fromXML-@@//
	var ___jindo = MobileCommentJindo.$Jindo;
	var oArgs = ___jindo.checkVarType(arguments, {
		'4str' : ['sXML:String+']
	},"<static> $Json#fromXML");
	var o  = {};
	var re = /\s*<(\/?[\w:\-]+)((?:\s+[\w:\-]+\s*=\s*(?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'))*)\s*((?:\/>)|(?:><\/\1>|\s*))|\s*<!\[CDATA\[([\w\W]*?)\]\]>\s*|\s*>?([^<]*)/ig;
	var re2= /^[0-9]+(?:\.[0-9]+)?$/;
	var ec = {"&amp;":"&","&nbsp;":" ","&quot;":"\"","&lt;":"<","&gt;":">"};
	var fg = {tags:["/"],stack:[o]};
	var es = function(s){
		if (___jindo.isUndefined(s)) return "";
		return  s.replace(/&[a-z]+;/g, function(m){ return (___jindo.isString(ec[m]))?ec[m]:m; })
	};
	var at = function(s,c){s.replace(/([\w\:\-]+)\s*=\s*(?:"((?:\\"|[^"])*)"|'((?:\\'|[^'])*)')/g, function($0,$1,$2,$3){c[$1] = es(($2?$2.replace(/\\"/g,'"'):undefined)||($3?$3.replace(/\\'/g,"'"):undefined));}) };
	var em = function(o){
		for(var x in o){
			if (o.hasOwnProperty(x)) {
				if(Object.prototype[x])
					continue;
					return false;
			}
		};
		return true
	};
	/*

$0 : 전체
$1 : 태그명
$2 : 속성문자열
$3 : 닫는태그
$4 : CDATA바디값
$5 : 그냥 바디값

	 */

	var cb = function($0,$1,$2,$3,$4,$5) {
		var cur, cdata = "";
		var idx = fg.stack.length - 1;

		if (___jindo.isString($1)&& $1) {
			if ($1.substr(0,1) != "/") {
				var has_attr = (typeof $2 == "string" && $2);
				var closed   = (typeof $3 == "string" && $3);
				var newobj   = (!has_attr && closed)?"":{};

				cur = fg.stack[idx];

				if (___jindo.isUndefined(cur[$1])) {
					cur[$1] = newobj;
					cur = fg.stack[idx+1] = cur[$1];
				} else if (cur[$1] instanceof Array) {
					var len = cur[$1].length;
					cur[$1][len] = newobj;
					cur = fg.stack[idx+1] = cur[$1][len];
				} else {
					cur[$1] = [cur[$1], newobj];
					cur = fg.stack[idx+1] = cur[$1][1];
				}

				if (has_attr) at($2,cur);

				fg.tags[idx+1] = $1;

				if (closed) {
					fg.tags.length--;
					fg.stack.length--;
				}
			} else {
				fg.tags.length--;
				fg.stack.length--;
			}
		} else if (___jindo.isString($4) && $4) {
			cdata = $4;
		} else if (___jindo.isString($5) && $5) {
			cdata = es($5);
		}

		if (cdata.replace(/^\s+/g, "").length > 0) {
			var par = fg.stack[idx-1];
			var tag = fg.tags[idx];

			if (re2.test(cdata)) {
				cdata = parseFloat(cdata,10);
			}else if (cdata == "true"){
				cdata = true;
			}else if(cdata == "false"){
				cdata = false;
			}

			if(___jindo.isUndefined(par)) return;

			if (par[tag] instanceof Array) {
				var o = par[tag];
				if (___jindo.isHash(o[o.length-1]) && !em(o[o.length-1])) {
					o[o.length-1].$cdata = cdata;
					o[o.length-1].toString = function(){ return cdata; }
				} else {
					o[o.length-1] = cdata;
				}
			} else {
				if (___jindo.isHash(par[tag])&& !em(par[tag])) {
					par[tag].$cdata = cdata;
					par[tag].toString = function(){ return cdata; }
				} else {
					par[tag] = cdata;
				}
			}
		}
	};

	sXML = sXML.replace(/<(\?|\!-)[^>]*>/g, "");
	sXML.replace(re, cb);

	return MobileCommentJindo.$Json(o);
};
//-!MobileCommentJindo.$Json.fromXML end!-//

//-!MobileCommentJindo.$Json.prototype.get start!-//
/**

 * @description get() 메서드는 특정 경로(path)에 해당하는 $Json() 객체의 값을 반환한다.
 * @param {String+} sPath 경로를 지정한 문자열
 * @return {Array} 지정된 경로에 해당하는 값을 원소로 가지는 배열.
 * @throws {MobileCommentJindo.$Except.PARSE_ERROR} json객체를 파싱하다가 에러발생할 때.
 * @example
var j = $Json.fromXML('<data><id>Faqh%$</id><str attr="123">string value</str></data>');
var r = j.get ("/data/id");

// 결과 :
// [Faqh%$]

 */
MobileCommentJindo.$Json.prototype.get = function(sPath) {
	//-@@$Json.get-@@//
	var ___jindo = MobileCommentJindo.$Jindo;
	var oArgs = ___jindo.checkVarType(arguments, {
		'4str' : ['sPath:String+']
	},"$Json#get");
	var o = MobileCommentJindo.$Json._oldMakeJSON(this._object,"$Json#get");
	if(!(___jindo.isHash(o)||___jindo.isArray(o))){
		throw new MobileCommentJindo.$Error(MobileCommentJindo.$Except.JSON_MUST_HAVE_ARRAY_HASH,"$Json#get");
	}
	var p = sPath.split("/");
	var re = /^([\w:\-]+)\[([0-9]+)\]$/;
	var stack = [[o]], cur = stack[0];
	var len = p.length, c_len, idx, buf, j, e;

	for(var i=0; i < len; i++) {
		if (p[i] == "." || p[i] == "") continue;
		if (p[i] == "..") {
			stack.length--;
		} else {
			buf = [];
			idx = -1;
			c_len = cur.length;

			if (c_len == 0) return [];
			if (re.test(p[i])) idx = +RegExp.$2;

			for(j=0; j < c_len; j++) {
				e = cur[j][p[i]];
				if (___jindo.isUndefined(e)) continue;
				if (___jindo.isArray(e)) {
					if (idx > -1) {
						if (idx < e.length) buf[buf.length] = e[idx];
					} else {
						buf = buf.concat(e);
					}
				} else if (idx == -1) {
					buf[buf.length] = e;
				}
			}

			stack[stack.length] = buf;
		}

		cur = stack[stack.length-1];
	}

	return cur;
};
//-!MobileCommentJindo.$Json.prototype.get end!-//

//-!MobileCommentJindo.$Json.prototype.toString start(MobileCommentJindo.$Json._oldToString)!-//
/**

 * @function
 * @description toString() 메서드는 $Json() 객체를 JSON 문자열 형태로 반환한다.
 * @return {String} JSON 문자열.
 * @see $Json#toObject
 * @see $Json#toXML
 * @see <a href="http://www.json.org/json-ko.html">json.org</a>
 * @example
var j = $Json({foo:1, bar: 31});
document.write (j.toString());
document.write (j);

// 결과 :
// {"bar":31,"foo":1}{"bar":31,"foo":1}

 */
MobileCommentJindo.$Json.prototype.toString = function() {
	//-@@$Json.toString-@@//
	// if (window.JSON&&window.JSON.stringify&&window.JSON.stringify(/!/)) {
		// MobileCommentJindo.$Json.prototype.toString = function() {
			// try{
				// return (window.JSON.stringify(this._object)).substr(0);
			// }catch(e){
				// return MobileCommentJindo.$Json._oldToString(this._object);
			// }
		// }
	// }else{
		MobileCommentJindo.$Json.prototype.toString = function() {
			return MobileCommentJindo.$Json._oldToString(this._object);
		}
	// }

	return this.toString();
};
//-!MobileCommentJindo.$Json.prototype.toString end!-//

//-!MobileCommentJindo.$Json._oldToString.hidden start(MobileCommentJindo.$H.prototype.ksort)!-//
MobileCommentJindo.$Json._oldToString = function(oObj){
	var ___jindo = MobileCommentJindo.$Jindo;
	var func = {
		$ : function($) {
			if (___jindo.isNull($)||$==Infinity) return "null";
			if (___jindo.isFunction($)) return undefined;
			if (___jindo.isUndefined($)) return undefined;
			if (___jindo.isBoolean($)) return $?"true":"false";
			if (___jindo.isString($)) return this.s($);
			if (___jindo.isNumeric($)) return $;
			if (___jindo.isArray($)) return this.a($);
			if (___jindo.isHash($)) return this.o($);
			if (typeof $ == "object"||___jindo.isRegExp($)) return "{}";
			if (isNaN($)) return "null";
		},
		s : function(s) {
			var e = {'"':'\\"',"\\":"\\\\","\n":"\\n","\r":"\\r","\t":"\\t"};
			var c = function(m){ return (e[m] !== undefined)?e[m]:m };
			return '"'+s.replace(/[\\"'\n\r\t]/g, c)+'"';
		},
		a : function(a) {
			// a = a.sort();
			var s = "[",c = "",n=a.length;
			for(var i=0; i < n; i++) {
				if (___jindo.isFunction(a[i])) continue;
				s += c+this.$(a[i]);
				if (!c) c = ",";
			}
			return s+"]";
		},
		o : function(o) {
			o = MobileCommentJindo.$H(o).ksort().$value();
			var s = "{",c = "";
			for(var x in o) {
				if (o.hasOwnProperty(x)) {
					if (___jindo.isUndefined(o[x])||___jindo.isFunction(o[x])) continue;
					s += c+this.s(x)+":"+this.$(o[x]);
					if (!c) c = ",";
				}
			}
			return s+"}";
		}
	}

	return func.$(oObj);
};
//-!MobileCommentJindo.$Json._oldToString.hidden end!-//

//-!MobileCommentJindo.$Json.prototype.toXML start!-//
/**

 * @description toXML() 메서드는 $Json() 객체를 XML 형태의 문자열로 반환한다.
 * @return {String} XML 형태의 문자열.
 * @throws {MobileCommentJindo.$Except.PARSE_ERROR} json객체를 파싱하다가 에러발생할 때.
 * @see $Json#toObject
 * @see $Json#toString
 * @example
var json = $Json({foo:1, bar: 31});
json.toXML();

// 결과 :
// <foo>1</foo><bar>31</bar>

 */
MobileCommentJindo.$Json.prototype.toXML = function() {
	//-@@$Json.toXML-@@//
	var f = function($,tag) {
		var t = function(s,at) { return "<"+tag+(at||"")+">"+s+"</"+tag+">" };

		switch (typeof $) {
			case 'undefined':
			case "null":
				return t("");
			case "number":
				return t($);
			case "string":
				if ($.indexOf("<") < 0){
					 return t($.replace(/&/g,"&amp;"));
				}else{
					return t("<![CDATA["+$+"]]>");
				}
			case "boolean":
				return t(String($));
			case "object":
				var ret = "";
				if ($ instanceof Array) {
					var len = $.length;
					for(var i=0; i < len; i++) { ret += f($[i],tag); };
				} else {
					var at = "";

					for(var x in $) {
						if ($.hasOwnProperty(x)) {
							if (x == "$cdata" || typeof $[x] == "function") continue;
							ret += f($[x], x);
						}
					}

					if (tag) ret = t(ret, at);
				}
				return ret;
		}
	};

	return f(MobileCommentJindo.$Json._oldMakeJSON(this._object,"$Json#toXML"), "");
};
//-!MobileCommentJindo.$Json.prototype.toXML end!-//

//-!MobileCommentJindo.$Json.prototype.toObject start!-//
/**

 * @description toObject() 메서드는 $Json() 객체를 원래의 데이터 객체로 반환한다.
 * @return {Object} 원본 데이터 객체.
 * @throws {MobileCommentJindo.$Except.PARSE_ERROR} json객체를 파싱하다가 에러발생할 때.
 * @see $Json#toObject
 * @see $Json#toString
 * @see $Json#toXML
 * @example
var json = $Json({foo:1, bar: 31});
json.toObject();

// 결과 :
// {foo: 1, bar: 31}

 */
MobileCommentJindo.$Json.prototype.toObject = function() {
	//-@@$Json.toObject-@@//
	//-@@$Json.$value-@@//
	return MobileCommentJindo.$Json._oldMakeJSON(this._object,"$Json#toObject");
};
//-!MobileCommentJindo.$Json.prototype.toObject end!-//

//-!MobileCommentJindo.$Json.prototype.compare start(MobileCommentJindo.$Json._oldToString,MobileCommentJindo.$Json.prototype.toObject,MobileCommentJindo.$Json.prototype.toString)!-//
/**

 * @description compare() 메서드는 Json 객체끼리 값이 같은지 비교한다.
 * @param {Varaint} oData 비교할 Json 포맷 객체.
 * @return {Boolean} 비교 결과. 값이 같으면 true, 다르면 false를 반환한다.
 * @throws {MobileCommentJindo.$Except.PARSE_ERROR} json객체를 파싱하다가 에러발생할 때.
 * @since  1.4.4
 * @example
$Json({foo:1, bar: 31}).compare({foo:1, bar: 31});

// 결과 :
// true

$Json({foo:1, bar: 31}).compare({foo:1, bar: 1});

// 결과 :
// false

 */
MobileCommentJindo.$Json.prototype.compare = function(oObj){
	//-@@$Json.compare-@@//
	var ___jindo = MobileCommentJindo.$Jindo;
	var oArgs = ___jindo.checkVarType(arguments, {
		'4obj' : ['oData:Hash+'],
		'4arr' : ['oData:Array+']
	},"$Json#compare");
	function compare(vSrc, vTar) {
		if (___jindo.isArray(vSrc)) {
			if (vSrc.length !== vTar.length) { return false; }
			for (var i = 0, nLen = vSrc.length; i < nLen; i++) {
				if (!arguments.callee(vSrc[i], vTar[i])) { return false; }
			}
			return true;
		} else if (___jindo.isRegExp(vSrc) || ___jindo.isFunction(vSrc) || ___jindo.isDate(vSrc)) { // toString 으로 비교할 것들
			return String(vSrc) === String(vTar);
		} else if (typeof vSrc === "number" && isNaN(vSrc)) {
			return isNaN(vTar);
		} else if (___jindo.isHash(vSrc)) {
			var nLen = 0;
			for (var k in vSrc) {nLen++; }
			for (var k in vTar) { nLen--; }
			if (nLen !== 0) { return false; }

			for (var k in vSrc) {
				if (k in vTar === false || !arguments.callee(vSrc[k], vTar[k])) { return false; }
			}

			return true
		}

		// === 로 비교할 것들
		return vSrc === vTar;

	}
	try{
		return compare(MobileCommentJindo.$Json._oldMakeJSON(this._object,"$Json#compare"), oObj);
	}catch(e){
		return false;
	}


//	return MobileCommentJindo.$Json._oldToString(this._object).toString() == MobileCommentJindo.$Json._oldToString(MobileCommentJindo.$Json(oData).toObject()).toString();
};
//-!MobileCommentJindo.$Json.prototype.compare end!-//

//-!MobileCommentJindo.$Json.prototype.$value start(MobileCommentJindo.$Json.prototype.toObject)!-//
/**

 * @description $value() 메서드는 toObject() 메서드와 같이 원래의 데이터 객체를 반환한다.
 * @return {Object} 원본 데이터 객체.
 * @see $Json#toObject

 */
MobileCommentJindo.$Json.prototype.$value = MobileCommentJindo.$Json.prototype.toObject;
//-!MobileCommentJindo.$Json.prototype.$value end!-//




/**

 * @fileOverview $Cookie의 생성자 및 메서드를 정의한 파일
 * @name cookie.js
 * @author  AjaxUI lab

 */

//-!MobileCommentJindo.$Cookie start!-//
/**

 * @class $Cookie() 객체는 쿠키(Cookie)에 정보를 추가, 수정, 혹은 삭제하거나 쿠키의 값을 가져온다.
 * @constructor
 * @description $Cookie() 객체를 생성한다.
 * @example
var cookie = $Cookie();

 */
MobileCommentJindo.$Cookie = function() {
	//-@@$Cookie-@@//
	var cl = arguments.callee;
	var cached = cl._cached;

	if (cl._cached) return cl._cached;
	if (!(this instanceof cl)) return new cl;
	if (typeof MobileCommentJindo.$Jindo.isUndefined(cl._cached)) cl._cached = this;
};
//-!MobileCommentJindo.$Cookie end!-//

//-!MobileCommentJindo.$Cookie.prototype.keys start!-//
/**

 * @description keys() 메서드는 쿠키 키(key)를 원소로 가지는 배열을 리턴한다.
 * @return {Array} 쿠키의 키를 원소로 가지는 배열
 * @see $Cookie#set
 * @example
var cookie = $Cookie();
cookie.set("session_id1", "value1", 1);
cookie.set("session_id2", "value2", 1);
cookie.set("session_id3", "value3", 1);

document.write (cookie.keys ());
// 결과 :
// session_id1, session_id2, session_id3

 */
MobileCommentJindo.$Cookie.prototype.keys = function() {
	//-@@$Cookie.keys-@@//
	var ca = document.cookie.split(";");
	var re = /^\s+|\s+$/g;
	var a  = new Array;

	for(var i=0; i < ca.length; i++) {
		a[a.length] = ca[i].substr(0,ca[i].indexOf("=")).replace(re, "");
	}

	return a;
};
//-!MobileCommentJindo.$Cookie.prototype.keys end!-//

//-!MobileCommentJindo.$Cookie.prototype.get start!-//
/**

 * @description get() 메서드는 쿠키에서 키(key)에 해당하는 값(value)을 가져온다. 값이 존재하지 않는다면 null을 반환한다.
 * @param {String+} sName 키 이름.
 * @return {String} 해당 키의 값.
 * @see $Cookie#set
 * @example
var cookie = $Cookie();
cookie.set("session_id1", "value1", 1);
document.write (cookie.get ("session_id1"));

// 결과 :
// value1

document.write (cookie.get ("session_id0"));
// 결과 :
// null

 */
MobileCommentJindo.$Cookie.prototype.get = function(sName) {
	//-@@$Cookie.get-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str' : [ 'sName:String+']
	},"$Cookie#get");
	var ca = document.cookie.split(/\s*;\s*/);
	var re = new RegExp("^(\\s*"+sName+"\\s*=)");

	for(var i=0; i < ca.length; i++) {
		if (re.test(ca[i])) return unescape(ca[i].substr(RegExp.$1.length));
	}

	return null;
};
//-!MobileCommentJindo.$Cookie.prototype.get end!-//

//-!MobileCommentJindo.$Cookie.prototype.set start!-//
/**

 * @description set() 메서드는 쿠키 값을 설정한다. 쿠키 값을 설정할 때 유효 기간, 유효 도메인, 유효 경로(path)를 함께 설정할 수 있다.
 *
 * @param1 {String+} sName 키의 이름
 * @param1 {String+} sValue 키의 값
 * @return1 {$Cookie} $Cookie() 객체
 *
 * @param2 {String+} sName 키의 이름
 * @param2 {String+} sValue 키의 값
 * @param2 {Numeric} nDays 쿠키 유효 시간. 유효 시간은 일단위로 설정한다. 유효시간을 생략했다면 쿠키는 웹 브라우저가 종료되면 없어진다.
 * @return2 {$Cookie} $Cookie() 객체
 *
 * @param3 {String+} sName 키의 이름
 * @param3 {String+} sValue 키의 값
 * @param3 {Numeric} nDays 쿠키 유효 시간. 유효 시간은 일단위로 설정한다. 유효시간을 생략했다면 쿠키는 웹 브라우저가 종료되면 없어진다.
 * @param3 {String+} sDomain 쿠키 도메인
 * @return3 {$Cookie} $Cookie() 객체
 *
 * @param4 {String+} sName 키의 이름
 * @param4 {String+} sValue 키의 값
 * @param4 {Numeric} nDays 쿠키 유효 시간. 유효 시간은 일단위로 설정한다. 유효시간을 생략했다면 쿠키는 웹 브라우저가 종료되면 없어진다.
 * @param4 {String+} sDomain 쿠키 도메인
 * @param4 {String+} sPath 쿠키 패스
 * @return4 {$Cookie} $Cookie() 객체
 *
 * @see $Cookie#set
 * @example
var cookie = $Cookie();
cookie.set("session_id1", "value1", 1);
cookie.set("session_id2", "value2", 1);
cookie.set("session_id3", "value3", 1);

 */
MobileCommentJindo.$Cookie.prototype.set = function(sName, sValue, nDays, sDomain, sPath) {
	//-@@$Cookie.set-@@//
	var ___jindo = MobileCommentJindo.$Jindo;
	var oArgs = ___jindo.checkVarType(arguments, {
		'4str' : [ 'sName:String+',"sValue:String+"],
		'day_for_string' : [ 'sName:String+',"sValue:String+","nDays:Numeric"],
		'domain_for_string' : [ 'sName:String+',"sValue:String+","nDays:Numeric","sDomain:String+"],
		'path_for_string' : [ 'sName:String+',"sValue:String+","nDays:Numeric","sDomain:String+","sPath:String+"]
	},"$Cookie#set");

	var sExpire = "";

	nDays = parseInt(nDays,10);
	if (!isNaN(nDays)&&___jindo.isNumeric(nDays)) {
		sExpire = ";expires="+(new Date((new Date()).getTime()+nDays*1000*60*60*24)).toGMTString();
	}
	if (___jindo.isUndefined(sDomain)) sDomain = "";
	if (___jindo.isUndefined(sPath)) sPath = "/";

	document.cookie = sName+"="+escape(sValue)+sExpire+"; path="+sPath+(sDomain?"; domain="+sDomain:"");

	return this;
};
//-!MobileCommentJindo.$Cookie.prototype.set end!-//

//-!MobileCommentJindo.$Cookie.prototype.remove start(MobileCommentJindo.$Cookie.prototype.get,MobileCommentJindo.$Cookie.prototype.set)!-//
/**

 * @description remove() 메서드는 쿠키에 설정된 쿠키 값을 제거한다. 만약 제거하려는 값에 유효 도메인과 유효 경로가 설정되어 있다면 정확히 지정해야 한다.
 *
 * @param1 {String+} sName 키 이름.
 * @return1 {$Cookie} $Cookie() 객체.
 *
 * @param2 {String+} sName 키 이름.
 * @param2 {String+} sDomain 설정된 유효 도메인.
 * @return2 {$Cookie} $Cookie() 객체.
 *
 * @param3 {String+} sName 키 이름.
 * @param3 {String+} sDomain 설정된 유효 도메인.
 * @param3 {String+} sPath 설정된 유효 경로.
 * @return3 {$Cookie} $Cookie() 객체.
 *
 * @see $Cookie#get
 * @see $Cookie#set
 * @example
var cookie = $Cookie();
cookie.set("session_id1", "value1", 1);
document.write (cookie.get ("session_id1"));

// 결과 :
// value1

cookie.remove("session_id1");
document.write (cookie.get ("session_id1"));

// 결과 :
// null

 */
MobileCommentJindo.$Cookie.prototype.remove = function(sName, sDomain, sPath) {
	//-@@$Cookie.remove-@@//
	var ___jindo = MobileCommentJindo.$Jindo;
	var oArgs = ___jindo.checkVarType(arguments, {
		'4str' : [ 'sName:String+'],
		'domain_for_string' : [ 'sName:String+',"sDomain:String+"],
		'path_for_string' : [ 'sName:String+',"sDomain:String+","sPath:String+"]
	},"$Cookie#remove");
	var aArg = _toArray(arguments);
	var aPram = [];
	for(var i = 0, l = aArg.length ; i < l ; i++){
		aPram.push(aArg[i]);
		if(i == 0){
			aPram.push("");
			aPram.push(-1);
		}
	}
	if (!___jindo.isNull(this.get(sName))) this.set.apply(this,aPram);

	return this;
};
//-!MobileCommentJindo.$Cookie.prototype.remove end!-//



//-!MobileCommentJindo.$Element start(MobileCommentJindo.$)!-//
/**

  * @fileOverview $Element의 생성자 및 메서드를 정의한 파일
  * @name element.js
  * @author AjaxUI lab

 */

/**

 * @class $Element() 객체는 HTML 요소를 래핑(wrapping)하며, 해당 요소를 좀 더 쉽게 다룰 수 있는 기능을 제공한다.
 * @constructor
 * @description $Element() 객체를 생성한다.
 * @param {Variant} vElement $Element() 객체 생성자는 문자열(String), HTML 요소(Element+|Node|Document+|Window+), 또는 $Element() 객체를 파라미터로 지정할 수 있다.<br>
 <ul>
	<li>파라미터가 문자열이면 두 가지 방식으로 동작한다.
		<ul>
			<li>만일 "&lt;tagName&gt;"과 같은 형식의 문자열이면 tagName을 가지는 객체를 생성한다.</li>
			<li>그 이외의 경우 지정한 문자열을 ID로 갖는 HTML 요소를 사용하여 $Element() 객체를 생성한다.</li>
		</ul>
	</li>
	<li>파라미터가 HTML 요소이면 해당 요소를 래핑하여 $Element() 를 생성한다.</li>
	<li>파라미터가 $Element()이면 전달된 파라미터를 그대로 반환한다.</li>
</ul>
생성자의 파라미터가 undefined 혹은 null인 경우 null을 반환한다.
 * @return {$Element} 생성된 $Element() 객체.
 * @example
var element = $Element($("box"));	// HTML 요소를 파라미터로 지정
var element = $Element("box");		// HTML 요소의 id를 파라미터로 지정
var element = $Element("<DIV>");	// 태그를 파라미터로 지정, DIV 엘리먼트를 생성하여 래핑함

 */
MobileCommentJindo.$Element = function(el) {
	//-@@$Element-@@//
	var cl = arguments.callee;
	if (el && el instanceof cl) return el;

	if (!(this instanceof cl)){
		try {
			MobileCommentJindo.$Jindo._warn(arguments.length, 1,"$Element");
			return new cl(el);
		} catch(e) {
			if (e instanceof TypeError) { return null; }
			throw e;
		}
	}
	var ___jindo = MobileCommentJindo.$Jindo;
	var oArgs = ___jindo.checkVarType(arguments, {
		'4str' : [ 'sID:String+' ],
		'4nod' : [ 'oEle:Node' ],
		'4doc' : [ 'oEle:Document+' ],
		'4win' : [ 'oEle:Window+' ]
	},"$Element");
	switch(oArgs + ""){
		case "4str":
			el = MobileCommentJindo.$(el);
			break;
		default:
			el = oArgs.oEle;
	}

	this._element = el;
	if(this._element != null){
		if(this._element.__jindo__id){
			this._key = this._element.__jindo__id;
		}else{
			this._element.__jindo__id = this._key = _makeRandom();
		}
		var tag = this._element.tagName;
		// tagname
		this.tag = tag !== undefined?tag.toLowerCase():'';
	}else{
		throw new TypeError("{not_found_element}");
	}

};

function _makeRandom(){
	return "e"+ new Date().getTime() + parseInt(Math.random() * 100000000,10);
}

/**

 */
MobileCommentJindo.$Element._eventBind = function(oEle,sEvent,fAroundFunc,bUseCapture){
	if(oEle.addEventListener){
		if(document.documentMode == 9){
			MobileCommentJindo.$Element._eventBind = function(oEle,sEvent,fAroundFunc){
				if(/resize/.test(sEvent) ){
					oEle.attachEvent("on"+sEvent,fAroundFunc);
				}else{
					oEle.addEventListener(sEvent, fAroundFunc, !!bUseCapture);
				}
			}
		}else{
			MobileCommentJindo.$Element._eventBind = function(oEle,sEvent,fAroundFunc,bUseCapture){
				oEle.addEventListener(sEvent, fAroundFunc, !!bUseCapture);
			}
		}
	}else{
		MobileCommentJindo.$Element._eventBind = function(oEle,sEvent,fAroundFunc){
			oEle.attachEvent("on"+sEvent,fAroundFunc);
		}
	}
	MobileCommentJindo.$Element._eventBind(oEle,sEvent,fAroundFunc,bUseCapture);
};

/**

 */
MobileCommentJindo.$Element._unEventBind = function(oEle,sEvent,fAroundFunc){
	if(oEle.removeEventListener){
		if(document.documentMode == 9){
			MobileCommentJindo.$Element._unEventBind = function(oEle,sEvent,fAroundFunc){
				if(/resize/.test(sEvent) ){
					oEle.detachEvent("on"+sEvent,fAroundFunc);
				}else{
					oEle.removeEventListener(sEvent,fAroundFunc,false);
				}
			}
		}else{
			MobileCommentJindo.$Element._unEventBind = function(oEle,sEvent,fAroundFunc){
				oEle.removeEventListener(sEvent,fAroundFunc,false);
			}
		}
	}else{
		MobileCommentJindo.$Element._unEventBind = function(oEle,sEvent,fAroundFunc){
			oEle.detachEvent("on"+sEvent,fAroundFunc);
		}
	}
	MobileCommentJindo.$Element._unEventBind(oEle,sEvent,fAroundFunc);
};
//-!MobileCommentJindo.$Element end!-//





//-!MobileCommentJindo.$Element.prototype.$value start!-//
/**

 * @description $value() 메서드는 원래의 HTML 요소를 반환한다.
 * @return {Element} $Element() 객체가 감싸고 있는 원본 요소.
 * @see $Element
 * @example
var element = $Element("sample_div");
element.$value(); // 원래의 엘리먼트가 반환된다

 */
MobileCommentJindo.$Element.prototype.$value = function() {
	//-@@$Element.$value-@@//
	return this._element;
};
//-!MobileCommentJindo.$Element.prototype.$value end!-//

//-!MobileCommentJindo.$Element.prototype.visible start(MobileCommentJindo.$Element.prototype._getCss,MobileCommentJindo.$Element.prototype.show,MobileCommentJindo.$Element.prototype.hide)!-//
/**

 * @description visible() 메서드는 HTML 요소의 display 속성을 확인하거나 display 속성을 설정하기 위해 사용한다. 파라미터를 생략하면 해당 요소의 display 속성을 확인하여 표시 여부를 Boolean 형태로 반환한다. display 속성이 none이면 false 값을 반환한다. 파라미터를 입력한 경우 display 속성에 대해 추가적인 설정이 가능하다.
 *
 * @param1 {Void}
 * @return1 {Boolean} display 여부
 *
 * @param2 {Boolean} bVisible 해당 요소의 표시 여부.<br>입력한 파라미터가 true인 경우 display 속성을 설정하고 false인 경우에는 display 속성을 none으로 변경한다. boolean이 아닌 값이 들어온 경우는 ToBoolean한 결과를 가지고 비교한다.
 * @return2 {$Element} display 속성을 변경한 $Element() 객체
 *
 * @param3 {Boolean} bVisible 해당 요소의 표시 여부.<br>입력한 파라미터가 true인 경우 display 속성을 설정하고 false인 경우에는 display 속성을 none으로 변경한다. boolean이 아닌 값이 들어온 경우는 ToBoolean한 결과를 가지고 비교한다.
 * @param3 {String+} sDisplay 해당 요소의 display 속성 값.<br>bVisible 파라미터가 true 이면 sDisplay 값을 display 속성으로 설정한다.
 * @return3 {$Element} display 속성을 변경한 $Element() 객체
 *
 * @since 1.1.2부터 bVisible 파라미터를 사용할 수 있다.
 * @since 1.4.5부터 sDisplay 파라미터를 사용할 수 있다.
 * @see <a href="http://www.w3.org/TR/2008/REC-CSS2-20080411/visuren.html#display-prop">display 속성</a> - W3C CSS2 Specification
 * @see $Element#show
 * @see $Element#hide
 * @see $Element#toggle
 * @example
<div id="sample_div" style="display:none">Hello world</div>

// 조회
$Element("sample_div").visible(); // false

 * @example
// 화면에 보이도록 설정
$Element("sample_div").visible(true, 'block');

//Before
<div id="sample_div" style="display:none">Hello world</div>

//After
<div id="sample_div" style="display:block">Hello world</div>

 */
MobileCommentJindo.$Element.prototype.visible = function(bVisible, sDisplay) {
	//-@@$Element.visible-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'g' : [  ],
		's4bln' : [ MobileCommentJindo.$Jindo._F('bVisible:Boolean') ],
		's4str' : [ 'bVisible:Boolean', "sDisplay:String+"]
	},"$Element#visible");
	switch(oArgs+""){
		case "g":
			return (this._getCss(this._element,"display") != "none");

		case "s4bln":
			this[bVisible?"show":"hide"]();
			return this;

		case "s4str":
			this[bVisible?"show":"hide"](sDisplay);
			return this;

	}
};
//-!MobileCommentJindo.$Element.prototype.visible end!-//

//-!MobileCommentJindo.$Element.prototype.show start!-//
/**

 * @description show() 메서드는 HTML 요소가 화면에 보이도록 display 속성을 변경한다.
 *
 * @param1 {Void}
 * @return1 {$Element} display 속성이 변경된 $Element() 객체.
 *
 * @param2 {String+} sDisplay display 속성에 지정할 값.<br>파라미터를 생략하면 태그별로 미리 지정된 기본 값이 속성 값으로 설정된다. 미리 지정된 기본 값이 없으면 "inline"으로 설정된다. 에러가 발생한 경우는 block으로 설정된다.
 * @return2 {$Element} display 속성이 변경된 $Element() 객체.
 *
 * @since 1.4.5부터 sDisplay 파라미터를 사용할 수 있다.
 * @see <a href="http://www.w3.org/TR/2008/REC-CSS2-20080411/visuren.html#display-prop">display 속성</a> - W3C CSS2 Specification
 * @see $Element#hide
 * @see $Element#toggle
 * @see $Element#visible
 * @example
// 화면에 보이도록 설정
$Element("sample_div").show();

//Before
<div id="sample_div" style="display:none">Hello world</div>

//After
<div id="sample_div" style="display:block">Hello world</div>

 */
MobileCommentJindo.$Element.prototype.show = function(sDisplay) {
	//-@@$Element.show-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4voi' : [  ],
		'4str' : ["sDisplay:String+"]
	},"$Element#show");


	var s = this._element.style;
	var b = "block";
	var c = { p:b,div:b,form:b,h1:b,h2:b,h3:b,h4:b,ol:b,ul:b,fieldset:b,td:"table-cell",th:"table-cell",
			  li:"list-item",table:"table",thead:"table-header-group",tbody:"table-row-group",tfoot:"table-footer-group",
			  tr:"table-row",col:"table-column",colgroup:"table-column-group",caption:"table-caption",dl:b,dt:b,dd:b};
	try {
		switch(oArgs+""){
			case "4voi":
				var type = c[this.tag];
				s.display = type || "inline";
				break;
			case "4str":
				s.display = sDisplay;

		}
	} catch(e) {
		/*

IE에서 sDisplay값이 비정상적일때 block로 셋팅한다.

		 */
		s.display = "block";
	}

	return this;
};
//-!MobileCommentJindo.$Element.prototype.show end!-//

//-!MobileCommentJindo.$Element.prototype.hide start!-//
/**

 * @description hide() 메서드는 HTML 요소가 화면에 보이지 않도록 display 속성을 none으로 변경한다.
 * @return {$Element} display 속성이 none으로 변경된 $Element() 객체.
 * @see <a href="http://www.w3.org/TR/2008/REC-CSS2-20080411/visuren.html#display-prop">display 속성</a> - W3C CSS2 Specification
 * @see $Element#show
 * @see $Element#toggle
 * @see $Element#visible
 * @example
// 화면에 보이지 않도록 설정
$Element("sample_div").hide();

//Before
<div id="sample_div" style="display:block">Hello world</div>

//After
<div id="sample_div" style="display:none">Hello world</div>

 */
MobileCommentJindo.$Element.prototype.hide = function() {
	//-@@$Element.hide-@@//
	this._element.style.display = "none";

	return this;
};

//-!MobileCommentJindo.$Element.prototype.hide end!-//

//-!MobileCommentJindo.$Element.prototype.toggle start(MobileCommentJindo.$Element.prototype._getCss,MobileCommentJindo.$Element.prototype.show,MobileCommentJindo.$Element.prototype.hide)!-//
/**

 * @description toggle() 메서드는 HTML 요소의 display 속성을 변경하여 해당 요소를 화면에 보이거나, 보이지 않게 한다. 이 메서드는 마치 스위치를 켜고 끄는 것과 같이 요소의 표시 여부를 반전시킨다.
 *
 * @param1 {Void}
 * @return1 {$Element} display 속성이 변경된 $Element() 객체.
 *
 * @param2 {String+} sDisplay 해당 요소가 보이도록 변경할 때 display 속성에 지정할 값.<br>파라미터를 생략하면 태그별로 미리 지정된 기본 값이 속성 값으로 설정된다. 미리 지정된 기본 값이 없으면 "inline"으로 설정된다.
 * @return2 {$Element} display 속성이 변경된 $Element() 객체.
 *
 * @since 1.4.5부터 보이도록 설정할 때 sDisplay 값으로 display 속성 값 지정이 가능하다.
 * @see <a href="http://www.w3.org/TR/2008/REC-CSS2-20080411/visuren.html#display-prop">display 속성</a> - W3C CSS2 Specification
 * @see $Element#show
 * @see $Element#hide
 * @see $Element#visible
 * @example
// 화면에 보이거나, 보이지 않도록 처리
$Element("sample_div1").toggle();
$Element("sample_div2").toggle();

//Before
<div id="sample_div1" style="display:block">Hello</div>
<div id="sample_div2" style="display:none">Good Bye</div>

//After
<div id="sample_div1" style="display:none">Hello</div>
<div id="sample_div2" style="display:block">Good Bye</div>

 */
MobileCommentJindo.$Element.prototype.toggle = function(sDisplay) {
	//-@@$Element.toggle-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4voi' : [  ],
		'4str' : ["sDisplay:String+"]
	},"$Element#toggle");

	this[this._getCss(this._element,"display")=="none"?"show":"hide"].apply(this,arguments);
	return this;
};
//-!MobileCommentJindo.$Element.prototype.toggle end!-//

//-!MobileCommentJindo.$Element.prototype.opacity start!-//
/**

 * @description opacity() 메서드는 HTML 요소의 투명도(opacity 속성) 값을 가져오거나 설정한다.
 *
 * @param1 {Void}
 * @return1 {Numeric} opacity값을 반환한다.
 *
 * @param2 {Numeric} nValue 설정할 투명도 값.<br>투명도 값은 0에서 1 사이의 실수 값으로 지정한다. 지정한 파라미터의 값이 0보다 작으면 0을, 1보다 크면 1을 설정한다.
 * @return2 {$Element} 값을 반영한 $Element() 객체를 반환한다.
 *
 * @example
<div id="sample" style="background-color:#2B81AF; width:20px; height:20px;"></div>

// 조회
$Element("sample").opacity();	// 1

 * @example
// 투명도 값 설정
$Element("sample").opacity(0.4);

//Before
<div style="background-color: rgb(43, 129, 175); width: 20px; height: 20px;" id="sample"></div>

//After
<div style="background-color: rgb(43, 129, 175); width: 20px; height: 20px; opacity: 0.4;" id="sample"></div>

 */
MobileCommentJindo.$Element.prototype.opacity = function(value) {
	//-@@$Element.opacity-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'g' : [  ],
		's' : ["nOpacity:Numeric"]
	},"$Element#opacity");

	var v,e = this._element,b;
	switch(oArgs+""){
		case "g":
			b = (this._getCss(e,"display") != "none");
			if (typeof e.filters != 'undefined') {
				v = typeof e.filters.alpha == 'undefined'?(b?100:0):e.filters.alpha.opacity;
				v = v / 100;
			} else {
				v = parseFloat(e.style.opacity,10);
				if (isNaN(v)) v = b?1:0;
			}
			return v;

		case "s":
			 /*

IE에서 layout을 가지고 있지 않으면 opacity가 적용되지 않음.

		     */
			b = (this._getCss(e,"display") != "none");
			value = oArgs.nOpacity;
			e.style.zoom = 1;
			value = Math.max(Math.min(value,1),0);

			if (typeof e.filters != 'undefined') {
				value = Math.ceil(value*100);

				if (typeof e.filters != 'unknown' && typeof e.filters.alpha != 'undefined') {
					e.filters.alpha.opacity = value;
				} else {
					e.style.filter = (e.style.filter + " alpha(opacity=" + value + ")");
				}
			} else {
				e.style.opacity = value;
			}

			return this;

	}

};


//-!MobileCommentJindo.$Element.prototype.opacity end!-//

//-!MobileCommentJindo.$Element.prototype.css start(MobileCommentJindo.$Element.prototype.opacity,MobileCommentJindo.$Element.prototype._getCss,MobileCommentJindo.$Element.prototype._setCss)!-//
/**

 * @description css() 메서드는 HTML 요소의 CSS 속성 값을 가져오거나 설정한다. 이 메서드로 CSS 속성은 카멜 표기법(Camel Notation)을 사용한다. 예를 들면 border-width-bottom 속성은 borderWidthBottom으로 지정할 수 있다. 또한 float 속성은 JavaScript의 예약어로 사용되므로 css() 메서드에서는 float 대신 cssFloat을 사용한다(Internet Explorer에서는 styleFloat, 그 외의 브라우저에서는 cssFloat를 사용한다.).
 *
 * @param1 {String+} vName CSS 속성 이름(String)
 * @return1 {String} CSS 속성 값을 반환한다.
 *
 * @param2 {String+} vName CSS 속성 이름(String)
 * @param2 {String+|Numeric} vValue CSS 속성에 설정할 값.<br>숫자(Number) 혹은 단위를 포함한 문자열(String)을 사용한다.
 * @return2 {$Element} CSS 속성 값을 반영한 $Element() 객체를 반환한다.
 *
 * @param3 {Hash+} oList 하나 이상의 CSS 속성과 값을 가지는 객체(Object) 또는 해시 객체($H() 객체).
 * @return3 {$Element} CSS 속성 값을 반영한 $Element() 객체를 반환한다.
 *
 * @throws {MobileCommentJindo.$Except.NOT_USE_CSS} css을 사용할 수 없는 엘리먼트 일 때.
 * @see $Element#attr
 * @example
<style type="text/css">
	#btn {
		width: 120px;
		height: 30px;
		background-color: blue;
	}
</style>

<span id="btn"></span>

...

// CSS 속성 값 조회
$Element('btn').css('backgroundColor');		// rgb (0, 0, 255)

 * @example
// CSS 속성 값 설정
$Element('btn').css('backgroundColor', 'red');

//Before
<span id="btn"></span>

//After
<span id="btn" style="background-color: red;"></span>

 * @example
// 여러개의 CSS 속성 값을 설정
$Element('btn').css({
	width: "200px",		// 200
	height: "80px"  	// 80 으로 설정하여도 결과는 같음
});

//Before
<span id="btn" style="background-color: red;"></span>

//After
<span id="btn" style="background-color: red; width: 200px; height: 80px;"></span>

 */
MobileCommentJindo.$Element.prototype.css = function(sName, sValue) {
	//-@@$Element.css-@@//

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'g' 	: [ 'sName:String+'],
		's4str' : [ MobileCommentJindo.$Jindo._F('sName:String+'), MobileCommentJindo.$Jindo._F('vValue:String+') ],
		's4num' : [ 'sName:String+', 'vValue:Numeric' ],
		's4obj' : [ 'oObj:Hash+']
	},"$Element#css");

	var e = this._element;
	switch(oArgs+"") {
		case 's4str':
		case 's4num':
			var obj = {};
			obj[sName] = sValue;
			sName = obj;
			break;
		case 's4obj':
			sName = oArgs.oObj;
			break;
		case 'g':
			var _getCss = this._getCss;
			if(sName == "opacity"){
				return this.opacity();
			}
			if((_JINDO_IS_FF||_JINDO_IS_OP)&&(sName=="backgroundPositionX"||sName=="backgroundPositionY")){
				var bp = _getCss(e, "backgroundPosition").split(/\s+/);
				return (sName == "backgroundPositionX") ? bp[0] : bp[1];
			}
			if (_JINDO_IS_IE && sName == "backgroundPosition") {
				return _getCss(e, "backgroundPositionX") + " " + _getCss(e, "backgroundPositionY")
			}
			if ((_JINDO_IS_FF||_JINDO_IS_SF||_JINDO_IS_CH) && (sName=="padding"||sName=="margin")) {
				var top		= _getCss(e, sName+"Top");
				var right	= _getCss(e, sName+"Right");
				var bottom	= _getCss(e, sName+"Bottom");
				var left	= _getCss(e, sName+"Left");
				if ((top == right) && (bottom == left)) {
					return top;
				}else if (top == bottom) {
					if (right == left) {
						return top+" "+right;
					}else{
						return top+" "+right+" "+bottom+" "+left;
					}
				}else{
					return top+" "+right+" "+bottom+" "+left;
				}
			}
			return _getCss(e, sName);

	}
	var v, type;

	for(var k in sName) {
		if(sName.hasOwnProperty(k)){
			v    = sName[k];
			if (!(MobileCommentJindo.$Jindo.isString(v)||MobileCommentJindo.$Jindo.isNumeric(v))) continue;
			if (k == 'opacity') {
				this.opacity(v);
				continue;
			}
			if (k == "cssFloat" && _JINDO_IS_IE) k = "styleFloat";

			if((_JINDO_IS_FF||_JINDO_IS_OP)&&( k =="backgroundPositionX" || k == "backgroundPositionY")){
				var bp = this.css("backgroundPosition").split(/\s+/);
				v = k == "backgroundPositionX" ? v+" "+bp[1] : bp[0]+" "+v;
				this._setCss(e, "backgroundPosition", v);
			}else{
				this._setCss(e, k, v);
			}
		}
	}

	return this;
};
//-!MobileCommentJindo.$Element.prototype.css end!-//

//-!MobileCommentJindo.$Element.prototype._getCss.hidden start!-//
/**

 * css에서 사용되는 함수
 * @ignore
 * @param {Element} e
 * @param {String} sName

 */
MobileCommentJindo.$Element.prototype._getCss = function(e, sName){
	var fpGetCss;
	if (e.currentStyle) {

		fpGetCss = function(e, sName){
			try{
				if (sName == "cssFloat") sName = "styleFloat";
				var sStyle = e.style[sName];
				if(sStyle){
					return sStyle;
				}else{
					var oCurrentStyle = e.currentStyle;
					if (oCurrentStyle) {
						return oCurrentStyle[sName];
					}
				}
				return sStyle;
			}catch(ex){
				throw new MobileCommentJindo.$Error((e.tagName||"document") + MobileCommentJindo.$Except.NOT_USE_CSS,"$Element#css");
			}
		}
	} else if (window.getComputedStyle) {
		fpGetCss = function(e, sName){
			try{
				if (sName == "cssFloat") sName = "float";
				var d = e.ownerDocument || e.document || document;
				var sVal =  (e.style[sName]||d.defaultView.getComputedStyle(e,null).getPropertyValue(sName.replace(/([A-Z])/g,"-$1").toLowerCase()));
				if (sName == "textDecoration") sVal = sVal.replace(",","");
				return sVal;
			}catch(ex){
				throw new MobileCommentJindo.$Error((e.tagName||"document") + MobileCommentJindo.$Except.NOT_USE_CSS,"$Element#css");
			}
		}

	} else {
		fpGetCss = function(e, sName){
			try{
				if (sName == "cssFloat" && _JINDO_IS_IE) sName = "styleFloat";
				return e.style[sName];
			}catch(ex){
				throw new MobileCommentJindo.$Error((e.tagName||"document") + MobileCommentJindo.$Except.NOT_USE_CSS,"$Element#css");
			}
		}
	}
	MobileCommentJindo.$Element.prototype._getCss = fpGetCss;
	return fpGetCss(e, sName);

};
//-!MobileCommentJindo.$Element.prototype._getCss.hidden end!-//

//-!MobileCommentJindo.$Element.prototype._setCss.hidden start!-//
/**

 * css에서 css를 세팅하기 위한 함수
 * @ignore
 * @param {Element} e
 * @param {String} k

 */
MobileCommentJindo.$Element.prototype._setCss = function(e, k, v){
	if (("#top#left#right#bottom#").indexOf(k+"#") > 0 && (typeof v == "number" ||(/\d$/.test(v)))) {
		e.style[k] = parseInt(v,10)+"px";
	}else{
		e.style[k] = v;
	}
};
//-!MobileCommentJindo.$Element.prototype._setCss.hidden end!-//

//-!MobileCommentJindo.$Element.prototype.attr start!-//
/**

 * @description attr() 메서드는 HTML 요소의 속성을 가져오거나 설정한다. 하나의 파라미터만 사용하면 지정한 속성의 값을 반환하고 해당 속성이 없다면 null을 반환한다.
 *
 * @param1 {String+} sName 속성 이름(String)
 * @return1 {String+} 속성 값을 반환.
 *
 * @param2 {String+} sName 속성 이름(String).
 * @param2 {Variant} vValue 속성에 설정할 값.<br>숫자(Number) 혹은 단위를 포함한 문자열(String)을 사용한다. 또한 속성의 값을 null로 설정하면 해당 HTML 속성을 삭제한다.
 * @return2 {$Element} 속성 값을 반영한 $Element() 객체를 반환한다.
 *
 * @param3 {Hash+} oList 하나 이상의 속성과 값을 가지는 객체(Object) 또는 해시 객체($H() 객체).
 * @return3 {$Element} 속성 값을 반영한 $Element() 객체를 반환한다.
 *
 * @throws {MobileCommentJindo.$Except.NOT_USE_CSS} sName은 문자,오브젝트 나 $Hash여야 한다.
 * @see $Element#css
 * @example
<a href="http://www.naver.com" id="sample_a" target="_blank">Naver</a>

$Element("sample_a").attr("href"); // http://www.naver.com
 * @example
$Element("sample_a").attr("href", "http://www.hangame.com/");

//Before
<a href="http://www.naver.com" id="sample_a" target="_blank">Naver</a>
//After
<a href="http://www.hangame.com" id="sample_a" target="_blank">Naver</a>
 * @example
$Element("sample_a").attr({
    "href" : "http://www.hangame.com",
    "target" : "_self"
})

//Before
<a href="http://www.naver.com" id="sample_a" target="_blank">Naver</a>
//After
<a href="http://www.hangame.com" id="sample_a" target="_self">Naver</a>

 */
MobileCommentJindo.$Element.prototype.attr = function(sName, sValue) {
	//-@@$Element.attr-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'g' 	: [ 'sName:String+'],
		's4str' : [ 'sName:String+', 'vValue:String+' ],
		's4num' : [ 'sName:String+', 'vValue:Numeric' ],
		's4nul' : [ 'sName:String+', 'vValue:Null' ],
		's4bln' : [ 'sName:String+', 'vValue:Boolean' ],
		's4obj' : [ MobileCommentJindo.$Jindo._F('oObj:Hash+')]
	},"$Element#attr");

	var e = this._element;
	switch(oArgs+""){
		case "s4str":
		case "s4nul":
		case "s4num":
		case "s4bln":
			var obj = {};
			obj[sName] = sValue;
			sName = obj;
			break;
		case "s4obj":
			sName = oArgs.oObj;
			break;
		case "g":
			if (sName == "class" || sName == "className"){
				return e.className;
			}else if(sName == "style"){
				return e.style.cssText;
			}else if(sName == "checked"||sName == "disabled"){
				return !!e[sName];
			}else if(sName == "value"){
				var val = e.getAttributeNode('value');
				if(val == null){
					return e.value;
				}else{
					return val.value;
				}
			}else if(sName == "href"){
				return e.getAttribute(sName,2);
			}
			return e.getAttribute(sName);

	}
	for(var k in sName) {
		if(sName.hasOwnProperty(k)){
			var v = sName[k];
			if (MobileCommentJindo.$Jindo.isNull(v)) {
				e.removeAttribute(k);
			}else{
				if (k == "class"|| k == "className") {
					e.className = v;
				}else if(k == "style"){
					e.style.cssText = v;
				}else if(k == "checked"||k == "disabled"){
					e[k] = v;
				}else if(k == "value"){
					e.value = v;
				}else{
					e.setAttribute(k, v);
				}

			}
		}
	}

	return this;
};
//-!MobileCommentJindo.$Element.prototype.attr end!-//

//-!MobileCommentJindo.$Element.prototype.width start!-//
/**

 * @description width() 메서드는 HTML 요소의 너비를 가져오거나 설정한다. width() 메서드는 HTML 요소의 실제 너비를 가져온다. 브라우저마다 Box 모델의 크기 계산 방법이 다르므로 CSS의 width 속성 값과 width 메서드()의 반환 값은 서로 다를 수 있다.
 *
 * @param1 {Void}
 * @return1 {Number} HTML 요소의 실제 너비(Number)를  반환한다.
 *
 * @param2 {Numeric} nWidth	설정할 너비 값.<br>단위는 픽셀(px)이며 파라미터의 값은 숫자로 지정한다.
 * @return2 {$Element} 너비 값이 반영된 $Element() 객체를 반환한다.
 *
 * @see $Element#height
 * @example
<style type="text/css">
	div { width:70px; height:50px; padding:5px; margin:5px; background:red; }
</style>

<div id="sample_div"></div>

...

// 조회
$Element("sample_div").width();	// 80

 * @example
// 위의 예제 HTML 요소에 너비 값을 설정
$Element("sample_div").width(200);

//Before
<div id="sample_div"></div>

//After
<div id="sample_div" style="width: 190px"></div>

 */
MobileCommentJindo.$Element.prototype.width = function(width) {
	//-@@$Element.width-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'g' : [  ],
		's' : ["nWidth:Numeric"]
	},"$Element#width");

	switch(oArgs+""){
		case "g" :

			return this._element.offsetWidth;

		case "s" :

			width = oArgs.nWidth;
			var e = this._element;
			e.style.width = width+"px";
			var off = e.offsetWidth;
			if (off != width && off!==0) {
				var w = (width*2 - off);
				if (w>0)
					e.style.width = w + "px";
			}
			return this;

	}

};
//-!MobileCommentJindo.$Element.prototype.width end!-//

//-!MobileCommentJindo.$Element.prototype.height start!-//
/**

 * @description height() 메서드는 HTML 요소의 높이를 가져오거나 설정한다. height() 메서드는 HTML 요소의 실제 높이를 가져온다. 브라우저마다 Box 모델의 크기 계산 방법이 다르므로 CSS의 height 속성 값과 height() 메서드의 반환 값은 서로 다를 수 있다.
 *
 * @param1 {Void}
 * @return1 {Number} HTML 요소의 실제 높이(Number)를 반환한다.
 *
 * @param2 {Number} nHeight 설정할 높이 값.<br>단위는 픽셀(px)이며 파라미터의 값은 숫자로 지정한다. 파라미터를 생략하면 높이 값을 반환한다.
 * @return2 {$Element} 높이 값이 반영된 $Element() 객체를 반환한다.
 *
 * @see $Element#width
 * @example
<style type="text/css">
	div { width:70px; height:50px; padding:5px; margin:5px; background:red; }
</style>

<div id="sample_div"></div>

...

// 조회
$Element("sample_div").height(); // 60

 * @example
// 위의 예제 HTML 요소에 높이 값을 설정
$Element("sample_div").height(100);

//Before
<div id="sample_div"></div>

//After
<div id="sample_div" style="height: 90px"></div>

 */
MobileCommentJindo.$Element.prototype.height = function(height) {
	//-@@$Element.height-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'g' : [  ],
		's' : ["nHeight:Numeric"]
	},"$Element#height");

	switch(oArgs+""){
		case "g" :
			return this._element.offsetHeight;

		case "s" :
			height = oArgs.nHeight;
			var e = this._element;
			e.style.height = height+"px";
			var off = e.offsetHeight;
			if (off != height && off!==0) {
				var height = (height*2 - off);
				if(height>0)
					e.style.height = height + "px";
			}
			return this;

	}
};
//-!MobileCommentJindo.$Element.prototype.height end!-//

//-!MobileCommentJindo.$Element.prototype.className start!-//
/**

 * @description className() 메서드는 HTML 요소의 클래스 이름을 설정하거나 반환한다.
 *
 * @param1 {Void}
 * @return1 {String} 클래스 이름(String)을 반환. 하나 이상의 클래스가 지정된 경우 공백으로 구분된 문자열이 반환된다.
 *
 * @param2 {String+} sClass 설정할 클래스 이름. 하나 이상의 클래스를 지정하려면 공백으로 구분하여 지정할 클래스 이름을 나열한다.
 * @return2 {$Element} 지정한 클래스가 반영된 $Element 객체가 반환된다.
 *
 * @throws {MobileCommentJindo.$Except.NOT_FOUND_ARGUMENT} 파라메터가 없는 경우.
 * @see $Element#hasClass
 * @see $Element#addClass
 * @see $Element#removeClass
 * @see $Element#toggleClass
 * @example
<style type="text/css">
p { margin: 8px; font-size:16px; }
.selected { color:#0077FF; }
.highlight { background:#C6E746; }
</style>

<p>Hello and <span id="sample_span" class="selected">Goodbye</span></p>

...

// 클래스 이름 조회
$Element("sample_span").className(); // selected

 * @example
// 위의 예제 HTML 요소에 클래스 이름 설정
welSample.className("highlight");

//Before
<p>Hello and <span id="sample_span" class="selected">Goodbye</span></p>

//After
<p>Hello and <span id="sample_span" class="highlight">Goodbye</span></p>

 */
MobileCommentJindo.$Element.prototype.className = function(sClass) {
	//-@@$Element.className-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'g' : [  ],
		's' : [MobileCommentJindo.$Jindo._F("sClass:String+")]
	},"$Element#className");
	var e = this._element;
	switch(oArgs+"") {
		case "g":
			return e.className;
		case "s":
			e.className = sClass;
			return this;

	}

};
//-!MobileCommentJindo.$Element.prototype.className end!-//

//-!MobileCommentJindo.$Element.prototype.hasClass start!-//
/**

 * @description hasClass() 메서드는 HTML 요소에서 특정 클래스를 사용하고 있는지 확인한다.
 * @param {String+} sClass 확인할 클래스 이름.
 * @return {Boolean} 지정한 클래스의 사용 여부.
 * @see $Element#className
 * @see $Element#addClass
 * @see $Element#removeClass
 * @see $Element#toggleClass
 *
 * @example
<style type="text/css">
	p { margin: 8px; font-size:16px; }
	.selected { color:#0077FF; }
	.highlight { background:#C6E746; }
</style>

<p>Hello and <span id="sample_span" class="selected highlight">Goodbye</span></p>

...

// 클래스의 사용여부를 확인
var welSample = $Element("sample_span");
welSample.hasClass("selected"); 			// true
welSample.hasClass("highlight"); 			// true

 */
MobileCommentJindo.$Element.prototype.hasClass = function(sClass) {
	//-@@$Element.hasClass-@@//
	var ___checkVarType = MobileCommentJindo.$Jindo.checkVarType;
	if(this._element.classList){
		MobileCommentJindo.$Element.prototype.hasClass = function(sClass){
			var oArgs = ___checkVarType(arguments, {
				'4str' : ["sClass:String+"]
			},"$Element#hasClass");
			return this._element.classList.contains(sClass);
		}
	} else {
		MobileCommentJindo.$Element.prototype.hasClass = function(sClass){
			var oArgs = ___checkVarType(arguments, {
				'4str' : ["sClass:String+"]
			},"$Element#hasClass");
			return (" "+this._element.className+" ").indexOf(" "+sClass+" ") > -1;
		}
	}
	return this.hasClass.apply(this,arguments);

};
//-!MobileCommentJindo.$Element.prototype.hasClass end!-//

//-!MobileCommentJindo.$Element.prototype.addClass start!-//
/**

 * @description addClass() 메서드는 HTML 요소에 클래스를 추가한다.
 * @param {String+} sClass 추가할 클래스 이름. 둘 이상의 클래스를 추가하려면 클래스 이름을 공백으로 구분하여 나열한다.
 * @return {$Element} 지정한 클래스가 추가된 $Element() 객체.
 * @see $Element#className
 * @see $Element#hasClass
 * @see $Element#removeClass
 * @see $Element#toggleClass
 * @example
// 클래스 추가
$Element("sample_span1").addClass("selected");
$Element("sample_span2").addClass("selected highlight");

//Before
<p>Hello and <span id="sample_span1">Goodbye</span></p>
<p>Hello and <span id="sample_span2">Goodbye</span></p>

//After
<p>Hello and <span id="sample_span1" class="selected">Goodbye</span></p>
<p>Hello and <span id="sample_span2" class="selected highlight">Goodbye</span></p>

 */
//MobileCommentJindo.$Element.prototype.addClass = function(sClass) {
//	//-@@$Element.addClass-@@//
//	if(this._element.classList){
//		MobileCommentJindo.$Element.prototype.addClass = function(sClass){
//			if(this._element==null) return this;
//			var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
//				'4str' : ["sClass:String+"]
//			},"$Element#addClass");
//
//			var aClass = (sClass+"").split(/\s+/);
//			var flistApi = this._element.classList;
//			for(var i = aClass.length ; i-- ;){
//				aClass[i]!=""&&flistApi.add(aClass[i]);
//			}
//			return this;
//		}
//	} else {
		MobileCommentJindo.$Element.prototype.addClass = function(sClass){
			var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
				'4str' : ["sClass:String+"]
			},"$Element#addClass");
			var e = this._element;
			var sClassName = e.className;
			var aClass = (sClass+"").split(" ");
			var sEachClass;
			for (var i = aClass.length - 1; i >= 0 ; i--){
				sEachClass = aClass[i];
				if ((" "+sClassName+" ").indexOf(" "+sEachClass+" ") == -1) {
					sClassName = sClassName+" "+sEachClass;
				}
			}
			e.className = sClassName.replace(/\s+$/, "").replace(/^\s+/, "");
			return this;
		};
//	}
//	return this.addClass.apply(this,arguments);
//
//};
//-!MobileCommentJindo.$Element.prototype.addClass end!-//

//-!MobileCommentJindo.$Element.prototype.removeClass start!-//
/**

 * @description removeClass() 메서드는 HTML 요소에서 특정 클래스를 제거한다.
 * @param {String+} sClass 제거할 클래스 이름. 둘 이상의 클래스를 제거하려면 클래스 이름을 공백으로 구분하여 나열한다.
 * @return {$Element} 지정한 클래스가 제거된 $Element() 객체.
 * @see $Element#className
 * @see $Element#hasClass
 * @see $Element#addClass
 * @see $Element#toggleClass
 *
 * @example
// 클래스 제거
$Element("sample_span").removeClass("selected");

//Before
<p>Hello and <span id="sample_span" class="selected highlight">Goodbye</span></p>

//After
<p>Hello and <span id="sample_span" class="highlight">Goodbye</span></p>
 * @example
// 여러개의 클래스를 제거
$Element("sample_span").removeClass("selected highlight");
$Element("sample_span").removeClass("highlight selected");

//Before
<p>Hello and <span id="sample_span" class="selected highlight">Goodbye</span></p>

//After
<p>Hello and <span id="sample_span" class="">Goodbye</span></p>

 */
//MobileCommentJindo.$Element.prototype.removeClass = function(sClass) {
//	//-@@$Element.removeClass-@@//
//	if(!this._element.classList){
//		MobileCommentJindo.$Element.prototype.removeClass = function(sClass){
//			var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
//				'4str' : ["sClass:String+"]
//			},"$Element#removeClass");
//			if(this._element==null) return this;
//			var flistApi = this._element.classList;
//			var aClass = (sClass+"").split(" ");
//			for(var i = aClass.length ; i-- ;){
//				aClass[i]!=""&&flistApi.remove(aClass[i]);
//			}
//			return this;
//		}
//	} else {

		MobileCommentJindo.$Element.prototype.removeClass = function(sClass){
			var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
				'4str' : ["sClass:String+"]
			},"$Element#removeClass");
			var e = this._element;
			var sClassName = e.className;
			var aClass = (sClass+"").split(" ");
			var sEachClass;

			for (var i = aClass.length - 1; i >= 0 ; i--){
				sClassName = (" "+sClassName+" ").replace(new RegExp("\\b"+aClass[i]+"\\s+","g")," ");
			}

			e.className = sClassName.replace(/\s+$/, "").replace(/^\s+/, "");

			return this;
		};
//	}
//	return this.removeClass.apply(this,arguments);
//
//};
//-!MobileCommentJindo.$Element.prototype.removeClass end!-//

//-!MobileCommentJindo.$Element.prototype.toggleClass start(MobileCommentJindo.$Element.prototype.addClass,MobileCommentJindo.$Element.prototype.removeClass,MobileCommentJindo.$Element.prototype.hasClass)!-//
/**

 * @description toogleClass() 메서드는 HTML 요소에 클래스가 이미 적용되어 있으면 제거하고 만약 없으면 추가한다. 파라미터를 하나만 입력할 경우 파라미터로 지정한 클래스가 사용되고 있으면 제거하고 사용되고 있지 않으면 추가한다. 만약 두 개의 파라미터를 입력할 경우 두 클래스 중에서 사용하고 있는 것을 제거하고 나머지 클래스를 추가한다.
 *
 * @param1 {String+} sClass 추가 혹은 제거할 클래스 이름.
 * @return1 {$Element} 클래스가 추가 혹은 제거된 현재의 $Element 객체
 *
 * @param2 {String+} sClass 추가 혹은 제거할 클래스 이름.
 * @param2 {String+} sClass2 추가 혹은 제거할 클래스 이름.
 * @return2 {$Element} 클래스가 추가 혹은 제거된 현재의 $Element 객체
 *
 * @import core.$Element[hasClass,addClass,removeClass]
 * @see $Element#className
 * @see $Element#hasClass
 * @see $Element#addClass
 * @see $Element#removeClass
 * @example
// 파라미터가 하나인 경우
$Element("sample_span1").toggleClass("highlight");
$Element("sample_span2").toggleClass("highlight");

//Before
<p>Hello and <span id="sample_span1" class="selected highlight">Goodbye</span></p>
<p>Hello and <span id="sample_span2" class="selected">Goodbye</span></p>

//After
<p>Hello and <span id="sample_span1" class="selected">Goodbye</span></p>
<p>Hello and <span id="sample_span2" class="selected highlight">Goodbye</span></p>

 * @example
// 파라미터가 두 개인 경우
$Element("sample_span1").toggleClass("selected", "highlight");
$Element("sample_span2").toggleClass("selected", "highlight");

//Before
<p>Hello and <span id="sample_span1" class="highlight">Goodbye</span></p>
<p>Hello and <span id="sample_span2" class="selected">Goodbye</span></p>

//After
<p>Hello and <span id="sample_span1" class="selected">Goodbye</span></p>
<p>Hello and <span id="sample_span2" class="highlight">Goodbye</span></p>

 */
MobileCommentJindo.$Element.prototype.toggleClass = function(sClass, sClass2) {
	//-@@$Element.toggleClass-@@//
	var ___checkVarType = MobileCommentJindo.$Jindo.checkVarType;
	if(this._element.classList){
		MobileCommentJindo.$Element.prototype.toggleClass = function(sClass, sClass2){
			var oArgs = ___checkVarType(arguments, {
				'4str'  : ["sClass:String+"],
				'4str2' : ["sClass:String+", "sClass2:String+"]
			},"$Element#toggleClass");

			switch(oArgs+"") {
				case '4str':
					this._element.classList.toggle(sClass+"");
					break;
				case '4str2':
					sClass = sClass+"";
					sClass2 = sClass2+"";
					if(this.hasClass(sClass)){
						this.removeClass(sClass);
						this.addClass(sClass2);
					}else{
						this.addClass(sClass);
						this.removeClass(sClass2);
					}

			}
			return this;
		};
	} else {
		MobileCommentJindo.$Element.prototype.toggleClass = function(sClass, sClass2){
			var oArgs = ___checkVarType(arguments, {
				'4str'  : ["sClass:String+"],
				'4str2' : ["sClass:String+", "sClass2:String+"]
			},"$Element#toggleClass");

			sClass2 = sClass2 || "";
			if (this.hasClass(sClass)) {
				this.removeClass(sClass);
				if (sClass2) this.addClass(sClass2);
			} else {
				this.addClass(sClass);
				if (sClass2) this.removeClass(sClass2);
			}

			return this;
		};
	}
	return this.toggleClass.apply(this,arguments);
};
//-!MobileCommentJindo.$Element.prototype.toggleClass end!-//

//-!MobileCommentJindo.$Element.prototype.cssClass start(MobileCommentJindo.$Element.prototype.addClass,MobileCommentJindo.$Element.prototype.removeClass,MobileCommentJindo.$Element.prototype.hasClass)!-//
/**

 * @description cssClass는 클래스를 추가, 삭제, 확인을 할 수 있다.
 * @since 2.0.0
 * @param1 {String+} sName class명(String)
 * @return1 {Boolean} 해당 클래스가 있는지 여부의 불린 값을 반환한다.
 *
 * @param2 {String+} sName class명(String),
 * @param2 {Boolean} bClassType true인 경우는 클래스를 추가하고 false인 경우는 클래스를 삭제한다.
 * @return2 {$Element} $Element인스턴스를 반환한다.
 *
 * @param3 {Hash+} oList 하나 이상의 속성명과 불린값을 가지는 객체(Object) 또는 해시 객체($H()객체).
 * @return3 {$Element} $Element인스턴스를 반환한다.
 *
 * @see $Element#addClass
 * @see $Element#removeClass
 * @example

// 첫 번째 파라메터만 넣은 경우
<div id="sample_span1"/>
$Element("sample_span1").cssClass("highlight");// false

// 두 번째 파라메터도 넣은 경우.
$Element("sample_span1").cssClass("highlight",true);
-> <div id="sample_span1" class="highlight"/>

$Element("sample_span1").cssClass("highlight",false);
-> <div id="sample_span1" class=""/>

// 첫 번째 파라메터를 오브젝트로 넣은 경우.
<div id="sample_span1" class="bar"/>

$Element("sample_span1").cssClass({
	"foo": true,
	"bar" : false
});
-> <div id="sample_span1" class="foo"/>

 */
MobileCommentJindo.$Element.prototype.cssClass = function(vClass, bCondition){
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'g'  : ["sClass:String+"],
		's4bln' : ["sClass:String+", "bCondition:Boolean"],
		's4obj' : ["oObj:Hash+"]
	},"$Element#cssClass");

	switch(oArgs+""){
		case "g":
			return this.hasClass(oArgs.sClass);

		case "s4bln":
			if(oArgs.bCondition){
				this.addClass(oArgs.sClass);
			}else{
				this.removeClass(oArgs.sClass);
			}
			return this;

		case "s4obj":
			var e = this._element;
			vClass = oArgs.oObj;
			var sClassName = e.className;
			for(var sEachClass in vClass){
				if (vClass.hasOwnProperty(sEachClass)) {
					if(vClass[sEachClass]){
						if ((" " + sClassName + " ").indexOf(" " + sEachClass + " ") == -1) {
							sClassName = (sClassName+" "+sEachClass).replace(/^\s+/, "");
						}
					}else{
						if ((" " + sClassName + " ").indexOf(" " + sEachClass + " ") > -1) {
							sClassName = (" "+sClassName+" ").replace(" "+sEachClass+" ", " ").replace(/\s+$/, "").replace(/^\s+/, "");
						}
					}
				}
			}
			e.className = sClassName;
			return this;

	}


};

//-!MobileCommentJindo.$Element.prototype.cssClass end!-//
//-!MobileCommentJindo.$Element.prototype.text start!-//
/**

 * @description text() 메서드는 HTML 요소의 텍스트 노드 값을 가져오거나 설정한다. 파라미터를 생략하면 텍스트 노드의 값을 가져오고, 파라미터를 지정하면 텍스트 노드를 지정한 값으로 설정한다.
 *
 * @param1 {Void}
 * @return1 {String} HTML 요소의 텍스트 노드(String)를 반환.
 *
 * @param2 {String+} sText 지정할 텍스트.
 * @return2 {$Element} 지정한 값으로 설정된 $Element() 객체를 반환.
 *
 * @example
<ul id="sample_ul">
	<li>하나</li>
	<li>둘</li>
	<li>셋</li>
	<li>넷</li>
</ul>

...

// 텍스트 노드 값 조회
$Element("sample_ul").text();
// 결과
//	하나
//	둘
//	셋
//	넷
@example
// 텍스트 노드 값 설정
$Element("sample_ul").text('다섯');

//Before
<ul id="sample_ul">
	<li>하나</li>
	<li>둘</li>
	<li>셋</li>
	<li>넷</li>
</ul>

//After
<ul id="sample_ul">다섯</ul>
@example
// 텍스트 노드 값 설정
$Element("sample_p").text("New Content");

//Before
<p id="sample_p">
	Old Content
</p>

//After
<p id="sample_p">
	New Content
</p>

 */
MobileCommentJindo.$Element.prototype.text = function(sText) {
	//-@@$Element.text-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'g'  : [],
		's4str' : ["sText:String+"],
		's4num' : [MobileCommentJindo.$Jindo._F("sText:Numeric")],
		's4bln' : ["sText:Boolean"]
	},"$Element#text");

	var ele = this._element;
	var tag = this.tag;

	switch(oArgs+""){
		case "g":
			var	prop = (ele.innerText !== undefined)?"innerText":"textContent";
			if (tag == "textarea" || tag == "input") prop = "value";
			return ele[prop];
		case "s4str":
		case "s4num":
		case "s4bln":
			var	prop = (ele.innerText !== undefined)?"innerText":"textContent";
			if (tag == "textarea" || tag == "input") prop = "value";
			sText += "";
			try {
				/*

 * Opera 11.01에서 textContext가 Get일때 정상적으로 동작하지 않음. 그래서 get일 때는 innerText을 사용하고 set하는 경우는 textContent을 사용한다.(http://devcafe.nhncorp.com/ajaxui/295768)

				 */
				if (prop!="value") prop = (ele.textContent !== undefined)?"textContent":"innerText";
				ele[prop] = sText+"";
			} catch(e) {
				return ele.innerHTML = (sText+"").replace(/&/g, '&amp;').replace(/</g, '&lt;');
			}
			return this;

	}
};
//-!MobileCommentJindo.$Element.prototype.text end!-//

//-!MobileCommentJindo.$Element.prototype.html start!-//
/**

 * @description html() 메서드는 HTML 요소의 내부 HTML 코드(innerHTML)를 가져오거나 설정한다. 파라미터를 생략하면 내부 HTML 코드를 가져오고, 파라미터를 지정하면 내부 HTML 코드를 지정한 값으로 변경한다.
 * @caution IE8에서 colgroup의 col을 수정하려고 할 때 colgroup을 삭제하고 다시 만든 후 col을 추가해야 합니다.
 *
 * @param1 {Void}
 * @return1 {String} 내부 HTML(String)을 반환.
 *
 * @param2 {String+} sHTML 내부 HTML 코드로 설정할 HTML 문자열.
 * @return2 {$Element} 지정한 값으로 설정된 $Element() 객체를 반환.
 *
 * @see <a href="https://developer.mozilla.org/en/DOM/element.innerHTML">element.innerHTML</a> - MDN Docs
 * @see $Element#outerHTML
 * @example
 <div id="sample_container">
  	<p><em>Old</em> content</p>
 </div>

...

// 내부 HTML 조회
$Element("sample_container").html(); // <p><em>Old</em> content</p>

 * @example
// 내부 HTML 설정
$Element("sample_container").html("<p>New <em>content</em></p>");

//Before
<div id="sample_container">
 	<p><em>Old</em> content</p>
</div>

//After
<div id="sample_container">
 	<p>New <em>content</em></p>
</div>

 */
MobileCommentJindo.$Element.prototype.html = function(sHTML) {
	//-@@$Element.html-@@//
	var isIe = _JINDO_IS_IE;
	var isFF = _JINDO_IS_FF;
	var _param = {
				'g'  : [],
				's4str' : [MobileCommentJindo.$Jindo._F("sText:String+")],
				's4num' : ["sText:Numeric"],
				's4bln' : ["sText:Boolean"]
	}
	var ___checkVarType = MobileCommentJindo.$Jindo.checkVarType;
	if (isIe) {
		MobileCommentJindo.$Element.prototype.html = function(sHTML){
			var oArgs = ___checkVarType(arguments,_param,"$Element#html");
			switch(oArgs+""){
				case "g":
					return this._element.innerHTML;

				case "s4str":
				case "s4num":
				case "s4bln":
					sHTML += "";
					if(MobileCommentJindo.cssquery) MobileCommentJindo.cssquery.release();
					var oEl = this._element;


					while(oEl.firstChild){
						oEl.removeChild(oEl.firstChild);
					}
					/*

	IE 나 FireFox 의 일부 상황에서 SELECT 태그나 TABLE, TR, THEAD, TBODY 태그에 innerHTML 을 셋팅해도
	문제가 생기지 않도록 보완 - hooriza

					 */
					var sId = 'R' + new Date().getTime() + parseInt(Math.random() * 100000,10);
					var oDoc = oEl.ownerDocument || oEl.document || document;

					var oDummy;
					var sTag = oEl.tagName.toLowerCase();

					switch (sTag) {
						case 'select':
						case 'table':
							oDummy = oDoc.createElement("div");
							oDummy.innerHTML = '<' + sTag + ' class="' + sId + '">' + sHTML + '</' + sTag + '>';
							break;
						case 'tr':
						case 'thead':
						case 'tbody':
						case 'colgroup':
							oDummy = oDoc.createElement("div");
							oDummy.innerHTML = '<table><' + sTag + ' class="' + sId + '">' + sHTML + '</' + sTag + '></table>';
							break;

						default:
							oEl.innerHTML = sHTML;

					}

					if (oDummy) {

						var oFound;
						for (oFound = oDummy.firstChild; oFound; oFound = oFound.firstChild)
							if (oFound.className == sId) break;

						if (oFound) {
							var notYetSelected = true;
							for (var oChild; oChild = oEl.firstChild;) oChild.removeNode(true); // innerHTML = '';

							for (var oChild = oFound.firstChild; oChild; oChild = oFound.firstChild){
								if(sTag=='select'){
									/*

* ie에서 select테그일 경우 option중 selected가 되어 있는 option이 있는 경우 중간에
* selected가 되어 있으면 그 다음 부터는 계속 selected가 true로 되어 있어
* 해결하기 위해 cloneNode를 이용하여 option을 카피한 후 selected를 변경함. - mixed

									 */
									var cloneNode = oChild.cloneNode(true);
									if (oChild.selected && notYetSelected) {
										notYetSelected = false;
										cloneNode.selected = true;
									}
									oEl.appendChild(cloneNode);
									oChild.removeNode(true);
								}else{
									oEl.appendChild(oChild);
								}

							}
							oDummy.removeNode && oDummy.removeNode(true);

						}

						oDummy = null;

					}

					return this;

			}
		};
	}else if(isFF){
		MobileCommentJindo.$Element.prototype.html = function(sHTML){
			var oArgs = ___checkVarType(arguments,_param,"$Element#html");
			switch(oArgs+""){
				case "g":
					return this._element.innerHTML;

				case "s4str":
				case "s4num":
				case "s4bln":
					sHTML += "";
					var oEl = this._element;

					if(!oEl.parentNode){
						/*

	IE 나 FireFox 의 일부 상황에서 SELECT 태그나 TABLE, TR, THEAD, TBODY 태그에 innerHTML 을 셋팅해도
	문제가 생기지 않도록 보완 - hooriza

						 */
						var sId = 'R' + new Date().getTime() + parseInt(Math.random() * 100000,10);
						var oDoc = oEl.ownerDocument || oEl.document || document;

						var oDummy;
						var sTag = oEl.tagName.toLowerCase();

						switch (sTag) {
						case 'select':
						case 'table':
							oDummy = oDoc.createElement("div");
							oDummy.innerHTML = '<' + sTag + ' class="' + sId + '">' + sHTML + '</' + sTag + '>';
							break;

						case 'tr':
						case 'thead':
						case 'tbody':
						case 'colgroup':
							oDummy = oDoc.createElement("div");
							oDummy.innerHTML = '<table><' + sTag + ' class="' + sId + '">' + sHTML + '</' + sTag + '></table>';
							break;

						default:
							oEl.innerHTML = sHTML;

						}

						if (oDummy) {
							var oFound;
							for (oFound = oDummy.firstChild; oFound; oFound = oFound.firstChild)
								if (oFound.className == sId) break;

							if (oFound) {
								for (var oChild; oChild = oEl.firstChild;) oChild.removeNode(true); // innerHTML = '';

								for (var oChild = oFound.firstChild; oChild; oChild = oFound.firstChild){
									oEl.appendChild(oChild);
								}

								oDummy.removeNode && oDummy.removeNode(true);

							}

							oDummy = null;

						}
					}else{
						oEl.innerHTML = sHTML;
					}


					return this;

			}
		};
	}else{
		MobileCommentJindo.$Element.prototype.html = function(sHTML){
			var oArgs = ___checkVarType(arguments,_param,"$Element#html");
			switch(oArgs+""){
				case "g":
					return this._element.innerHTML;

				case "s4str":
				case "s4num":
				case "s4bln":
					sHTML += "";
					var oEl = this._element;
					oEl.innerHTML = sHTML;
					return this;

			}

		};
	}

	return this.html.apply(this,arguments);
};
//-!MobileCommentJindo.$Element.prototype.html end!-//

//-!MobileCommentJindo.$Element.prototype.outerHTML start!-//
/**

 * @description outerHTML() 메서드는 HTML 요소의 내부 코드(innerHTML)에 해당하는 부분과 자신의 태그를 포함한 HTML 코드를 반환한다.
 * @return {String} HTML 코드.
 * @see $Element#html
 * @example
<h2 id="sample0">Today is...</h2>

<div id="sample1">
  	<p><span id="sample2">Sample</span> content</p>
</div>

...

// 외부 HTML 값을 조회
$Element("sample0").outerHTML(); // <h2 id="sample0">Today is...</h2>

$Element("sample1").outerHTML(); // <div id="sample1">  <p><span id="sample2">Sample</span> content</p>  </div>

$Element("sample2").outerHTML(); // <span id="sample2">Sample</span>

 */
MobileCommentJindo.$Element.prototype.outerHTML = function() {
	//-@@$Element.outerHTML-@@//
	var e = this._element;
	if (e.outerHTML !== undefined) return e.outerHTML;

	var oDoc = e.ownerDocument || e.document || document;
	var div = oDoc.createElement("div");
	var par = e.parentNode;

    /**
      상위노드가 없으면 innerHTML반환
     */
	if(!par) return e.innerHTML;

	par.insertBefore(div, e);
	div.style.display = "none";
	div.appendChild(e);

	var s = div.innerHTML;
	par.insertBefore(e, div);
	par.removeChild(div);

	return s;
};
//-!MobileCommentJindo.$Element.prototype.outerHTML end!-//

//-!MobileCommentJindo.$Element.prototype.toString start(MobileCommentJindo.$Element.prototype.outerHTML)!-//
/**

 * @function
 * @description toString() 메서드는 해당 요소의 코드를 문자열로 변환하여 반환한다(outerHTML 메서드와 동일).
 * @return {String} HTML 코드.
 * @see $Element#outerHTML

 */
MobileCommentJindo.$Element.prototype.toString = MobileCommentJindo.$Element.prototype.outerHTML;
//-!MobileCommentJindo.$Element.prototype.toString end!-//

//-!MobileCommentJindo.$Element.prototype.attach start(MobileCommentJindo.$Element.prototype.isEqual,MobileCommentJindo.$Element.prototype.isChildOf,MobileCommentJindo.$Element.prototype.detach, MobileCommentJindo.$Element.event_etc, MobileCommentJindo.$Element.domready, MobileCommentJindo.$Element.unload, MobileCommentJindo.$Event)!-//
/**

 * @description 엘리먼트에 이벤트를 할당한다.
 * @since 2.0.0
 * @param {String+} sEvent 이벤트 명
   <ul>
	<li>이벤트 이름에는 on 접두어를 사용하지 않는다.</li>
	<li>마우스 휠 스크롤 이벤트는 mousewheel 로 사용한다.</li>
	<li>기본 이벤트 외에 추가로 사용이 가능한 이벤트로 domready, mouseenter, mouseleave, mousewheel이 있다.</li>
   </ul>
 * @param {Function+} fpCallback 이벤트가 발생했을 때 실행되는 콜백함수.
 * @see $Element#detach
 * @see $Element#delegate
 * @see $Element#undelegate
 * @return {$Element} $Element() 객체.
 * @throws {MobileCommentJindo.$Except.NOT_WORK_DOMREADY} IE인 경우 프레임 안에서는 domready함수를 사용할 때.
 * @since 2.0.0
 * @example
function normalEvent(e){
	alert("click");
}
function groupEvent(e){
	alert("group click");
}

//일반적인 이벤트 할당.
$Element("some_id").attach("click",normalEvent);

 */
MobileCommentJindo.$Element.prototype.attach = function(sEvent, fpCallback){
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str'  : ["sEvent:String+", "fpCallback:Function+"]
	},"$Element#attach");
	return this._add("normal",sEvent.toLowerCase(),null,fpCallback);
};
//-!MobileCommentJindo.$Element.prototype.attach end!-//

//-!MobileCommentJindo.$Element.prototype.detach start(MobileCommentJindo.$Element.prototype.attach)!-//
/**

 * @description detach() 메서드는 엘리먼트에 등록된 이벤트 핸들러를 등록 해제한다.
 * @since 2.0.0
 * @param {String+} sEvent 이벤트 명
 * @param {Function+} fpCallback 이벤트가 발생했을 때 실행되는 콜백함수.
 * @see $Element#detach
 * @see $Element#delegate
 * @see $Element#undelegate
 * @return {$Element} $Element() 객체.
 * @example
function normalEvent(e){
	alert("click");
}
function groupEvent(e){
	alert("group click");
}
function groupEvent2(e){
	alert("group2 click");
}
function groupEvent3(e){
	alert("group3 click");
}

//일반적인 이벤트 할당.
$Element("some_id").attach("click",normalEvent);
//일반적인 이벤트 해제. 일반적인 이벤트 해제는 반드시 함수를 넣어야지만 해제가 가능하다.
$Element("some_id").detach("click",normalEvent);


 */
MobileCommentJindo.$Element.prototype.detach = function(sEvent, fpCallback){
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'group_for_string'  : ["sEvent:String+"],
		'4fun'  : ["sEvent:String+", "fpCallback:Function+"]
	},"$Element#detach");
	return this._del("normal",sEvent.toLowerCase(),null,fpCallback);
};
//-!MobileCommentJindo.$Element.prototype.detach end!-//

//-!MobileCommentJindo.$Element.prototype.delegate start(MobileCommentJindo.$Element.prototype.undelegate, MobileCommentJindo.$Element.event_etc, MobileCommentJindo.$Element.domready, MobileCommentJindo.$Element.unload, MobileCommentJindo.$Event)!-//
/**

 * @description delegate() 메서드는 이벤트 위임(Event Deligation) 방식으로 이벤트를 처리한다. 이벤트 위임이란 이벤트 버블링을 이용하여 이벤트를 관리하는 상위 요소를 따로 두어 효율적으로 이벤트를 관리하는 방법이다.
 * @param {String+} sEvent 이벤트 이름.<br>on 접두어는 생략한다.
 * @param {Variant} vFilter 특정 HTML 요소에 대해서만 이벤트 핸들러를 실행하도록 하기 위한 필터.<br>
 * 필터는 CSS 선택자(String)와 함수(Function)으로 지정할 수 있다.
<ul>
	<li>문자열을 입력하면 CSS 선택자로 이벤트 핸들러를 실행시킬 요소를 지정할 수 있다.</li>
	<li>Boolean 값을 반환하는 함수를 파라미터 입력할 수 있다. 이 함수를 사용할 경우 함수가 true를 반환할 때 실행할 콜백 함수(fCallback)를 파라미터로 추가 지정해야 한다.
</ul>
 * @param {Function+} [fCallback] vFilter에 지정된 함수가 true를 반환하는 경우 실행할 콜백 함수.<br>콜백 함수의 첫 번째 파라미터는 HTML 요소 자신이고, 두 번째 파라미터는 이벤트가 발생한 HTML 요소가 입력된다.
 * @return {$Element} $Element() 객체.
 * @since 1.4.6
 * @since 2.0.0부터  domready, mousewheel, mouseleave, mouseenter 이벤트 사용가능.
 * @see $Element#attach
 * @see $Element#detach
 * @see $Element#undelegate
 * @example
	<ul id="parent">
		<li class="odd">1</li>
		<li>2</li>
		<li class="odd">3</li>
		<li>4</li>
	</ul>

	// CSS 셀렉터를 필터로 사용하는 경우
	$Element("parent").delegate("click",
		".odd", 			// 필터
		function(eEvent){	// 콜백 함수
			alert("odd 클래스를 가진 li가 클릭 될 때 실행");
		});
 * @example
	<ul id="parent">
		<li class="odd">1</li>
		<li>2</li>
		<li class="odd">3</li>
		<li>4</li>
	</ul>

	// 함수를 필터로 사용하는 경우
	$Element("parent").delegate("click",
		function(oEle,oClickEle){	// 필터
			return oClickEle.innerHTML == "2"
		},
		function(eEvent){			// 콜백 함수
			alert("클릭한 요소의 innerHTML이 2인 경우에 실행");
		});

*/
MobileCommentJindo.$Element.prototype.delegate = function(sEvent , vFilter , fpCallback){
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str'  : ["sEvent:String+", "vFilter:String+", "fpCallback:Function+"],
		'4fun'  : ["sEvent:String+", "vFilter:Function+", "fpCallback:Function+"]
	},"$Element#delegate");
	return this._add("delegate",sEvent.toLowerCase(),vFilter,fpCallback);
};
//-!MobileCommentJindo.$Element.prototype.delegate end!-//

//-!MobileCommentJindo.$Element.prototype.undelegate start(MobileCommentJindo.$Element.prototype.delegate)!-//
/**

 * @description undelegate() 메서드는 delegate() 메서드로 등록한 이벤트 위임을 해제한다.
 * @param {String+} sEvent 이벤트 위임을 등록할 때 사용한 이벤트 이름.<br>on 접두어는 생략한다.
 * @param {Variant} vFilter 이벤트 위임을 등록할 때 지정한 필터. 안넣으면 엘리먼트에 delegate로 할당한 이벤트 중 특정 이벤트의 모든 조건이 사라진다.
 * @param {Function+} [fCallback] 이벤트 위임을 등록할 때 지정한 콜백 함수.
 * @return {$Element} $Element() 객체.
 * @since 1.4.6
 * @see $Element#attach
 * @see $Element#detach
 * @see $Element#delegate
 * @example
<ul id="parent">
	<li class="odd">1</li>
	<li>2</li>
	<li class="odd">3</li>
	<li>4</li>
</ul>

// 콜백 함수
function fnOddClass(eEvent){
	alert("odd 클래스를 가진 li가 클릭 될 때 실행");
};
function fnOddClass2(eEvent){
	alert("odd 클래스를 가진 li가 클릭 될 때 실행2");
};
function fnOddClass3(eEvent){
	alert("odd 클래스를 가진 li가 클릭 될 때 실행3");
};

$Element("parent").delegate("click", ".odd", fnOddClass);	// 이벤트 델리게이션 사용

$Element("parent").undelegate("click", ".odd", fnOddClass);	// fnOddClass만 이벤트 해제

 */
MobileCommentJindo.$Element.prototype.undelegate = function(sEvent , vFilter , fpCallback){
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str'  : ["sEvent:String+", "vFilter:String+", "fpCallback:Function+"],
		'4fun'  : ["sEvent:String+", "vFilter:Function+", "fpCallback:Function+"],
		'group_for_string'  : ["sEvent:String+", "vFilter:String+"],
		'group_for_function'  : ["sEvent:String+", "vFilter:Function+"]
	},"$Element#undelegate");
	return this._del("delegate",sEvent.toLowerCase(),vFilter,fpCallback);
};
//-!MobileCommentJindo.$Element.prototype.undelegate end!-//

//-!MobileCommentJindo.$Element.event_etc.hidden start!-//
/**

 * 이벤트를 추가하는 내부 함수.
 * @ignore
 * @param {String} sType delegate인지 일반 이벤트인지 확인.
 * @param {String} sEvent 이벤트명.
 * @param {String|Function} vFilter 필터 함수.
 * @param {Function} fpCallback 이벤트 콜백함수.

 */
MobileCommentJindo.$Element.prototype._add = function(sType, sEvent , vFilter , fpCallback){

	var oManager = MobileCommentJindo.$Element.eventManager;
	var oEvent = oManager.splitGroup(sEvent);
	sEvent = oEvent.event;
	var sGroup = oEvent.group;

	if((!document.addEventListener)&&("domready"==sEvent)){
		if(window.top != window) throw  MobileCommentJindo.$Error(MobileCommentJindo.$Except.NOT_WORK_DOMREADY,"$Element#attach");
		MobileCommentJindo.$Element._domready(this._element, fpCallback);
		return this;
	}

	fpCallback = oManager.revisionCallback(sType, sEvent, fpCallback);
	sEvent = oManager.revisionEvent(sType, sEvent);

	if(!oManager.isInit(this._key)){
		oManager.init(this._key, this._element);
	}

	if(!oManager.hasEvent(this._key, sEvent)){
		oManager.initEvent(this, sEvent,sGroup);
	}

	if(!oManager.hasGroup(this._key, sEvent, sGroup)){
		oManager.initGroup(this._key, sEvent, sGroup);
	}

	oManager.addEventListener(this._key, sEvent, sGroup, sType, vFilter, fpCallback);

	return this;
};

/**

 * 이벤트를 삭제할 때 사용하는 내부 함수.
 * @ignore
 * @param {String} sType 이벤트 delegate인지 일반 이벤트인지 확인.
 * @param {String} sEvent 이벤트명.
 * @param {String|Function} vFilter 필터 함수.
 * @param {Function} fpCallback 이벤트 콜백함수.

 */
MobileCommentJindo.$Element.prototype._del = function(sType, sEvent, vFilter, fpCallback){
	var oManager = MobileCommentJindo.$Element.eventManager;
	var oEvent = oManager.splitGroup(sEvent);
	sEvent = oEvent.event;
	var sGroup = oEvent.group;
	sEvent = oManager.revisionEvent(sType, sEvent);
	if((!document.addEventListener)&&("domready"==sEvent)){
		var aNewDomReady = [];
		var list = MobileCommentJindo.$Element._domready.list;
		for(var i=0,l=list.length; i < l ;i++){
			if(list[i]!=fpCallback){
				aNewDomReady.push(list[i]);
			}
		}
		MobileCommentJindo.$Element._domready.list = aNewDomReady;
		return this;
	}

	var NONE_GROUP = "_jindo_event_none";
	if(sGroup === NONE_GROUP && !MobileCommentJindo.$Jindo.isFunction(fpCallback)){
		throw new MobileCommentJindo.$Error(MobileCommentJindo.$Except.HAS_FUNCTION_FOR_GROUP,"$Element#"+(sType=="normal"?"detach":"delegate"));
	}

	oManager.removeEventListener(this._key, sEvent, sGroup, sType, vFilter, fpCallback);
	return this;
};

/**

 * $Element의 이벤트를 관리하는 객체.
 * @ignore

 */
MobileCommentJindo.$Element.eventManager = (function(){
	var eventStore = {};
	var NONE_GROUP = "_jindo_event_none";
	function bind(fpFunc, oScope, aPram){
		return function() {
			var args = _slice.call( arguments, 0);
			if (aPram.length) args = aPram.concat(args);
			return fpFunc.apply(oScope, args);
		};
	}
	var touch;

	if(_JINDO_IS_MO){
		touch =  {
			 "mousedown":"touchstart",
			 "mousemove":"touchmove",
			 "mouseup":"touchend"
		};
	}else{
		touch = {
			 "mousedown":"mousedown",
			 "mousemove":"mousemove",
			 "mouseup":"mouseup"
		};
	}
	return {
		/**

 * mouseenter나 mouseleave 이벤트가 없는 브라우저에서 이벤트를 할당 할 때 동작하게끔 콜백함수를 조정하는 함수.
 * IE에서 delegate에 mouseenter나 mouseleave을 사용할 때도 사용.
 * @ignore
 * @param {String} sType 이벤트 delegate인지 일반 이벤트인지 확인.
 * @param {String} sEvent 이벤트명
 * @param {Function} fpCallback 이벤트 콜백함수

		 */
		revisionCallback : function(sType, sEvent, fpCallback){
			if((document.addEventListener !== undefined&&(sEvent=="mouseenter"||sEvent=="mouseleave")) || (_JINDO_IS_IE&&(sType=="delegate")&&(sEvent=="mouseenter"||sEvent=="mouseleave"))){
				var fpWrapCallback = MobileCommentJindo.$Element.eventManager._fireWhenElementBoundary(sType, fpCallback);
				fpWrapCallback._origin_ = fpCallback;
				fpCallback = fpWrapCallback;
			}
			return fpCallback;
		},
		/**

 * mouseenter나 mouseleave 이벤트가 없는 브라우저에서 에뮬레이션해주는 함수.
 * @ignore
 * @param {String} sType 이벤트 delegate인지 일반 이벤트인지 확인.
 * @param {Function} fpCallback 이벤트 콜백함수

		 */
		_fireWhenElementBoundary : function(sType, fpCallback){
			return function(oEvent){
				var woRelatedElement = oEvent.relatedElement?MobileCommentJindo.$Element(oEvent.relatedElement):null;
				var eElement = oEvent.currentElement;
				if(sType == "delegate"){
					eElement = oEvent.element;
				}
				if(woRelatedElement && (woRelatedElement.isEqual(eElement) || woRelatedElement.isChildOf(eElement))) return;

				fpCallback(oEvent);
			}
		},
		/**

 * 브라우저마다 차이있는 이벤트 명을 보정하는 함수.
 * @ignore
 * @param {String} sType 이벤트 delegate인지 일반 이벤트인지 확인.
 * @param {String} sEvent 이벤트명

		 */
		revisionEvent : function(sType, sEvent){
			if (document.addEventListener !== undefined) {
				this.revisionEvent = function(sType, sEvent){
					sEvent = sEvent.toLowerCase();
					if (sEvent == "domready") {
						sEvent = "DOMContentLoaded";
					}else if (sEvent == "mousewheel" && !_JINDO_IS_WK && !_JINDO_IS_OP && !_JINDO_IS_IE) {
						/*

  IE9인 경우도 DOMMouseScroll이 동작하지 않음.

						 */
						sEvent = "DOMMouseScroll";
					}else if (sEvent == "mouseenter" && !_JINDO_IS_IE){
						sEvent = "mouseover";
					}else if (sEvent == "mouseleave" && !_JINDO_IS_IE){
						sEvent = "mouseout";
					}else if(sEvent == "transitionend"||sEvent == "transitionstart"){
						var sPrefix, sPostfix = sEvent.replace("transition","");

						sPostfix = sPostfix.substr(0,1).toUpperCase() + sPostfix.substr(1);

						if(document.body.style.WebkitTransition !== undefined){
							sPrefix = "webkit";
						}else if(document.body.style.OTransition !== undefined){
							sPrefix = "o";
						}else if(document.body.style.MsTransition !== undefined){
							sPrefix = "ms";
						}
						sEvent = (sPrefix?sPrefix+"Transition":"transition")+sPostfix;
					}else if(sEvent == "animationstart"||sEvent == "animationend"||sEvent == "animationiteration"){
						var sPrefix, sPostfix = sEvent.replace("animation","");

						sPostfix = sPostfix.substr(0,1).toUpperCase() + sPostfix.substr(1);

						if(document.body.style.WebkitAnimationName !== undefined){
							sPrefix = "webkit";
						}else if(document.body.style.OAnimationName !== undefined){
							sPrefix = "o";
						}else if(document.body.style.MsTransitionName !== undefined){
							sPrefix = "ms";
						}
						sEvent = (sPrefix?sPrefix+"Animation":"animation")+sPostfix;
					}else if("mousedown|mousemove|mouseup".indexOf(sEvent) > -1){
						sEvent = touch[sEvent];
					}
					return sEvent;
				}
			}else{
				this.revisionEvent = function(sType, sEvent){
					/*

  IE에서 delegate에 mouseenter나 mouseleave을 사용할 때는 mouseover나 mouseleave을 이용하여 에뮬레이션 하도록 수정해야 함.

					 */
					if (sType=="delegate"&&sEvent == "mouseenter"){
						sEvent = "mouseover";
					}else if (sType=="delegate"&&sEvent == "mouseleave"){
						sEvent = "mouseout";
					}else if("mousedown|mousemove|mouseup".indexOf(sEvent) > -1){
						sEvent = touch[sEvent];
					}
					return sEvent;
				}
			}
			return this.revisionEvent(sType, sEvent);
		},
		/**

 * 테스트를 위한 함수.
 * @ignore

		 */
		test : function(){
			return eventStore;
		},
		/**

		 * 키에 해당하는 함수가 초기화 되었는지 확인하는 함수.
		 * @param {String} sKey 엘리먼트 키값

		 */
		isInit : function(sKey){
			return !!eventStore[sKey];
		},
		/**

		 * 초기화 하는 함수.
		 * @ignore
		 * @param {String} sKey 엘리먼트 키값
		 * @param {Element} eEle 엘리먼트

		 */
		init : function(sKey, eEle){
			eventStore[sKey] = {
				"ele" : eEle,
				"event" : {}
			}
		},
		/**

		 * 키값의 해당하는 정보를 반환.
		 * @ignore
		 * @param {String} sKey 엘리먼트 키값

		 */
		getEventConfig : function(sKey){
			return eventStore[sKey];
		},
		/**

		 * 해당 키에 이벤트가 있는지 확인하는 함수.
		 * @ignore
		 * @param {String} sKey 엘리먼트 키값
		 * @param {String} sEvent 이벤트명

		 */
		hasEvent : function(sKey, sEvent){
			try{
				return !!eventStore[sKey]["event"][sEvent];
			}catch(e){
				return false;
			}
		},
		/**

		 * 해당 그룹이 있는지 확인하는 함수.
		 * @ignore
		 * @param {String} sKey 엘리먼트 키값
		 * @param {String} sEvent 이벤트 명
		 * @param {String} sEvent 그룹명

		 */
		hasGroup : function(sKey, sEvent, sGroup){
			return !!eventStore[sKey]["event"][sEvent]["type"][sGroup];
		},
		/**

		 * 이벤트를 초기화 하는 함수
		 * @ignore
		 * @param {Hash+} oThis this 객체
		 * @param {String} sEvent 이벤트 명
		 * @param {String} sEvent 그룹명

		 */
		initEvent : function(oThis, sEvent, sGroup){
			var sKey = oThis._key;
			var oEvent = eventStore[sKey]["event"];

			var fAroundFunc = bind(function(sEvent,wEvent){

				wEvent = wEvent || window.event;
				if (wEvent.currentTarget === undefined) {
					wEvent.currentTarget = this._element;
				}
				var weEvent = MobileCommentJindo.$Event(wEvent);
				if(!weEvent.currentElement){
					weEvent.currentElement = this._element;
				}
				var oEle = weEvent.element;
				var oManager = MobileCommentJindo.$Element.eventManager;
				var oConfig = oManager.getEventConfig(weEvent.currentElement.__jindo__id);

				var oType = oConfig["event"][sEvent].type;
				for(var i in oType){
					if(oType.hasOwnProperty(i)){
						var aNormal = oType[i].normal;
						for(var j = 0, l = aNormal.length; j < l; j++){
							aNormal[j](weEvent);
						}
						var oDelegate = oType[i].delegate;
						var aResultFilter;
						var afpFilterCallback;
						for(var k in oDelegate){
							if(oDelegate.hasOwnProperty(k)){
								aResultFilter = oDelegate[k].checker(oEle);
								if(aResultFilter[0]){
									afpFilterCallback = oDelegate[k].callback;
									weEvent.element = aResultFilter[1];
									for(var m = 0, leng = afpFilterCallback.length; m < leng ; m++){
										afpFilterCallback[m](weEvent);
									}
								}
							}
						}
					}

				}
			},oThis,[sEvent]);

			oEvent[sEvent] = {
				"listener" : fAroundFunc,
				"type" :{}
			}

			MobileCommentJindo.$Element._eventBind(oThis._element,sEvent,fAroundFunc,false);

		},
		/**

		 * 그룹을 초기화 하는 함수
		 * @ignore
		 * @param {String} sKey 엘리먼트 키값
		 * @param {String} sEvent 이벤트 명
		 * @param {String} sEvent 그룹명

		 */
		initGroup : function(sKey, sEvent, sGroup){
			var oType = eventStore[sKey]["event"][sEvent]["type"];
			oType[sGroup] = {
				"normal" : [],
				"delegate" :{}
			}
		},
		/**

		 * 이벤트를 추가하는 함수
		 * @ignore
		 * @param {String} ssKey 엘리먼트 키 값
		 * @param {String} sEvent 이벤트명
		 * @param {String} sGroup 그룹명
		 * @param {String} sType delegate인지 일반 이벤트인지 확인.
		 * @param {Function} vFilter 필터링하는 css선택자 혹은 필터함수
		 * @param {Function} fpCallback 콜백함수

		 */
		addEventListener : function(sKey, sEvent, sGroup, sType, vFilter, fpCallback){

			var oEventInfo = eventStore[sKey]["event"][sEvent]["type"][sGroup];

			if(sType === "normal"){
				oEventInfo.normal.push(fpCallback);
			}else if(sType === "delegate"){
				if(!this.hasDelegate(oEventInfo,vFilter)){
					this.initDelegate(eventStore[sKey].ele,oEventInfo,vFilter);
				}
				this.addDelegate(oEventInfo,vFilter,fpCallback);
			}

		},
		/**

		 * delegate가 있는지 확인하는 함수.
		 * @ignore
		 * @param {Hash+} oEventInfo 이벤트 정보객체
		 * @param {Function} vFilter 필터링하는 css선택자 혹은 필터함수

		 */
		hasDelegate : function(oEventInfo,vFilter){
			return !!oEventInfo.delegate[vFilter];
		},
		/**

		 * delegate를 초기화 하는 함수.
		 * @ignore
		 * @param {Hash+} eOwnEle
		 * @param {Hash+} oEventInfo 이벤트 정보객체
		 * @param {Function} vFilter 필터링하는 css선택자 혹은 필터함수

		 */
		initDelegate : function(eOwnEle,oEventInfo,vFilter){
			var fpCheck;
			if(MobileCommentJindo.$Jindo.isString(vFilter)){
				fpCheck = bind(function(eOwnEle,sCssquery,oEle){
					var eIncludeEle = oEle;
					var ___query = MobileCommentJindo.cssquery;
					var isIncludeEle = ___query.test(oEle, sCssquery);
					if(!isIncludeEle){
						var aPropagationElements = this._getParent(eOwnEle,oEle);
						for(var i = 0, leng = aPropagationElements.length ; i < leng ; i++){
							eIncludeEle = aPropagationElements[i];
							if(___query.test(eIncludeEle, sCssquery)){
								isIncludeEle = true;
								break;
							}
						}
					}
					return [isIncludeEle,eIncludeEle];
				},this,[eOwnEle,vFilter]);
			}else{
				fpCheck = bind(function(eOwnEle,fpFilter,oEle){
					var eIncludeEle = oEle;
					var isIncludeEle = fpFilter(eOwnEle,oEle);
					if(!isIncludeEle){
						var aPropagationElements = this._getParent(eOwnEle,oEle);
						for(var i = 0, leng = aPropagationElements.length ; i < leng ; i++){
							eIncludeEle = aPropagationElements[i];
							if(fpFilter(eOwnEle,eIncludeEle)){
								isIncludeEle = true;
								break;
							}
						}
					}
					return [isIncludeEle,eIncludeEle];
				},this,[eOwnEle,vFilter]);
			}
			oEventInfo.delegate[vFilter] = {
				"checker" : fpCheck,
				"callback" : []
			}
		},
		/**

		 * delegate를 추가하는 함수.
		 * @ignore
		 * @param {Hash+} oEventInfo 이벤트 정보객체
		 * @param {Function} vFilter 필터링하는 css선택자 혹은 필터함수
		 * @param {Function} fpCallback 콜백함수

		 */
		addDelegate : function(oEventInfo,vFilter,fpCallback){
			oEventInfo.delegate[vFilter].callback.push(fpCallback);
		},
		/**

		 * 이벤트를 해제하는 함수.
		 * @ignore
		 * @param {String} ssKey 엘리먼트 키 값
		 * @param {String} sEvent 이벤트명
		 * @param {String} sGroup 그룹명
		 * @param {String} sType delegate인지 일반 이벤트인지 확인.
		 * @param {Function} vFilter 필터링하는 css선택자 혹은 필터함수
		 * @param {Function} fpCallback 콜백함수

		 */
		removeEventListener : function(sKey, sEvent, sGroup, sType, vFilter, fpCallback){
			var oEventInfo;
			try{
				oEventInfo = eventStore[sKey]["event"][sEvent]["type"][sGroup];
			}catch(e){
				return;
			}
			var aNewCallback = [];
			var aOldCallback;
			if(sType === "normal"){
				aOldCallback = oEventInfo.normal;
			}else{
				aOldCallback  = oEventInfo.delegate[vFilter].callback;
			}
			if (sEvent == NONE_GROUP || MobileCommentJindo.$Jindo.isFunction(fpCallback)) {
				for(var i = 0, l = aOldCallback.length; i < l; i++){
					if((aOldCallback[i]._origin_||aOldCallback[i]) != fpCallback){
						aNewCallback.push(aOldCallback[i]);
					}
				}
			}
			if(sType === "normal"){

				delete oEventInfo.normal;
				oEventInfo.normal = aNewCallback;
			}else if(sType === "delegate"){
				delete oEventInfo.delegate[vFilter].callback;
				oEventInfo.delegate[vFilter].callback = aNewCallback;
			}

			this.cleanUp(sKey, sEvent);
		},
		/**

		 * 모든 이벤트를 해제하는 함수(절대 사용불가.)
		 * @ignore

		 */
		cleanUpAll : function(){
			var oEvent;
			for(var sKey in eventStore){
				if (eventStore.hasOwnProperty(sKey)) {
					this.cleanUpUsingKey(sKey, true);
				}
			}
		},
		/**

		 * 엘리먼트 키를 이용하여 모든 이벤트를 삭제할 때 사용.
		 * @ignore
		 * @param {String} sKey

		 */
		cleanUpUsingKey : function(sKey, bForce){
			var oEvent;
			try{
				oEvent = eventStore[sKey].event;
			}catch(e){
				return;
			}
			for(var sEvent in oEvent){
				if (oEvent.hasOwnProperty(sEvent)) {
					this.cleanUp(sKey, sEvent, bForce);
				}
			}
		},
		/**

		 * 키에 해당하는 모든 이벤트를 해제하는 함수(절대 사용불가)
		 * @ignore
		 * @param {String} ssKey 엘리먼트 키 값
		 * @param {String} sEvent 이벤트명
		 * @param {Boolean} bForce 강제로 해제할 것인지 여부

		 */
		cleanUp : function(sKey, sEvent, bForce){
			var oTypeInfo;
			try{
				oTypeInfo = eventStore[sKey]["event"][sEvent]["type"];
			}catch(e){
				return;

			}
			var oEventInfo;
			var bHasEvent = false;
			if(!bForce){
				for(var i in oTypeInfo){
					if (oTypeInfo.hasOwnProperty(i)) {
						oEventInfo = oTypeInfo[i];
						if(oEventInfo.normal.length){
							bHasEvent = true;
							break;
						}
						var oDele = oEventInfo.delegate;
						for(var j in oDele){
							if (oDele.hasOwnProperty(j)) {
								if(oDele[j].callback.length){
									bHasEvent = true;
									break;
								}
							}
						}
						if(bHasEvent) break;

					}
				}
			}
			if(!bHasEvent){
				MobileCommentJindo.$Element._unEventBind(eventStore[sKey].ele, sEvent, eventStore[sKey]["event"][sEvent]["listener"]);
				delete eventStore[sKey]["event"][sEvent];
				var bAllDetach = true;
				var oEvent = eventStore[sKey]["event"];
				for(var k in oEvent){
					if (oEvent.hasOwnProperty(k)) {
						bAllDetach = false;
						break;
					}
				}
				if(bAllDetach){
					delete eventStore[sKey];
				}
			}
		},
		/**

		 * 이벤트 명과 그룹을 구분하는 함수.
		 * @ignore
		 * @param {String} sEvent 이벤트명

		 */
		splitGroup : function(sEvent){
			var aMatch = /\s*(.+?)\s*\(\s*(.*?)\s*\)/.exec(sEvent);
			if(aMatch){
				return {
					"event" : aMatch[1].toLowerCase(),
					"group" : aMatch[2].toLowerCase()
				}
			}else{
				return {
					"event" : sEvent.toLowerCase(),
					"group" : NONE_GROUP
				}
			}
		},
		/**

		 * delegate에서 부모를 찾는 함수.
		 * @ignore
		 * @param {Element} oOwnEle 자신의 엘리먼트
		 * @param {Element} oEle 비교 엘리먼트

		 */
		_getParent : function(oOwnEle, oEle){
			var e = oOwnEle;
			var a = [], p = null;
			var oDoc = oEle.ownerDocument || oEle.document || document;
			while (oEle.parentNode && p != e) {
				p = oEle.parentNode;
				if (p == oDoc.documentElement) break;
				a[a.length] = p;
				oEle = p;
			}

			return a;
		}
	};
})();
/*

// $Element의 보관 구조.
//
// {
//	"key" : {
//		"ele" : ele,
//		"event" : {
//			"click":{
//				"listener" : function(){},
//				"type":{
//					"-none-" : {
//						"normal" : [],
//						"delegate" :{
//							"vFilter" :{
//								"checker" : function(){},
//								"callback" : [function(){}]
//							}
//
//						}
//					}
//				}
//			}
//		}
//	}
//}

 */
//-!MobileCommentJindo.$Element.event_etc.hidden end!-//

//-!MobileCommentJindo.$Element.domready.hidden start!-//
/**

 * Emulates the domready (=DOMContentLoaded) event in Internet Explorer.
 * @ignore

*/
MobileCommentJindo.$Element._domready = function(doc, func) {
	if (MobileCommentJindo.$Element._domready.list === undefined) {
		var f = null, l  = MobileCommentJindo.$Element._domready.list = [func];

		// use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		var done = false, execFuncs = function(){
			if(!done) {
				done = true;
				var evt = {
					type : "domready",
					target : doc,
					currentTarget : doc
				};

				while(f = l.shift()) f(evt);
			}
		};

		(function (){
			try {
				doc.documentElement.doScroll("left");
			} catch(e) {
				setTimeout(arguments.callee, 50);
				return;
			}
			execFuncs();
		})();

		// trying to always fire before onload
		doc.onreadystatechange = function() {
			if (doc.readyState == 'complete') {
				doc.onreadystatechange = null;
				execFuncs();
			}
		};

	} else {
		MobileCommentJindo.$Element._domready.list.push(func);
	}
};

//-!MobileCommentJindo.$Element.domready.hidden end!-//

//-!MobileCommentJindo.$Element.unload.hidden start!-//
/*

 * IE에서 unload시에 이벤트를 해제하지 않으면 메모리닉이 발생하여 unload시 이벤트를 해제하는 로직 추가.
 * 모바일에서는 unload를 설정하면 iOS5 미만의 모바일 사파리에서는 캐시가 적용안됨.

 */
if (!MobileCommentJindo.$Jindo.isUndefined(window)&& !(_j_ag.indexOf("IEMobile") == -1 && _j_ag.indexOf("Mobile") > -1 && _JINDO_IS_SP)) {
 	(new MobileCommentJindo.$Element(window)).attach("unload",function(e){
		MobileCommentJindo.$Element.eventManager.cleanUpAll();
	});
}
//-!MobileCommentJindo.$Element.unload.hidden end!-//



//-!MobileCommentJindo.$Element._getTransition.hidden start!-//
/**

 * @fileOverview $Element의 확장 메서드를 정의한 파일
 * @name element.extend.js

 */

/**

 * appear ,disappear에서 사용되는 함수로 현재 transition을 사용 할수 있는지를 학인한다.
 * @ignore

 */
MobileCommentJindo.$Element._getTransition = function(){
	var hasTransition = false , sTransitionName = "";

	if (document.body.style.trasition) {
		hasTransition = true;
		sTransitionName = "trasition";
	}
	/*

아직 firefox는 transitionEnd API를 지원 하지 않음.

	 */
	// else if(typeof document.body.style.MozTransition !== 'undefined'){
	// 	hasTransition = true;
	// 	sTransitionName = "MozTransition";
	// }
	else if(document.body.style.webkitTransition !== undefined){
		hasTransition = true;
		sTransitionName = "webkitTransition";
	}else if(document.body.style.OTransition !== undefined){
		hasTransition = true;
		sTransitionName = "OTransition";
	}
	return (MobileCommentJindo.$Element._getTransition = function(){
		return {
			"hasTransition" : hasTransition,
			"name" : sTransitionName
		};
	})();
};
//-!MobileCommentJindo.$Element._getTransition.hidden end!-//

//-!MobileCommentJindo.$Element.prototype.appear start(MobileCommentJindo.$Element._getTransition,MobileCommentJindo.$Element.prototype.opacity,MobileCommentJindo.$Element.prototype.show)!-//
/**

 * @description appear() 메서드는 HTML 요소를 서서히 나타나게 한다(Fade-in 효과). 인터넷 익스플로러 6 버전에서 filter를 사용하면서 해당 요소가 position 속성을 가지고 있으며 사라지는 문제가 있다. 이 경우에는 HTML 요소에 position 속성이 없어야 정상적으로 사용할 수 있다. Webkit 기반의 브라우저(Safari 5 버전 이상, Mobile Safari, Chrome, Mobile Webkit), Opear 10.60 버전 이상의 브라우저에서는 CSS3 transition 속성을 사용한다. 그 이외의 브라우저에서는 자바스크립트를 사용한다.
 *
 * @param1 {Void}
 * @return1 {$Element} 현재의 $Element() 객체
 *
 * @param2 {Numeric} nDuration HTML 요소가 완전히 나타날 때까지 걸리는 시간. 단위는 초(second)이다.
 * @return2 {$Element} 현재의 $Element() 객체
 *
 * @param3 {Numeric} nDuration HTML 요소가 완전히 나타날 때까지 걸리는 시간. 단위는 초(second)이다.
 * @param3 {Function} fCallback HTML 요소가 완전히 나타난 후에 실행할 콜백 함수.
 * @return3 {$Element} 현재의 $Element() 객체
 *
 * @see <a href="http://www.w3.org/TR/css3-transitions/">CSS Transitions</a> - W3C
 * @see $Element#show
 * @see $Element#disappear
 * @example
$Element("sample1").appear(5, function(){
	$Element("sample2").appear(3);
});

//Before
<div style="display: none; background-color: rgb(51, 51, 153); width: 100px; height: 50px;" id="sample1">
	<div style="display: none; background-color: rgb(165, 10, 81); width: 50px; height: 20px;" id="sample2">
	</div>
</div>

//After(1) : sample1 요소가 나타남
<div style="display: block; background-color: rgb(51, 51, 153); width: 100px; height: 50px; opacity: 1;" id="sample1">
	<div style="display: none; background-color: rgb(165, 10, 81); width: 50px; height: 20px;" id="sample2">
	</div>
</div>

//After(2) : sample2 요소가 나타남
<div style="display: block; background-color: rgb(51, 51, 153); width: 100px; height: 50px; opacity: 1;" id="sample1">
	<div style="display: block; background-color: rgb(165, 10, 81); width: 50px; height: 20px; opacity: 1;" id="sample2">
	</div>
</div>

 */
MobileCommentJindo.$Element.prototype.appear = function(duration, callback) {
	//-@@$Element.appear-@@//
	var oTransition = MobileCommentJindo.$Element._getTransition();
	function appear(){
		var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
			'4voi' : [ ],
			'4num' : [ 'nDuration:Numeric'],
			'4fun' : [ 'nDuration:Numeric' ,'fpCallback:Function+']
		},"$Element#appear");
		switch(oArgs+""){
			case "4voi":
				duration = 0.3;
				callback = function(){};
				break;
			case "4num":
				duration = oArgs.nDuration;
				callback = function(){};
				break;
			case "4fun":
				duration = oArgs.nDuration;

		}
		return [duration, callback];
	}
	if (oTransition.hasTransition) {
		MobileCommentJindo.$Element.prototype.appear = function(duration, callback) {
			var aOption = appear.apply(this,_toArray(arguments));
			duration = aOption[0];
			callback = aOption[1];
			var self = this;
			var ele = this._element;
			var name = oTransition.name;
			var bindFunc = function(){
				self.show();
				ele.style[name + 'Property'] = '';
				ele.style[name + 'Duration'] = '';
				ele.style[name + 'TimingFunction'] = '';
				ele.style.opacity = '';
				callback(self);
				ele.removeEventListener(name+"End", arguments.callee , false );
			};
			if(!this.visible()){
				ele.style.opacity = ele.style.opacity||0;
				self.show();
			}
			ele.addEventListener( name+"End", bindFunc , false );
			ele.style[name + 'Property'] = 'opacity';
			ele.style[name + 'Duration'] = duration+'s';
			ele.style[name + 'TimingFunction'] = 'linear';

			setTimeout(function(){
				ele.style.opacity = '1';
			},1);

			return this;
		}
	}else{
		MobileCommentJindo.$Element.prototype.appear = function(duration, callback) {
			var aOption = appear.apply(this,_toArray(arguments));
			duration = aOption[0];
			callback = aOption[1];
			var self = this;
			var op   = this.opacity();
			if(this._getCss(this._element,"display")=="none") op = 0;

			if (op == 1) return this;
			try { clearTimeout(this._fade_timer); } catch(e){};

			var step = (1-op) / ((duration||0.3)*100);
			var func = function(){
				op += step;
				self.opacity(op);

				if (op >= 1) {
					callback(self);
				} else {
					self._fade_timer = setTimeout(func, 10);
				}
			};

			this.show();
			func();
			return this;
		}
	}
	return this.appear.apply(this,arguments);

};
//-!MobileCommentJindo.$Element.prototype.appear end!-//

//-!MobileCommentJindo.$Element.prototype.disappear start(MobileCommentJindo.$Element._getTransition,MobileCommentJindo.$Element.prototype.opacity)!-//
/**

 * @description disappear() 메서드는 HTML 요소를 서서히 사라지게 한다(Fade-out 효과). HTML 요소가 완전히 사라지면 해당 요소의 display 속성은 none으로 변한다. Webkit 기반의 브라우저(Safari 5 버전 이상, Mobile Safari, Chrome, Mobile Webkit), Opear 10.6 버전 이상의 브라우저에서는 CSS3 transition 속성을 사용한다. 그 이외의 브라우저에서는 자바스크립트를 사용한다.
 *
 * @param1 {Void}
 * @return1 {$Element} 현재의 $Element() 객체.
 *
 * @param2 {Numeric} nDuration HTML 요소 완전히 사라질 때까지 걸리는 시간. 단위는 초를 사용한다.
 * @return2 {$Element} 현재의 $Element() 객체.
 *
 * @param3 {Numeric} nDuration HTML 요소 완전히 사라질 때까지 걸리는 시간. 단위는 초를 사용한다.
 * @param3 {Function} fCallback HTML 요소가 완전히 사라진 후에 실행할 콜백 함수.
 * @return3 {$Element} 현재의 $Element() 객체.
 *
 * @see <a href="http://www.w3.org/TR/css3-transitions/">CSS Transitions</a> - W3C
 * @see $Element#hide
 * @see $Element#appear
 * @example
$Element("sample1").disappear(5, function(){
	$Element("sample2").disappear(3);
});

//Before
<div id="sample1" style="background-color: rgb(51, 51, 153); width: 100px; height: 50px;">
</div>
<div id="sample2" style="background-color: rgb(165, 10, 81); width: 100px; height: 50px;">
</div>

//After(1) : sample1 요소가 사라짐
<div id="sample1" style="background-color: rgb(51, 51, 153); width: 100px; height: 50px; opacity: 1; display: none;">
</div>
<div id="sample2" style="background-color: rgb(165, 10, 81); width: 100px; height: 50px;">
</div>

//After(2) : sample2 요소가 사라짐
<div id="sample1" style="background-color: rgb(51, 51, 153); width: 100px; height: 50px; opacity: 1; display: none;">
</div>
<div id="sample2" style="background-color: rgb(165, 10, 81); width: 100px; height: 50px; opacity: 1; display: none;">
</div>

 */
MobileCommentJindo.$Element.prototype.disappear = function(duration, callback) {
	//-@@$Element.disappear-@@//
	var oTransition = MobileCommentJindo.$Element._getTransition();
	function disappear(){
		var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
			'4voi' : [ ],
			'4num' : [ 'nDuration:Numeric'],
			'4fun' : [ 'nDuration:Numeric' ,'fpCallback:Function+']
		},"$Element#disappear");
		switch(oArgs+""){
			case "4voi":
				duration = 0.3;
				callback = function(){};
				break;
			case "4num":
				duration = oArgs.nDuration;
				callback = function(){};
				break;
			case "4fun":
				duration = oArgs.nDuration;

		}
		return [duration, callback];
	}
	if (oTransition.hasTransition) {
		MobileCommentJindo.$Element.prototype.disappear = function(duration, callback) {
			var aOption = disappear.apply(this,_toArray(arguments));
			duration = aOption[0];
			callback = aOption[1];
			var self = this;
			var name = oTransition.name;
			var bindFunc = function(){
				self.hide();
				ele.style[name + 'Property'] = '';
				ele.style[name + 'Duration'] = '';
				ele.style[name + 'TimingFunction'] = '';
				ele.style.opacity = '';
				callback(self);
				this.removeEventListener(name+"End", arguments.callee , false );
			};
			var ele = this._element;
			ele.addEventListener( name+"End", bindFunc , false );


			ele.style[name + 'Property'] = 'opacity';
			ele.style[name + 'Duration'] = duration+'s';
			ele.style[name + 'TimingFunction'] = 'linear';
			/*

opera 버그로 인하여 아래와 같이 처리함.

			 */
			setTimeout(function(){
				ele.style.opacity = '0';
			},1);

			return this;
		}
	}else{
		MobileCommentJindo.$Element.prototype.disappear = function(duration, callback) {
			var aOption = disappear.apply(this,_toArray(arguments));
			duration = aOption[0];
			callback = aOption[1];

			var self = this;
			var op   = this.opacity();

			if (op == 0) return this;
			try { clearTimeout(this._fade_timer); } catch(e){};

			var step = op / ((duration||0.3)*100);
			var func = function(){
				op -= step;
				self.opacity(op);

				if (op <= 0) {
					self._element.style.display = "none";
					self.opacity(1);
					callback(self);
				} else {
					self._fade_timer = setTimeout(func, 10);
				}
			};

			func();

			return this;
		}
	}
	return this.disappear.apply(this,arguments);
};
//-!MobileCommentJindo.$Element.prototype.disappear end!-//

//-!MobileCommentJindo.$Element.prototype.offset start!-//
/**

 * @description offset() 메서드는 HTML 요소의 위치를 가져오거나 설정한다. 파라미터를 생략하면 해당 HTML 요소의 위치 값을 반환한다. 파라미터를 지정하면 HTML 요소의 위치를 설정한다. 위치를 결정하는 기준점은 브라우저가 페이지를 표시하는 화면의 왼쪽 위 모서리이다. HTML 요소가 보이는 상태(display)에서 적용해야 한다. 요소가 화면에 보이지 않으면 정상적으로 동작하지 않을 수 있다. 일부 브라우저와 일부 상황에서 inline 요소에 대한 위치를 올바르게 구하지 못하는 문제가 있으며 이 경우 해당 요소의 position 속성을 relative 값으로 바꿔서 해결할 수 있다.<br>
 다음은 위치 값을 반환할 때 반환되는 객체의 속성 설명이다.<br>
 <table>
	<caption>HTML 요소 위치 정보 객체의 속성</caption>
	<thead>
		<tr>
			<th scope="col">이름</th>
			<th scope="col">타입</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>top</td>
			<td>Number</td>
			<td>문서의 맨 위에서 HTML 요소의 윗 부분까지의 거리를 저장한다.</td>
		</tr>
		<tr>
			<td>left</td>
			<td>Number</td>
			<td>문서의 왼쪽 가장자리에서 HTML 요소의 왼쪽 가장자리까지의 거리를 저장한다.</td>
		</tr>
	</tbody>
</table>
 *
 * @param1 {Void}
 * @return1 {Hash+} HTML 요소의 위치 값을 객체로 반환한다.
 *
 * @param2 {Numeric} nTop 문서의 맨 위에서 HTML 요소의 윗 부분까지의 거리. 단위는 픽셀(px)이다.
 * @param2 {Numeric} nLeft 문서의 왼쪽 가장자리에서 HTML 요소의 왼쪽 가장자리까지의 거리. 단위는 픽셀(px)이다.
 * @return2 {$Element} 위치 값이 변경된 $Element() 객체를 반환한다.
 *
 * @example
<style type="text/css">
	div { background-color:#2B81AF; width:20px; height:20px; float:left; left:100px; top:50px; position:absolute;}
</style>

<div id="sample"></div>

...

// 위치 값 조회
$Element("sample").offset(); // { left=100, top=50 }

 * @example
// 위치 값 설정
$Element("sample").offset(40, 30);

//Before
<div id="sample"></div>

//After
<div id="sample" style="top: 40px; left: 30px;"></div>

 */
MobileCommentJindo.$Element.prototype.offset = function(nTop, nLeft) {
	//-@@$Element.offset-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'g' : [ ],
		's' : [ 'nTop:Numeric', 'nLeft:Numeric']
	},"$Element#offset");

	switch(oArgs+""){
		case "g":
			return this.offset_get();

		case "s":
			return this.offset_set(oArgs.nTop, oArgs.nLeft);

	}
};

MobileCommentJindo.$Element.prototype.offset_set = function(nTop,nLeft){
	var oEl = this._element;
	var oPhantom = null;

	if (isNaN(parseFloat(this._getCss(oEl,'top'),10))) oEl.style.top = "0px";
	if (isNaN(parseFloat(this._getCss(oEl,'left'),10))) oEl.style.left = "0px";

	var oPos = this.offset_get();
	var oGap = { top : nTop - oPos.top, left : nLeft - oPos.left };
	oEl.style.top = parseFloat(this._getCss(oEl,'top'),10) + oGap.top + 'px';
	oEl.style.left = parseFloat(this._getCss(oEl,'left'),10) + oGap.left + 'px';

	return this;
};

MobileCommentJindo.$Element.prototype.offset_get = function(nTop,nLeft){
	var oEl = this._element;
	var oPhantom = null;

	var bSafari = _JINDO_IS_SP;
	var bIE = _JINDO_IS_IE;
	var nVer = 0;
	if(bIE){
		if(document.documentMode){
			nVer = document.documentMode;
		}else{
			nVer = navigator.userAgent.match(/(?:MSIE) ([0-9.]+)/)[1];
		}
	}

	var fpSafari = function(oEl) {

		var oPos = { left : 0, top : 0 };

		for (var oParent = oEl, oOffsetParent = oParent.offsetParent; oParent = oParent.parentNode; ) {

			if (oParent.offsetParent) {

				oPos.left -= oParent.scrollLeft;
				oPos.top -= oParent.scrollTop;

			}

			if (oParent == oOffsetParent) {

				oPos.left += oEl.offsetLeft + oParent.clientLeft;
				oPos.top += oEl.offsetTop + oParent.clientTop ;

				if (!oParent.offsetParent) {

					oPos.left += oParent.offsetLeft;
					oPos.top += oParent.offsetTop;

				}

				oOffsetParent = oParent.offsetParent;
				oEl = oParent;
			}
		}

		return oPos;

	};

	var fpOthers = function(oEl) {
		var oPos = { left : 0, top : 0 };

		var oDoc = oEl.ownerDocument || oEl.document || document;
		var oHtml = oDoc.documentElement;
		var oBody = oDoc.body;

		if (oEl.getBoundingClientRect) { // has getBoundingClientRect
			if (!oPhantom) {
				var bHasFrameBorder = (window == top);
				if(!bHasFrameBorder){
					try{
						bHasFrameBorder = (window.frameElement && window.frameElement.frameBorder == 1);
					}catch(e){}
				}
				if ((bIE && nVer < 8 && window.external) && bHasFrameBorder) {
					oPhantom = { left : 2, top : 2 };
					oBase = null;
				} else {
					oPhantom = { left : 0, top : 0 };
				}
			}

			var box = oEl.getBoundingClientRect();
			if (oEl !== oHtml && oEl !== oBody) {

				oPos.left = box.left - oPhantom.left;
				oPos.top = box.top - oPhantom.top;
				oPos.left += oHtml.scrollLeft || oBody.scrollLeft;
				oPos.top += oHtml.scrollTop || oBody.scrollTop;

			}

		} else if (oDoc.getBoxObjectFor) { // has getBoxObjectFor
			var box = oDoc.getBoxObjectFor(oEl);
			var vpBox = oDoc.getBoxObjectFor(oHtml || oBody);

			oPos.left = box.screenX - vpBox.screenX;
			oPos.top = box.screenY - vpBox.screenY;

		} else {
			for (var o = oEl; o; o = o.offsetParent) {

				oPos.left += o.offsetLeft;
				oPos.top += o.offsetTop;

			}

			for (var o = oEl.parentNode; o; o = o.parentNode) {

				if (o.tagName == 'BODY') break;
				if (o.tagName == 'TR') oPos.top += 2;

				oPos.left -= o.scrollLeft;
				oPos.top -= o.scrollTop;

			}

		}

		return oPos;

	};

	return (bSafari ? fpSafari : fpOthers)(oEl);
};
//-!MobileCommentJindo.$Element.prototype.offset end!-//

//-!MobileCommentJindo.$Element.prototype.evalScripts start!-//
/**

 * @description evalScripts() 메서드는 문자열에 포함된 JavaScript 코드를 실행한다. &lt;script&gt; 태그가 포함된 문자열을 파라미터로 지정하면, &lt;script&gt; 안에 있는 내용을 파싱하여 eval() 메서드를 수행한다.
 * @param {String+} sHTML &lt;script&gt; 요소가 포함된 HTML 문자열.
 * @return {$Element} 현재의 $Element() 객체를 반환.
 * @example
// script 태그가 포함된 문자열을 지정
var response = "<script type='text/javascript'>$Element('sample').appendHTML('<li>4</li>')</script>";

$Element("sample").evalScripts(response);

//Before
<ul id="sample">
	<li>1</li>
	<li>2</li>
	<li>3</li>
</ul>

//After
<ul id="sample">
	<li>1</li>
	<li>2</li>
	<li>3</li>
<li>4</li></ul>

 */
MobileCommentJindo.$Element.prototype.evalScripts = function(sHTML) {
	//-@@$Element.evalScripts-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str' : [ "sHTML:String+" ]
	},"$Element#evalScripts");
	var aJS = [];
    sHTML = sHTML.replace(new RegExp('<script(\\s[^>]+)*>(.*?)</'+'script>', 'gi'), function(_1, _2, sPart) { aJS.push(sPart); return ''; });
    eval(aJS.join('\n'));

    return this;

};
//-!MobileCommentJindo.$Element.prototype.evalScripts end!-//

//-!MobileCommentJindo.$Element._common.hidden start!-//
/**
 * @ignore
 */
MobileCommentJindo.$Element._common = function(oElement,sMethod){

	try{
		return MobileCommentJindo.$Element(oElement)._element;
	}catch(e){
		throw TypeError(e.message.replace(/\$Element/g,"$Element#"+sMethod).replace(/Element\.html/g,"Element.html#"+sMethod));
	}
};
//-!MobileCommentJindo.$Element._common.hidden end!-//
//-!MobileCommentJindo.$Element._prepend.hidden start(MobileCommentJindo.$)!-//
/**

 * element를 앞에 붙일때 사용되는 함수.
 * @ignore
 * @param {Element} 기준 엘리먼트
 * @param {Element} 붙일 엘리먼트
 * @return {$Element} 두번째 파라메터의 엘리먼트

 */
MobileCommentJindo.$Element._prepend = function(oParent, oChild){
	var nodes = oParent.childNodes;
	if (nodes.length > 0) {
		oParent.insertBefore(oChild, nodes[0]);
	} else {
		oParent.appendChild(oChild);
	}
};
//-!MobileCommentJindo.$Element._prepend.hidden end!-//

//-!MobileCommentJindo.$Element.prototype.append start(MobileCommentJindo.$Element._common)!-//
/**

 * @description append() 메서드는 $Element() 객체에 있는 요소의 마지막 자식 노드로 파라미터로 지정한 HTML 요소를 배정한다.
 *
 * @param1 {String+} sId 마지막 자식 노드로 배정할 HTML 요소의 ID
 * @return1 {$Element} $Element() 객체.
 *
 * @param2 {Element+|Node} vElement 마지막 자식 노드로 배정할 HTML 요소(Element) 또는 $Element() 객체를 파라미터로 지정할 수 있다.
 * @return2 {$Element} $Element() 객체.
 *
 * @see $Element#prepend
 * @see $Element#before
 * @see $Element#after
 * @see $Element#appendTo
 * @see $Element#prependTo
 * @see $Element#wrap
 * @example
// ID가 sample1인 HTML 요소에
// ID가 sample2인 HTML 요소를 추가
$Element("sample1").append("sample2");

//Before
<div id="sample2">
    <div>Hello 2</div>
</div>
<div id="sample1">
    <div>Hello 1</div>
</div>

//After
<div id="sample1">
	<div>Hello 1</div>
	<div id="sample2">
		<div>Hello 2</div>
	</div>
</div>

 * @example
// ID가 sample인 HTML 요소에
// 새로운 DIV 요소를 추가
var elChild = $("<div>Hello New</div>");
$Element("sample").append(elChild);

//Before
<div id="sample">
	<div>Hello</div>
</div>

//After
<div id="sample">
	<div>Hello </div>
	<div>Hello New</div>
</div>

 */
MobileCommentJindo.$Element.prototype.append = function(oElement) {
	//-@@$Element.append-@@//
	this._element.appendChild(MobileCommentJindo.$Element._common(oElement,"append"));
	return this;
};
//-!MobileCommentJindo.$Element.prototype.append end!-//

//-!MobileCommentJindo.$Element.prototype.prepend start(MobileCommentJindo.$Element._prepend)!-//
/**

 * @description prepend() 메서드는 $Element() 객체에 있는 요소의 첫 번째 자식 노드로 파라미터로 지정한 HTML 요소를 배정한다.
 *
 * @param1 {String+} sId 첫 번째 자식 노드로 배정할 HTML 요소의 ID
 * @return1 {$Element} $Element() 객체.
 *
 * @param2 {Element+|Node} vElement 첫 번째 자식 노드로 배정할 HTML 요소(Element) 또는 $Element() 객체를 파라미터로 지정할 수 있다.
 * @return2 {$Element} $Element() 객체.
 *
 * @see $Element#append
 * @see $Element#before
 * @see $Element#after
 * @see $Element#appendTo
 * @see $Element#prependTo
 * @see $Element#wrap
 * @example
// ID가 sample1인 HTML 요소에서
// ID가 sample2인 HTML 요소를 첫 번째 자식 노드로 이동
$Element("sample1").prepend("sample2");

//Before
<div id="sample1">
    <div>Hello 1</div>
	<div id="sample2">
	    <div>Hello 2</div>
	</div>
</div>

//After
<div id="sample1">
	<div id="sample2">
	    <div>Hello 2</div>
	</div>
    <div>Hello 1</div>
</div>

 * @example
// ID가 sample인 HTML 요소에
// 새로운 DIV 요소를 추가
var elChild = $("<div>Hello New</div>");
$Element("sample").prepend(elChild);

//Before
<div id="sample">
	<div>Hello</div>
</div>

//After
<div id="sample">
	<div>Hello New</div>
	<div>Hello</div>
</div>

 */
MobileCommentJindo.$Element.prototype.prepend = function(oElement) {
	//-@@$Element.prepend-@@//
	MobileCommentJindo.$Element._prepend(this._element, MobileCommentJindo.$Element._common(oElement,"prepend"));

	return this;
};
//-!MobileCommentJindo.$Element.prototype.prepend end!-//

//-!MobileCommentJindo.$Element.prototype.replace start(MobileCommentJindo.$Element._common)!-//
/**

 * @description replace() 메서드는 $Element() 객체 내부의 HTML 요소를 지정한 파라미터의 요소로 대체한다.
 *
 * @param1 {String+} sId 대체할 HTML 요소의 ID
 * @return1 {$Element} $Element() 객체.
 *
 * @param2 {Element+|Node} vElement 대체할 HTML 요소(Element) 또는 $Element() 객체를 파라미터로 지정할 수 있다.
 * @return2 {$Element} $Element() 객체.
 *
 * @example
// ID가 sample1인 HTML 요소에서
// ID가 sample2인 HTML 요소로 대체
$Element('sample1').replace('sample2');

//Before
<div>
	<div id="sample1">Sample1</div>
</div>
<div id="sample2">Sample2</div>

//After
<div>
	<div id="sample2">Sample2</div>
</div>

 * @example
// 새로운 DIV 요소로 대체
$Element("btn").replace($("<div>Sample</div>"));

//Before
<button id="btn">Sample</button>

//After
<div>Sample</div>

 */
MobileCommentJindo.$Element.prototype.replace = function(oElement) {
	//-@@$Element.replace-@@//
	oElement = MobileCommentJindo.$Element._common(oElement,"replace");
	if(MobileCommentJindo.cssquery) MobileCommentJindo.cssquery.release();
	var e = this._element;
	var oParentNode = e.parentNode;
	if(oParentNode&&oParentNode.replaceChild){
		oParentNode.replaceChild(oElement,e);
		return this;
	}

	var _o = oElement;

	oParentNode.insertBefore(_o, e);
	oParentNode.removeChild(e);

	return this;
};
//-!MobileCommentJindo.$Element.prototype.replace end!-//

//-!MobileCommentJindo.$Element.prototype.appendTo start(MobileCommentJindo.$Element._common)!-//
/**

 * @description appendTo() 메서드는 $Element() 객체에 있는 요소를 파라미터로 지정한 요소의 마지막 자식 요소로 배정한다.
 *
 * @param1 {String+} sId 마지막 자식 노드가 배정 될 HTML 요소의 ID
 * @return1 {$Element} $Element() 객체.
 *
 * @param2 {Element+|Node} vElement 마지막 자식 노드가 배정 될 HTML 요소(Element) 또는 $Element() 객체를 파라미터로 지정할 수 있다.
 * @return2 {$Element} $Element() 객체.
 *
 * @see $Element#append
 * @see $Element#prepend
 * @see $Element#before
 * @see $Element#after
 * @see $Element#prependTo
 * @see $Element#wrap
 * @example
// ID가 sample2인 HTML 요소에
// ID가 sample1인 HTML 요소를 추가
$Element("sample1").appendTo("sample2");

//Before
<div id="sample1">
    <div>Hello 1</div>
</div>
<div id="sample2">
    <div>Hello 2</div>
</div>

//After
<div id="sample2">
    <div>Hello 2</div>
	<div id="sample1">
	    <div>Hello 1</div>
	</div>
</div>

 */
MobileCommentJindo.$Element.prototype.appendTo = function(oElement) {
	//-@@$Element.appendTo-@@//
	MobileCommentJindo.$Element._common(oElement,"appendTo").appendChild(this._element);
	return this;
};
//-!MobileCommentJindo.$Element.prototype.appendTo end!-//

//-!MobileCommentJindo.$Element.prototype.prependTo start(MobileCommentJindo.$Element._prepend, MobileCommentJindo.$Element._common)!-//
/**

 * @description prependTo() 메서드는 $Element() 객체에 있는 요소를 파라미터로 지정한 요소의 첫 번째 자식 노드로 배정한다.
 *
 * @param1 {String+} sId 첫 번째 자식 노드가 배정 될 HTML 요소의 ID
 * @return1 {$Element} $Element() 객체.
 *
 * @param2 {Element+|Node} vElement 첫 번째 자식 노드가 배정 될 HTML 요소(Element) 또는 $Element() 객체를 파라미터로 지정할 수 있다.
 * @return2 {$Element} $Element() 객체.
 *
 * @see $Element#append
 * @see $Element#prepend
 * @see $Element#before
 * @see $Element#after
 * @see $Element#appendTo
 * @see $Element#wrap
 * @example
// ID가 sample2인 HTML 요소에
// ID가 sample1인 HTML 요소를 추가
$Element("sample1").prependTo("sample2");

//Before
<div id="sample1">
    <div>Hello 1</div>
</div>
<div id="sample2">
    <div>Hello 2</div>
</div>

//After
<div id="sample2">
	<div id="sample1">
	    <div>Hello 1</div>
	</div>
    <div>Hello 2</div>
</div>

 */
MobileCommentJindo.$Element.prototype.prependTo = function(oElement) {
	//-@@$Element.prependTo-@@//
	MobileCommentJindo.$Element._prepend(MobileCommentJindo.$Element._common(oElement,"prependTo"), this._element);
	return this;
};
//-!MobileCommentJindo.$Element.prototype.prependTo end!-//

//-!MobileCommentJindo.$Element.prototype.before start(MobileCommentJindo.$Element._common)!-//
/**

 * @description before() 메서드는 $Element() 객체에 있는 요소의 이전 형제 노드(previousSibling)로 파라미터로 지정한 요소를 배정한다.
 *
 * @param1 {String+} sId 이전 형제 노드로 배정할 HTML 요소의 ID
 * @return1 {$Element} $Element() 객체.
 *
 * @param2 {Element+|Node} vElement 이전 형제 노드로 배정할 HTML 요소(Element) 또는 $Element() 객체를 파라미터로 지정할 수 있다.
 * @return2 {$Element} $Element() 객체.
 *
 * @see $Element#append
 * @see $Element#prepend
 * @see $Element#after
 * @see $Element#appendTo
 * @see $Element#prependTo
 * @see $Element#wrap
 * @example
// ID가 sample1인 HTML 요소 앞에
// ID가 sample2인 HTML 요소를 추가 함
$Element("sample1").before("sample2"); // sample2를 래핑한 $Element 를 반환

//Before
<div id="sample1">
    <div>Hello 1</div>
	<div id="sample2">
	    <div>Hello 2</div>
	</div>
</div>

//After
<div id="sample2">
	<div>Hello 2</div>
</div>
<div id="sample1">
  <div>Hello 1</div>
</div>

 * @example
// 새로운 DIV 요소를 추가
var elNew = $("<div>Hello New</div>");
$Element("sample").before(elNew); // elNew 요소를 래핑한 $Element 를 반환

//Before
<div id="sample">
	<div>Hello</div>
</div>

//After
<div>Hello New</div>
<div id="sample">
	<div>Hello</div>
</div>

 */
MobileCommentJindo.$Element.prototype.before = function(oElement) {
	//-@@$Element.before-@@//
	var o = MobileCommentJindo.$Element._common(oElement,"before");

	this._element.parentNode.insertBefore(o, this._element);

	return this;
};
//-!MobileCommentJindo.$Element.prototype.before end!-//

//-!MobileCommentJindo.$Element.prototype.after start(MobileCommentJindo.$Element.prototype.before, MobileCommentJindo.$Element._common)!-//
/**

 * @description after() 메서드는 $Element() 객체에 있는 요소의 다음 형제 노드(nextSibling)로 파라미터로 지정한 요소를 배정한다.
 *
 * @param1 {String+} sId 다음 형제 노드로 배정할 HTML 요소의 ID
 * @return1 {$Element} $Element() 객체.
 *
 * @param2 {Element+|Node} vElement 다음 형제 노드로 배정할 HTML 요소(Element) 또는 $Element() 객체를 파라미터로 지정할 수 있다.
 * @return2 {$Element} $Element() 객체.
 *
 * @see $Element#append
 * @see $Element#prepend
 * @see $Element#before
 * @see $Element#appendTo
 * @see $Element#prependTo
 * @see $Element#wrap
 * @example
// ID가 sample1인 HTML 요소 뒤에
// ID가 sample2인 HTML 요소를 추가 함
$Element("sample1").after("sample2");  // sample2를 래핑한 $Element 를 반환

//Before
<div id="sample1">
    <div>Hello 1</div>
	<div id="sample2">
	    <div>Hello 2</div>
	</div>
</div>

//After
<div id="sample1">
	<div>Hello 1</div>
</div>
<div id="sample2">
	<div>Hello 2</div>
</div>

 * @example
// 새로운 DIV 요소를 추가
var elNew = $("<div>Hello New</div>");
$Element("sample").after(elNew); // elNew 요소를 래핑한 $Element 를 반환

//Before
<div id="sample">
	<div>Hello</div>
</div>

//After
<div id="sample">
	<div>Hello</div>
</div>
<div>Hello New</div>

 */
MobileCommentJindo.$Element.prototype.after = function(oElement) {
	//-@@$Element.after-@@//
	oElement = MobileCommentJindo.$Element._common(oElement,"after");
	this.before(oElement);
	MobileCommentJindo.$Element(oElement).before(this);

	return this;
};
//-!MobileCommentJindo.$Element.prototype.after end!-//

//-!MobileCommentJindo.$Element.prototype.parent start!-//
/**

 * @description parent() 메서드는 HTML 요소의 상위 노드에 해당하는 요소를 검색한다.
 *
 * @param1 {Void}
 * @return1 {$Element} 부모 요소가 담긴 $Element() 객체.
 *
 * @param2 {Function+} fCallback 상위 요소의 검색 조건을 지정한 콜백 함수.<br>파라미터를 생략하면 부모 요소를 반환하고, 파라미터로 콜백 함수를 지정하면 콜백 함수의 실행 결과가 true를 반환하는 상위 요소를 반환한다. 이때 콜백 함수는 결과를 배열로 반환한다. 콜백 함수의 파라미터로 탐색 중인 상위 요소의 $Element() 객체가 입력된다.
 * @return2 {Variant} 부모 요소가 담긴 $Element() 객체 혹은 조건을 만족하는 상위 요소의 배열(Array).<br>파라미터를 생략하여 부모 요소를 반환하는 경우, $Element() 객체로 반환하고 그 이외에는 $Element() 객체를 원소로 갖는 배열로 반환한다.
 *
 * @param3 {Function+} fCallback 상위 요소의 검색 조건을 지정한 콜백 함수.<br>파라미터를 생략하면 부모 요소를 반환하고, 파라미터로 콜백 함수를 지정하면 콜백 함수의 실행 결과가 true를 반환하는 상위 요소를 반환한다. 이때 콜백 함수는 결과를 배열로 반환한다. 콜백 함수의 파라미터로 탐색 중인 상위 요소의 $Element() 객체가 입력된다.
 * @param3 {Numeric} nLimit 탐색할 상위 요소의 레벨.<br>파라미터를 생략하면 모든 상위 요소를 탐색한다. fCallback 파라미터를 null로 설정하고 nLimit 파라미터를 설정하면 제한된 레벨의 상위 요소를 조건없이 검색한다.
 * @return3 {Variant} 부모 요소가 담긴 $Element() 객체 혹은 조건을 만족하는 상위 요소의 배열(Array).<br>파라미터를 생략하여 부모 요소를 반환하는 경우, $Element() 객체로 반환하고 그 이외에는 $Element() 객체를 원소로 갖는 배열로 반환한다.
 *
 * @see $Element#child
 * @see $Element#prev
 * @see $Element#next
 * @see $Element#first
 * @see $Element#last
 * @see $Element#indexOf
 * @example
<div class="sample" id="div1">
	<div id="div2">
		<div class="sample" id="div3">
			<div id="target">
				Sample
				<div id="div4">
					Sample
				</div>
				<div class="sample" id="div5">
					Sample
				</div>
			</div>
			<div class="sample" id="div6">
				Sample
			</div>
		</div>
	</div>
</div>

<script type="text/javascript">
	var welTarget = $Element("target");
	var parent = welTarget.parent();
	// ID가 div3인 DIV를 래핑한 $Element를 반환

	parent = welTarget.parent(function(v){
	        return v.hasClass("sample");
	    });
	// ID가 div3인 DIV를 래핑한 $Element와
	// ID가 div1인 DIV를 래핑한 $Element를 원소로 하는 배열을 반환

	parent = welTarget.parent(function(v){
	        return v.hasClass("sample");
	    }, 1);
	// ID가 div3인 DIV를 래핑한 $Element를 원소로 하는 배열을 반환
</script>

 */
MobileCommentJindo.$Element.prototype.parent = function(pFunc, limit) {
	//-@@$Element.parent-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4voi' : [],
		'4fun' : [ 'fpFunc:Function+' ],
		'4nul' : [ 'fpFunc:Null' ],
		'for_function_number' : [ 'fpFunc:Function+', 'nLimit:Numeric'],
		'for_null_number' : [ 'fpFunc:Null', 'nLimit:Numeric' ]
	},"$Element#parent");

	var e = this._element;

	switch(oArgs+""){
		case "4voi":
			return e.parentNode?MobileCommentJindo.$Element(e.parentNode):null;
		case "4fun":
		case "4nul":
			 limit = -1;
			 break;
		case "for_function_number":
		case "for_null_number":
			if(oArgs.nLimit==0)limit = -1;

	}


	var a = [], p = null;

	while (e.parentNode && limit-- != 0) {
		try{
			p = MobileCommentJindo.$Element(e.parentNode);
		}catch(e){
			p = null;
		}
		if (e.parentNode == document.documentElement) break;
		if (!pFunc || (pFunc && pFunc(p))) a[a.length] = p;

		e = e.parentNode;
	}
	return a;
};
//-!MobileCommentJindo.$Element.prototype.parent end!-//

//-!MobileCommentJindo.$Element.prototype.child start!-//
/**

 * @description child() 메서드는 HTML 요소의 하위 노드에 해당하는 요소를 검색한다.
 *
 * @param1 {Void}
 * @return1 {Variant} 자식 요소가 담긴 배열(Array)<br>$Element() 객체를 원소로 갖는 배열로 반환한다.
 *
 * @param2 {Function+} fCallback 하위 요소의 검색 조건을 지정한 콜백 함수.<br>파라미터를 생략하면 자식 요소를 반환하고, 파라미터로 콜백 함수를 지정하면 콜백 함수의 실행 결과가 true를 반환하는 하위 요소를 반환한다. 이때 콜백 함수는 결과를 배열로 반환한다. 콜백 함수의 파라미터로 탐색 중인 하위 요소의 $Element() 객체가 입력된다.
 * @return2 {Variant} 자식 요소가 담긴 배열(Array) 혹은 조건을 만족하는 하위 요소의 배열(Array).<br>하나의 하위 요소를 반환할 때는 $Element() 객체를 반환하고 그 이외에는 $Element() 객체를 원소로 갖는 배열로 반환한다.
 *
 * @param3 {Function+} fCallback 하위 요소의 검색 조건을 지정한 콜백 함수.<br>파라미터를 생략하면 자식 요소를 반환하고, 파라미터로 콜백 함수를 지정하면 콜백 함수의 실행 결과가 true를 반환하는 하위 요소를 반환한다. 이때 콜백 함수는 결과를 배열로 반환한다. 콜백 함수의 파라미터로 탐색 중인 하위 요소의 $Element() 객체가 입력된다.
 * @param3 {Numeric} nLimit 탐색할 하위 요소의 레벨.<br>파라미터를 생략하면 모든 하위 요소를 탐색한다. fCallback 파라미터를 null로 설정하고 nLimit 파라미터를 설정하면 제한된 레벨의 하위 요소를 조건없이 검색한다.
 * @return3 {Variant} 자식 요소가 담긴 배열(Array) 혹은 조건을 만족하는 하위 요소의 배열(Array).<br>하나의 하위 요소를 반환할 때는 $Element() 객체를 반환하고 그 이외에는 $Element() 객체를 원소로 갖는 배열로 반환한다.
 *
 * @see $Element#parent
 * @see $Element#prev
 * @see $Element#next
 * @see $Element#first
 * @see $Element#last
 * @see $Element#indexOf
 * @example
<div class="sample" id="target">
	<div id="div1">
		<div class="sample" id="div2">
			<div id="div3">
				Sample
				<div id="div4">
					Sample
				</div>
				<div class="sample" id="div5">
					Sample
					<div class="sample" id="div6">
						Sample
					</div>
				</div>
			</div>
		</div>
	</div>
	<div class="sample" id="div7">
		Sample
	</div>
</div>

<script type="text/javascript">
	var welTarget = $Element("target");
	var child = welTarget.child();
	// ID가 div1인 DIV를 래핑한 $Element와
	// ID가 div7인 DIV를 래핑한 $Element를 원소로 하는 배열을 반환

	child = welTarget.child(function(v){
	        return v.hasClass("sample");
	    });
	// ID가 div2인 DIV를 래핑한 $Element와
	// ID가 div5인 DIV를 래핑한 $Element와
	// ID가 div6인 DIV를 래핑한 $Element와
	// ID가 div7인 DIV를 래핑한 $Element를 원소로 하는 배열을 반환

	child = welTarget.child(function(v){
	        return v.hasClass("sample");
	    }, 1);
	// ID가 div7인 DIV를 래핑한 $Element를 원소로 하는 배열을 반환

	child = welTarget.child(function(v){
	        return v.hasClass("sample");
	    }, 2);
	// ID가 div2인 DIV를 래핑한 $Element와
	// ID가 div7인 DIV를 래핑한 $Element를 원소로 하는 배열을 반환
</script>

 */
MobileCommentJindo.$Element.prototype.child = function(pFunc, limit) {
	//-@@$Element.child-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4voi' : [],
		'4fun' : [ 'fpFunc:Function+' ],
		'4nul' : [ 'fpFunc:Null' ],
		'for_function_number' : [ 'fpFunc:Function+', 'nLimit:Numeric'],
		'for_null_number' : [ 'fpFunc:Null', 'nLimit:Numeric' ]
	},"$Element#child");
	var e = this._element;
	var a = [], c = null, f = null;

	switch(oArgs+""){
		case "4voi":
			var child = e.childNodes;
			var filtered = [];
			for(var  i = 0, l = child.length ; i < l ; i++){
				if(child[i].nodeType == 1){
					try{
						filtered.push(MobileCommentJindo.$Element(child[i]));
					}catch(e){
						filtered.push(null);
					}
				}
			}
			return filtered;
		case "4fun":
		case "4nul":
			 limit = -1;
			 break;
		case "for_function_number":
		case "for_null_number":
			if(oArgs.nLimit==0)limit = -1;

	}

	(f = function(el, lim){
		var ch = null, o = null;

		for(var i=0; i < el.childNodes.length; i++) {
			ch = el.childNodes[i];
			if (ch.nodeType != 1) continue;
			try{
				o = MobileCommentJindo.$Element(el.childNodes[i]);
			}catch(e){
				o = null;
			}
			if (!pFunc || (pFunc && pFunc(o))) a[a.length] = o;
			if (lim != 0) f(el.childNodes[i], lim-1);
		}
	})(e, limit-1);

	return a;
};
//-!MobileCommentJindo.$Element.prototype.child end!-//

//-!MobileCommentJindo.$Element.prototype.prev start!-//
/**

 * @description prev() 메서드는 HTML 요소의 이전 형제 노드에 해당하는 요소를 검색한다.
 *
 * @param1 {Void}
 * @return1 {$Element} 바로 이전 형제 요소가 담긴 $Element() 객체. 만약 엘리먼트가 없으면 null을 반환.
 *
 * @param2 {Null} fCallback null인 경우 모든 이전 형제노드를 반환한다.
 * @return2 {Variant} 이전 형제 요소의 배열(Array).<br>$Element() 객체를 원소로 갖는 배열로 반환한다.
 *
 * @param3 {Function+} fCallback 이전 형제 요소의 검색 조건을 지정한 콜백 함수.<br>파라미터로 콜백 함수를 지정하면 콜백 함수의 실행 결과가 true를 반환하는 이전 형제 요소를 반환한다. 이때 콜백 함수는 결과를 배열로 반환한다. 콜백 함수의 파라미터로 탐색 중인 이전 형제 요소의 $Element() 객체가 입력된다.
 * @return3 {Variant} 조건을 만족하는 이전 형제 요소의 배열(Array).<br>$Element() 객체를 원소로 갖는 배열로 반환한다.
 *
 * @see $Element#parent
 * @see $Element#child
 * @see $Element#next
 * @see $Element#first
 * @see $Element#last
 * @see $Element#indexOf
 * @example
<div class="sample" id="sample_div1">
	<div id="sample_div2">
		<div class="sample" id="sample_div3">
			Sample1
		</div>
		<div id="sample_div4">
			Sample2
		</div>
		<div class="sample" id="sample_div5">
			Sample3
		</div>
		<div id="sample_div">
			Sample4
			<div id="sample_div6">
				Sample5
			</div>
		</div>
		<div id="sample_div7">
			Sample6
		</div>
		<div class="sample" id="sample_div8">
			Sample7
		</div>
	</div>
</div>

<script type="text/javascript">
	var sibling = $Element("sample_div").prev();
	// ID가 sample_div5인 DIV를 래핑한 $Element를 반환

	sibling = $Element("sample_div").prev(function(v){
	    return $Element(v).hasClass("sample");
	});
	// ID가 sample_div5인 DIV를 래핑한 $Element와
	// ID가 sample_div3인 DIV를 래핑한 $Element를 원소로 하는 배열을 반환
</script>

 */
MobileCommentJindo.$Element.prototype.prev = function(pFunc) {
	//-@@$Element.prev-@@//

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4voi' : [],
		'4fun' : [ 'fpFunc:Function+' ],
		'4nul' : [ 'fpFunc:Null' ]
	},"$Element#prev");

	var e = this._element;
	var a = [];

	switch(oArgs+""){
		case "4voi":
			if (!e) return null;
			do {

				e = e.previousSibling;
				if (!e || e.nodeType != 1) continue;
				try{
					if(e==null) return null;
					return MobileCommentJindo.$Element(e);
				}catch(e){
					return null;
				}
			} while(e);
			try{
				if(e==null) return null;
				return MobileCommentJindo.$Element(e);
			}catch(e){
				return null;
			}
		case "4fun":
		case "4nul":
			if (!e) return a;
			do {
				e = e.previousSibling;

				if (!e || e.nodeType != 1) continue;
				if (!pFunc||pFunc(e)) {

					try{
						if(e==null) a[a.length]=null;
						else a[a.length] = MobileCommentJindo.$Element(e);
					}catch(e){
						a[a.length] = null;
					}

				}
			} while(e);
			try{
				return a;
			}catch(e){
				return null;
			}
	}
};
//-!MobileCommentJindo.$Element.prototype.prev end!-//

//-!MobileCommentJindo.$Element.prototype.next start!-//
/**

 * @description next() 메서드는 HTML 요소의 다음 형제 노드에 해당하는 요소를 검색한다.
 *
 * @param1 {Void}
 * @return1 {$Element} 바로 다음 형제 요소가 담긴 $Element() 객체.만약 엘리먼트가 없으면 null을 반환.
 *
 * @param2 {Null} fCallback null인 경우 모든 다음 형제노드를 반환한다.
 * @return2 {Variant} 다음 형제 요소의 배열(Array).<br>$Element() 객체를 원소로 갖는 배열로 반환한다.
 *
 * @param3 {Function+} fCallback 다음 형제 요소의 검색 조건을 지정한 콜백 함수.<br>파라미터로 콜백 함수를 지정하면 콜백 함수의 실행 결과가 true를 반환하는 다음 형제 요소를 반환한다. 이때 콜백 함수는 결과를 배열로 반환한다. 콜백 함수의 파라미터로 탐색 중인 다음 형제 요소의 $Element() 객체가 입력된다.
 * @return3 {Variant} 조건을 만족하는 다음 형제 요소의 배열(Array).<br>$Element() 객체를 원소로 갖는 배열로 반환한다.
 *
 * @see $Element#parent
 * @see $Element#child
 * @see $Element#prev
 * @see $Element#first
 * @see $Element#last
 * @see $Element#indexOf
 * @example
<div class="sample" id="sample_div1">
	<div id="sample_div2">
		<div class="sample" id="sample_div3">
			Sample1
		</div>
		<div id="sample_div4">
			Sample2
		</div>
		<div class="sample" id="sample_div5">
			Sample3
		</div>
		<div id="sample_div">
			Sample4
			<div id="sample_div6">
				Sample5
			</div>
		</div>
		<div id="sample_div7">
			Sample6
		</div>
		<div class="sample" id="sample_div8">
			Sample7
		</div>
	</div>
</div>

<script type="text/javascript">
	var sibling = $Element("sample_div").next();
	// ID가 sample_div7인 DIV를 래핑한 $Element를 반환

	sibling = $Element("sample_div").next(function(v){
	    return $Element(v).hasClass("sample");
	});
	// ID가 sample_div8인 DIV를 래핑한 $Element를 원소로 하는 배열을 반환
</script>

 */
MobileCommentJindo.$Element.prototype.next = function(pFunc) {
	//-@@$Element.next-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4voi' : [],
		'4fun' : [ 'fpFunc:Function+' ],
		'4nul' : [ 'fpFunc:Null' ]
	},"$Element#next");
	var e = this._element;
	var a = [];

	switch(oArgs+""){
		case "4voi":
			if (!e) return null;
			do {
				e = e.nextSibling;
				if (!e || e.nodeType != 1) continue;
				try{
					if(e==null) return null;
					return MobileCommentJindo.$Element(e);
				}catch(e){
					return null;
				}
			} while(e);
			try{
				if(e==null) return null;
				return MobileCommentJindo.$Element(e);
			}catch(e){
				return null;
			}

		case "4fun":
		case "4nul":
			if (!e) return a;
			do {
				e = e.nextSibling;

				if (!e || e.nodeType != 1) continue;
				if (!pFunc||pFunc(e)) {

					try{
						if(e==null) a[a.length] = null;
						else a[a.length] = MobileCommentJindo.$Element(e);
					}catch(e){
						a[a.length] = null;
					}

				}
			} while(e);
			try{
				return a;
			}catch(e){
				return null;
			}

	}
};
//-!MobileCommentJindo.$Element.prototype.next end!-//

//-!MobileCommentJindo.$Element.prototype.first start!-//
/**

 * @description first() 메서드는 HTML 요소의 첫 번째 자식 노드에 해당하는 요소를 반환한다.
 * @return {$Element} 첫 번째 자식 노드에 해당하는 요소.만약 엘리먼트가 없으면 null을 반환.
 * @since 1.2.0
 * @see $Element#parent
 * @see $Element#child
 * @see $Element#prev
 * @see $Element#next
 * @see $Element#last
 * @see $Element#indexOf
 * @example
<div id="sample_div1">
	<div id="sample_div2">
		<div id="sample_div">
			Sample1
			<div id="sample_div3">
				<div id="sample_div4">
					Sample2
				</div>
				Sample3
			</div>
			<div id="sample_div5">
				Sample4
				<div id="sample_div6">
					Sample5
				</div>
			</div>
		</div>
	</div>
</div>

<script type="text/javascript">
	var firstChild = $Element("sample_div").first();
	// ID가 sample_div3인 DIV를 래핑한 $Element를 반환
</script>

 */
MobileCommentJindo.$Element.prototype.first = function() {
	//-@@$Element.first-@@//
	var el = this._element.firstElementChild||this._element.firstChild;
	if (!el) return null;
	while(el && el.nodeType != 1) el = el.nextSibling;
	try{
		return el?MobileCommentJindo.$Element(el):null;
	}catch(e){
		return null;
	}
};
//-!MobileCommentJindo.$Element.prototype.first end!-//

//-!MobileCommentJindo.$Element.prototype.last start!-//
/**

 * @description last() 메서드는 HTML 요소의 마지막 자식 노드에 해당하는 요소를 반환한다.
 * @return {$Element} 마지막 자식 노드에 해당하는 요소.만약 엘리먼트가 없으면 null을 반환.
 * @since 1.2.0
 * @see $Element#parent
 * @see $Element#child
 * @see $Element#prev
 * @see $Element#next
 * @see $Element#first
 * @see $Element#indexOf
 * @example
<div id="sample_div1">
	<div id="sample_div2">
		<div id="sample_div">
			Sample1
			<div id="sample_div3">
				<div id="sample_div4">
					Sample2
				</div>
				Sample3
			</div>
			<div id="sample_div5">
				Sample4
				<div id="sample_div6">
					Sample5
				</div>
			</div>
		</div>
	</div>
</div>

<script type="text/javascript">
	var lastChild = $Element("sample_div").last();
	// ID가 sample_div5인 DIV를 래핑한 $Element를 반환
</script>

 */
MobileCommentJindo.$Element.prototype.last = function() {
	//-@@$Element.last-@@//
	var el = this._element.lastElementChild||this._element.lastChild;
	if (!el) return null;
	while(el && el.nodeType != 1) el = el.previousSibling;

	try{
		return el?MobileCommentJindo.$Element(el):null;
	}catch(e){
		return null;
	}
};
//-!MobileCommentJindo.$Element.prototype.last end!-//

//-!MobileCommentJindo.$Element._contain.hidden start!-//
/**

 * isChildOf , isParentOf의 기본이 되는 API(IE에서는 contains,기타 브라우져에는 compareDocumentPosition을 사용하고 둘다 없는 경우는 기존 레거시 API사용.)
 * @param {HTMLElement} eParent	부모노드
 * @param {HTMLElement} eChild	자식노드
 * @ignore

 */
MobileCommentJindo.$Element._contain = function(eParent,eChild){
	if (document.compareDocumentPosition) {
		return !!(eParent.compareDocumentPosition(eChild)&16);
	}else if(eParent.contains){
		return (eParent !== eChild)&&(eParent.contains ? eParent.contains(eChild) : true);
	}else if(document.body.contains){
		if(eParent===(eChild.ownerDocument || eChild.document)&&eChild.tagName&&eChild.tagName.toUpperCase()==="BODY"){ return true;}//document에서 body찾을 때
		if(eParent.nodeType === 9&&eParent!==eChild){
			eParent = eParent.body;
		}
		try{
			return (eParent !== eChild)&&(eParent.contains ? eParent.contains(eChild) : true);
		}catch(e){
			return false;
		}
	}else{
		var e  = eParent;
		var el = eChild;

		while(e && e.parentNode) {
			e = e.parentNode;
			if (e == el) return true;
		}
		return false;
	}
};
//-!MobileCommentJindo.$Element._contain.hidden end!-//

//-!MobileCommentJindo.$Element.prototype.isChildOf start(MobileCommentJindo.$Element._contain)!-//
/**

 * @description isChildOf() 메서드는 파라미터로 지정한 요소가 HTML 요소의 부모 노드인지 검사한다.
 *
 * @param1 {String+} sElement 부모 노드인지 검사할 HTML 요소의 ID
 * @return1 {Boolean} 지정한 요소가 부모 요소이면 true, 그렇지 않으면 false를 반환한다.
 *
 * @param2 {Element+} elElement 부모 노드인지 검사할 HTML 요소
 * @return2 {Boolean} 지정한 요소가 부모 요소이면 true, 그렇지 않으면 false를 반환한다.
 *
 * @see $Element#isParentOf
 * @example
<div id="parent">
	<div id="child">
		<div id="grandchild"></div>
	</div>
</div>
<div id="others"></div>

...

// 부모/자식 확인하기
$Element("child").isChildOf("parent");		// 결과 : true
$Element("others").isChildOf("parent");		// 결과 : false
$Element("grandchild").isChildOf("parent");	// 결과 : true

 */
MobileCommentJindo.$Element.prototype.isChildOf = function(element) {
	//-@@$Element.isChildOf-@@//
	try{
		return MobileCommentJindo.$Element._contain(MobileCommentJindo.$Element(element)._element,this._element);
	}catch(e){
		return false;
	}
};
//-!MobileCommentJindo.$Element.prototype.isChildOf end!-//

//-!MobileCommentJindo.$Element.prototype.isParentOf start(MobileCommentJindo.$Element._contain)!-//
/**

 * @description isParentOf() 메서드는 파라미터로 지정한 요소가 HTML 요소의 자식 노드인지 검사한다.
 *
 * @param1 {String+} sElement 자식 노드인지 검사할 HTML 요소의 ID
 * @return1 {Boolean} 지정한 요소가 자식 요소이면 true, 그렇지 않으면 false를 반환한다.
 *
 * @param2 {Element+} elElement 자식 노드인지 검사할 HTML 요소
 * @return2 {Boolean} 지정한 요소가 자식 요소이면 true, 그렇지 않으면 false를 반환한다.
 *
 * @see $Element#isChildOf
 * @example
<div id="parent">
	<div id="child"></div>
</div>
<div id="others"></div>

...

// 부모/자식 확인하기
$Element("parent").isParentOf("child");		// 결과 : true
$Element("others").isParentOf("child");		// 결과 : false
$Element("parent").isParentOf("grandchild");// 결과 : true

 */
MobileCommentJindo.$Element.prototype.isParentOf = function(element) {
	//-@@$Element.isParentOf-@@//
	try{
		return MobileCommentJindo.$Element._contain(this._element, MobileCommentJindo.$Element(element)._element);
	}catch(e){
		return false;
	}
};
//-!MobileCommentJindo.$Element.prototype.isParentOf end!-//

//-!MobileCommentJindo.$Element.prototype.isEqual start!-//
/**

 * @description isEqual() 메서드는 파라미터로 지정한 요소가 HTML 요소와 같은 요소인지 검사한다. DOM Level 3 명세의 API 중 isSameNode 함수와 같은 메서드로 레퍼런스까지 확인한다. isEqualNode() 메서드와는 다른 함수이기 때문에 주의한다.
 *
 * @param1 {String+} vElement 같은 요소인지 비교할 HTML 요소의 ID.
 * @return1 {Boolean} 지정한 요소와 같은 요소이면 true, 그렇지 않으면 false를 반환한다.
 *
 * @param2 {Element+} vElement 같은 요소인지 비교할 HTML 요소.
 * @return2 {Boolean} 지정한 요소와 같은 요소이면 true, 그렇지 않으면 false를 반환한다.
 *
 * @see <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isSameNode">isSameNode</a> - W3C DOM Level 3 Specification
 * @see $Element#isEqualnode
 * @example
<div id="sample1"><span>Sample</span></div>
<div id="sample2"><span>Sample</span></div>

...

// 같은 HTML 요소인지 확인
var welSpan1 = $Element("sample1").first();	// <span>Sample</span>
var welSpan2 = $Element("sample2").first();	// <span>Sample</span>

welSpan1.isEqual(welSpan2); // 결과 : false
welSpan1.isEqual(welSpan1); // 결과 : true

 */
MobileCommentJindo.$Element.prototype.isEqual = function(element) {
	//-@@$Element.isEqual-@@//
	try {
		return (this._element === MobileCommentJindo.$Element(element)._element);
	} catch(e) {
		return false;
	}
};
//-!MobileCommentJindo.$Element.prototype.isEqual end!-//

//-!MobileCommentJindo.$Element.prototype.fireEvent start!-//
/**

 * @description fireEvent() 메서드는 HTML 요소에 이벤트를 발생시킨다. 파라미터로 발생시킬 이벤트 종류와 이벤트 객체의 속성을 지정할 수 있다.
 *
 * @param1 {String+} sEvent 발생시킬 이벤트 이름. on 접두사는 생략한다.
 * @return1 {$Element} 이벤트가 발생한 HTML 요소의 $Element() 객체.
 *
 * @param2 {String+} sEvent 발생시킬 이벤트 이름. on 접두사는 생략한다.
 * @param2 {Hash+} oProps 이벤트 객체의 속성을 지정한 객체. 이벤트를 발생시킬 때 속성을 설정할 수 있다.
 * @return2 {$Element} 이벤트가 발생한 HTML 요소의 $Element() 객체.
 *
 * @since 1.4.1 버전부터 keyCode 값을 설정할 수 있다. WebKit 계열에서는 이벤트 객체의 keyCode가 읽기 전용(read-only)인 관계로 key 이벤트를 발생시킬 경우 keyCode 값을 설정할 수 없었다.
 * @example
$Element("div").fireEvent("click", {left : true, middle : false, right : false}); // click 이벤트 발생
$Element("div").fireEvent("mouseover", {screenX : 50, screenY : 50, clientX : 50, clientY : 50}); // mouseover 이벤트 발생
$Element("div").fireEvent("keydown", {keyCode : 13, alt : true, shift : false ,meta : false, ctrl : true}); // keydown 이벤트 발생

 */
MobileCommentJindo.$Element.prototype.fireEvent = function(sEvent, oProps) {
	//-@@$Element.fireEvent-@@//
	var _oParam = {
			'4str' : [ MobileCommentJindo.$Jindo._F('sEvent:String+') ],
			'4obj' : [ 'sEvent:String+', 'oProps:Hash+' ]
	};
	function IE(sEvent, oProps) {
		var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, _oParam,"$Element#fireEvent");

		sEvent = (sEvent+"").toLowerCase();
		var oEvent = document.createEventObject();

		switch(oArgs+""){
			case "4obj":
				oProps = oArgs.oProps;
				for (k in oProps){
					if(oProps.hasOwnProperty(k))
						oEvent[k] = oProps[k];
				}
				oEvent.button = (oProps.left?1:0)+(oProps.middle?4:0)+(oProps.right?2:0);
				oEvent.relatedTarget = oProps.relatedElement||null;

		}

		var ele = this._element;
		if(this.tag == "input" && sEvent == "click"){
	        if(ele.type=="checkbox"){
	        	ele.checked = (!ele.checked);
	        }else if(ele.type=="radio"){
	        	ele.checked = true;
	        }
		}

		this._element.fireEvent("on"+sEvent, oEvent);
		return this;
	}

	function DOM2(sEvent, oProps) {
		var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, _oParam,"$Element#fireEvent");
		var sType = "HTMLEvents";
		sEvent = (sEvent+"").toLowerCase();

		if (sEvent == "click" || sEvent.indexOf("mouse") == 0) {
			sType = "MouseEvent";
			if (sEvent == "mousewheel") sEvent = "dommousescroll";
		} else if (sEvent.indexOf("key") == 0) {
			sType = "KeyboardEvent";
		}
		var evt;
		switch (oArgs+"") {
			case "4obj":
				oProps = oArgs.oProps;
				oProps.button = 0 + (oProps.middle?1:0) + (oProps.right?2:0);
				oProps.ctrl = oProps.ctrl||false;
				oProps.alt = oProps.alt||false;
				oProps.shift = oProps.shift||false;
				oProps.meta = oProps.meta||false;
				switch (sType) {
					case 'MouseEvent':
						evt = document.createEvent(sType);

						evt.initMouseEvent( sEvent, true, true, null, oProps.detail||0, oProps.screenX||0, oProps.screenY||0, oProps.clientX||0, oProps.clientY||0,
											oProps.ctrl, oProps.alt, oProps.shift, oProps.meta, oProps.button, oProps.relatedElement||null);
						break;
					case 'KeyboardEvent':
						if (window.KeyEvent) {
					        evt = document.createEvent('KeyEvents');
					        evt.initKeyEvent(sEvent, true, true, window,  oProps.ctrl, oProps.alt, oProps.shift, oProps.meta, oProps.keyCode, oProps.keyCode);
					    } else {
							try {
					            evt = document.createEvent("Events");
					        } catch (e){
					            evt = document.createEvent("UIEvents");
					        } finally {
								evt.initEvent(sEvent, true, true);
								evt.ctrlKey  = oProps.ctrl;
						        evt.altKey   = oProps.alt;
						        evt.shiftKey = oProps.shift;
						        evt.metaKey  = oProps.meta;
						        evt.keyCode = oProps.keyCode;
						        evt.which = oProps.keyCode;
					        }
					    }
						break;
					default:
						evt = document.createEvent(sType);
						evt.initEvent(sEvent, true, true);
				}
			break;
			case "4str":
				evt = document.createEvent(sType);
				evt.initEvent(sEvent, true, true);

		}
		this._element.dispatchEvent(evt);
		return this;
	}
	MobileCommentJindo.$Element.prototype.fireEvent =  (document.dispatchEvent !== undefined)?DOM2:IE;
	return this.fireEvent.apply(this,_toArray(arguments));
}
//-!MobileCommentJindo.$Element.prototype.fireEvent end!-//

//-!MobileCommentJindo.$Element.prototype.empty start(MobileCommentJindo.$Element.prototype.html)!-//
/**

 * @description empty() 메서드는 HTML 요소의 자식 노드를 모두 제거한다.
 * @return {$Element} 자식 노드를 모두 제거한 $Element 객체.
 * @see $Element#leave
 * @see $Element#remove
 * @example
// 자식 노드를 모두 제거
$Element("sample").empty();

//Before
<div id="sample"><span>노드</span> <span>모두</span> 삭제하기 </div>

//After
<div id="sample"></div>

 */
MobileCommentJindo.$Element.prototype.empty = function() {
	//-@@$Element.empty-@@//
	if(MobileCommentJindo.cssquery) MobileCommentJindo.cssquery.release();
	this.html("");
	return this;
};
//-!MobileCommentJindo.$Element.prototype.empty end!-//

//-!MobileCommentJindo.$Element.prototype.remove start(MobileCommentJindo.$Element.prototype.leave, MobileCommentJindo.$Element._common)!-//
/**

 * @description remove() 메서드는 HTML 요소의 특정 자식 노드를 제거한다. 파라미터로 지정한 자식 요소를 제거하며 제거되는 자식 요소의 이벤트 핸들러도 제거한다.
 *
 * @param1 {String+} vElement 자식 요소에서 제거할 HTML 요소의 ID.
 * @return1 {$Element} 지정한 자식 요소를 제거한 $Element() 객체.
 *
 * @param2 {Element+} vElement 자식 요소에서 제거할 HTML 요소.
 * @return2 {$Element} 지정한 자식 요소를 제거한 $Element() 객체.
 *
 * @see $Element#empty
 * @see $Element#leave
 * @example
// 특정 자식 노드를 제거
$Element("sample").remove("child2");

//Before
<div id="sample"><span id="child1">노드</span> <span id="child2">삭제하기</span></div>

//After
<div id="sample"><span id="child1">노드</span> </div>

 */
MobileCommentJindo.$Element.prototype.remove = function(oChild) {
	//-@@$Element.remove-@@//
	if(MobileCommentJindo.cssquery) MobileCommentJindo.cssquery.release();
	var ___element = MobileCommentJindo.$Element;
	___element(___element._common(oChild,"remove")).leave();
	return this;
};
//-!MobileCommentJindo.$Element.prototype.remove end!-//

//-!MobileCommentJindo.$Element.prototype.leave start(MobileCommentJindo.$Element.event_etc)!-//
/**

 * @description leave() 메서드는 HTML 요소를 자신의 부모 요소에서 제거한다. HTML 요소에 등록된 이벤트 핸들러도 제거한다.
 * @return {$Element} 부모 요소에서 제거된 $Element() 객체.
 * @see $Element#empty
 * @see $Element#remove
 *
 * @example
// 부모 요소 노드에서 제거
$Element("sample").leave();

//Before
<div>
	<div id="sample"><span>노드</span> <span>모두</span> 삭제하기 </div>
</div>

//After
// <div id="sample"><span>노드</span> <span>모두</span> 삭제하기 </div>를 래핑한 $Element가 반환된다
<div>

</div>

 */
MobileCommentJindo.$Element.prototype.leave = function() {
	//-@@$Element.leave-@@//
	var e = this._element;

	if (e.parentNode) {
		if(MobileCommentJindo.cssquery) MobileCommentJindo.cssquery.release();
		e.parentNode.removeChild(e);
	}

	if(this._element.__jindo__id){
		MobileCommentJindo.$Element.eventManager.cleanUpUsingKey(this._element.__jindo__id,true);
	}

	return this;
};
//-!MobileCommentJindo.$Element.prototype.leave end!-//

//-!MobileCommentJindo.$Element.prototype.wrap start(MobileCommentJindo.$Element._common)!-//
/**

 * @description wrap() 메서드는 HTML 요소를 지정한 요소로 감싼다. HTML 요소는 지정한 요소의 마지막 자식 요소가 된다.
 *
 * @param1 {String+} vElement 부모가 될 HTML 요소의 ID.
 * @return1 {$Element} 지정한 요소로 감싸진 $Element() 객체.
 *
 * @param2 {Element+|Node} vElement 부모가 될 HTML 요소.
 * @return2 {$Element} 지정한 요소로 감싸진 $Element() 객체.
 *
 * @example
$Element("sample1").wrap("sample2");

//Before
<div id="sample1"><span>Sample</span></div>
<div id="sample2"><span>Sample</span></div>

//After
<div id="sample2"><span>Sample</span><div id="sample1"><span>Sample</span></div></div>

 * @example
$Element("box").wrap($('<DIV>'));

//Before
<span id="box"></span>

//After
<div><span id="box"></span></div>

 */
MobileCommentJindo.$Element.prototype.wrap = function(wrapper) {
	//-@@$Element.wrap-@@//
	var e = this._element;
	wrapper = MobileCommentJindo.$Element._common(wrapper,"wrap");
	if (e.parentNode) {
		e.parentNode.insertBefore(wrapper, e);
	}
	wrapper.appendChild(e);

	return this;
};
//-!MobileCommentJindo.$Element.prototype.wrap end!-//

//-!MobileCommentJindo.$Element.prototype.ellipsis start(MobileCommentJindo.$Element.prototype._getCss,MobileCommentJindo.$Element.prototype.text)!-//
/**

 * @description ellipsis() 메서드는 HTML 요소의 텍스트 노드가 브라우저에서 한 줄로 보이도록 길이를 조절한다. 이 메서드는 HTML 요소가 텍스트 노드만을 포함한다고 가정하고 동작한다. 따라서, 이 외의 상황에서는 사용을 자제한다. 또한 브라우저에서 HTML 요소의 너비를 기준으로 텍스트 노드의 길이를 정하므로 HTML 요소는 반드시 보이는 상태(display)여야 한다. 화면에 전체 텍스트 노드가 보였다가 줄어드는 경우가 있다. 이 경우, HTML 요소에 overflow 속성의 값을 hidden으로 지정하면 해결할 수 있다.
 *
 * @param1 {Void}
 * @return1 {$Element} $Element() 객체 자신
 *
 * @param2 {String+} sTail 말줄임 표시자.<br>파라미터에 지정한 문자열을 텍스트 노드 끝에 붙이고 텍스트 노드의 길이를 조절한다. 파라미터를 생락하면 기본 값으로 '...'를 사용한다.
 * @return2 {$Element} $Element() 객체 자신
 *
 * @example
$Element("sample_span").ellipsis();

//Before
<div style="width:300px; border:1px solid #CCCCCC; padding:10px">
	<span id="sample_span">NHN은 검색과 게임을 양축으로 혁신적이고 편리한 온라인 서비스를 꾸준히 선보이며 디지털 라이프를 선도하고 있습니다.</span>
</div>

//After
<div style="width:300px; border:1px solid #CCCCCC; padding:10px">
	<span id="sample_span">NHN은 검색과 게임을 양축으로 혁신적...</span>
</div>

 */
MobileCommentJindo.$Element.prototype.ellipsis = function(stringTail) {
	//-@@$Element.ellipsis-@@//

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4voi' : [ ],
		'4str' : [ 'stringTail:String+' ]
	},"$Element#ellipsis");

	stringTail = stringTail || "...";
	var txt   = this.text();
	var len   = txt.length;
	var padding = parseInt(this._getCss(this._element,"paddingTop"),10) + parseInt(this._getCss(this._element,"paddingBottom"),10);
	var cur_h = this._element.offsetHeight - padding;
	var i     = 0;
	var h     = this.text('A')._element.offsetHeight - padding;

	if (cur_h < h * 1.5) {
		this.text(txt);
		return this;
	}

	cur_h = h;
	while(cur_h < h * 1.5) {
		i += Math.max(Math.ceil((len - i)/2), 1);
		cur_h = this.text(txt.substring(0,i)+stringTail)._element.offsetHeight - padding;
	}

	while(cur_h > h * 1.5) {
		i--;
		cur_h = this.text(txt.substring(0,i)+stringTail)._element.offsetHeight - padding;
	}
	return this;
};
//-!MobileCommentJindo.$Element.prototype.ellipsis end!-//

//-!MobileCommentJindo.$Element.prototype.indexOf start!-//
/**

 * @description indexOf() 메서드는 HTML 요소에서 파라미터로 지정한 요소가 몇 번째 자식인지 확인하여 인덱스를 반환한다.
 *
 * @param1 {String+} vElement 몇 번째 자식인지 검색할 요소의 ID
 * @return1 {Numeric} 검색 결과 인덱스.<br>인덱스는 0부터 시작하며, 찾지 못한 경우에는 -1 을 반환한다.
 *
 * @param2 {Element+} vElement 몇 번째 자식인지 검색할 요소.
 * @return2 {Numeric} 검색 결과 인덱스.<br>인덱스는 0부터 시작하며, 찾지 못한 경우에는 -1 을 반환한다.
 *
 * @since 1.2.0
 * @see $Element#parent
 * @see $Element#child
 * @see $Element#prev
 * @see $Element#next
 * @see $Element#first
 * @see $Element#last
 * @example
<div id="sample_div1">
	<div id="sample_div">
		<div id="sample_div2">
			Sample1
		</div>
		<div id="sample_div3">
			<div id="sample_div4">
				Sample2
			</div>
			Sample3
		</div>
		<div id="sample_div5">
			Sample4
			<div id="sample_div6">
				Sample5
			</div>
		</div>
	</div>
</div>

<script type="text/javascript">
	var welSample = $Element("sample_div");
	welSample.indexOf($Element("sample_div1"));	// 결과 : -1
	welSample.indexOf($Element("sample_div2"));	// 결과 : 0
	welSample.indexOf($Element("sample_div3"));	// 결과 : 1
	welSample.indexOf($Element("sample_div4"));	// 결과 : -1
	welSample.indexOf($Element("sample_div5"));	// 결과 : 2
	welSample.indexOf($Element("sample_div6"));	// 결과 : -1
</script>

 */
MobileCommentJindo.$Element.prototype.indexOf = function(element) {
	//-@@$Element.indexOf-@@//
	try {
		var e = MobileCommentJindo.$Element(element)._element;
		var n = this._element.childNodes;
		var c = 0;
		var l = n.length;

		for (var i=0; i < l; i++) {
			if (n[i].nodeType != 1) continue;

			if (n[i] === e) return c;
			c++;
		}
	}catch(e){}

	return -1;
};
//-!MobileCommentJindo.$Element.prototype.indexOf end!-//

//-!MobileCommentJindo.$Element.prototype.queryAll start(MobileCommentJindo.cssquery)!-//
/**

 * @description queryAll() 메서드는 HTML 요소에서 특정 CSS 선택자(CSS Selector)를 만족하는 하위 요소를 찾는다.
 * @param {String+} sSelector CSS 선택자. CSS 선택자로 사용할 수 있는 패턴은 표준 패턴과 비표준 패턴이 있다. 표준 패턴은 CSS Level3 명세서에 있는 패턴을 지원한다.
 * @return {Array($Element)} CSS 셀렉터 조건을 만족하는 HTML 요소의 $Element배열을 반환한다.<br>만족하는 HTML 요소가 존재하지 않으면 빈 배열을 반환한다.
 * @see $Element#query
 * @see $Element#queryAll
 * @see <a href="http://www.w3.org/TR/css3-selectors/">CSS Level3 명세서</a> - W3C
 * @example
<div id="sample">
	<div></div>
	<div class="pink"></div>
	<div></div>
	<div class="pink"></div>
	<div></div>
	<div class="blue"></div>
	<div class="blue"></div>
</div>

<script type="text/javascript">
	$Element("sample").queryAll(".pink");
	// <div class="pink"></div>와 <div class="pink"></div>를 원소로 하는 배열을 반환

	$Element("sample").queryAll(".green");
	// [] 빈 배열을 반환
</script>

 */
MobileCommentJindo.$Element.prototype.queryAll = function(sSelector) {
	//-@@$Element.queryAll-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str'  : [ 'sSelector:String+']
	},"$Element#queryAll");

	var arrEle = MobileCommentJindo.cssquery(sSelector, this._element);
	var returnArr = [];
	for(var i = 0, l = arrEle.length; i < l; i++){
		returnArr.push(MobileCommentJindo.$Element(arrEle[i]));
	}
	return returnArr;
};
//-!MobileCommentJindo.$Element.prototype.queryAll end!-//

//-!MobileCommentJindo.$Element.prototype.query start(MobileCommentJindo.cssquery)!-//
/**

 * @description query() 메서드는 HTML 요소에서 특정 CSS 선택자(CSS Selector)를 만족하는 첫 번째 하위 요소를 반환한다.
 * @param {String+} sSelector CSS 선택자. CSS 선택자로 사용할 수 있는 패턴은 표준 패턴과 비표준 패턴이 있다. 표준 패턴은 CSS Level3 명세서에 있는 패턴을 지원한다.
 * @return {$Element} CSS 선택자의 조건을 만족하는 첫 번째 HTML 요소의 $Element인스턴스.<br>만족하는 HTML 요소가 존재하지 않으면 null을 반환한다.
 * @see $Element#test
 * @see $Element#queryAll
 * @see <a href="http://www.w3.org/TR/css3-selectors/">CSS Level3 명세서</a> - W3C
 * @example
<div id="sample">
	<div></div>
	<div class="pink"></div>
	<div></div>
	<div class="pink"></div>
	<div></div>
	<div class="blue"></div>
	<div class="blue"></div>
</div>

<script type="text/javascript">
	$Element("sample").query(".pink");
	// 첫 번째 <div class="pink"></div> DIV 요소를 반환

	$Element("sample").query(".green");
	// null 을 반환
</script>

 */
MobileCommentJindo.$Element.prototype.query = function(sSelector) {
	//-@@$Element.query-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str'  : [ 'sSelector:String+']
	},"$Element#query");
	var ele =  MobileCommentJindo.cssquery.getSingle(sSelector, this._element);
	return ele === null? ele : MobileCommentJindo.$Element(ele);
};
//-!MobileCommentJindo.$Element.prototype.query end!-//

//-!MobileCommentJindo.$Element.prototype.test start(MobileCommentJindo.cssquery)!-//
/**

 * @description test() 메서드는 HTML 요소에서 특정 CSS 선택자(CSS Selector)를 만족하는지 확인한다.
 *
 * @param {String+} sSelector CSS 선택자. CSS 선택자로 사용할 수 있는 패턴은 표준 패턴과 비표준 패턴이 있다. 표준 패턴은 CSS Level3 명세서에 있는 패턴을 지원한다.
 * @return {Boolean} CSS 선택자의 조건을 만족하면 true, 그렇지 않으면 false를 반환한다.
 * @see $Element#query
 * @see $Element#queryAll
 * @see <a href="http://www.w3.org/TR/css3-selectors/">CSS Level3 명세서</a> - W3C
 * @example
<div id="sample" class="blue"></div>

<script type="text/javascript">
	$Element("sample").test(".blue");	// 결과 : true
	$Element("sample").test(".red");	// 결과 : false
</script>

 */
MobileCommentJindo.$Element.prototype.test = function(sSelector) {
	//-@@$Element.test-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str'  : [ 'sSelector:String+']
	},"$Element#test");
	return MobileCommentJindo.cssquery.test(this._element, sSelector);
};
//-!MobileCommentJindo.$Element.prototype.test end!-//

//-!MobileCommentJindo.$Element.prototype.xpathAll start(MobileCommentJindo.cssquery)!-//
/**

 * @description xpathAll() 메서드는 HTML 요소를 기준으로 XPath 문법을 만족하는 요소를 가져온다. 지원하는 문법이 제한적이므로 특수한 경우에만 사용할 것을 권장한다.
 * @param {String+} sXPath XPath 값.
 * @return {Array($Element)} XPath 문법을 만족하는 요소를 원소로 하는 배열.
 * @see <a href="_global_.html#$$">$$()</a>
 * @example
<div id="sample">
	<div>
		<div>1</div>
		<div>2</div>
		<div>3</div>
		<div>4</div>
		<div>5</div>
		<div>6</div>
	</div>
</div>

<script type="text/javascript">
	$Element("sample").xpathAll("div/div[5]");
	// <div>5</div> 요소를 원소로 하는 배열이 반환 됨
</script>

 */
MobileCommentJindo.$Element.prototype.xpathAll = function(sXPath) {
	//-@@$Element.xpathAll-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str'  : [ 'sXPath:String+']
	},"$Element#xpathAll");
	var arrEle = MobileCommentJindo.cssquery.xpath(sXPath, this._element);
	var returnArr = [];
	for(var i = 0, l = arrEle.length; i < l; i++){
		returnArr.push(MobileCommentJindo.$Element(arrEle[i]));
	}
	return returnArr;
};
//-!MobileCommentJindo.$Element.prototype.xpathAll end!-//

//-!MobileCommentJindo.$Element.prototype.insertAdjacentHTML.hidden start(MobileCommentJindo._createEle)!-//
/**

 * insertAdjacentHTML 함수. 직접사용하지 못함.
 * @ignore

 */
MobileCommentJindo.$Element.insertAdjacentHTML = function(ins,html,insertType,type,fn,sType){
	var aArg = [ html ];
	aArg.callee = arguments.callee;
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(aArg, {
		'4str'  : [ 'sHTML:String+' ]
	},"$Element#"+sType);
	var _ele = ins._element;
	html = html+"";
	if( _ele.insertAdjacentHTML && !(/^<(option|tr|td|th|col)(?:.*?)>/.test(html.replace(/^(\s|　)+|(\s|　)+$/g, "").toLowerCase()))){
		_ele.insertAdjacentHTML(insertType, html);
	}else{
		var oDoc = _ele.ownerDocument || _ele.document || document;
		var fragment = oDoc.createDocumentFragment();
		var defaultElement;
		var sTag = html.replace(/^(\s|　)+|(\s|　)+$/g, "");
		var oParentTag = {
			"option" : "select",
			"tr" : "tbody",
			"thead" : "table",
			"tbody" : "table",
			"col" : "table",
			"td" : "tr",
			"th" : "tr",
			"div" : "div"
		}
		var aMatch = /^\<(option|tr|thead|tbody|td|th|col)(?:.*?)\>/i.exec(sTag);
		var sChild = aMatch === null ? "div" : aMatch[1].toLowerCase();
		var sParent = oParentTag[sChild] ;
		defaultElement = MobileCommentJindo._createEle(sParent,sTag,oDoc,true);
		var scripts = defaultElement.getElementsByTagName("script");

		for ( var i = 0, l = scripts.length; i < l; i++ ){
			scripts[i].parentNode.removeChild( scripts[i] );
		}

		while ( defaultElement[ type ]){
			fragment.appendChild( defaultElement[ type ] );
		}

		fn(fragment.cloneNode(true));

	}
	return ins;
};

//-!MobileCommentJindo.$Element.prototype.insertAdjacentHTML.hidden end!-//

//-!MobileCommentJindo.$Element.prototype.appendHTML start(MobileCommentJindo.$Element.prototype.insertAdjacentHTML)!-//
/**

 * @description appendHTML() 메서드는 내부 HTML 코드(innerHTML)의 뒤에 파라미터로 지정한 HTML 코드를 덧붙인다.
 * @param {String+} sHTML 덧붙일 HTML 문자열.
 * @return {$Element} 내부 HTML 코드를 변경한 $Element() 객체.
 * @since 1.4.6
 * @since 1.4.8 부터 $Element 객체를 반환한다.
 * @see $Element#prependHTML
 * @see $Element#beforeHTML
 * @see $Element#afterHTML
 * @example
// 내부 HTML 가장 뒤에 덧붙이기
$Element("sample_ul").appendHTML("<li>3</li><li>4</li>");

//Before
<ul id="sample_ul">
	<li>1</li>
	<li>2</li>
</ul>

//After
<ul id="sample_ul">
	<li>1</li>
	<li>2</li>
	<li>3</li>
	<li>4</li>
</ul>

 */
MobileCommentJindo.$Element.prototype.appendHTML = function(sHTML) {
	//-@@$Element.appendHTML-@@//
	return MobileCommentJindo.$Element.insertAdjacentHTML(this,sHTML,"beforeEnd","firstChild",MobileCommentJindo.$Fn(function(oEle){
		var ele = this._element;
		if(ele.tagName.toLowerCase() === "table"){
			var nodes = ele.childNodes;
			for(var i=0,l=nodes.length; i < l; i++){
				if(nodes[i].nodeType==1){
					ele = nodes[i];
					break;
				}

			}
		};
		ele.appendChild(oEle);
	},this).bind(),"appendHTML");
};
//-!MobileCommentJindo.$Element.prototype.appendHTML end!-//

//-!MobileCommentJindo.$Element.prototype.prependHTML start(MobileCommentJindo.$Element.prototype.insertAdjacentHTML,MobileCommentJindo.$Element._prepend)!-//
/**

 * @description prependHTML() 메서드는 내부 HTML 코드(innerHTML)의 앞에 파라미터로 지정한 HTML 코드를 삽입한다.
 * @param {String+} sHTML 삽입할 HTML 문자열.
 * @return {$Element} 내부 HTML 코드를 변경한 $Element() 객체.
 * @since 1.4.6
 * @since 1.4.8 부터 $Element 객체를 반환한다.
 * @see $Element#appendHTML
 * @see $Element#beforeHTML
 * @see $Element#afterHTML
 * @example
// 내부 HTML 가장 앞에 삽입
$Element("sample_ul").prependHTML("<li>3</li><li>4</li>");

//Before
<ul id="sample_ul">
	<li>1</li>
	<li>2</li>
</ul>

//After
<ul id="sample_ul">
	<li>4</li>
	<li>3</li>
	<li>1</li>
	<li>2</li>
</ul>

 */
MobileCommentJindo.$Element.prototype.prependHTML = function(sHTML) {
	//-@@$Element.prependHTML-@@//
	var ___element = MobileCommentJindo.$Element
	return ___element.insertAdjacentHTML(this,sHTML,"afterBegin","firstChild",MobileCommentJindo.$Fn(function(oEle){
		var ele = this._element;
		if(ele.tagName.toLowerCase() === "table"){
			var nodes = ele.childNodes;
			for(var i=0,l=nodes.length; i < l; i++){
				if(nodes[i].nodeType==1){
					ele = nodes[i];
					break;
				}

			}
		};
		___element._prepend(ele,oEle);
	},this).bind(),"prependHTML");
};
//-!MobileCommentJindo.$Element.prototype.prependHTML end!-//

//-!MobileCommentJindo.$Element.prototype.beforeHTML start(MobileCommentJindo.$Element.prototype.insertAdjacentHTML)!-//
/**

 * @description beforeHTML() 메서드는 HTML 코드(outerHTML)의 앞에 파라미터로 지정한 HTML 코드를 삽입한다.
 * @param {String+} sHTML 삽입할 HTML 문자열.
 * @return {$Element} HTML 코드를 변경한 $Element() 객체.
 * @since 1.4.6
 * @since 1.4.8 부터 $Element 객체를 반환한다.
 * @see $Element#appendHTML
 * @see $Element#prependHTML
 * @see $Element#afterHTML
 * @example
var welSample = $Element("sample_ul");

welSample.beforeHTML("<ul><li>3</li><li>4</li></ul>");
welSample.beforeHTML("<ul><li>5</li><li>6</li></ul>");

//Before
<ul id="sample_ul">
	<li>1</li>
	<li>2</li>
</ul>

//After
<ul>
	<li>5</li>
	<li>6</li>
</ul>
<ul>
	<li>3</li>
	<li>4</li>
</ul>
<ul id="sample_ul">
	<li>1</li>
	<li>2</li>
</ul>

 */
MobileCommentJindo.$Element.prototype.beforeHTML = function(sHTML) {
	//-@@$Element.beforeHTML-@@//
	return MobileCommentJindo.$Element.insertAdjacentHTML(this,sHTML,"beforeBegin","firstChild",MobileCommentJindo.$Fn(function(oEle){
		this._element.parentNode.insertBefore(oEle, this._element);
	},this).bind(),"beforeHTML");
};
//-!MobileCommentJindo.$Element.prototype.beforeHTML end!-//

//-!MobileCommentJindo.$Element.prototype.afterHTML start(MobileCommentJindo.$Element.prototype.insertAdjacentHTML)!-//
/**

 * @description afterHTML() 메서드는 HTML 코드(outerHTML)의 뒤에 파라미터로 지정한 HTML 코드를 삽입한다.
 * @param {String+} sHTML 삽입할 HTML 문자열.
 * @return {$Element} HTML 코드를 변경한 $Element() 객체.
 * @since 1.4.6
 * @since 1.4.8 부터 $Element 객체를 반환한다.
 * @see $Element#appendHTML
 * @see $Element#prependHTML
 * @see $Element#beforeHTML
 * @example
var welSample = $Element("sample_ul");

welSample.afterHTML("<ul><li>3</li><li>4</li></ul>");
welSample.afterHTML("<ul><li>5</li><li>6</li></ul>");

//Before
<ul id="sample_ul">
	<li>1</li>
	<li>2</li>
</ul>

//After
<ul id="sample_ul">
	<li>1</li>
	<li>2</li>
</ul>
<ul>
	<li>3</li>
	<li>4</li>
</ul>
<ul>
	<li>5</li>
	<li>6</li>
</ul>

 */
MobileCommentJindo.$Element.prototype.afterHTML = function(sHTML) {
	//-@@$Element.afterHTML-@@//
	return MobileCommentJindo.$Element.insertAdjacentHTML(this,sHTML,"afterEnd","firstChild",MobileCommentJindo.$Fn(function(oEle){
		this._element.parentNode.insertBefore( oEle, this._element.nextSibling );
	},this).bind(),"afterHTML");
};
//-!MobileCommentJindo.$Element.prototype.afterHTML end!-//

//-!MobileCommentJindo.$Element.prototype.hasEventListener start(MobileCommentJindo.$Element.prototype.attach)!-//
/**

 * 엘리먼트에 해당 이벤트가 할당되어 있는지를 확인.
 * @since 2.0.0
 * @param {String+} sEvent 이벤트명
 * @return {Boolean} 이벤트 할당 유무
 * @example
 $Element("test").attach("click",function(){});

 $Element("test").hasEventListener("click"); //true
 $Element("test").hasEventListener("mousemove"); //false

 */
MobileCommentJindo.$Element.prototype.hasEventListener = function(sEvent){

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str' : [ 'sEvent:String+' ]
	},"$Element#hasEventListener");

	if(this._key){
		return !!MobileCommentJindo.$Element.eventManager.hasEvent(this._key, oArgs.sEvent);
	}

	return false;
};
//-!MobileCommentJindo.$Element.prototype.hasEventListener end!-//

//-!MobileCommentJindo.$Element.prototype.preventTapHighlight start(MobileCommentJindo.$Element.prototype.addClass, MobileCommentJindo.$Element.prototype.removeClass)!-//
/**

 * 모바일에서 이벤트 델리게이트를 사용했을때 부모 엘리먼트에 하이라이트가 되는 것을 막는다.
 * @caution 데스크탑에서는 작동하지 않는다.
 * @since 2.0.0
 * @param {Boolean} bType 하이라이트를 막을지 유무
 * @return {$Element} 자신
 * @example
 <ul id="test">
 	<li><a href="#nhn">nhn</a></li>
 	<li><a href="#naver">naver</a></li>
 	<li><a href="#hangame">hangame</a></li>
 </ul>

 $Element("test").preventTapHighlight(true);//이렇게 하면 모바일에서 test에 하이라이트가 되는 것을 막는다.
 $Element("test").delegate("click","a",function(e){});


 */
MobileCommentJindo.$Element.prototype.preventTapHighlight = function(bFlag){
	if(_JINDO_IS_MO){
		var sClassName = 'no_tap_highlight' + new Date().getTime();

		var elStyleTag = document.createElement('style');
		var elHTML = document.getElementsByTagName('html')[0];

		elStyleTag.type = "text/css";

		elHTML.insertBefore(elStyleTag, elHTML.firstChild);
		var oSheet = elStyleTag.sheet || elStyleTag.styleSheet;

		oSheet.insertRule('.' + sClassName + ' { -webkit-tap-highlight-color: rgba(0,0,0,0); }', 0);
		oSheet.insertRule('.' + sClassName + ' * { -webkit-tap-highlight-color: rgba(0,0,0,.25); }', 0);

		MobileCommentJindo.$Element.prototype.preventTapHighlight = function(bFlag) {
			return this[bFlag ? 'addClass' : 'removeClass'](sClassName);
		};
	}else{
		MobileCommentJindo.$Element.prototype.preventTapHighlight = function(bFlag) { return this; };
	}
	return this.preventTapHighlight.apply(this,_toArray(arguments));
};
//-!MobileCommentJindo.$Element.prototype.preventTapHighlight end!-//


//-!MobileCommentJindo.$Fn start(MobileCommentJindo.$Fn.prototype.attach)!-//
/**

 * @fileOverview $Fn() 객체의 생성자 및 메서드를 정의한 파일
 * @name function.js

 */

/**

 * @class $Fn() 객체는 Function 객체를 래핑(wrapping)하여 함수와 관련된 확장 기능을 제공한다.
 * @extends core
 * @constructor
 * @description $Fn() 객체()를 생성한다. 생성자의 파라미터로 특정 함수를 지정할 수 있다. 이 때, 함수와 함께 this 키워드를 상황에 맞게 사용할 수 있도록 실행 문맥(Execution Context)을 함께 지정할 수 있다. 또한 생성자의 파라미터로 래핑할 함수의 파라미터와 몸체를 각각 입력하여 $Fn() 객체를 생성할 수 있다.
 *
 * @param1 {Function+} fpFunction 랩핑할 함수
 * @return1 {$Fn} $Fn() 객체
 *
 * @param2 {Function+} fpFunction 랩핑할 함수
 * @param2 {Variant} vExeContext 함수의 실행 문맥이 될 객체
 * @return2 {$Fn} $Fn() 객체
 *
 * @param3 {String} sFuncArgs 함수의 파라미터를 나타내는 문자열
 * @param3 {String} sFuncBody 함수의 몸체를 나타내는 문자열
 * @return3 {$Fn} $Fn() 객체
 *
 * @see $Fn#toFunction
 * @example
func : function() {
       // code here
}

var fn = $Fn(func, this);

 * @example
var someObject = {
    func : function() {
       // code here
   }
}

var fn = $Fn(someObject.func, someObject);

 * @example
var fn = $Fn("a, b", "return a + b;");
var result = fn.$value()(1, 2) // result = 3;

// fn은 함수 리터럴인 function(a, b){ return a + b;}와 동일한 함수를 래핑한다.

 */
MobileCommentJindo.$Fn = function(func, thisObject) {
	//-@@$Fn-@@//
	var cl = arguments.callee;
	if (func instanceof cl) return func;

	if (!(this instanceof cl)){
		try {
			MobileCommentJindo.$Jindo._warn(arguments.length, 2,"$Fn");
			return new cl(func, thisObject);
		} catch(e) {
			if (e instanceof TypeError) { return null; }
			throw e;
		}
	}

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4fun' : ['func:Function+'],
		'4fun2' : ['func:Function+', "thisObject:Variant"],
		'4str' : ['func:String+', "thisObject:String+"]
	},"$Fn");

	this._tmpElm = null;
	this._key    = null;

	switch(oArgs+""){
		case "4str":
			this._func = eval("false||function("+func+"){"+thisObject+"}");
			break;
		case "4fun":
		case "4fun2":
			this._func = func;
			this._this = thisObject;

	}

};

/**
 * @ignore
 */
MobileCommentJindo.$Fn._commonPram = function(oPram,sMethod){
	return MobileCommentJindo.$Jindo.checkVarType(oPram, {
		'4ele' : ['eElement:Element+',"sEvent:String+"],
		'4ele2' : ['eElement:Element+',"sEvent:String+","bUseCapture:Boolean"],
		'4str' : ['eElement:String+',"sEvent:String+"],
		'4str2' : ['eElement:String+',"sEvent:String+","bUseCapture:Boolean"],
		'4arr' : ['aElement:Array+',"sEvent:String+"],
		'4arr2' : ['aElement:Array+',"sEvent:String+","bUseCapture:Boolean"],
		'4doc' : ['eElement:Document+',"sEvent:String+"],
		'4win' : ['eElement:Window+',"sEvent:String+"],
		'4doc2' : ['eElement:Document+',"sEvent:String+","bUseCapture:Boolean"],
		'4win2' : ['eElement:Window+',"sEvent:String+","bUseCapture:Boolean"]
	},sMethod);
};
//-!MobileCommentJindo.$Fn end!-//

//-!MobileCommentJindo.$Fn.prototype.$value start!-//
/**

 * @description $value() 메서드는 원본 Function 객체를 반환한다.
 * @return {Function} 원본 Function 객체
 * @example
func : function() {
	// code here
}

var fn = $Fn(func, this);
     fn.$value(); // 원래의 함수가 리턴된다.

 */
MobileCommentJindo.$Fn.prototype.$value = function() {
	//-@@$Fn.$value-@@//
	return this._func;
};
//-!MobileCommentJindo.$Fn.prototype.$value end!-//

//-!MobileCommentJindo.$Fn.prototype.bind start!-//
/**

 * @description bind() 메서드는 생성자가 지정한 객체의 메서드로 동작하도록 묶은 Function 객체를 반환한다. 이때 해당 메서드의 실행 문맥(Execution Context)이 지정한 객체로 설정된다.
 * @param {Variant} [vParameter1] 생성한 함수에 기본적으로 입력할 첫 번째 파라미터.
 * @param {Variant} […] …
 * @param {Variant} [vParameterN] 생성한 함수에 기본적으로 입력할 N 번째 파라미터.
 * @return {Function} 실행 문맥의 메서드로 묶인 Function 객체
 * @see $Fn
 * @see $Class
 * @example
var sName = "OUT";
var oThis = {
    sName : "IN"
};

function getName() {
    return this.sName;
}

oThis.getName = $Fn(getName, oThis).bind();

alert( getName() );       	  //  OUT
alert( oThis.getName() ); //   IN

 * @example
 // 바인드한 메서드에 인수를 입력할 경우
var b = $Fn(function(one, two, three){
	console.log(one, two, three);
}).bind(true);

b();	// true, undefined, undefined
b(false);	// true, false, undefined
b(false, "1234");	// true, false, "1234"


 * @example
// 함수를 미리 선언하고 나중에 사용할 때 함수에서 참조하는 값은 해당 함수를
// 생성할 때의 값이 아니라 함수 실행 시점의 값이 사용되므로 이때 bind() 메서드를 이용한다.
for(var i=0; i<2;i++){
	aTmp[i] = function(){alert(i);}
}

for(var n=0; n<2;n++){
	aTmp[n](); // 숫자 2만 두번 alert된다.
}

for(var i=0; i<2;i++){
aTmp[i] = $Fn(function(nTest){alert(nTest);}, this).bind(i);
}

for(var n=0; n<2;n++){
	aTmp[n](); // 숫자 0, 1이 alert된다.
}

 * @example
//클래스를 생성할 때 함수를 파라미터로 사용하면, scope를 맞추기 위해 bind() 메서드를 사용한다.
var MyClass = $Class({
	fFunc : null,
	$init : function(func){
		this.fFunc = func;

		this.testFunc();
	},
	testFunc : function(){
		this.fFunc();
	}
})
var MainClass = $Class({
	$init : function(){
		var oMyClass1 = new MyClass(this.func1);
		var oMyClass2 = new MyClass($Fn(this.func2, this).bind());
	},
	func1 : function(){
		alert(this);// this는 MyClass 를 의미한다.
	},
	func2 : function(){
		alert(this);// this는 MainClass 를 의미한다.
	}
})
function init(){
	var a = new MainClass();
}

*/
MobileCommentJindo.$Fn.prototype.bind = function() {
	//-@@$Fn.bind-@@//
	var a = _slice.call( arguments, 0);
	var f = this._func;
	var t = this._this;

	var b = function() {
		var args = _slice.call( arguments, 0);
		// fix opera concat bug
		if (a.length) args = a.concat(args);

		return f.apply(t, args);
	};
	return b;
};
//-!MobileCommentJindo.$Fn.prototype.bind end!-//

//-!MobileCommentJindo.$Fn.prototype.attach start(MobileCommentJindo.$Fn.prototype.bind, MobileCommentJindo.$Element.prototype.attach, MobileCommentJindo.$Element.prototype.detach)!-//
/**

 * @description attach() 메서드는 함수를 특정 요소의 이벤트 핸들러로 등록한다. $Fn() 객체에 바인딩하여 사용할 때 함수의 반환 값이 false인 경우, 인터넷 익스플로러에서 기본 기능을 막기 때문에 사용하지 않도록 주의한다. 또한 다음과 같은 제약 사항이 있다.<br>
<ul>
	<li>이벤트 이름에는 on 접두어를 사용하지 않는다.</li>
	<li>마우스 휠 스크롤 이벤트는 mousewheel 로 사용한다.</li>
	<li>기본 이벤트 외에 추가로 사용이 가능한 이벤트로 domready, mouseenter, mouseleave, mousewheel이 있다.</li>
</ul>
 *
 * @param1 {Element} elElement 이벤트 핸들러를 할당할 요소
 * @param1 {String} sEvent 이벤트 종류
 * @return1 {$Fn} 생성된 $Fn() 객체.
 *
 * @param2 {Element} elElement 이벤트 핸들러를 할당할 요소
 * @param2 {String} sEvent 이벤트 종류
 * @param2 {Boolean} bUseCapture 캡쳐링(capturing) 사용 여부(1.4.2 버전부터 지원). 사용하면 true 사용하지 않으면 false를 입력한다.
 * @return2 {$Fn} 생성된 $Fn() 객체.
 *
 * @param3 {Array} aElement 이벤트 핸들러를 할당할 요소로 이루어진 배열
 * @param3 {String} sEvent 이벤트 종류
 * @return3 {$Fn} 생성된 $Fn() 객체.
 *
 * @param4 {Array|$A} vElement 이벤트 핸들러를 할당할 요소로 이루어진 배열
 * @param4 {String} sEvent 이벤트 종류
 * @param4 {Boolean} bUseCapture 캡쳐링(capturing) 사용 여부(1.4.2 버전부터 지원). 사용하면 true 사용하지 않으면 false를 입력한다.
 * @return4 {$Fn} 생성된 $Fn() 객체.
 *
 * @param5 {String} sElement 이벤트 핸들러를 할당할 요소의 id
 * @param5 {String} sEvent 이벤트 종류
 * @return5 {$Fn} 생성된 $Fn() 객체.
 *
 * @param6 {String} sElement 이벤트 핸들러를 할당할 요소의 id
 * @param6 {String} sEvent 이벤트 종류
 * @param6 {Boolean} bUseCapture 캡쳐링(capturing) 사용 여부(1.4.2 버전부터 지원). 사용하면 true 사용하지 않으면 false를 입력한다.
 * @return6 {$Fn} 생성된 $Fn() 객체.
 *
 * @see $Fn#detach
 * @deprecated Since version 2.0.0. $Element#attach로 변경
 * @example
var someObject = {
    func : function() {
		// code here
   }
}

// 단일 요소에 클릭 이벤트 핸들러를 등록할 경우
$Fn(someObject.func, someObject).attach($("test"),"click");

// 여러 요소에 클릭 이벤트 핸들러를 등록할 경우
// 아래와 같이 첫 번째 파라미터로 배열이 입력되면 해당 모든 요소에 이벤트 핸들러가 등록된다.
$Fn(someObject.func, someObject).attach($$(".test"),"click");

 */
MobileCommentJindo.$Fn.prototype.attach = function(oElement, sEvent, bUseCapture) {
	//-@@$Fn.attach-@@//
	var oArgs = MobileCommentJindo.$Fn._commonPram(arguments,"$Fn#attach");
	var fn = null, l, ev = sEvent, el = oElement, ua = _j_ag;

	if (bUseCapture !== true) {
		bUseCapture = false;
	};

	this._bUseCapture = bUseCapture;

	switch(oArgs+""){
		case "4arr":
		case "4arr2":
			var el = oArgs.aElement;
			var ev = oArgs.sEvent;
			for(var i=0, l= el.length; i < l; i++) this.attach(el[i], ev, !!bUseCapture);
			return this;
	}
	fn = this._bind = this._bind?this._bind:this.bind();
	MobileCommentJindo.$Element(el).attach(ev,fn);

	return this;
};


/**

 * @description detach() 메서드는 요소에 등록된 이벤트 핸들러를 등록 해제한다.
 * @param {Element} elElement 이벤트 핸들러를 등록 해제할 요소
 * @param {String} sEvent 이벤트 종류. 이벤트 이름에는 on 접두어를 사용하지 않는다.
 * @return {$Fn} 생성된 $Fn() 객체.
 * @see $Fn#attach
 * @deprecated Since version 2.0.0. $Element#detach 로 변경
 * @example
var someObject = {
    func : function() {
		// code here
   }
}

var fpFn = $Fn(someObject.func, someObject);
fpFn.attach($("test"),"click");
// 단일 요소에 등록된 클릭 이벤트 핸들러를 등록 해제할 경우
// detach 함수는 attach 함수가 실행 된 같은 $Fn 인스턴스에서만 사용 가능하다
fpFn.detach($("test"),"click");

var fpFn = $Fn(someObject.func, someObject);
fpFn.attach($$(".test"),"click");
// 여러 요소에 등록된 클릭 이벤트 핸들러를 등록 해제할 경우
// 아래와 같이 첫 번째 파라미터로 배열이 입력되면 해당 모든 요소에 이벤트 핸들러가 등록된다.
// detach 함수는 attach 함수가 실행 된 같은 $Fn 인스턴스에서만 사용 가능하다.
fpFn.detach($$(".test"),"click");

 */
MobileCommentJindo.$Fn.prototype.detach = function(oElement, sEvent, bUseCapture) {
	//-@@$Fn.detach-@@//
	var oArgs = MobileCommentJindo.$Fn._commonPram(arguments,"$Fn#detach");

	var fn = null, l, el = oElement, ev = sEvent, ua = _j_ag;

	switch(oArgs+""){
		case "4arr":
		case "4arr2":
			var el = oArgs.aElement;
			var ev = oArgs.sEvent;
			for(var i=0, l= el.length; i < l; i++) this.detach(el[i], ev, !!bUseCapture);
			return this;

	}
	fn = this._bind = this._bind?this._bind:this.bind();
	MobileCommentJindo.$Element(oArgs.eElement).detach(oArgs.sEvent, fn);

	return this;
};
//-!MobileCommentJindo.$Fn.prototype.attach end!-//

//-!MobileCommentJindo.$Fn.prototype.detach start!-//
//-!MobileCommentJindo.$Fn.prototype.detach end!-//

//-!MobileCommentJindo.$Fn.prototype.delay start(MobileCommentJindo.$Fn.prototype.bind)!-//
/**

 * @description delay() 메서드는 래핑한 함수를 지정한 시간 이후에 호출한다.

 * @param1 {Numeric} nSec 함수를 호출할 때까지 대기할 시간(초 단위).
 * @return1 {$Fn} 생성된 $Fn() 객체.

 * @param2 {Numeric} nSec 함수를 호출할 때까지 대기할 시간(초 단위).
 * @param2 {Array+} [aArgs] 함수를 호출할 때 사용할 파라미터를 담은 배열.
 * @return2 {$Fn} 생성된 $Fn() 객체.

 * @see $Fn#bind
 * @see $Fn#setInterval
 * @example
function func(a, b) {
	alert(a + b);
}

$Fn(func).delay(5, [3, 5]);//5초 이후에 3, 5 값을 매개변수로 하는 함수 func를 호출한다.

 */
MobileCommentJindo.$Fn.prototype.delay = function(nSec, args) {
	//-@@$Fn.delay-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4num' : ['nSec:Numeric'],
		'4arr' : ['nSec:Numeric','args:Array+']
	},"$Fn#delay");
	switch(oArgs+""){
		case "4num":
			args = args || [];
			break;
		case "4arr":
			args = oArgs.args;

	}
	this._delayKey = setTimeout(this.bind.apply(this, args), nSec*1000);
	return this;
};
//-!MobileCommentJindo.$Fn.prototype.delay end!-//

//-!MobileCommentJindo.$Fn.prototype.setInterval start(MobileCommentJindo.$Fn.prototype.bind)!-//
/**

 * @description setInterval() 메서드는 래핑한 함수를 지정한 시간 간격마다 호출한다.

 * @param1 {Numeric} nSec 함수를 호출할 시간 간격(초 단위).
 * @return1 {$Fn} 생성된 $Fn() 객체.

 * @param2 {Numeric} nSec 함수를 호출할 시간 간격(초 단위).
 * @param2 {Array+} [aArgs] 함수를 호출할 때 사용할 파라미터를 담은 배열.
 * @return2 {$Fn} 생성된 $Fn() 객체.
 * @see $Fn#bind
 * @see $Fn#delay
 * @example
function func(a, b) {
	alert(a + b);
}

$Fn(func).setInterval(5, [3, 5]);//5초 간격으로 3, 5 값을 매개변수로 하는 함수 func를 호출한다.

 */
MobileCommentJindo.$Fn.prototype.setInterval = function(nSec, args) {
	//-@@$Fn.setInterval-@@//
	//-@@$Fn.repeat-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4num' : ['nSec:Numeric'],
		'4arr' : ['nSec:Numeric','args:Array+']
	},"$Fn#setInterval");
	switch(oArgs+""){
		case "4num":
			args = args || [];
			break;
		case "4arr":
			args = oArgs.args;

	}
	this._repeatKey = setInterval(this.bind.apply(this, args), nSec*1000);
	return this;
};
//-!MobileCommentJindo.$Fn.prototype.setInterval end!-//

//-!MobileCommentJindo.$Fn.prototype.repeat start(MobileCommentJindo.$Fn.prototype.setInterval)!-//
/**

 * @function
 * @description repeat 메서드는 setInterval() 메서드와 동일하다.

 * @param1 {Numeric} nSec 함수를 호출할 시간 간격(초 단위).
 * @return1 {$Fn} 생성된 $Fn() 객체.

 * @param2 {Numeric} nSec 함수를 호출할 시간 간격(초 단위).
 * @param2 {Array+} [aArgs] 함수를 호출할 때 사용할 파라미터를 담은 배열.
 * @return2 {$Fn} 생성된 $Fn() 객체.
 * @see $Fn#setInterval
 * @see $Fn#bind
 * @see $Fn#delay
 * @example
function func(a, b) {
	alert(a + b);
}

$Fn(func).repeat(5, [3, 5]);//5초 간격으로 3, 5 값을 매개변수로 하는 함수 func를 호출한다.

 */
MobileCommentJindo.$Fn.prototype.repeat = MobileCommentJindo.$Fn.prototype.setInterval;
//-!MobileCommentJindo.$Fn.prototype.repeat end!-//

//-!MobileCommentJindo.$Fn.prototype.stopDelay start!-//
/**

 * @description stopDelay() 메서드는 delay() 메서드로 지정한 함수 호출을 중지할 때 사용한다.
 * @return {$Fn} $Fn() 객체.
 * @see $Fn#delay
 * @example
function func(a, b) {
	alert(a + b);
}

var fpDelay = $Fn(func);
	fpDelay.delay(5, [3, 5]);
	fpDelay.stopDelay();


 */
MobileCommentJindo.$Fn.prototype.stopDelay = function(){
	//-@@$Fn.stopDelay-@@//
	if(this._delayKey !== undefined){
		window.clearTimeout(this._delayKey);
		delete this._delayKey;
	}
	return this;
};
//-!MobileCommentJindo.$Fn.prototype.stopDelay end!-//

//-!MobileCommentJindo.$Fn.prototype.stopRepeat start!-//
/**

 * @description stopRepeat() 메서드는 repeat() 메서드로 지정한 함수 호출을 멈출 때 사용한다.
 * @return {$Fn} $Fn() 객체.
 * @see $Fn#repeat
 * @example
function func(a, b) {
	alert(a + b);
}

var fpDelay = $Fn(func);
	fpDelay.repeat(5, [3, 5]);
	fpDelay.stopRepeat();

 */
MobileCommentJindo.$Fn.prototype.stopRepeat = function(){
	//-@@$Fn.stopRepeat-@@//
	if(this._repeatKey !== undefined){
		window.clearInterval(this._repeatKey);
		delete this._repeatKey;
	}
	return this;
};
//-!MobileCommentJindo.$Fn.prototype.stopRepeat end!-//


//-!MobileCommentJindo.$Event start!-//
/**

 * @fileOverview $Event() 객체의 생성자 및 메서드를 정의한 파일
 * @name event.js
 * @author AjaxUI lab

 */

/**

 * @class $Event() 객체는 Event 객체를 래핑하여 이벤트 처리와 관련된 확장 기능을 제공한다. 사용자는 $Event() 객체를 사용하여 발생한 이벤트에 대한 정보를 파악하거나 동작을 지정할 수 있다.
 * @constructor
 * @description Event 객체를 래핑한 $Event() 객체를 생성한다.
 * @param {Event} event Event 객체.

 */
MobileCommentJindo.$Event = (function(isMobile) {
	if(isMobile){
		return function(e){
			//-@@$Event-@@//
			var cl = arguments.callee;
			if (e instanceof cl) return e;
			if (!(this instanceof cl)) return new cl(e);

			this._event = this._posEvent = e;
			this._globalEvent = window.event;
		    /**

이벤트의 종류

		     */
			this.type = e.type.toLowerCase();
			if (this.type == "dommousescroll") {
				this.type = "mousewheel";
			} else if (this.type == "domcontentloaded") {
				this.type = "domready";
			}

			this.isTouch = false;
			if(this.type.indexOf("touch") > -1){
				this._posEvent = e.changedTouches[0];
				this.isTouch = true;
			}

			this.canceled = false;

			/**

이벤트가 발생한 엘리먼트

		     */
			this.element = e.target || e.srcElement;
		    /**

이벤트가 정의된 엘리먼트

		     */
			this.currentElement = e.currentTarget;
		    /**

이벤트의 연관 엘리먼트

		     */
			this.relatedElement = null;

			if (!MobileCommentJindo.$Jindo.isUndefined(e.relatedTarget)) {
				this.relatedElement = e.relatedTarget;
			} else if(e.fromElement && e.toElement) {
				this.relatedElement = e[(this.type=="mouseout")?"toElement":"fromElement"];
			}
		};
	}else{
		return function(e){
			//-@@$Event-@@//
			var cl = arguments.callee;
			if (e instanceof cl) return e;
			if (!(this instanceof cl)) return new cl(e);

			if (e === undefined) e = window.event;
			if (e === window.event && document.createEventObject) e = document.createEventObject(e);


			this.isTouch = false;
			this._event = this._posEvent = e;
			this._globalEvent = window.event;

		    /**

이벤트의 종류

		     */
			this.type = e.type.toLowerCase();
			if (this.type == "dommousescroll") {
				this.type = "mousewheel";
			} else if (this.type == "domcontentloaded") {
				this.type = "domready";
			}

			this.canceled = false;

			/**

이벤트가 발생한 엘리먼트

		     */
			this.element = e.target || e.srcElement;
		    /**

이벤트가 정의된 엘리먼트

		     */
			this.currentElement = e.currentTarget;
		    /**

이벤트의 연관 엘리먼트

		     */
			this.relatedElement = null;

			if (e.relatedTarget !== undefined) {
				this.relatedElement = e.relatedTarget;
			} else if(e.fromElement && e.toElement) {
				this.relatedElement = e[(this.type=="mouseout")?"toElement":"fromElement"];
			}
		};
	}
})(_JINDO_IS_MO);
//-!MobileCommentJindo.$Event end!-//

//-!MobileCommentJindo.$Event.prototype.mouse start!-//
/**

 * @description mouse() 메서드는 마우스 이벤트 정보를 담고 있는 객체를 반환한다. 마우스 이벤트 정보 객체의 속성에 대한 설명은 다음 표와 같다.<br>
 * @since 2.0.0부터는 인자로 boolean값을 넣을 수 있으며 true인 경우 scroll속성을 알 수 있다.
 * @param1
 * @return1 {Object} 마우스 이벤트 정보를 갖는 객체.
 * @param2 {Boolean} bIsScrollbar true이면 scroll속성을 알 수 있다.(기본 값은 false) - desktop에서만 사용가능
 * @return2 {Object} 마우스 이벤트 정보를 갖는 객체.
 <table>
	<caption>마우스 이벤트 정보 객체 속성</caption>
	<thead>
		<tr>
			<th scope="col">속성</th>
			<th scope="col">타입</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>delta</td>
			<td>Number</td>
			<td>마우스 휠을 굴린 정도를 정수로 저장한다. 마우스 휠을 위로 굴린 정도는 양수 값으로, 아래로 굴린 정도는 음수 값으로 저장한다.</td>
		</tr>
		<tr>
			<td>left</td>
			<td>Boolean</td>
			<td>마우스 왼쪽 버튼 클릭 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>middle</td>
			<td>Boolean</td>
			<td>마우스 가운데 버튼 클릭 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>right</td>
			<td>Boolean</td>
			<td>마우스 오른쪽 버튼 클릭 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>scroll</td>
			<td>Boolean</td>
			<td>이벤트가 스크롤에서 발생했는지를 알수있다.</td>
		</tr>
	</tbody>
</table>
* @example
function eventHandler(evt) {
   var mouse = evt.mouse();

   mouse.delta;   // Number. 휠이 움직인 정도. 휠을 위로 굴리면 양수, 아래로 굴리면 음수.
   mouse.left;    // 마우스 왼쪽 버튼을 입력된 경우 true, 아니면 false
   mouse.middle;  // 마우스 중간 버튼을 입력된 경우 true, 아니면 false
   mouse.right;   // 마우스 오른쪽 버튼을 입력된 경우 true, 아니면 false
}

 */
MobileCommentJindo.$Event.prototype.mouse = function(bIsScrollbar) {
	//-@@$Event.mouse-@@//
	MobileCommentJindo.$Jindo.checkVarType(arguments,{
		"voi" : [],
		"bol" : ["bIsScrollbar:Boolean"]
	});
	var e    = this._event;
	var ele  = this.element;
	var delta = 0;
	var left = false,mid = false,right = false;

	var left  = e.which ? e.button==0 : !!(e.button&1);
	var mid   = e.which ? e.button==1 : !!(e.button&4);
	var right = e.which ? e.button==2 : !!(e.button&2);
	var ret   = {};

	if (e.wheelDelta) {
		delta = e.wheelDelta / 120;
	} else if (e.detail) {
		delta = -e.detail / 3;
	}
	var scrollbar;
	if(bIsScrollbar){
		scrollbar = _event_isScroll(ele,e);
	}


	ret = {
		delta  : delta,
		left   : left,
		middle : mid,
		right  : right,
		scrollbar : scrollbar
	};
	// replace method
	this.mouse = function(bIsScrollbar){
		if(bIsScrollbar){
			ret.scrollbar = _event_isScroll(this.element,this._event);
			this.mouse = function(){return ret;};
		}
		return ret;
	};

	return ret;
};
/**
 * @ignore
 */
function _event_getScrollbarSize() {

	var oScrollbarSize = { x : 0, y : 0 };

	var elDummy = MobileCommentJindo.$([
		'<div style="',
		[
			'overflow:scroll',
			'width:100px',
			'height:100px',
			'position:absolute',
			'left:-1000px',
			'border:0',
			'margin:0',
			'padding:0'
		].join(' !important;'),
		' !important;">'
	].join(''));

	document.body.insertBefore(elDummy, document.body.firstChild);

	oScrollbarSize = {
		x : elDummy.offsetWidth - elDummy.scrollWidth,
		y : elDummy.offsetHeight - elDummy.scrollHeight
	};

	document.body.removeChild(elDummy);
	elDummy = null;

	_event_getScrollbarSize = function() {
		return oScrollbarSize;
	};

	return oScrollbarSize;

}
/**
 * @ignore
 */
function _event_isScroll(ele,e){

	// IE 의 경우 componentFromPoint 메서드를 제공하므로 이걸 활용
	if (ele.componentFromPoint) {
		return /(scrollbar|outside)/.test(ele.componentFromPoint(e.clientX, e.clientY));
	}

	// 파이어폭스는 스크롤바 클릭시 XUL 객체로 지정
	if (_JINDO_IS_FF) {

		try {
			var name = e.originalTarget.localName;
			return (
				name === 'thumb' ||
				name === 'slider' ||
				name === 'scrollcorner' ||
				name === 'scrollbarbutton'
			);
		} catch(ex) {
			return true;
		}

	}

	var sDisplay = MobileCommentJindo.$Element(ele).css('display');
	if (sDisplay === 'inline') { return false; }

	// 엘리먼트 내에서 클릭된 위치 얻기
	var oPos = {
		x : e.offsetX || e.layerX || 0,
		y : e.offsetY || e.layerY || 0
	};

	// Webkit 의 경우 border 의 사이즈가 더해져서 나옴
	if (_JINDO_IS_WK) {
		oPos.x -= ele.clientLeft;
		oPos.y -= ele.clientTop;
	}

	var oScrollbarSize = _event_getScrollbarSize();

	// 스크롤바가 있는 영역
	var oScrollPos = {
		x : [ ele.clientWidth, ele.clientWidth + oScrollbarSize.x ],
		y : [ ele.clientHeight, ele.clientHeight + oScrollbarSize.y ]
	};

	return (
		(oScrollPos.x[0] <= oPos.x && oPos.x <= oScrollPos.x[1]) ||
		(oScrollPos.y[0] <= oPos.y && oPos.y <= oScrollPos.y[1])
	);
}
//-!MobileCommentJindo.$Event.prototype.mouse end!-//

//-!MobileCommentJindo.$Event.prototype.key start!-//
/**

  * @description key() 메서드는 키보드 이벤트 정보를 담고 있는 객체를 반환한다. 키보드 이벤트 정보 객체의 속성에 대한 설명은 다음 표와 같다.<br>
 <table>
	<caption>키보드 이벤트 정보 객체 속성</caption>
	<thead>
		<tr>
			<th scope="col">속성</th>
			<th scope="col">타입</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>alt</td>
			<td>Boolean</td>
			<td>ALT 키 입력 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>ctrl</td>
			<td>Boolean</td>
			<td>CTRL 키 입력 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>down</td>
			<td>Boolean</td>
			<td>아래쪽 방향키 입력 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>enter</td>
			<td>Boolean</td>
			<td>엔터(enter)키 입력 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>esc</td>
			<td>Boolean</td>
			<td>ESC 키 입력 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>keyCode</td>
			<td>Boolean</td>
			<td>입력한 키의 코드 값을 정수 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>left</td>
			<td>Boolean</td>
			<td>왼쪽 방향키 입력 여부를 불리언 형태 저장한다.</td>
		</tr>
		<tr>
			<td>meta</td>
			<td>Boolean</td>
			<td>META키(Mac 용 키보드의 Command 키) 입력 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>right</td>
			<td>Boolean</td>
			<td>오른쪽 방향키 입력 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>shift</td>
			<td>Boolean</td>
			<td>Shift키 입력 여부를 불리언 형태로 저장한다.</td>
		</tr>
		<tr>
			<td>up</td>
			<td>Boolean</td>
			<td>위쪽 방향키 입력 여부를 불리언 형태로 저장한다.</td>
		</tr>
	</tbody>
</table>
 * @return {Object} 키보드 이벤트 정보를 갖는 객체.
 * @example
function eventHandler(evt) {
   var key = evt.key();

   key.keyCode; // Number. 키보드의 키코드
   key.alt;     // Alt 키를 입력된 경우 true.
   key.ctrl;    // Ctrl 키를 입력된 경우 true.
   key.meta;    // Meta 키를 입력된 경우 true.
   key.shift;   // Shift 키를 입력된 경우 true.
   key.up;      // 위쪽 화살표 키를 입력된 경우 true.
   key.down;    // 아래쪽 화살표 키를 입력된 경우 true.
   key.left;    // 왼쪽 화살표 키를 입력된 경우 true.
   key.right;   // 오른쪽 화살표 키를 입력된 경우 true.
   key.enter;   // 리턴키를 눌렀으면 true
   key.esc;   // ESC키를 눌렀으면 true
   }

 */
MobileCommentJindo.$Event.prototype.key = function() {
	//-@@$Event.key-@@//
	var e     = this._event;
	var k     = e.keyCode || e.charCode;
	var ret   = {
		keyCode : k,
		alt     : e.altKey,
		ctrl    : e.ctrlKey,
		meta    : e.metaKey,
		shift   : e.shiftKey,
		up      : (k == 38),
		down    : (k == 40),
		left    : (k == 37),
		right   : (k == 39),
		enter   : (k == 13),
		esc   : (k == 27)
	};

	this.key = function(){ return ret };

	return ret;
};
//-!MobileCommentJindo.$Event.prototype.key end!-//

//-!MobileCommentJindo.$Event.prototype.pos start(MobileCommentJindo.$Element.prototype.offset)!-//
/**

   * @description pos() 메서드는 마우스 커서의 위치 정보를 담고 있는 객체를 반환한다. 키보드 커서 위치 정보 객체의 속성에 대한 설명은 다음 표와 같다.<br>
 <table>
	<caption>마우서 커서 위치 정보 객체 속성</caption>
	<thead>
		<tr>
			<th scope="col">속성</th>
			<th scope="col">타입</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>clientX</td>
			<td>Number</td>
			<td>화면을 기준으로 마우스 커서의 X좌표를 저장한다.</td>
		</tr>
		<tr>
			<td>clientY</td>
			<td>Number</td>
			<td>화면을 기준으로 마우스 커서의 Y좌표를 저장한다.</td>
		</tr>
		<tr>
			<td>offsetX</td>
			<td>Number</td>
			<td>DOM 요소를 기준으로 마우스 커서의 상대적인 X좌표를 저장한다.</td>
		</tr>
		<tr>
			<td>offsetY</td>
			<td>Number</td>
			<td>DOM 요소를 기준으로 마우스 커서의 상대적인 Y좌표를 저장한다.</td>
		</tr>
		<tr>
			<td>pageX</td>
			<td>Number</td>
			<td>문서를 기준으로 마우스 커서의 X 좌표를 저장한다.</td>
		</tr>
		<tr>
			<td>pageY</td>
			<td>Number</td>
			<td>문서를 기준으로 마우스 커서의 Y좌표를 저장한다.</td>
		</tr>
	</tbody>
</table>
<b>참고</b>
<ul>
	<li>layerX, layerY는 더 이상 지원하지 않는다(deprecated).</li>
	<li>pos() 메서드를 사용하려면 Jindo 프레임워크에 $Element() 객체가 포함되어 있어야 한다.</li>
</ul>
 * @param1
 * @return1 {Object} 마우스 커서의 위치 정보.
 * @param2 {Boolean} bGetOffset 이벤트가 발생한 요소에서 마우스 커서의 상대 위치인 offsetX, offsetY 값을 구할 것인지를 결정할 파라미터. bGetOffset 값이 true면 값을 구한다.
 * @return2 {Object} 마우스 커서의 위치 정보.
 * @example
function eventHandler(evt) {
   var pos = evt.pos();

   pos.clientX;  // 현재 화면에 대한 X 좌표
   pos.clientY;  // 현재 화면에 대한 Y 좌표
   pos.pageX;  // 문서 전체에 대한 X 좌표
   pos.pageY;  // 문서 전체에 대한 Y 좌표
   pos.offsetX; // 이벤트가 발생한 엘리먼트에 대한 마우스 커서의 상대적인 X좌표 (1.2.0 이상)
   pos.offsetY; // 이벤트가 발생한 엘리먼트에 대한 마우스 커서의 상대적인 Y좌표 (1.2.0 이상)
   pos.layerX;  // (deprecated)이벤트가 발생한 엘리먼트로부터의 상대적인 X 좌표
   pos.layerY;  // (deprecated)이벤트가 발생한 엘리먼트로부터의 상대적인 Y 좌표
}

 */
MobileCommentJindo.$Event.prototype.pos = function(bGetOffset) {
	//-@@$Event.pos-@@//
	MobileCommentJindo.$Jindo.checkVarType(arguments,{
		"voi" : [],
		"bol" : ["bGetOffset:Boolean"]
	});
	var e   = this._posEvent;
	var doc = (this.element.ownerDocument||document);
	var b   = doc.body;
	var de  = doc.documentElement;
	var pos = [b.scrollLeft || de.scrollLeft, b.scrollTop || de.scrollTop];
	var ret = {
		clientX : e.clientX,
		clientY : e.clientY,
		pageX   : 'pageX' in e ? e.pageX : e.clientX+pos[0]-b.clientLeft,
		pageY   : 'pageY' in e ? e.pageY : e.clientY+pos[1]-b.clientTop,
		layerX  : 'offsetX' in e ? e.offsetX : e.layerX - 1,
		layerY  : 'offsetY' in e ? e.offsetY : e.layerY - 1
	};

    /*

오프셋을 구하는 메소드의 비용이 크므로, 요청시에만 구하도록 한다.

     */
	if (bGetOffset && MobileCommentJindo.$Element) {
		var offset = MobileCommentJindo.$Element(this.element).offset();
		ret.offsetX = ret.pageX - offset.left;
		ret.offsetY = ret.pageY - offset.top;
	}

	return ret;
};
//-!MobileCommentJindo.$Event.prototype.pos end!-//

//-!MobileCommentJindo.$Event.prototype.stop start!-//
/**

 * @description stop() 메서드는 이벤트의 버블링과 기본 동작을 중지시킨다. 버블링은 특정 HTML 엘리먼트에서 이벤트가 발생했을 때 이벤트가 상위 노드로 전파되는 현상이다. 예를 들어, &lt;div&gt; 요소를 클릭할 때 &lt;div&gt; 요소와 함께 상위 요소인 document 요소에도 onclick 이벤트가 발생한다. stop() 메서드는 지정한 객체에서만 이벤트가 발생하도록 버블링을 차단한다.
 *
 * @param1 {Void}
 * @return1 {$Event} 이벤트 객체.
 *
 * @param2 {Numeric} nCancelConstant $Event() 객체의 상수. 지정한 상수에 따라 이벤트의 버블링과 기본 동작을 선택하여 중지시킨다. $Event() 객체의 상수 값으로 CANCEL_ALL, CANCEL_BUBBLE, CANCEL_DEFAULT가 있으며, 기본 값은 CANCEL_ALL이다(1.1.3 버전 이상).
 * @return2 {$Event} 이벤트 객체.
 *
 * @see $Event.CANCEL_ALL
 * @see $Event.CANCEL_BUBBLE
 * @see $Event.CANCEL_DEFAULT
 * @example
// 기본 동작만 중지시키고 싶을 때 (1.1.3버전 이상)
function stopDefaultOnly(evt) {
	// Here is some code to execute

	// Stop default event only
	evt.stop($Event.CANCEL_DEFAULT);
}

 */
MobileCommentJindo.$Event.prototype.stop = function(nCancel) {
	//-@@$Event.stop-@@//
	MobileCommentJindo.$Jindo.checkVarType(arguments,{
		"voi" : [],
		"num" : ["nCancel:Numeric"]
	});
	nCancel = nCancel || MobileCommentJindo.$Event.CANCEL_ALL;

	var e = (window.event && window.event == this._globalEvent)?this._globalEvent:this._event;
	var b = !!(nCancel & MobileCommentJindo.$Event.CANCEL_BUBBLE); // stop bubbling
	var d = !!(nCancel & MobileCommentJindo.$Event.CANCEL_DEFAULT); // stop default event

	this.canceled = true;

	if (e.preventDefault !== undefined && d) e.preventDefault();
	if (e.stopPropagation !== undefined && b) e.stopPropagation();

	if(d) e.returnValue = false;
	if(b) e.cancelBubble = true;

	return this;
};

/**

 * @description stopDefault() 메서드는 이벤트의 기본 동작을 중지시킨다. stop() 메서드의 파라미터로 CANCEL_DEFAULT 값을 입력한 것과 같다.
 * @return {$Event} 이벤트 객체.
 * @see $Event#stop
 * @see $Event.CANCEL_DEFAULT

 */
MobileCommentJindo.$Event.prototype.stopDefault = function(){
	return this.stop(MobileCommentJindo.$Event.CANCEL_DEFAULT);
};

/**

 * @description stopBubble() 메서드는 이벤트의 버블링을 중지시킨다. stop() 메서드의 파라미터로 CANCEL_BUBBLE 값을 입력한 것과 같다.
 * @return {$Event} 이벤트 객체.
 * @see $Event#stop
 * @see $Event.CANCEL_BUBBLE

 */
MobileCommentJindo.$Event.prototype.stopBubble = function(){
	return this.stop(MobileCommentJindo.$Event.CANCEL_BUBBLE);
};

/**

 * @constant
 * @description CANCEL_BUBBLE는 stop() 메서드에서 버블링을 중지시킬 때 사용되는 상수이다.
 * @see $Event#stop
 * @final

 */
MobileCommentJindo.$Event.CANCEL_BUBBLE = 1;

/**

 * @constant
 * @description CANCEL_DEFAULT는 stop() 메서드에서 기본 동작을 중지시킬 때 사용되는 상수이다.
 * @see $Event#stop
 * @final

 */
MobileCommentJindo.$Event.CANCEL_DEFAULT = 2;

/**

 * @constant
 * @description CANCEL_ALL는 stop() 메서드에서 버블링과 기본 동작을 모두 중지시킬 때 사용되는 상수이다.
 * @see $Event#stop
 * @final

 */
MobileCommentJindo.$Event.CANCEL_ALL = 3;
//-!MobileCommentJindo.$Event.prototype.stop end!-//

//-!MobileCommentJindo.$Event.prototype.$value start!-//
/**

 * @description $value 메서드는 원본 Event 객체를 리턴한다
 * @return {Event} 원본 Event 객체
 * @example
function eventHandler(evt){
	evt.$value();
}

 */
MobileCommentJindo.$Event.prototype.$value = function() {
	//-@@$Event.$value-@@//
	return this._event;
};
//-!MobileCommentJindo.$Event.prototype.$value end!-//

//-!MobileCommentJindo.$Event.prototype.changedTouch start(MobileCommentJindo.$Event.prototype.targetTouch)!-//
/**

 * 모바일에서 touch관련 이벤트를 사용시 changeTouches객체를 좀 더 쉽게 사용하도록 한다.
 * @name $Event#changedTouch
 * @caution 데스크탑에서는 작동하지 않는다.
 * @since 2.0.0

 * @param1 {Void}
 * @return1 {Array} 각종 정보 데이터가 들어있는 배열

 * @param2 {Numeric} 인덱스 번호
 * @return2 {Hash} 각종 정보 데이터

 * @throws {$Except.NOT_SUPPORT_METHOD} 데스크탑에서 사용할 때 예외상황 발생.
 * @see $Event#targetTouch
 * @see $Event#pos
 * @example
 $Element("only_mobile").attach("touchstart",function(e){
 	e.changeTouch(0);
	{
	   "id" : "123123",// identifier
	   "event" : $Event,// $Event
	   "element" : element, // 해당 엘리먼트
	   "pos" : function(){}//  메서드 (Pos메서드과 같음)
	}

 	e.changeTouch();
	[
		{
		   "id" : "123123",
		   "event" : $Event,
		   "element" : element,
		   "pos" : function(){}
		},
		{
		   "id" : "123123",
		   "event" : $Event,
		   "element" : element,
		   "pos" : function(){}
		}
	]

 });

 */
(function(aType){
	var sTouches = "Touch";
	for(var i = 0, l = aType.length; i < l; i++){
		MobileCommentJindo.$Event.prototype[aType[i]+sTouches] = (function(sType){
			return function(nIndex){
				if(this.isTouch){
					var oRet = [];
					var ev = this._event[sType+"es"];
					var l = ev.length;
					var e;
					for(var i = 0; i < l; i++){
						e = ev[i];
						oRet.push({
							"id" : e.identifier,
							"event" : this,
							"element" : e.target,
							"_posEvent" : e,
							"pos" : MobileCommentJindo.$Event.prototype.pos
						});
					}
					this[sType] = function(nIndex){
						var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
							'void' : [  ],
							'4num' : [ 'nIndex:Numeric' ]
						},"$Event#"+sType);
						if(oArgs+"" == 'void') return oRet;

						return oRet[nIndex];
					}
				}else{
					this[sType] = function(nIndex){
						throw new MobileCommentJindo.$Error(MobileCommentJindo.$Except.NOT_SUPPORT_METHOD,"$Event#"+sType);
					}
				}

				return this[sType].apply(this,_toArray(arguments));
			};
		})(aType[0]+sTouches);
	}

})(["changed","target"]);
//-!MobileCommentJindo.$Event.prototype.changedTouch end!-//

//-!MobileCommentJindo.$Event.prototype.targetTouch start(MobileCommentJindo.$Event.prototype.changedTouch)!-//
/**

 * 모바일에서 touch관련 이벤트를 사용시 targetTouches객체를 좀 더 쉽게 사용하도록 한다.
 * @name $Event#targetTouch
 * @caution 데스크탑에서는 작동하지 않는다.
 * @since 2.0.0

 * @param1 {Void}
 * @return1 {Array} 각종 정보 데이터가 들어있는 배열

 * @param2 {Numeric} 인덱스 번호
 * @return2 {Hash} 각종 정보 데이터

 * @throws {$Except.NOT_SUPPORT_METHOD} 데스크탑에서 사용할 때 예외상황 발생.
 * @see $Event#changedTouch
 * @see $Event#pos
 * @example
 $Element("only_mobile").attach("touchstart",function(e){
	e.targetTouch(0);
	{
	   "id" : "123123",// identifier
	   "event" : $Event,// $Event
	   "element" : element, // 해당 엘리먼트
	   "pos" : function(){}//  메서드 (Pos메서드과 같음)
	}

	e.targetTouch();
	[
		{
		   "id" : "123123",
		   "event" : $Event,
		   "element" : element,
		   "pos" : function(){}
		},
		{
		   "id" : "123123",
		   "event" : $Event,
		   "element" : element,
		   "pos" : function(){}
		}
	]
 });

 */
//-!MobileCommentJindo.$Event.prototype.targetTouch end!-//


//-!MobileCommentJindo.$ElementList start(MobileCommentJindo.$Element)!-//
/**

 * @fileOverview $ElementList의 생성자 및 메서드를 정의한 파일
 * @name elementlist.js
 * @author AjaxUI lab

 */

/**

 * @class $ElementList() 객체는 여러 개의 DOM 요소를 한 번에 다룰 수 있는 기능을 제공한다. $ElementList 객체는 DOM 요소를 배열 형태로 관리한다.
 * @constructor
 * @description $ElementList() 객체를 생성한다. $ElementList() 객체를 생성할 때 DOM 요소의 ID 또는 ID를 원소로 같은 배열, 혹은 CSS 선택자, $Element() 객체를 원소로 갖는 배열 등을 사용하여 $ElementList() 객체를 생성한다.
 *
 * @param1 {Void}
 *
 * @param2 {String+} sIDorSelector 문서에서 DOM 요소를 찾기 위한 CSS 선택자(CSS Selector) 혹은 ID 를 입력한다.
 *
 * @param3 {Array+} aList 문서에서 DOM 요소의 ID, Element, $Element() 객체를 원소로 같는 배열을 입력한다.
 *
 * @borrows $Element#show as this.show
 * @borrows $Element#hide as this.hide
 * @borrows $Element#toggle as this.toggle
 * @borrows $Element#addClass as this.addClass
 * @borrows $Element#removeClass as this.removeClass
 * @borrows $Element#toggleClass as this.toggleClass
 * @borrows $Element#fireEvent as this.fireEvent
 * @borrows $Element#leave as this.leave
 * @borrows $Element#empty as this.empty
 * @borrows $Element#appear as this.appear
 * @borrows $Element#disappear as this.disappear
 * @borrows $Element#className as this.className
 * @borrows $Element#width as this.width
 * @borrows $Element#height as this.height
 * @borrows $Element#text as this.text
 * @borrows $Element#html as this.html
 * @borrows $Element#css as this.css
 * @borrows $Element#attr as this.attr
 * @example
 // 'foo', 'bar' 요소의 ElementList를 생성한다.
var woElList = $ElementList($('foo','bar'));

// 문서의 모든 'DIV' 요소에 대한 $ElementList를 생성한다.
var woElList = $ElementList('DIV');


 */
MobileCommentJindo.$ElementList = function (els) {
	//-@@$ElementList-@@//
	var cl = arguments.callee;
	if (els instanceof cl) return els;

	if (!(this instanceof cl)){
		try {
			return new cl(els);
		} catch(e) {
			if (e instanceof TypeError) { return null; }
			throw e;
		}
	}

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4arr' : [ 'aEle:Array+' ],
		'4str' : [ 'sCssQuery:String+' ],
		'4nul' : [ 'oEle:Null' ],
		'4und' : [ 'oEle:Undefined' ]
	},"$ElementList");

	switch(oArgs+""){
		case "4arr":
			els = oArgs.aEle;
			break;
		case "4str":
			els = MobileCommentJindo.cssquery(oArgs.sCssQuery);
			break;
		case "4nul":
		case "4und":
			els = [];
	}

	this._elements = [];
	for(var i = 0, l = els.length; i < l ;i++){
		this._elements.push(MobileCommentJindo.$Element(els[i]));
	}
};
//-@@$ElementList.meta_program_config-@@//
(function(proto){
	var setters = ['show','hide','toggle','addClass','removeClass','toggleClass','fireEvent','leave',
				   'empty','className','width','height','text','html','css','attr'];

	for (var i = 0, l = setters.length; i < l; i++) {
		var name = setters[i];
		if(MobileCommentJindo.$Element.prototype[name]){
			proto[setters[i]] = (function(name) {
				return function(){
					//-@@$ElementList.meta_program-@@//
					try{
						var args = [];
						for(var j = 0,m = arguments.length ; j < m ; j++){
							args.push(arguments[j]);
						}
						for(var k = 0,n = this._elements.length ; k < n ; k++){
							this._elements[k][name].apply(this._elements[k], args);
						}
						return this;
					}catch(e){
						throw TypeError(e.message.replace(/\$Element/g,"$Elementlist#"+name).replace(/Element\.html/g,"Elementlist.html#"+name));
					}
				}

			})(setters[i]);
		}

	}


	var setters2 = ['appear','disappear'];
	for (var i = 0, l = setters2.length; i < l; i++) {
		if (MobileCommentJindo.$Element.prototype[name]) {
			proto[setters2[i]] = (function(name){
				return function(duration, callback) {
					//-@@$ElementList.meta_program-@@//
					try{
						var self = this;
						for (var j = 0, m = this._elements.length; j < m; j++) {
							if(j == m-1) {
								this._elements[j][name](duration, function(){callback(self)});
							} else {
								this._elements[j][name](duration);
							}
						}
						return this;
					}catch(e){
						throw TypeError(e.message.replace(/\$Element/g,"$Elementlist#"+name).replace(/Element\.html/g,"Elementlist.html#"+name));
					}
				}
			})(setters2[i]);
		}
	}

})(MobileCommentJindo.$ElementList.prototype);
//-!MobileCommentJindo.$ElementList end!-//

//-!MobileCommentJindo.$ElementList.prototype.get start!-//
/**

 * @description get() 메서드는 $ElementList() 객체의 내부 요소 중에서 지정한 인덱스에 해당하는 요소를 반환한다.
 * @param {Numeric} nIndex 가져올 요소의 인덱스.<br>인덱스는 0부터 시작한다.
 * @return {$Element} 지정한 인덱스의 요소.

*/
MobileCommentJindo.$ElementList.prototype.get = function(idx) {
	//-@@$ElementList.get-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4num' : [ 'nIdx:Numeric' ]
	},"$ElementList#get");
	return this._elements[idx];
};
//-!MobileCommentJindo.$ElementList.prototype.get end!-//

//-!MobileCommentJindo.$ElementList.prototype.getFirst start!-//
/**

 * @description getFirst() 메서드는 $ElementList() 객체의 첫 번째 요소를 반환한다. get() 메서드에 인덱스 값으로 0을 지정한 것과 동일하다.
 * @return {$Element} $ElementList() 객체의 첫 번째 요소.
 * @see $ElementList#get
 * @see $ElementList#getLast

*/
MobileCommentJindo.$ElementList.prototype.getFirst = function() {
	//-@@$ElementList.getFirst-@@//
	return this._elements[0];
};
//-!MobileCommentJindo.$ElementList.prototype.getFirst end!-//

//-!MobileCommentJindo.$ElementList.prototype.getLast start!-//
/**

 * @description getFirst() 메서드는 $ElementList() 객체의 마지막 요소를 반환한다. get() 메서드에 인덱스 값으로 마지막 인덱스 번호를 지정한 것과 동일하다.
 * @return {$Element} $ElementList() 객체의 마지막 요소.
 * @see $ElementList#get
 * @see $ElementList#getFirst

*/
MobileCommentJindo.$ElementList.prototype.getLast = function() {
	//-@@$ElementList.getLast-@@//
	return this._elements[Math.max(this._elements.length-1,0)];
};
//-!MobileCommentJindo.$ElementList.prototype.getLast end!-//

//-!MobileCommentJindo.$ElementList.prototype.length start(MobileCommentJindo.$A.prototype.length)!-//
/**

 * @description length() 메서드는 $A() 객체의 length() 메서드를 이용하여 $ElementList() 객체의 크기를 반환하거나 조정한다.
 *
 * @param1 {Void}
 * @return1 	{Number} 현재 $ElementList() 객체의 배열 크기(Number)를 반환한다.
 *
 * @param2 	{Numeric} nLen 지정할 배열의 크기. nLen이 기존 $ElementList() 객체의 배열 크기보다 작으면 nLen 번째 이후의 원소는 제거한다.
 * @return2 	{$ElementList} 내부 배열을 변경한 $ElementList() 객체를 반환한다.
 *
 * @param3 	{Numeric} nLen 지정할 배열의 크기. nLen이 기존 $ElementList() 객체의 배열 크기보다 크면 추가된 배열의 공간에 oValue 파라미터의 값으로 채운다. nLen이 기존 $ElementList() 객체의 배열 크기보다 작으면 nLen 번째 이후의 원소는 제거한다.
 * @param3 	{Variant} oValue 새로운 원소를 추가할 때 사용할 초기 값.
 * @return3 	{$ElementList} 내부 배열을 변경한 $ElementList() 객체를 반환한다.
 *
 * @since 1.4.3
 * @see $A#length

*/
MobileCommentJindo.$ElementList.prototype.length = function(nLen, oValue) {
	//-@@$ElementList.length-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4voi' : [],
		'4num' : [ MobileCommentJindo.$Jindo._F("nLen:Numeric")],
		'4var' : [ "nLen:Numeric", "oValue:Variant"]
	},"$ElementList#length");

	var waEle = MobileCommentJindo.$A(this._elements);
	try{
		return waEle.length.apply(waEle, _toArray(arguments));
	}catch(e){
		throw TypeError(e.message.replace(/\$A/g,"$Elementlist#length").replace(/A\.html/g,"Elementlist.html#length"));
	}
};
//-!MobileCommentJindo.$ElementList.prototype.length end!-//

//-!MobileCommentJindo.$ElementList.prototype.$value start!-//
/**

 * @description $value() 메서드는 내부 배열을 반환한다.
 * @return {Array} $Element() 객체를 원소로 갖는 배열.

*/
MobileCommentJindo.$ElementList.prototype.$value = function() {
	//-@@$ElementList.$value-@@//
	return this._elements;
};
//-!MobileCommentJindo.$ElementList.prototype.$value end!-//

//-!MobileCommentJindo.$ElementList.prototype.show start(MobileCommentJindo.$Element.prototype.show)!-//
//-!MobileCommentJindo.$ElementList.prototype.show end!-//
//-!MobileCommentJindo.$ElementList.prototype.hide start(MobileCommentJindo.$Element.prototype.hide)!-//
//-!MobileCommentJindo.$ElementList.prototype.hide end!-//
//-!MobileCommentJindo.$ElementList.prototype.toggle start(MobileCommentJindo.$Element.prototype.toggle)!-//
//-!MobileCommentJindo.$ElementList.prototype.toggle end!-//
//-!MobileCommentJindo.$ElementList.prototype.addClass start(MobileCommentJindo.$Element.prototype.addClass)!-//
//-!MobileCommentJindo.$ElementList.prototype.addClass end!-//
//-!MobileCommentJindo.$ElementList.prototype.removeClass start(MobileCommentJindo.$Element.prototype.removeClass)!-//
//-!MobileCommentJindo.$ElementList.prototype.removeClass end!-//
//-!MobileCommentJindo.$ElementList.prototype.toggleClass start(MobileCommentJindo.$Element.prototype.toggleClass)!-//
//-!MobileCommentJindo.$ElementList.prototype.toggleClass end!-//
//-!MobileCommentJindo.$ElementList.prototype.fireEvent start(MobileCommentJindo.$Element.prototype.fireEvent)!-//
//-!MobileCommentJindo.$ElementList.prototype.fireEvent end!-//
//-!MobileCommentJindo.$ElementList.prototype.leave start(MobileCommentJindo.$Element.prototype.leave)!-//
//-!MobileCommentJindo.$ElementList.prototype.leave end!-//
//-!MobileCommentJindo.$ElementList.prototype.empty start(MobileCommentJindo.$Element.prototype.empty)!-//
//-!MobileCommentJindo.$ElementList.prototype.empty end!-//
//-!MobileCommentJindo.$ElementList.prototype.className start(MobileCommentJindo.$Element.prototype.className)!-//
//-!MobileCommentJindo.$ElementList.prototype.className end!-//
//-!MobileCommentJindo.$ElementList.prototype.width start(MobileCommentJindo.$Element.prototype.width)!-//
//-!MobileCommentJindo.$ElementList.prototype.width end!-//
//-!MobileCommentJindo.$ElementList.prototype.height start(MobileCommentJindo.$Element.prototype.height)!-//
//-!MobileCommentJindo.$ElementList.prototype.height end!-//
//-!MobileCommentJindo.$ElementList.prototype.text start(MobileCommentJindo.$Element.prototype.text)!-//
//-!MobileCommentJindo.$ElementList.prototype.text end!-//
//-!MobileCommentJindo.$ElementList.prototype.html start(MobileCommentJindo.$Element.prototype.html)!-//
//-!MobileCommentJindo.$ElementList.prototype.html end!-//
//-!MobileCommentJindo.$ElementList.prototype.css start(MobileCommentJindo.$Element.prototype.css)!-//
//-!MobileCommentJindo.$ElementList.prototype.css end!-//
//-!MobileCommentJindo.$ElementList.prototype.attr start(MobileCommentJindo.$Element.prototype.attr)!-//
//-!MobileCommentJindo.$ElementList.prototype.attr end!-//
//-!MobileCommentJindo.$ElementList.prototype.appear start(MobileCommentJindo.$Element.prototype.appear)!-//
//-!MobileCommentJindo.$ElementList.prototype.appear end!-//
//-!MobileCommentJindo.$ElementList.prototype.disappear start(MobileCommentJindo.$Element.prototype.disappear)!-//
//-!MobileCommentJindo.$ElementList.prototype.disappear end!-//




/**

 * @fileOverview $S의 생성자 및 메서드를 정의한 파일
 * @name string.js
 * @author AjaxUI lab

 */

//-!MobileCommentJindo.$S start!-//
/**

 * @class $S() 객체는 String 객체를 래핑(wrapping)하여 문자열을 처리하기 위한 확장 기능을 제공한다.
 * @constructor
 * @description $S() 객체를 생성한다.
 * @param {String+} sStr 래핑할 문자열.
 * @example
var sStr = 'Hello world!';
var oStr = $S(sStr);            // $S() 객체 생성
var oStr2 = new $S(sStr);        // new를 사용한 $S() 객체 생성

 */
MobileCommentJindo.$S = function(str) {
	//-@@$S-@@//
	var cl = arguments.callee;

	if (str instanceof cl) return str;

	if (!(this instanceof cl)){
		try {
			MobileCommentJindo.$Jindo._warn(arguments.length, 1,"$Json");
			return new cl(str||"");
		} catch(e) {
			if (e instanceof TypeError) { return null; }
			throw e;
		}
	}

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str' : ['str:String+']
	},"$S");

	this._str = str + '';
};
//-!MobileCommentJindo.$S end!-//

//-!MobileCommentJindo.$S.prototype.$value start!-//
/**

 * @description $value() 메서드는 $S() 객체가 감싸고 있던 원본 문자열(String 객체)을 반환한다. toString() 메서드와 같은 의미이다.
 * @return {String} 원본 String 객체.
 * @see $S#toString
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String">String</a> - MDN Docs
 * @example
var str = $S("Hello world!!");
str.$value();
// 결과 :
// Hello world!!

 */
MobileCommentJindo.$S.prototype.$value = function() {
	//-@@$S.$value-@@//
	//-@@$S.toString-@@//
	return this._str;
};
//-!MobileCommentJindo.$S.prototype.$value end!-//

//-!MobileCommentJindo.$S.prototype.toString start!-//
/**

 * @function
 * @description toString() 메서드는 $S() 객체가 감싸고 있던 원본 문자열(String 객체)을 반환한다. $value() 메서드와 같은 의미이다.
 * @return {String} 원본 String 객체.
 * @see $S#$value
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String">String</a> - MDN Docs
 * @example
var str = $S("Hello world!!");
str.toString();
// 결과 :
// Hello world!!

 */
MobileCommentJindo.$S.prototype.toString = MobileCommentJindo.$S.prototype.$value;
//-!MobileCommentJindo.$S.prototype.toString end!-//

//-!MobileCommentJindo.$S.prototype.trim start!-//
/**

 * @description trim() 메서드는 문자열의 양 끝에 있는 공백을 제거한다.
 * @return {$S} 문자열의 양 끝에 있는 공백을 제거한 새로운 $S() 객체
 * @since 1.4.1 버전부터 전각공백도 제거
 * @example
var str = "   I have many spaces.   ";
document.write ( $S(str).trim() );
// 결과 :
// I have many spaces.

 */
MobileCommentJindo.$S.prototype.trim = function() {
	//-@@$S.trim-@@//
	if ("".trim) {
		MobileCommentJindo.$S.prototype.trim = function() {
			return MobileCommentJindo.$S(this._str.trim());
		}
	}else{
		MobileCommentJindo.$S.prototype.trim = function() {
			return MobileCommentJindo.$S(this._str.replace(/^(\s|　)+/g, "").replace(/(\s|　)+$/g, ""));
		}
	}

	return MobileCommentJindo.$S(this.trim());

};
//-!MobileCommentJindo.$S.prototype.trim end!-//

//-!MobileCommentJindo.$S.prototype.escapeHTML start!-//
/**

 * @description escapeHTML() 메서드는 HTML 특수 문자를 HTML 엔티티(Entities)형식으로 변환한다. 변경하는 문자는 다음 표와 같다.<br>
 <table>
	<caption>HTML Escape 문자 변환</caption>
	<thead>
		<tr>
			<th>변환 대상 문자</th>
			<th>&quot;</th>
			<th>&amp;</th>
			<th>&lt;</th>
			<th>&gt;</th>
			<th>&#39;</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>변환 결과</th>
			<td>&amp;quot;</td>
			<td>&amp;amp;</td>
			<td>&amp;lt;</td>
			<td>&amp;gt;</td>
			<td>&#39;</td>
		</tr>
	</tbody>
 </table>
 * @return {$S} HTML 특수 문자를 엔티티 형식으로 변환한 새로운 $S() 객체.
 * @see $S#unescapeHTML
 * @see $S#escape
 * @example
 var str = ">_<;;";
 document.write( $S(str).escapeHTML() );

 // 결과 :
 // &amp;gt;_&amp;lt;;;

 */
MobileCommentJindo.$S.prototype.escapeHTML = function() {
	//-@@$S.escapeHTML-@@//
	var entities = {'"':'quot','&':'amp','<':'lt','>':'gt','\'':'#39'};
	var s = this._str.replace(/[<>&"']/g, function(m0){
		return entities[m0]?'&'+entities[m0]+';':m0;
	});
	return MobileCommentJindo.$S(s);
};
//-!MobileCommentJindo.$S.prototype.escapeHTML end!-//

//-!MobileCommentJindo.$S.prototype.stripTags start!-//
/**

 * @description stripTags() 메서드는 문자열에서 XML 혹은 HTML 태그를 제거한다.
 * @return {$S} XML 혹은 HTML 태그를 제거한 새로운 $S() 객체.
 * @example
 var str = "Meeting <b>people</b> is easy.";
 document.write( $S(str).stripTags() );

 // 결과 :
 // Meeting people is easy.

 */
MobileCommentJindo.$S.prototype.stripTags = function() {
	//-@@$S.stripTags-@@//
	return MobileCommentJindo.$S(this._str.replace(/<\/?(?:h[1-5]|[a-z]+(?:\:[a-z]+)?)[^>]*>/ig, ''));
};
//-!MobileCommentJindo.$S.prototype.stripTags end!-//

//-!MobileCommentJindo.$S.prototype.times start!-//
/**

 * @description times() 메서드는 문자열을 파라미터로 지정한 횟수만큼 반복하는 문자열을 생성한다.
 * @param {Numeric} nTimes 반복할 횟수.(기본값은 1)
 * @return {$S} 문자열을 지정한 횟수만큼 반복한 새로운 $S() 객체
 * @example
 document.write ( $S("Abc").times(3) );

 // 결과 : AbcAbcAbc

 */
MobileCommentJindo.$S.prototype.times = function(nTimes) {
	//-@@$S.times-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str' : ['nTimes:Numeric']
	},"$S#times");
	if (!oArgs) { return this; }
	return MobileCommentJindo.$S(Array(oArgs.nTimes+1).join(this._str));
};
//-!MobileCommentJindo.$S.prototype.times end!-//

//-!MobileCommentJindo.$S.prototype.unescapeHTML start!-//
/**

 * @description unescapeHTML() 메서드는 이스케이프(escape)된 문자를 원래의 문자로 변환한다.
 * @return {$S} 이스케이프된 문자를 원래의 문자로 변환한 새로운 $S() 객체
 * @see $S#escapeHTML
 * @example
var str = "&lt;a href=&quot;http://naver.com&quot;&gt;Naver&lt;/a&gt;";
document.write( $S(str).unescapeHTML() );

// 결과 :
// <a href="http://naver.com">Naver</a>

 */
MobileCommentJindo.$S.prototype.unescapeHTML = function() {
	//-@@$S.unescapeHTML-@@//
	var entities = {'quot':'"','amp':'&','lt':'<','gt':'>','#39':'\''};
	var s = this._str.replace(/&([a-z]+|#[0-9]+);/g, function(m0,m1){
		return entities[m1]?entities[m1]:m0;
	});
	return MobileCommentJindo.$S(s);
};
//-!MobileCommentJindo.$S.prototype.unescapeHTML end!-//

//-!MobileCommentJindo.$S.prototype.escape start!-//
/**

 * @description escape() 메서드는 문자열에 포함된 한글을 ASCII 문자열로 인코딩하고 non-ASCII 문자를 이스케이프(escape)한다. 변경하는 문자는 다음 표와 같다.<br>
 <table>
	<caption>Escape 문자 변환</caption>
	<thead>
		<tr>
			<th>변환 대상 문자</th>
			<th>\r</th>
			<th>\n</th>
			<th>\t</th>
			<th>'</th>
			<th>"</th>
			<th>non-ASCII 문자</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>변환 결과</th>
			<td>\\r</td>
			<td>\\n</td>
			<td>\\t</td>
			<td>\'</td>
			<td>\"</td>
			<td>\uXXXX</td>
		</tr>
	</tbody>
 </table>
 * @return {$S} 문자열을 이스케이프한 새로운 $S() 객체
 * @see $S#escapeHTML
 * @example
 var str = '가"\'나\\';
 document.write( $S(str).escape() );

 // 결과 :
 // \uAC00\"\'\uB098\\

 */
MobileCommentJindo.$S.prototype.escape = function() {
	//-@@$S.escape-@@//
	var s = this._str.replace(/([\u0080-\uFFFF]+)|[\n\r\t"'\\]/g, function(m0,m1,_){
		if(m1) return escape(m1).replace(/%/g,'\\');
		return (_={"\n":"\\n","\r":"\\r","\t":"\\t"})[m0]?_[m0]:"\\"+m0;
	});

	return MobileCommentJindo.$S(s);
};
//-!MobileCommentJindo.$S.prototype.escape end!-//

//-!MobileCommentJindo.$S.prototype.bytes start!-//
/**

 * @description bytes() 메서드는 문자열의 실제 바이트(byte) 수를 반환하고, 제한하려는 바이트(byte) 수를 지정하면 문자열을 해당 크기에 맞게 잘라낸다. 또한, 지정한 인코딩 방식에 따라 한글을 비롯한 유니코드 문자열의 바이트 수를 계산한다.
 *
 * @param1 {Void}
 * @return1 {Number} 문자열의 바이트 수를 반환한다.
 *
 * @param2 {Numeric} nLength 잘라내고자 하는 바이트 수
 * @return2 {$S} 해당 크기만큼 문자열을 잘라낸 $S() 객체
 *
 * @param3 {Hash+} oOptions 인코딩 방식과 제한할 크기를 설정한 객체.
 * @return3 {Variant} 파라미터에 제한할 바이트 수를 지정하면 해당 크기만큼 문자열을 잘라낸 $S() 객체를 반환하고 이외의 경우 문자열의 크기(Number)를 반환한다.
 *
 * @since 1.4.3 버전부터 인코딩 방식 사용 가능
 * @example
// 문서가 euc-kr 환경임을 가정합니다.
var str = "한글과 English가 섞인 문장...";

document.write( $S(str).bytes() );
// 결과 :
// 37

document.write( $S(str).bytes(20) );
// 결과 :
// 한글과 English가

document.write( $S(str).bytes({charset:'euc-kr',size:20}) );
// 결과 :
// 한글과 English가 섞

document.write( $S(str).bytes({charset:'euc-kr'}) );
// 결과 :
// 29

 */
MobileCommentJindo.$S.prototype.bytes = function(vConfig) {
	//-@@$S.bytes-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4voi' : [],
		'4num' : ["nConfig:Numeric"],
		'4obj' : ["nConfig:Hash+"]
	},"$S#bytes");
	var code = 0, bytes = 0, i = 0, len = this._str.length;
	var charset = ((document.charset || document.characterSet || document.defaultCharset)+"");
	var cut,nBytes;
	switch(oArgs+""){
		case "4voi":
			cut = false;
			break;
		case "4num":
			cut = true;
			nBytes = vConfig;
			break;
		case "4obj":
			charset = vConfig.charset||charset;
			nBytes  = vConfig.size||false;
			cut = !!nBytes;
			break;

	}

	if (charset.toLowerCase() == "utf-8") {
		/*

유니코드 문자열의 바이트 수는 위키피디아를 참고했다(http://ko.wikipedia.org/wiki/UTF-8).

		 */
		for(i=0; i < len; i++) {
			code = this._str.charCodeAt(i);
			if (code < 128) {
				bytes += 1;
			}else if (code < 2048){
				bytes += 2;
			}else if (code < 65536){
				bytes += 3;
			}else{
				bytes += 4;
			}

			if (cut && bytes > nBytes) {
				this._str = this._str.substr(0,i);
				break;
			}
		}
	} else {
		for(i=0; i < len; i++) {
			bytes += (this._str.charCodeAt(i) > 128)?2:1;

			if (cut && bytes > nBytes) {
				this._str = this._str.substr(0,i);
				break;
			}
		}
	}

	return cut?this:bytes;
};
//-!MobileCommentJindo.$S.prototype.bytes end!-//

//-!MobileCommentJindo.$S.prototype.parseString start!-//
/**

 * @description parseString() 메서드는 URL 쿼리스트링(Query String)을 객체로 파싱한다. 예제를 확인한다.
 * @return {Object} 쿼리스트링을 파싱한 객체.
 * @see <a href="http://en.wikipedia.org/wiki/Querystring">Query String</a> - Wikipedia
 * @example
var str = "aa=first&bb=second";
var obj = $S(str).parseString();
// 결과 :
// obj => { aa : "first", bb : "second" }

 */
MobileCommentJindo.$S.prototype.parseString = function() {
	//-@@$S.parseString-@@//
	if(this._str=="") return {};

	var str = this._str.split(/&/g), pos, key, val, buf = {},isescape = false;

	for(var i=0; i < str.length; i++) {
		key = str[i].substring(0, pos=str[i].indexOf("=")), isescape = false;
		try{
			val = decodeURIComponent(str[i].substring(pos+1));
		}catch(e){
			isescape = true;
			val = decodeURIComponent(unescape(str[i].substring(pos+1)));
		}


		if (key.substr(key.length-2,2) == "[]") {
			key = key.substring(0, key.length-2);
			if (MobileCommentJindo.$Jindo.isUndefined(buf[key])) buf[key] = [];
			buf[key][buf[key].length] = isescape? escape(val) : val;;
		} else {
			buf[key] = isescape? escape(val) : val;
		}
	}

	return buf;
};
//-!MobileCommentJindo.$S.prototype.parseString end!-//

//-!MobileCommentJindo.$S.prototype.escapeRegex start!-//
/**

 * @description escapeRegex() 메서드는 문자열을 정규식에 사용할 수 있도록 이스케이프(escape)한다. 예제를 참고한다.
 * @since 1.2.0
 * @return {$S} 내부 문자열이 이스케이프된 $S() 객체.
 * @see <a href="http://en.wikipedia.org/wiki/Regexp">Regular Expression</a>
 * @example
var str = "Slash / is very important. Backslash \ is more important. +_+";
document.write( $S(str).escapeRegex() );

 // 결과 : \/ is very important\. Backslash \\ is more important\. \+_\+

 */
MobileCommentJindo.$S.prototype.escapeRegex = function() {
	//-@@$S.escapeRegex-@@//
	var s = this._str;
	var r = /([\?\.\*\+\-\/\(\)\{\}\[\]\:\!\^\$\\\|])/g;

	return MobileCommentJindo.$S(s.replace(r, "\\$1"));
};
//-!MobileCommentJindo.$S.prototype.escapeRegex end!-//

//-!MobileCommentJindo.$S.prototype.format start(MobileCommentJindo.$S.prototype.times)!-//
/**

 * @descritpion format() 메서드는 문자열을 형식 문자열(Format Specifier)에 대입하여 새로운 문자열을 만든다. 형식 문자열은 %로 시작하며, 사용하는 형식 문자열의 종류는 PHP의 sprintf() 함수가 사용하는 것과 동일하다.
 * @param {String} sFormatString 대입할 형식 문자열.
 * @return {String} 문자열을 형식 문자열에 대입하여 만든 새로운 문자열.
 * @see <a href="http://www.php.net/manual/en/function.sprintf.php">sprintf()</a>" - php.net
 * @example
var str = $S("%4d년 %02d월 %02d일").format(2008, 2, 13);
*
* // 결과 :
* // str = "2008년 02월 13일"

var str = $S("패딩 %5s 빈공백").format("값");
*
* // 결과 :
* // str => "패딩     값 빈공백"

var str = $S("%b").format(10);
*
* // 결과 :
* // str => "1010"

var str = $S("%x").format(10);
*
* // 결과 :
* // str => "a"

var str = $S("%X").format(10);
*
* // 결과 :
* // str => "A"
 * @see $S#times

 */
MobileCommentJindo.$S.prototype.format = function() {
	//-@@$S.format-@@//
	var args = arguments;
	var idx  = 0;
	var s = this._str.replace(/%([ 0])?(-)?([1-9][0-9]*)?([bcdsoxX])/g, function(m0,m1,m2,m3,m4){
		var a = args[idx++];
		var ret = "", pad = "";

		m3 = m3?+m3:0;

		if (m4 == "s") {
			ret = a+"";
		} else if (" bcdoxX".indexOf(m4) > 0) {
			if (!MobileCommentJindo.$Jindo.isNumeric(a)) return "";
			ret = (m4 == "c")?String.fromCharCode(a):a.toString(({b:2,d:10,o:8,x:16,X:16})[m4]);
			if (" X".indexOf(m4) > 0) ret = ret.toUpperCase();
		}

		if (ret.length < m3) pad = MobileCommentJindo.$S(m1||" ").times(m3 - ret.length)._str;
		(m2 == '-')?(ret+=pad):(ret=pad+ret);

		return ret;
	});

	return MobileCommentJindo.$S(s);
};
//-!MobileCommentJindo.$S.prototype.format end!-//



//-!MobileCommentJindo.$Document start(MobileCommentJindo.$Document.prototype.renderingMode)!-//
/**

 * @fileOverview $Document 생성자 및 메서드를 정의한 파일
 * @name document.js
 * @author AjaxUI lab

 */

/**

 * @class $Document() 객체는 문서와 관련된 정보를 제공한다.
 * @constructor
 * @description $Document() 객체를 생성한다. 파라미터를 생략하면 기본 값으로 현재 문서의 document 요소가 입력된다.
 *
 * @param1 {Void}
 *
 * @param2 {Element} elDocument 정보를 확인할 document 요소.
 *

 */
MobileCommentJindo.$Document = function (el) {
	//-@@$Document-@@//
	var cl = arguments.callee;
	if (el instanceof cl) return el;

	if (!(this instanceof cl)){
		try {
			MobileCommentJindo.$Jindo._warn(arguments.length, 1,"$Document");
			return new cl(el||document);
		} catch(e) {
			if (e instanceof TypeError) { return null; }
			throw e;
		}
	}

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4doc'  : [ 'oDocument:Document+']
	},"$Document");
	if(oArgs==null){this._doc = document;}
	else{this._doc = el;}

	this._docKey = this.renderingMode() == 'Standards' ? 'documentElement' : 'body';
};
(function(){
	var qu = MobileCommentJindo.cssquery;
	var type = {
		"query" : qu.getSingle,
		"queryAll" : qu,
		"xpathAll" : qu.xpath
	};
	for(var i in type){
		MobileCommentJindo.$Document.prototype[i] = (function(sMethod,fp){
			return function(sQuery){
				var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
					'4str'  : [ 'sQuery:String+']
				},"$Document#"+sMethod);
				return fp(sQuery,this._doc);
			}
		})(i, type[i])
	}

})();
//-!MobileCommentJindo.$Document end!-//

//-!MobileCommentJindo.$Document.prototype.$value start!-//
/**

 * @description $value() 메서드는 원본 document 요소를 반환한다.
 * @return {Element} document 요소

 */
MobileCommentJindo.$Document.prototype.$value = function() {
	//-@@$Document.$value-@@//
	return this._doc;
};
//-!MobileCommentJindo.$Document.prototype.$value end!-//

//-!MobileCommentJindo.$Document.prototype.scrollSize start!-//
/**

 * @description scrollSize() 메서드는 문서의 가로 크기와 세로 크기 정보를 담은 객체를 반환한다. 다음은 문서의 가로, 세로 크기 정보를 담고 있는 객체의 속성을 설명한 표이다.<br>
 <table>
	<caption>문서 크기 정보 객체</caption>
	<thead>
		<tr>
			<th scope="col">이름</th>
			<th scope="col">타입</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>width</td>
			<td>Number</td>
			<td>문서의 가로 크기 정보. 단위는 픽셀(px)이다.</td>
		</tr>
		<tr>
			<td>height</td>
			<td>Number</td>
			<td>문서의 세로 크기 정보. 단위는 픽셀(px)이다.</td>
		</tr>
	</tbody>
 </table>
 * @return {Object} 문서의 가로, 세로 크기 정보를 담고 있는 객체.
 * @see $Document#clientSize
 * @example
var size = $Document().scrollSize();
alert('가로 : ' + size.width + ' / 세로 : ' + size.height);

 */
MobileCommentJindo.$Document.prototype.scrollSize = function() {
	//-@@$Document.scrollSize-@@//
	/*

webkit 계열에서는 Standard 모드라도 body를 사용해야 정상적인 scroll Size를 얻어온다.

	 */
	var oDoc = this._doc[_JINDO_IS_WK?'body':this._docKey];

	return {
		width : Math.max(oDoc.scrollWidth, oDoc.clientWidth),
		height : Math.max(oDoc.scrollHeight, oDoc.clientHeight)
	};

};
//-!MobileCommentJindo.$Document.prototype.scrollSize end!-//

//-!MobileCommentJindo.$Document.prototype.scrollPosition start!-//
/**

 * @description scrollPosition() 메서드는 현재 문서에서 스크롤바의 위치를 구한다. 다음은 스크롤바의 위치 정보를 담고 있는 객체의 속성을 설명한 표이다.<br>
 <table>
	<caption>스크롤바 위치 정보 객체의 속성</caption>
	<thead>
		<tr>
			<th scope="col">이름</th>
			<th scope="col">타입</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>left</td>
			<td>number</td>
			<td>수평 스크롤바의 가로 위치. 단위는 픽셀(px)이다.</td>
		</tr>
		<tr>
			<td>height</td>
			<td>number</td>
			<td>수직 스크롤바의 세로 위치. 단위는 픽셀(px)이다.</td>
		</tr>
	</tbody>
 </table>
 * @return {Object} 가로 위치는 left, 세로위치는 top 라는 키값으로 리턴된다.
 * @since 1.3.5
 * @example
var size = $Document().scrollPosition();
alert('가로 : ' + size.left + ' / 세로 : ' + size.top);

 */
MobileCommentJindo.$Document.prototype.scrollPosition = function() {
	//-@@$Document.scrollPosition-@@//
	/*

webkit 계열에서는 Standard 모드라도 body를 사용해야 정상적인 scroll Size를 얻어온다.

	 */
	var oDoc = this._doc[_JINDO_IS_WK?'body':this._docKey];
	return {
		left : oDoc.scrollLeft||window.pageXOffset||window.scrollX||0,
		top : oDoc.scrollTop||window.pageYOffset||window.scrollY||0
	};

};
//-!MobileCommentJindo.$Document.prototype.scrollPosition end!-//

//-!MobileCommentJindo.$Document.prototype.clientSize start!-//
/**

 * @description clientSize() 메서드는 문서에서 스크롤바가 생겨 보이지 않는 부분을 제외한 영역(화면에 보이는 부분)의 가로 크기와 세로 크기 정보를 담은 객체를 반환한다. 다음은 화면에 보이는 영역의 가로, 세로 크기 정보를 담고 있는 객체의 속성을 설명한 표이다.<br>
 <table>
	<caption>화면 크기 정보 객체</caption>
	<thead>
		<tr>
			<th scope="col">이름</th>
			<th scope="col">속성</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>width</td>
			<td>number</td>
			<td>화면에 보이는 부분의 가로 크기. 단위는 픽셀(px)이다.</td>
		</tr>
		<tr>
			<td>height</td>
			<td>number</td>
			<td>화면에 보이는 부분의 세로 크기. 단위는 픽셀(px)이다.</td>
		</tr>
	</tbody>
 </table>
 * @return {Object} 화면에 보이는 부분의 크기를 저장하고 있는 객체.
 * @see $Document#scrollSize
 * @example
var size = $Document(document).clientSize();
alert('가로 : ' + size.width + ' / 세로 : ' + size.height);

 */
MobileCommentJindo.$Document.prototype.clientSize = function() {
	//-@@$Document.clientSize-@@//
	var oDoc = this._doc[this._docKey];

	var isSafari = _JINDO_IS_SP && !_JINDO_IS_CH;

	/*

사파리의 경우 윈도우 리사이즈시에 clientWidth,clientHeight값이 정상적으로 나오지 않아서 window.innerWidth,innerHeight로 대체

	 */
	return (isSafari)?{
					width : window.innerWidth,
					height : window.innerHeight
				}:{
					width : oDoc.clientWidth,
					height : oDoc.clientHeight
				};
};
//-!MobileCommentJindo.$Document.prototype.clientSize end!-//

//-!MobileCommentJindo.$Document.prototype.renderingMode start!-//
/**

 * @description renderingMode() 메서드는 문서가 렌더링된 방식을 검사하여 반환한다. 이 메서드가 확인할 수 있는 렌더링 방식은 다음 표와 같다.<br>
  <table>
	<caption>렌더링 방식</caption>
	<thead>
		<tr>
			<th scope="col">렌더링 모드</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Standards</td>
			<td>표준 렌더링 모드.</td>
		</tr>
		<tr>
			<td>Almost</td>
			<td>유사 표준 렌더링 모드. 인터넷 익스플로러 외의 브라우저에서 DTD를 올바르게 지정하지 않았을 때 반환된다.</td>
		</tr>
		<tr>
			<td>Quirks</td>
			<td>비표준 렌더링 모드.</td>
		</tr>
	</tbody>
 </table>
 * @return {String} 렌더링 모드.
 * @see DTD와 브라우저에 따른 렌더링 차이 설명(<a href="http://hsivonen.iki.fi/doctype/">http://hsivonen.iki.fi/doctype/</a>)
 * @example
var mode = $Document().renderingMode();
alert('렌더링 방식 : ' + mode);

 */
MobileCommentJindo.$Document.prototype.renderingMode = function() {
	//-@@$Document.renderingMode-@@//
	var agent = navigator.userAgent;
	var isIe = _JINDO_IS_IE;
	var isSafari = (_JINDO_IS_WK && !_JINDO_IS_CH && navigator.vendor.indexOf("Apple")>-1);
	var sRet;

	if ('compatMode' in this._doc){
		sRet = this._doc.compatMode == 'CSS1Compat' ? 'Standards' : (isIe ? 'Quirks' : 'Almost');
	}else{
		sRet = isSafari ? 'Standards' : 'Quirks';
	}

	return sRet;

};
//-!MobileCommentJindo.$Document.prototype.renderingMode end!-//

//-!MobileCommentJindo.$Document.prototype.queryAll start(MobileCommentJindo.cssquery)!-//
/**

 * @description 문서를 대상으로 지정한 선택자를 만족시키는 요소의 배열을 반환한다. 만족하는 요소가 존재하지 않으면 빈 배열을 반환한다. $$() 함수에서 elBaseElement 파라미터에 문서를 지정한 것과 같은 의미이다.
 * @param {String+} sSelector CSS 선택자(CSS Selector). CSS 선택자로 사용할 수 있는 패턴은 표준 패턴과 비표준 패턴이 있다. 표준 패턴은 CSS Level3 명세서에 있는 패턴을 지원한다. 선택자의 패턴에 대한 설명은 $$() 함수와 See Also 항목을 참고한다.
 * @return {Array} 조건을 만족하는 요소의 배열
 * @see <a href="_global_.html#$$">$$()</a>
 * @see <a href="http://www.w3.org/TR/css3-selectors/">CSS Level3 명세서</a> - W3C
 * @example
 $Document().queryAll("span");  // 문서 내에 모든 <span> 요소를 선택한다.

 */
//-!MobileCommentJindo.$Document.prototype.queryAll end!-//

//-!MobileCommentJindo.$Document.prototype.query start(MobileCommentJindo.cssquery)!-//
/**

 * @description 문서를 대상으로 지정한 선택자를 만족시키는 첫 번째 요소를 반환한다. 만족하는 요소가 존재하지 않으면 null을 반환한다. $$.getSingle 함수에서 elBaseElement 파라미터에 문서를 지정한 것과 같은 의미이다.
 * @param {String+} sSelector CSS 선택자(CSS Selector). CSS 선택자로 사용할 수 있는 패턴은 표준 패턴과 비표준 패턴이 있다. 표준 패턴은 CSS Level3 명세서에 있는 패턴을 지원한다. 선택자의 패턴에 대한 설명은 $$() 함수와 See Also 항목을 참고한다.
 * @return {Element} 선택자 조건을 만족하는 첫 번째 요소.
 * @see <a href="_global_.html#.$$.getSingle">$$.getSingle()</a>
 * @see <a href="_global_.html#$$">$$()</a>
 * @see <a href="http://www.w3.org/TR/css3-selectors/">CSS Level3 명세서</a> - W3C
 * @example
 $Document().query("body");  // <body> 요소를 선택한다.

 */
//-!MobileCommentJindo.$Document.prototype.query end!-//

//-!MobileCommentJindo.$Document.prototype.xpathAll start(MobileCommentJindo.cssquery)!-//
/**

 * @description 문서를 대상으로 XPath 문법을 만족하는 요소를 가져온다. 지원하는 문법이 제한 적이므로 특수한 경우에만 사용할 것을 권장한다. $$.xpath() 함수에서 elBaseElement 파라미터에 문서를 지정한 것과 같은 의미이다.
 * @param {String+} sXPath XPath 값.
 * @return {Array} XPath 문법을 만족하는 요소를 원소로 하는 배열.
 * @see <a href="_global_.html#.$$.xpath">$$()</a>
 * @see <a href="http://www.w3.org/standards/techs/xpath#w3c_all">XPath 문서</a> - W3C
 * @example
var oDocument = $Document();
alert (oDocument.xpathAll("body/div/div").length);

 */
//-!MobileCommentJindo.$Document.prototype.xpathAll end!-//



/**

 * @fileOverview $Form 생성자 및 메서드를 정의한 파일
 * @name form.js
 * @author AjaxUI lab

 */

//-!MobileCommentJindo.$Form start!-//
/**

 * @class $Form() 객체는 &lt;form&gt; 요소와 자식 요소를 제어하는 기능을 제공한다.
 * @constructor
 * @description $Form() 객체를 생성한다.
 *
 * @param1 {Element} elForm	&lt;form&gt; 요소(Element).
 * @return1 {Element} 원본 &lt;form&gt; 요소
 *
 * @param2 {String} elForm	&lt;form&gt; 요소의 ID(String). 만약 동일한 ID를 사용한 &lt;form&gt; 요소가 둘 이상이면 먼저 나오는 요소를 감싼 $Form() 객체를 반환한다.
 * @return2 {Element} 원본 &lt;form&gt; 요소

 */
MobileCommentJindo.$Form = function (el) {
	//-@@$Form-@@//
	var cl = arguments.callee;
	if (el instanceof cl) return el;

	if (!(this instanceof cl)){
		try {
			MobileCommentJindo.$Jindo._warn(arguments.length, 1,"$Form");
			return new cl(el);
		} catch(e) {
			if (e instanceof TypeError) { return null; }
			throw e;
		}
	}

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str' : ['oForm:String+'],
		'4ele' : [ 'oForm:Element+']
	},"$Form");

	switch (oArgs + "") {
		case "4str":
			el = MobileCommentJindo.$(el);
			break;
	}

	if (!(el.tagName&&el.tagName.toUpperCase()=="FORM")) {
		throw TypeError("only form");
	}
	this._form = el;
};
//-!MobileCommentJindo.$Form end!-//

//-!MobileCommentJindo.$Form.prototype.$value start!-//
/**

 * @description $value() 메서드는 원본 &lt;form&gt; 요소를 반환한다
 * @example
var el = $('<form>');
var form = $Form(el);

alert(form.$value() === el); // true

 */
MobileCommentJindo.$Form.prototype.$value = function() {
	//-@@$Form.$value-@@//
	return this._form;
};
//-!MobileCommentJindo.$Form.prototype.$value end!-//

//-!MobileCommentJindo.$Form.prototype.serialize start(MobileCommentJindo.$H.prototype.toQueryString)!-//
/**

 * @description serialize() 메서드는 &lt;form&gt; 요소의 특정 또는 전체 입력 요소를 쿼리스트링(Query String) 형태로 반환한다. serialize() 메서드를 사용할 때 파라미터를 입력하지 않으면 &lt;form&gt; 요소의 하위의 모든 입력 요소를 쿼리스트링으로 반환하고 파라미터를 입력하면 지정한 이름과 같은 name 속성을 가지는 입력 요소를 쿼리스트링 형태로 반환한다.
 * @param {String} [sName1] 첫 번째 입력 요소의 이름(name).
 * @param {String} […] …
 * @param {String} [sNameN] N 번째 입력 요소의 이름(name).
 * @return {String} 쿼리스트링 형태로 변환한 문자열.
 * @see <a href="http://en.wikipedia.org/wiki/Querystring">Query String</a> - Wikipedia
 * @example
<form id="TEST">
	<input name="ONE" value="1" type="text" />
	<input name="TWO" value="2" checked="checked" type="checkbox" />
	<input name="THREE" value="3_1" type="radio" />
	<input name="THREE" value="3_2" checked="checked" type="radio" />
	<input name="THREE" value="3_3" type="radio" />
	<select name="FOUR">
		<option value="4_1">..</option>
		<option value="4_2">..</option>
		<option value="4_3" selected="selected">..</option>
	</select>
</form>

<script type="text/javascript">
	var form = $Form('TEST');

	var allstr = form.serialize();
	// ONE=1&TWO=2&THREE=3_2&FOUR=4_3

	var str = form.serialize('ONE', 'THREE');
	// ONE=1&THREE=3_2'
</script>

 */
MobileCommentJindo.$Form.prototype.serialize = function() {
	//-@@$Form.serialize-@@//
 	var self = this;
 	var oRet = {};

 	var nLen = arguments.length;
 	var fpInsert = function(eEle,sKey) {
		if(!eEle.disabled){
	 		var sVal = self.value(sKey);
	 		if (sVal !== undefined) oRet[sKey] = sVal;
		}
 	};

 	if (nLen == 0) {
 		var len = this._form.elements.length;
 		for(var i=0; i<len; i++){
 			var o = this._form.elements[i];
 			if(o.name) fpInsert(o,o.name);
 		}
	}else{
		for (var i = 0; i < nLen; i++) {
			fpInsert(this.element(arguments[i]),arguments[i]);
		}
	}

	return MobileCommentJindo.$H(oRet).toQueryString();
};
//-!MobileCommentJindo.$Form.prototype.serialize end!-//

//-!MobileCommentJindo.$Form.prototype.element start!-//
/**

 * @description element() 메서드는 특정 또는 전체 입력 요소를 반환한다. 파라미터에 가져올 입력 요소의 이름(name)을 지정할 수 있다. 또한, 파라미터를 생략하면 모든 입력 요소의 값을 가져온다.
 *
 * @param1 {Void}
 * @return1 {Array} 입력 요소를 가진 배열.
 *
 * @param2 {String+} sKey 입력 요소의 이름(name).
 * @return2 {Element} 입력 요소.

 */
MobileCommentJindo.$Form.prototype.element = function(sKey) {
	//-@@$Form.element-@@//

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4voi' : [],
		'4str' : [MobileCommentJindo.$Jindo._F('sKey:String+')]
	},"$Form#element");

	switch(oArgs+""){
		case "4voi":
			return _toArray(this._form.elements);
		case "4str":
			return this._form.elements[sKey+""];
	}
};
//-!MobileCommentJindo.$Form.prototype.element end!-//

//-!MobileCommentJindo.$Form.prototype.enable start!-//
/**

 * @description enable() 메서드는 입력 요소의 활성화 여부를 검사하거나 설정한다. 파라미터에 입력 요소의 이름(name)만 입력하면 해당 요소의 활성화 여부를 확인할 수 있다. 입력 요소의 이름과 함께 true 값을 입력하면 해당 요소를 활성화하고 false를 입력하면 비활성화한다. 또한, 한번에 여러 요소의 활성화 상태를 변경하기 위해 객체를 입력할 수도 있다.
 *
 * @param1 {String+} sName 입력 요소의 이름.
 * @return1 {Boolean} 입력 요소의 활성화 여부를 나타내는 Boolean 값.
 *
 * @param2 {String+} sName 입력 요소의 이름.
 * @param2 {Boolean} bEnable 활성화 여부.
 * @return2 {$Form} 입력 요소의 활성화 여부를 반영한 $Form() 객체.
 *
 * @param3 {Hash+} oList 여러 입력 요소의 활성화 여부를 지정한 객체및 $H.
 * @return3 {$Form} 입력 요소의 활성화 여부를 반영한 $Form() 객체.
 *
 * @example

<form id="TEST">
	<input name="ONE" disabled="disabled" type="text" />
	<input name="TWO" type="checkbox" />
</form>

<script type="text/javascript">
	var form = $Form('TEST');

	form.enable('ONE');	// false

	form.enable('TWO', false);
	form.enable('TWO');	// false

	form.enable({
		'ONE' : true,
		'TWO' : false
	});

	form.enable('ONE');	// true
	form.enable('TWO');	// false

</script>

 */
MobileCommentJindo.$Form.prototype.enable = function(sKey) {
	//-@@$Form.enable-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		's4bln' : [ 'sName:String+', 'bEnable:Boolean' ],
		's4obj' : [ 'oObj:Hash+'],
		'g' : [ MobileCommentJindo.$Jindo._F('sName:String+')]
	},"$Form#enable");

	switch(oArgs+""){
		case "s4bln":
			var aEls = this._form[sKey];
			if (!aEls) return this;
			aEls = aEls.nodeType == 1 ? [ aEls ] : aEls;
			var sFlag = oArgs.bEnable;
			for(var i=0; i<aEls.length; i++){
				aEls[i].disabled = !sFlag;
			}
			return this;

		case "s4obj":
			sKey = oArgs.oObj;
			var self = this;
			for (var k in sKey) {
				if (sKey.hasOwnProperty(k)) {
					self.enable(k, sKey[k]);
				}
			}
			return this;

		case "g":
			var aEls = this._form[sKey];
			if (!aEls) return this;
			aEls = aEls.nodeType == 1 ? [ aEls ] : aEls;

			var bEnabled = true;
			for(var i=0; i<aEls.length; i++){
				if(aEls[i].disabled){
					bEnabled=false;
					break;
				}
			}
			return bEnabled;

	}
};
//-!MobileCommentJindo.$Form.prototype.enable end!-//

//-!MobileCommentJindo.$Form.prototype.value start(MobileCommentJindo.$A.prototype.has)!-//
/**

 * @description value() 메서드는 &lt;form&gt; 요소의 값을 얻거나 설정한다. 파라미터에 입력 요소의 이름(name)만 입력하면 해당 요소의 값을 확인할 수 있다. 입력 요소의 이름과 함께 값을 지정하면 해당 요소의 값을 변경한다. 또한, 한번에 여러 요소의 값을 변경하기 위해 객체를 입력할 수도 있다.
 *
 * @param1 {String+} sName 입력 요소의 이름.
 * @return1 {String} 입력 요소의 값.
 *
 * @param2 {String+} sName 입력 요소의 이름.
 * @param2 {Variant} sValue 입력 요소에 지정할 값.
 * @return2 {$Form} 입력 요소의 값을 반영한 $Form() 객체.
 *
 * @param3 {Hash+} sName 입력 요소의 이름. 이 파라미터로 여러 입력 요소의 값을 지정한 객체를 입력할 수 있다.
 * @return3 {$Form} 입력 요소의 값을 반영한 $Form() 객체.
 *
 * @throws {MobileCommentJindo.$Except.NOT_FOUND_ELEMENT} 엘리먼트가 없을 때 예외상황 발생한다.
 * @example

<form id="TEST">
	<input name="ONE" value="1" type="text" />
	<input name="TWO" type="checkbox" />
</form>
<script type="text/javascript">
	var form = $Form('TEST');

	form.value('ONE');	// 1

	form.value('TWO');	// undefined

	form.value('TWO', 2);
	form.value('TWO');	//2

	form.value({
		'ONE' : '1111',
		'TWO' : '2'
	});

	form.value('ONE');	// 1111
	form.value('ONE');	// 2
</script>

 */
MobileCommentJindo.$Form.prototype.value = function(sKey) {
	//-@@$Form.value-@@//

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		's4str' : [ 'sKey:String+', 'vValue:Variant' ],
		's4obj' : [ MobileCommentJindo.$Jindo._F('oObj:Hash+')],
		'g' : [ 'sKey:String+']
	},"$Form#value");

	if(oArgs+"" == "s4obj"){
		var self = this;
		sKey = oArgs.oObj;
		for(var k in sKey){
			if (sKey.hasOwnProperty(k)) {
				self.value(k, sKey[k]);
			}
		}
		return this;
	}

	var aEls = this._form[sKey];
	if (!aEls) throw new MobileCommentJindo.$Error(sKey+MobileCommentJindo.$Except.NONE_ELEMENT,"$Form#value");

	aEls = aEls.nodeType == 1 ? [ aEls ] : aEls;
	switch(oArgs+""){
		case "s4str":
			var sVal = oArgs.vValue;
			var nLen = aEls.length;
			for(var i=0; i<nLen; i++){
				var o = aEls[i];
				switch (o.type) {
					case 'radio':
						o.checked = (o.value == sVal);
						break;
					case 'checkbox':
						if(sVal.constructor == Array){
							o.checked = MobileCommentJindo.$A(sVal).has(o.value);
						}else{
							o.checked = (o.value == sVal);
						}
						break;

					case 'select-one':
						var nIndex = -1;
						for (var i = 0, len = o.options.length; i < len; i++){
							if (o.options[i].value == sVal) nIndex = i;
						}
						o.selectedIndex = nIndex;

						break;

					case 'select-multiple':
						var nIndex = -1;
						if(sVal.constructor == Array){
							var waVal = MobileCommentJindo.$A(sVal);
							for (var i = 0, len = o.options.length; i < len; i++){
								o.options[i].selected = waVal.has(o.options[i].value);
							}
						}else{
							for (var i = 0, len = o.options.length; i < len; i++){
								if (o.options[i].value == sVal) nIndex = i;
							}
							o.selectedIndex = nIndex;
						}
						break;

					default:
						o.value = sVal;

				}
			}

			return this;

		case "g":
			var aRet = [];
			var nLen = aEls.length;
			for(var i=0;i<nLen; i++){
				var o = aEls[i];
				switch (o.type) {
				case 'radio':
				case 'checkbox':
					if (o.checked) aRet.push(o.value);
					break;

				case 'select-one':
					if (o.selectedIndex != -1) aRet.push(o.options[o.selectedIndex].value);
					break;
				case 'select-multiple':
					if (o.selectedIndex != -1){
						for (var i = 0, len = o.options.length; i < len; i++){
							if (o.options[i].selected) aRet.push(o.options[i].value);
						}
					}
					break;
				default:
					aRet.push(o.value);

				}

			}

			return aRet.length > 1 ? aRet : aRet[0];

	}




};
//-!MobileCommentJindo.$Form.prototype.value end!-//

//-!MobileCommentJindo.$Form.prototype.submit start!-//
/**

 * @description submit() 메서드는 &lt;form&gt; 요소의 데이터를 제출(submit)한다. submit() 메서드에 파라미터를 지정하면 &lt;form&gt; 요소의 target 속성을 무시하고 지정한 전송 대상으로 정보를 전송한다. 이때 기존 &lt;form&gt; 요소의 target 속성을 변경하지 않는다. 또한 파라미터로 함수를 입력할 수 있으며 해당 함수가 true 값을 반환하면 데이터를 제출한다. 이 함수를 사용하여 데이터를 전송하기 전에 검증할 수 있다.
 *
 * @param1 {Void}
 * @return1 {$Form} 데이터를 제출한 $Form() 객체.
 *
 * @param2 {String+} sTargetName 전송 대상.
 * @return2 {$Form} 데이터를 제출한 $Form() 객체.
 *
 * @param3 {Function+} fValidation &lt;form&gt; 요소의 데이터를 검증할 함수. 이 함수의 파라미터로 $Form() 객체가 감싸고 있는 원본 &lt;form&gt; 요소가 입력된다.
 * @return4 {$Form} 데이터를 제출한 $Form() 객체.
 *
 * @param4 {String+} sTargetName 전송 대상.
 * @param4 {Function+} fValidation &lt;form&gt; 요소의 데이터를 검증할 함수. 이 함수의 파라미터로 $Form() 객체가 감싸고 있는 원본 &lt;form&gt; 요소가 입력된다.
 * @return4 {$Form} 데이터를 제출한 $Form() 객체.
 *
 * @example
var form = $Form(el);
form.submit();
form.submit('foo');

* @example
// fValidation 파라미터 사용한 경우
var form = $Form(el);
form.submit("target_name");

form.submit(function(){
	if($("test").value.length > 0) {
		return true; //true를 리턴하면 submit() 수행
	}

	return false; //false를 리턴하면 submit() 수행하지 않음
});

form.submit("target_name", function(){
	if($("test").value.length > 0) {
		return true;
	}

	return false;
});

 */
MobileCommentJindo.$Form.prototype.submit = function(sTargetName, fValidation) {
	//-@@$Form.submit-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'voi' : [],
		'4str' : [ 'sTargetName:String+'],
		'4fun' : [ 'fValidation:Function+'],
		'4fun2' : [ 'sTargetName:String+',"fValidation:Function+"]
	},"$Form#submit");

	var sOrgTarget = null;
	switch(oArgs+""){
		case "4str":
			sOrgTarget = this._form.target;
			this._form.target = oArgs.sTargetName;
			break;
		case "4fun":
		case "4fun2":
			if(!oArgs.fValidation(this._form)) return this;
			if(oArgs+"" == "4fun2"){
				sOrgTarget = this._form.target;
				this._form.target = oArgs.sTargetName;
			}


	}
	this._form.submit();
	if (!MobileCommentJindo.$Jindo.isNull(sOrgTarget)) this._form.target = sOrgTarget;
	return this;
};
//-!MobileCommentJindo.$Form.prototype.submit end!-//

//-!MobileCommentJindo.$Form.prototype.reset start!-//
/**

 * @description reset() 메서드는 &lt;form&gt; 요소를 초기화(reset)한다. 파라미터로 함수를 입력할 수 있으며 해당 함수가 true 값을 반환하면 &lt;form&gt; 요소를 초기화한다.
 *
 * @param1 {Void}
 * @return1 {$Form} 초기화한 $Form() 객체.
 *
 * @param2 {Function+} fValidation &lt;form&gt; 요소의 데이터를 초기화하기 전에 실행할 함수.
 * @return2 {$Form} 초기화한 $Form() 객체.
 *
 * @example
var form = $Form(el);
form.reset();

 * @example
// fValidation 파라미터 사용한 경우
var form = $Form(el);

form.submit(function(){
	return confirm("초기화하시겠습니까?");
});

 */
MobileCommentJindo.$Form.prototype.reset = function(fValidation) {
	//-@@$Form.reset-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4voi' : [ ],
		'4fun' : [ 'fValidation:Function+']
	},"$Form#reset");

	if(oArgs+"" == "4fun") if(!fValidation(this._form)) return this;

	this._form.reset();
	return this;

};
//-!MobileCommentJindo.$Form.prototype.reset end!-//



/**

 * @fileOverview $Template의 생성자 및 메서드를 정의한 파일
 * @name template.js
 * @author AjaxUI lab

 */

//-!MobileCommentJindo.$Template start!-//
/**

 * @class $Template() 객체를 사용하면 템플릿을 해석하여 템플릿에 동적으로 데이터를 적용할 수 있다.
 * @constructor
 * @description $Template() 객체를 생성한다.
 * @param1 {String+} sTemplate 템플릿으로 사용할 문자열 또는 템플릿 HTML 요소의 id<br>
	파라미터가 문자열이면 두 가지 방식으로 동작한다.
	<ul>
		<li>문자열이 HTML 요소의 id라면 HTML 요소의 innerHTML을 템플릿으로 사용한다.</li>
		<li>만약 일반 문자열이라면 문자열 자체를 템플릿으로 사용한다.</li>
	</ul>
 * @param2 {Element+} elTemplate 템플릿으로 HTML 요소<br>
	파라미터가 HTML 요소이면 TEXTAREA와 SCRIPT 요소만 사용할 수 있다.
	<ul>
		<li>HTML 요소가 SCRIPT 요소인 경우 type 속성은 반드시 "text/template"으로 지정해야 한다.</li>
		<li>HTML 요소의 value 값을 템플릿으로 사용하며, value 값이 없을 경우 HTML 요소의 innerHTML을 템플릿으로 사용한다.</li>
	</ul>
 * @example
// 파라미터가 일반 문자열인 경우
var tpl = $Template("{=service} : {=url}");

 * @example
<textarea id="tpl1">
{=service} : {=url}
&lt;/textarea&gt;

// 같은 TEXTAREA 요소를 템플릿으로 사용한다
var template1 = $Template("tpl1");		// 파라미터가 HTML 요소의 ID
var template2 = $Template($("tpl1"));	// 파라미터가 TEXTAREA 요소인 경우
</script>

 * @example
<script type="text/template" id="tpl2">
{=service} : {=url}
</script>

// 같은 SCRIPT 요소를 템플릿으로 사용한다
var template1 = $Template("tpl2");		// 파라미터가 HTML 요소의 ID
var template2 = $Template($("tpl2"));	// 파라미터가가 SCRIPT 요소인 경우

 */
MobileCommentJindo.$Template = function(str) {
	//-@@$Template-@@//
    var obj = null, tag = "";
    var cl  = arguments.callee;

    if (str instanceof cl) return str;

	if (!(this instanceof cl)){
		try {
			MobileCommentJindo.$Jindo._warn(arguments.length, 1,"$Template");
			return new cl(str||"");
		} catch(e) {
			if (e instanceof TypeError) { return null; }
			throw e;
		}
	}

	MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str' : ['str:String+'],
		'4ele' : ['ele:Element+']
	},"$Template");

    if( (obj=document.getElementById(str)||str) && obj.tagName && (tag=obj.tagName.toUpperCase()) && (tag == "TEXTAREA" || (tag == "SCRIPT" && obj.getAttribute("type") == "text/template")) ) {
        str = (obj.value||obj.innerHTML).replace(/^\s+|\s+$/g,"");
    }

    this._str = str+"";
};
MobileCommentJindo.$Template.splitter = /(?!\\)[\{\}]/g;
MobileCommentJindo.$Template.pattern  = /^(?:if (.+)|elseif (.+)|for (?:(.+)\:)?(.+) in (.+)|(else)|\/(if|for)|=(.+)|js (.+)|set (.+)|gset (.+))$/;
//-!MobileCommentJindo.$Template end!-//

//-!MobileCommentJindo.$Template.prototype.process start!-//
 /**

 * @description  process() 메서드는 템플릿을 해석하고 데이터를 적용하여 새로운 문자열을 생성한다. 템플릿 내에 구문이 없으면 단순 문자열 치환으로 처리한다. 템플릿을 해석할 때에 템플릿에 구문이 있으면 구문에 따라 템플릿을 해석이 달라진다. 각 구문의 해석은 예제와 다음 표를 참고한다.<br>
 <table>
	<caption>템플릿 구문</caption>
	<thead>
		<tr>
			<th scope="col">구분</th>
			<th scope="col">설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>{=변수}</td>
			<td>파라미터로 입력된 데이터 객체에서 변수와 이름이 같은 속성의 값을 출력한다.</td>
		</tr>
		<tr>
			<td>{if 조건}<br>{elseif 조건}<br>{else}<br>{/if}</td>
			<td>조건에 따라 출력할 템플릿 내용을 선택한다.</td>
		</tr>
		<tr>
			<td>{for [인덱스:]변수 in 배열}<br>{/for}</td>
			<td>for문 안에 있는 템플릿의 내용을 반복하여 출력한다.</td>
		</tr>
		<tr>
			<td>{set 변수 = 값}</td>
			<td>템플릿에서 사용할 임시 변수에 값을 할당한다.</td>
		</tr>
		<tr>
			<td>{gset 변수 = 값}</td>
			<td>set과 달리 지역변수로 할당되어 {js}에서 사용가능하다.(버전 2.0.0부터 사용가능)</td>
		</tr>
		<tr>
			<td>{js 함수}</td>
			<td>템플릿에서 특정 기능의 함수를 호출한다.</td>
		</tr>
	</tbody>
</table>
 * @param1 {Void}
 * @return1 {String} 템플릿을 해석하고 데이터를 적용한 새로운 문자열.

 * @param2 {Hash+} oDdata 템플릿에 적용할 데이터를 가진 객체. 템플릿에 데이터를 적용할 부분은 객체의 속성(property) 이름으로 찾는다.
 * @return2 {String} 템플릿을 해석하고 데이터를 적용한 새로운 문자열.
 * @example
// 단순 문자열 치환
// {=value} 부분의 값을 치환한다.
var tpl  = $Template("Value1 : {=val1}, Value2 : {=val2}")
var data = { val1: "first value", val2: "second value" };

document.write( tpl.process(data) );

// 결과
// Value1 : first value, Value2 : second value

 * @example
// if/elseif/else : 조건문
// 템플릿을 해석할 때 조건문을 판단하여 처리한다.
var tpl= $Template("{if num >= 7}7보다 크거나 같다.{elseif num <= 5}5보다 작거나 같다.{else}아마 6?{/if}");
var data = { num: 5 };

document.write( tpl.process(data) );

// 결과
// 5보다 작거나 같다.

 * @example
// set : 임시 변수 사용
// set val=1 로 설정하는 경우 {=val} 부분에 1을 대입한다.
var tpl  = $Template("{set val3=val1}Value1 : {=val1}, Value2 : {=val2}, Value3 : {=val3}")
var data = { val1: "first value", val2: "second value" };

document.write( tpl.process(data) );

// 결과
// Value1 : first value, Value2 : second value, Value3 : first value

 * @example
// gset : 지역 변수로 할당.
// gset val=1 로 설정하는 경우 {js}을 사용해서 접근 가능하다.
var tpl  = $Template("{gset length=(=books).length}{for num:book in books}{js length}.{=book}\n{/for}")
var data = {"books":[1,2,3]};

document.write( tpl.process(data) );

// 결과
// 3.1
// 3.2
// 3.3

 * @example
// js : JavaScript 사용
// 템플릿을 해석할 때 해당 JavaScript를 실행한다.
var tpl  = $Template("Value1 : {js $S(=val1).bytes()}, Value2 : {=val2}")
var data = { val1: "first value", val2: "second value" };

document.write( tpl.process(data) );

// 결과
// Value1 : 11, Value2 : second value

 * @example
// for in : 반복문(인덱스를 사용하지 않는 경우)
var tpl  = $Template("<h1>포탈 사이트</h1>\n<ul>{for site in portals}\n<li><a href='{=site.url}'>{=site.name}</a></li>{/for}\n</ul>");
var data = { portals: [
	{ name: "네이버", url : "http://www.naver.com" },
	{ name: "다음",  url : "http://www.daum.net" },
	{ name: "야후",  url : "http://www.yahoo.co.kr" }
]};

document.write( tpl.process(data) );

// 결과
//<h1>포탈 사이트</h1>
//<ul>
//<li><a href='http://www.naver.com'>네이버</a></li>
//<li><a href='http://www.daum.net'>다음</a></li>
//<li><a href='http://www.yahoo.co.kr'>야후</a></li>
//</ul>

 * @example
// for: 반복문(인덱스를 사용하는 경우)
var tpl  = $Template("{for num:word in numbers}{=word}({=num}){/for}");
var data = { numbers: ["zero", "one", "two", "three"] };

document.write( tpl.process(data) );

// 결과
// zero(0) one(1) two(2) three(3)

 */
MobileCommentJindo.$Template.prototype.process = function(data) {
	//-@@$Template.process-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4obj' : ['data:Hash+'],
		'4voi' : []
	},"$Template#process");
	var key = "\x01";
	var leftBrace = "\x02";
	var rightBrace = "\x03";
    var tpl = (" "+this._str+" ").replace(/\\{/g,leftBrace).replace(/\\}/g,rightBrace).replace(/(?!\\)\}\{/g, "}"+key+"{").split(MobileCommentJindo.$Template.splitter), i = tpl.length;

    var map = {'"':'\\"','\\':'\\\\','\n':'\\n','\r':'\\r','\t':'\\t','\f':'\\f'};
    var reg = [/(["'](?:(?:\\.)+|[^\\["']+)*["']|[a-zA-Z_](?:[\w\.]|\[(?:.*?)\])*)/g, /[\n\r\t\f"\\]/g, /^\s+/, /\s+$/, /#/g];
	var cb = [function(m){ return (m.substring(0,1)=='"' || m.substring(0,1)=='\''||m=='null'||m=="false"||m=="true")?m:"d."+m; }, function(m){return map[m]||m}, "", ""];
    var stm = [];
	var lev = 0;

	// remove " "
	tpl[0] = tpl[0].substr(1);
	tpl[i-1] = tpl[i-1].substr(0, tpl[i-1].length-1);

    // no pattern
    if(i<2) return tpl[0];

	tpl = tpl.reverse();

	var delete_info;
    while(i--) {
        if(i%2) {
            tpl[i] = tpl[i].replace(MobileCommentJindo.$Template.pattern, function(){
                var m = arguments;
				//gset
				if (m[11]) {
					return m[11].replace(/(\w+)(?:\s*)=(?:\s*)(?:([a-zA-Z0-9_]+)|(.+))$/g, function(){
										var mm = arguments;
										var str = "var "+ mm[1]+"=";
										if(mm[2]){
											str+= mm[2];
										}else {
											str += mm[3].replace(   /(=(?:[a-zA-Z_][\w\.]*)+)/g,
                				                                           function(m){ return (m.substring(0,1)=='=')?"d."+m.replace('=','') : m; }
                                				                        );
										}
										return str;
								}) +	";";

				}
				// set
				if (m[10]) {
					var a =  m[10].replace(/(\w+)(?:\s*)=(?:\s*)(?:([a-zA-Z0-9_]+)|(.+))$/g, function(){
										var mm = arguments;
										var str = "d."+mm[1]+"=";
										if(mm[2]){
											str+="d."+mm[2];
										}else {
											str += mm[3].replace(/((?:[a-zA-Z_](?:[\w\.]|\[(?:.*?)\])*)+)/g,
                				                                           function(m){
																			   return "d."+m;
																		   }
                                				                 );
										}
										return str;
								}) +	";";
					return a;

				}
				// js
				if(m[9]) {
					return 's[i++]=' + m[9].replace(   /(=(?:[a-zA-Z_][\w\.]*)+)/g,
                				                                           function(m){ return (m.substring(0,1)=='=')?"d."+m.replace('=','') : m; }
                                				                        )+';';
				}
                // variables
                if(m[8]) return 's[i++]= d.'+m[8]+';';

                // if
                if(m[1]) {
                    return 'if('+m[1].replace(reg[0],cb[0]).replace(/d\.(typeof) /,'$1 ').replace(/ d\.(instanceof) d\./,' $1 ')+'){';
                }

                // else if
                if(m[2]) return '}else if('+m[2].replace(reg[0],cb[0]).replace(/d\.(typeof) /,'$1 ').replace(/ d\.(instanceof) d\./,' $1 ')+'){';

                // for loop
                if(m[5]) {
					delete_info = m[4];
					var _aStr = [];
					_aStr.push('var t#=d.'+m[5]+'||{},p#=MobileCommentJindo.$Jindo.isArray(t#),i#=0;');
					_aStr.push('for(var x# in t#){');

					_aStr.push('if(!t#.hasOwnProperty(x#)){continue;}');
					_aStr.push('	if( (p# && isNaN(i#=parseInt(x#,10))) || (!p# && !t#.propertyIsEnumerable(x#)) ) continue;');
					_aStr.push('	d.'+m[4]+'=t#[x#];');
					_aStr.push(m[3]?'d.'+m[3]+'=p#?i#:x#;':'');
					return  _aStr.join("").replace(reg[4], lev++ );
                }

                // else
                if(m[6]) return '}else{';

                // end if, end for
                if(m[7]) {
					if(m[7]=="for"){
						return "delete d."+delete_info+"; };";
					}else{
						return '};';
					}

                }

                return m[0];
            });
        }else if(tpl[i] == key) {
			tpl[i] = "";
        }else if(tpl[i]){
            tpl[i] = 's[i++]="'+tpl[i].replace(reg[1],cb[1])+'";';
        }
    }

	tpl = tpl.reverse().join('').replace(new RegExp(leftBrace,'g'),"{").replace(new RegExp(rightBrace,'g'),"}");

	var _aStr = [];
	_aStr.push('d = d||{};');
	_aStr.push('var s=[],i=0;');
	_aStr.push(tpl);
	_aStr.push('return s.join("");');
	tpl = new Function("d",''+
		_aStr.join("")
	);

	tpl = tpl(oArgs+""=="for_void"?"":oArgs.data);
    return tpl;
};
//-!MobileCommentJindo.$Template.prototype.process end!-//


/**

 * @fileOverview $Date() 객체의 생성자 및 메서드를 정의한 파일
 * @name date.js
 * @author  AjaxUI lab

 */

//-!MobileCommentJindo.$Date start!-//
/**

 * @class $Date() 객체는 Date 객체를 래핑(Wrapping)하여 날짜 및 시간을 처리하기 위한 확장 기능을 제공한다.
 * @extends core
 * @constructor
 * @description $Date() 객체를 생성한다. $Date() 객체를 생성할 때 파라미터 없이 생성하거나 ISO Date 포맷 또는 밀리 초 단위의 정수를 생성자의 인수로 입력할 수 있다. ISO Date 포맷 문자를 넣은 경우 $Date.utc 속성을 기반하여 날짜를 계산한다.
 *
 * @param1 {Void}
 *
 * @param2 {String+} sDate Date 포맷의 문자열.
 *
 * @param3 {Number} nDate 밀리 초 단위의 TimeStamp 정수 값.
 *
 * @param4 {Date+} oDate Date 또는 $Date 객체
 *
 * @param5 {Numeric} nYear 정수 값(Number) 년
 * @param5 {Numeric} nMonth 정수 값(Number) 월
 *
 * @param6 {Numeric} nYear 정수 값(Number) 년
 * @param6 {Numeric} nMonth 정수 값(Number) 월
 * @param6 {Numeric} nDate 정수 값(Number) 일
 *
 * @param7 {Numeric} nYear 정수 값(Number) 년
 * @param7 {Numeric} nMonth 정수 값(Number) 월
 * @param7 {Numeric} nDate 정수 값(Number) 일
 * @param7 {Numeric} nHour 정수 값(Number) 시
 *
 * @param8 {Numeric} nYear 정수 값(Number) 년
 * @param8 {Numeric} nMonth 정수 값(Number) 월
 * @param8 {Numeric} nDate 정수 값(Number) 일
 * @param8 {Numeric} nHour 정수 값(Number) 시
 * @param8 {Numeric} nMinute 정수 값(Number) 분
 *
 * @param9 {Numeric} nYear 정수 값(Number) 년
 * @param9 {Numeric} nMonth 정수 값(Number) 월
 * @param9 {Numeric} nDate 정수 값(Number) 일
 * @param9 {Numeric} nHour 정수 값(Number) 시
 * @param9 {Numeric} nMinute 정수 값(Number) 분
 * @param9 {Numeric} nSecond 정수 값(Number) 초
 *
 * @param10 {Numeric} nYear 정수 값(Number) 년
 * @param10 {Numeric} nMonth 정수 값(Number) 월
 * @param10 {Numeric} nDate 정수 값(Number) 일
 * @param10 {Numeric} nHour 정수 값(Number) 시
 * @param10 {Numeric} nMinute 정수 값(Number) 분
 * @param10 {Numeric} nSecond 정수 값(Number) 초
 * @param10 {Numeric} nMiliSec 정수 값(Number) 밀리세컨드

 *
 * @see $Date.utc
 * @see $Date#format
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">Date</a> - MDN Docs
 * @see <a href="http://ko.wikipedia.org/wiki/ISO_8601">ISO 8601</a> - W3C
 * @example
$Date();
$Date(milliseconds);
$Date(dateString);
//1.4.6 이후부터 달까지만 넣어도 $Date사용 가능하여 빈 값은 1로 설정
$Date(year, month, [date, [hours, [minitues, [seconds, [milliseconds]]]]]);
$Date(2010,6);//이러고 하면 $Date(2010,6,1,1,1,1,1); 와 같음.

 */
MobileCommentJindo.$Date = function(src) {
	//-@@$Date-@@//
	var a=arguments,t="";
	var cl=arguments.callee;

	if (src && src instanceof cl) return src;
	if (!(this instanceof cl)){
		var str="";
		for(var i = 0, l = a.length; i < l; i++){
			str += "a["+i+"],";
		}
		var init = new Function('cl','a','return new cl('+str.replace(/,$/,"")+');');

		try {
			MobileCommentJindo.$Jindo._warn(arguments.length, 7,"$Date");
			return init(cl,a);
		} catch(e) {
			if (e instanceof TypeError) { return null; }
			throw e;
		}

	}

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4voi'  : [ ],
		'4str'  : [ 'src:String+' ],
		'4num'  : [ 'src:Numeric'],
		'4dat' 	: [ 'src:Date+'],
		'4num2' : [ 'src:Numeric', 'src:Numeric'],
		'4num3' : [ 'src:Numeric', 'src:Numeric', 'src:Numeric'],
		'4num4' : [ 'src:Numeric', 'src:Numeric', 'src:Numeric', 'src:Numeric'],
		'4num5' : [ 'src:Numeric', 'src:Numeric', 'src:Numeric', 'src:Numeric', 'src:Numeric'],
		'4num6' : [ 'src:Numeric', 'src:Numeric', 'src:Numeric', 'src:Numeric', 'src:Numeric', 'src:Numeric'],
		'4num7' : [ 'src:Numeric', 'src:Numeric', 'src:Numeric', 'src:Numeric', 'src:Numeric', 'src:Numeric', 'src:Numeric']
	},"$Date");

	switch(oArgs+""){
		case '4voi' :
			this._date = new Date;
			break;
		case '4num' :
			this._date = new Date(src*1);
			break;
		case '4str' :
			if (/(\d\d\d\d)(?:-?(\d\d)(?:-?(\d\d)))/.test(src)) {
				this._date = MobileCommentJindo.$Date._makeISO(src);
			}else{
				this._date = cl.parse(src);
			}
			break;
		case '4dat' :
			(this._date = new Date).setTime(src.getTime());
			this._date.setMilliseconds(src.getMilliseconds());
			break;
		case '4num2':
		case '4num3':
		case '4num4':
		case '4num5':
		case '4num6':
		case '4num7':
			for(var i = 0 ; i < 7 ; i++){
				if(!MobileCommentJindo.$Jindo.isNumeric(a[i])){
					a[i] = 1;
				}
			}
			this._date = new Date(a[0],a[1],a[2],a[3],a[4],a[5],a[6]);
	}
	this._names = {};
	for(var i in MobileCommentJindo.$Date.names){
		if(MobileCommentJindo.$Date.names.hasOwnProperty(i))
			this._names[i] = MobileCommentJindo.$Date.names[i];
	}
};
/**
 * @ignore
 */
MobileCommentJindo.$Date._makeISO = function(src){
	var match = src.match(/(\d\d\d\d)(?:-?(\d\d)(?:-?(\d\d)(?:[T ](\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|(?:([-+])(\d\d)(?::?(\d\d))?)?)?)?)?)?/);
	var hour = parseInt(match[4]||0,10);
	var min = parseInt(match[5]||0,10);
	if (match[8] == "Z") {
		hour += MobileCommentJindo.$Date.utc;
	}else if(match[9] == "+" || match[9] == "-"){
		hour += (MobileCommentJindo.$Date.utc - parseInt(match[9]+match[10],10));
		min  +=  parseInt(match[9] + match[11],10);
	}
	return new Date(match[1]||0,parseInt(match[2]||0,10)-1,match[3]||0,hour ,min ,match[6]||0,match[7]||0);

};
/**
 * @ignore
 */
MobileCommentJindo.$Date._paramCheck = function(aPram, sType){
	return MobileCommentJindo.$Jindo.checkVarType(aPram, {
		's' : [ 'nParm:Numeric'],
		'g' : []
	},"$Date#"+sType);
};
/**

 * @description names 속성은 $Date() 객체에서 사용하는 달, 요일, 오전/오후를 표시하는 문자열을 저장한다. s_ 를 접두어로 가지는 이름은 약어(abbreviation)이다.<br>
<table>
	<caption>달, 요일, 오전/오후 표시 문자열</caption>
	<thead>
		<tr>
			<th scope="col">구분</th>
			<th scope="col">문자열</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>month</td>
			<td>January, Febrary, March, April, May, June, July, August, September, October, Novermber, December</td>
		</tr>
		<tr>
			<td>s_month</td>
			<td>Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec</td>
		</tr>
		<tr>
			<td>day</td>
			<td>Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday</td>
		</tr>
		<tr>
			<td>s_day</td>
			<td>Sun, Mon, Tue, Wed, Thu, Fri, Sat</td>
		</tr>
		<tr>
			<td>ampm</td>
			<td>AM, PM</td>
		</tr>
	</tbody>
</table>

 */
MobileCommentJindo.$Date.names = {
	month   : ["January","Febrary","March","April","May","June","July","August","September","October","Novermber","December"],
	s_month : ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],
	day     : ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
	s_day   : ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],
	ampm    : ["AM", "PM"]
};

/**

 * @description utc 속성은 협정 세계시와 시차를 저장한다. 기본 값은 한국 시간 기준으로 +9로 저장된다.
 * @see <a href="http://ko.wikipedia.org/wiki/UTC">협정 세계시간</a>
 * @example
$Date.utc = -10; // 하와이 시간을 기준으로 한다.

 */
MobileCommentJindo.$Date.utc = 9;
//-!MobileCommentJindo.$Date end!-//

//-!MobileCommentJindo.$Date.now start!-//
/**

 * @description now() 메서드는 현재 시간을 밀리 초(millisecond) 단위의 정수로 리턴한다.
 * @return {Numeric} 현재 시간을 밀리 초 단위의 정수로 나타낸 값.
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/now">Date.now()</a> - MDN Docs
 * @example
$Date().now(); //sample : 1304907432081

 */
MobileCommentJindo.$Date.now = function() {
	//-@@$Date.now-@@//
  if(Date.now){
	/**
	 * @ignore
	 */
  	this.now = function(){
		return Date.now();
	}
  }else{
	/**
	 * @ignore
	 */
  	this.now = function(){
		return +new Date();
	}
  }
  return this.now();
};
//-!MobileCommentJindo.$Date.now end!-//

//-!MobileCommentJindo.$Date.prototype.name start!-//
/**

 * @description name() 메서드는 names 속성에 정의된 달, 요일, 오전/오후를 표시하는 문자열의 값을 가져오거나 문자열을 새로 설정할 수 있다.
 * @since 1.4.1
 *
 * @param1 {String+} vName names속성 이름(String).
 * @return1 {Variant} names 속성 값을 반환한다
 *
 * @param2 {Hash+} 하나 이상의 names속성과 값을 가지는 객체(Object) 또는 해시 객체($H()객체).
 * @return2 {Variant} 값을 반영한 인스턴스를 반환한다.
 *
 * @param3 {String+} vName names속성 이름(String)
 * @param3 {Array+} aValue names속성에 설정할 값.
 * @return3 {Variant} 값을 반영한 인스턴스를 반환한다.
 *
 * @see $Date.names

 */
MobileCommentJindo.$Date.prototype.name = function(vName,aValue){
	//-@@$Date.name-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		's4str' : [ 'sKey:String+', 'aValue:Array+' ],
		's4obj' : [ 'oObject:Hash+' ],
		'g' : [ 'sKey:String+' ]
	},"$Date#name");

	switch(oArgs+"") {
		case 's4str':
			this._names[vName] = aValue;
			break;
		case 's4obj':
			vName = oArgs.oObject;
			for(var i in vName){
				if(vName.hasOwnProperty(i)){
					this._names[i] = vName[i];
				}
			}
			break;
		case 'g':
			return this._names[vName];
	}

	return this;
};
//-!MobileCommentJindo.$Date.prototype.name end!-//

//-!MobileCommentJindo.$Date.prototype.parse start!-//
/**

 * @description parse() 메서드는 인수로 지정한 문자열을 파싱하여 $Date() 객체를 생성한다.
 * @param {String+} sDate 날짜, 혹은 시간 형식을 가진 문자열
 * @return {Object} Date 객체.
 * @throws {MobileCommentJindo.$Except.INVALID_DATE} date가 정상적인 문자 포맷이 아닌경우.
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">Date</a> - MDN Docs

 */
MobileCommentJindo.$Date.parse = function(strDate) {
	//-@@$Date.parse-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str' : [ 'sKey:String+']
	},"$Date#parse");

	var date = new Date(Date.parse(strDate));
	if(isNaN(date)||date == "Invalid Date"){
		throw new MobileCommentJindo.$Error(MobileCommentJindo.$Except.INVALID_DATE, "$Date#parse");
	}
	return date;
};
//-!MobileCommentJindo.$Date.prototype.parse end!-//

//-!MobileCommentJindo.$Date.prototype.$value start!-//
/**

 * @description $value() 메서드는 $Date() 객체가 감싸고 있던 원본 Date 객체를 반환한다.
 * @return {Object} 원본 Date 객체.
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">Date</a> - MDN Docs

 */
MobileCommentJindo.$Date.prototype.$value = function(){
	//-@@$Date.$value-@@//
	return this._date;
};
//-!MobileCommentJindo.$Date.prototype.$value end!-//

//-!MobileCommentJindo.$Date.prototype.format start(MobileCommentJindo.$Date.prototype.name,MobileCommentJindo.$Date.prototype.isLeapYear,MobileCommentJindo.$Date.prototype.time)!-//
/**

 * @description format() 메서드는 $Date() 객체가 저장하고 있는 시간을 파라미터로 지정한 형식 문자열(Format Specifier)에 맞추어 변환한다. 지원하는 형식 문자열은 PHP의 date() 함수와 동일하다.<br>
	<table>
		<caption>날짜</caption>
		<thead>
			<tr>
				<th scope="col">문자</th>
				<th scope="col">설명</th>
				<th scope="col">기타</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>d</td>
				<td>두자리 날짜</td>
				<td>01 ~ 31</td>
			</tr>
			<tr>
				<td>j</td>
				<td>0 없는 날짜</td>
				<td>1 ~ 31</td>
			</tr>
			<tr>
				<td>l (소문자L)</td>
				<td>주의 전체 날짜</td>
				<td>$Date.names.day에 지정되는 날짜</td>
			</tr>
			<tr>
				<td>D</td>
				<td>요약된 날짜</td>
				<td>$Date.names.s_day에 지정된 날짜</td>
			</tr>
			<tr>
				<td>w</td>
				<td>그 주의 몇번째 일</td>
				<td>0(일) ~ 6(토)</td>
			</tr>
			<tr>
				<td>N</td>
				<td>ISO-8601 주의 몇번째 일</td>
				<td>1(월) ~ 7(일)</td>
			</tr>
			<tr>
				<td>S</td>
				<td>2글자, 서수형식의 표현(1st, 2nd)</td>
				<td>st, nd, rd, th</td>
			</tr>
			<tr>
				<td>z</td>
				<td>해당 년도의 몇번째 일(0부터)</td>
				<td>0 ~ 365</td>
			</tr>
		</tbody>
	</table>
	<table>
		<caption>월</caption>
		<thead>
			<tr>
				<th scope="col">문자</th>
				<th scope="col">설명</th>
				<th scope="col">기타</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>m</td>
				<td>두자리 고정으로 월</td>
				<td>01 ~ 12</td>
			</tr>
			<tr>
				<td>n</td>
				<td>앞에 0제외 월</td>
				<td>1 ~ 12</td>
			</tr>
		</tbody>
	</table>
	<table>
		<caption>년</caption>
		<thead>
			<tr>
				<th scope="col">문자</th>
				<th scope="col">설명</th>
				<th scope="col">기타</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>L</td>
				<td>윤년 여부</td>
				<td>true, false</td>
			</tr>
			<tr>
				<td>o</td>
				<td>4자리 연도</td>
				<td>2010</td>
			</tr>
			<tr>
				<td>Y</td>
				<td>o와 같음.</td>
				<td>2010</td>
			</tr>
			<tr>
				<td>y</td>
				<td>2자리 연도</td>
				<td>10</td>
			</tr>
		</tbody>
	</table>
	<table>
		<caption>시</caption>
		<thead>
			<tr>
				<th scope="col">문자</th>
				<th scope="col">설명</th>
				<th scope="col">기타</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>a</td>
				<td>소문자 오전, 오후</td>
				<td>am,pm</td>
			</tr>
			<tr>
				<td>A</td>
				<td>대문자 오전,오후</td>
				<td>AM,PM</td>
			</tr>
			<tr>
				<td>g</td>
				<td>(12시간 주기)0없는 두자리 시간.</td>
				<td>1~12</td>
			</tr>
			<tr>
				<td>G</td>
				<td>(24시간 주기)0없는 두자리 시간.</td>
				<td>0~24</td>
			</tr>
			<tr>
				<td>h</td>
				<td>(12시간 주기)0있는 두자리 시간.</td>
				<td>01~12</td>
			</tr>
			<tr>
				<td>H</td>
				<td>(24시간 주기)0있는 두자리 시간.</td>
				<td>00~24</td>
			</tr>
			<tr>
				<td>i</td>
				<td>0포함 2자리 분.</td>
				<td>00~59</td>
			</tr>
			<tr>
				<td>s</td>
				<td>0포함 2자리 초</td>
				<td>00~59</td>
			</tr>
			<tr>
				<td>u</td>
				<td>microseconds</td>
				<td>654321</td>
			</tr>
		</tbody>
	</table>
	<table>
		<caption>기타</caption>
		<thead>
			<tr>
				<th scope="col">문자</th>
				<th scope="col">설명</th>
				<th scope="col">기타</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>U</td>
				<td>Unix Time(1970 00:00:00 GMT) </td>
				<td></td>
			</tr>
		</tbody>
	</table>
 * @param {String+} sFormat  형식 문자열
 * @return {String} 시간을 형식 문자열에 맞추어 변환한 문자열.
 * @see <a href="http://kr2.php.net/manual/en/function.date.php">date()</a> - php.net
 * @example
	var oDate = $Date("Jun 17 2009 12:02:54");
	oDate.format("Y.m.d(D) A H:i") => "2009.06.17(Wed) PM 12:02"

 */
MobileCommentJindo.$Date.prototype.format = function(strFormat){
	//-@@$Date.format-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4str' : [ 'sFormat:String+']
	},"$Date#format");
	strFormat = oArgs.sFormat;

	var o = {};
	var d = this._date;
	var name = this._names;
	var self = this;
	return (strFormat||"").replace(/[a-z]/ig, function callback(m){
		if (o[m] !== undefined) return o[m];

		switch(m) {
			case"d":
			case"j":
				o.j = d.getDate();
				o.d = (o.j>9?"":"0")+o.j;
				return o[m];
			case"l":
			case"D":
			case"w":
			case"N":
				o.w = d.getDay();
				o.N = o.w?o.w:7;
				o.D = name.s_day[o.w];
				o.l = name.day[o.w];
				return o[m];
			case"S":
				return (!!(o.S=["st","nd","rd"][d.getDate()]))?o.S:(o.S="th");
			case"z":
				o.z = Math.floor((d.getTime() - (new Date(d.getFullYear(),0,1)).getTime())/(3600*24*1000));
				return o.z;
			case"m":
			case"n":
				o.n = d.getMonth()+1;
				o.m = (o.n>9?"":"0")+o.n;
				return o[m];
			case"L":
				o.L = self.isLeapYear();
				return o.L;
			case"o":
			case"Y":
			case"y":
				o.o = o.Y = d.getFullYear();
				o.y = (o.o+"").substr(2);
				return o[m];
			case"a":
			case"A":
			case"g":
			case"G":
			case"h":
			case"H":
				o.G = d.getHours();
				o.g = (o.g=o.G%12)?o.g:12;
				o.A = o.G<12?name.ampm[0]:name.ampm[1];
				o.a = o.A.toLowerCase();
				o.H = (o.G>9?"":"0")+o.G;
				o.h = (o.g>9?"":"0")+o.g;
				return o[m];
			case"i":
				o.i = (((o.i=d.getMinutes())>9)?"":"0")+o.i;
				return o.i;
			case"s":
				o.s = (((o.s=d.getSeconds())>9)?"":"0")+o.s;
				return o.s;
			case"u":
				o.u = d.getMilliseconds();
				return o.u;
			case"U":
				o.U = self.time();
				return o.U;
			default:
				return m;
		}
	});
};
//-!MobileCommentJindo.$Date.prototype.format end!-//

//-!MobileCommentJindo.$Date.prototype.time start!-//
/**

 * @description time() 메서드는 GMT(1970/01/01 00:00:00)를 기준으로 경과한 시간을 $Date() 객체에 설정하거나 $Date() 객체가 가지고 있는 값을 가져온다. 파라미터를 입력하면 경과한 시간을 설정하고 파라미터를 생략하면 현재 시간을 기준으로 경과한 시간을 가져온다.
 *
 * @param1 {Void}
 * @return1 {Number} $Date() 객체가 저장하고 있는 밀리세컨드 단위의 timeStamp 값.
 *
 * @param2 {Numeric} nTimeStamp  밀리 초 단위의 정수 값.
 * @return2 {$Date} GMT를 기준으로 파라미터에 지정한 시간만큼 경과한 시간을 설정한 $Date() 객체.
 *
 * @throws {MobileCommentJindo.$Except.INVALID_DATE} 파라메터나 숫자가 아닌 경우 예외상황 발생.
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getTime">Date.getTime()</a> - MDN
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/setTime">Date.setTime()</a> - MDN
 * @see <a href="http://ko.wikipedia.org/wiki/GMT">GMT</a>
 * @example
var oDate = new $Date(Date.now());
oDate.time(); //sample : 1304908070435

 */
MobileCommentJindo.$Date.prototype.time = function(nTime) {
	//-@@$Date.time-@@//
	var oArgs = MobileCommentJindo.$Date._paramCheck(arguments,"time");
	nTime = oArgs.nParm;

	switch(oArgs+""){
		case 's':
			this._date.setTime(nTime);
			return this;
		case 'g':
			return this._date.getTime();
	}
};
//-!MobileCommentJindo.$Date.prototype.time end!-//

//-!MobileCommentJindo.$Date.prototype.year start!-//
/**

 * @description year() 메서드는 $Date() 객체가 저장하고 있는 시각의 연도(year)를 가져오거나 지정한 값으로 설정한다. 파라미터를 입력하면 $Date() 객체에 지정한 연도를 설정하고 파라미터를 생략하면 $Date() 객체가 저장하고 있는 연도를 반환한다. 이때 연도 값의 형식은 4자리 정수 값이다.
 *
 * @param1 {Void}
 * @return1 {Number} $Date() 객체가 저장하고 있는 시각의 연도를 반환한다.
 *
 * @param2 {Numeric} nYear $Date() 객체에 설정할 연도(year).
 * @return2 {$Date} 연도를 새로 설정한 $Date() 객체.
 *
 * @throws {MobileCommentJindo.$Except.INVALID_DATE} 파라메터나 숫자가 아닌 경우 예외상황 발생.
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getFullYear">Date.getFullYear()</a> - MDN
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/setFullYear">Date.setFullYear()</a> - MDN
 * @example
var oDate = new $Date(Date.now());
oDate.year(); // 2011
oDate.year(1984);
oDate.year(); // 1984

 */
MobileCommentJindo.$Date.prototype.year = function(nYear) {
	//-@@$Date.year-@@//
	var oArgs = MobileCommentJindo.$Date._paramCheck(arguments,"year");
	nYear = oArgs.nParm;

	switch(oArgs+""){
		case 's':
			this._date.setFullYear(nYear);
			return this;

		case 'g':
			return this._date.getFullYear();

	}
};
//-!MobileCommentJindo.$Date.prototype.year end!-//

//-!MobileCommentJindo.$Date.prototype.month start!-//
/**

 * @description month() 메서드는 $Date() 객체가 저장하고 있는 시각의 달(month)을 가져오거나 지정한 값으로 설정한다. 파라미터를 입력하면 $Date() 객체에 지정한 달을 설정하고 파라미터를 생략하면 $Date() 객체가 저장하고 있는 달을 반환한다. 이때 사용되는 달 값의 범위는 0(1월)에서 11(12월)사이의 정수 값이다.
 *
 * @param1 {Void}
 * @return1 {Number} $Date() 객체가 저장하고 있는 시각의 달을 반환한다.
 *
 * @param2 {Numeric} nMon  $Date() 객체에 설정할 달(month).
 * @return2 {$Date} 새로 설정한 $Date() 객체를 반환.
 *
 * @throws {MobileCommentJindo.$Except.INVALID_DATE} 파라메터나 숫자가 아닌 경우 예외상황 발생.
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getMonth">Date.getMonth()</a> - MDN
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/setMonth">Date.setMonth()</a> - MDN
 * @example
var oDate = new $Date(Date.now());
oDate.month(); // 4, 5월
oDate.month(1);
oDate.month(); // 3, 4월

 */
MobileCommentJindo.$Date.prototype.month = function(nMon) {
	//-@@$Date.month-@@//
	var oArgs = MobileCommentJindo.$Date._paramCheck(arguments,"month");
	nMon = oArgs.nParm;

	switch(oArgs+""){
		case 's':
			this._date.setMonth(nMon);
			return this;

		case 'g':
			return this._date.getMonth();

	}

};
//-!MobileCommentJindo.$Date.prototype.month end!-//

//-!MobileCommentJindo.$Date.prototype.date start!-//
/**

 * @description date() 메서드는 $Date() 객체가 저장하고 있는 시각의 날짜(day of the month)를 가져오거나 지정한 값으로 설정한다. 파라미터를 입력하면 $Date() 객체에 지정한 날짜를 설정하고 파라미터를 생략하면 $Date() 객체가 저장하고 있는 날짜를 반환한다. 이때 사용되는 날짜의 범위는 1에서 31 사이의 정수 값이다.
 *
 * @param1 {Void}
 * @return1 {Number} $Date() 객체가 저장하고 있는 시각의 날짜를 반환한다.
 *
 * @param2 {Numeric} nMon  $Date() 객체에 설정할 날짜(day of the month).
 * @return2 {$Date} 새로 설정한 $Date() 객체를 반환.
 *
 * @throws {MobileCommentJindo.$Except.INVALID_DATE} 파라메터나 숫자가 아닌 경우 예외상황 발생.
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getDate">Date.getDate()</a> - MDN
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/setDate">Date.setDate()</a> - MDN
 * @example
var oDate = new $Date(Date.now());
oDate.date(); // 9, 9일
oDate.date(15);
oDate.date(); // 14, 14일

 */
MobileCommentJindo.$Date.prototype.date = function(nDate) {
	//-@@$Date.date-@@//
	var oArgs = MobileCommentJindo.$Date._paramCheck(arguments,"date");
	nDate = oArgs.nParm;

	switch(oArgs+""){
		case 's':
			this._date.setDate(nDate);
			return this;

		case 'g':
			return this._date.getDate();

	}
};
//-!MobileCommentJindo.$Date.prototype.date end!-//

//-!MobileCommentJindo.$Date.prototype.day start!-//
/**

 * @description day() 메서드는 $Date() 객체가 지정하고 있는 시각의 요일(day of the week)를 가져온다. 이때 반환되는 요일의 범위는 0(일요일)에서 6(토요일) 사이의 정수 값이다.
 * @return {Number} $Date() 객체가 저장하고 있는 시각의 요일(0~6)을 반환한다.
 * @throws {MobileCommentJindo.$Except.INVALID_DATE} 파라메터나 숫자가 아닌 경우 예외상황 발생.
 * @see $Date#Date
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getDay">Date.getDay()</a> - MDN
 * @example
var oDate = new $Date(Date.now());
oDate.date(); // 9, 9일
oDate.day(); // 1, 월요일
oDate.date(10);
oDate.day(); // 2, 화요일

 */
MobileCommentJindo.$Date.prototype.day = function() {
	//-@@$Date.day-@@//
	return this._date.getDay();
};
//-!MobileCommentJindo.$Date.prototype.day end!-//

//-!MobileCommentJindo.$Date.prototype.hours start!-//
/**

 * @description hours() 메서드는 $Date() 객체가 저장하고 있는 시각의 시간(hour)을 가져오거나 지정한 값으로 설정한다. 파라미터를 입력하면 $Date() 객체에 지정한 날짜를 설정하고 파라미터를 생략하면 $Date() 객체가 저장하고 있는 시간을 반환한다. 이때 사용되는 시간의 범위는 0에서 23 사이의 정수 값이다.
 *
 * @param1 {Void}
 * @return1 {Number} $Date() 객체가 저장하고 있는 시각의 시간를 반환한다.
 *
 * @param2 {Numeric} nMon  $Date() 객체에 설정할 시간(hour).
 * @return2 {$Date} 새로 설정한 $Date() 객체를 반환.
 *
 * @throws {MobileCommentJindo.$Except.INVALID_DATE} 파라메터나 숫자가 아닌 경우 예외상황 발생.
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getHours">Date.getHours()</a> - MDN
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/setHours">Date.setHours()</a> - MDN
 * @example
var oDate = new $Date(Date.now());
oDate.hours(); // 11, 11시
oDate.hours(19);
oDate.hours(); // 19, 19시

 */
MobileCommentJindo.$Date.prototype.hours = function(nHour) {
	//-@@$Date.hours-@@//
	var oArgs = MobileCommentJindo.$Date._paramCheck(arguments,"hours");
	nHour = oArgs.nParm;

	switch(oArgs+""){
		case 's':
			this._date.setHours(nHour);
			return this;

		case 'g':
			return this._date.getHours();

	}

};
//-!MobileCommentJindo.$Date.prototype.hours end!-//

//-!MobileCommentJindo.$Date.prototype.minutes start!-//
/**

 * @description minutes() 메서드는 $Date() 객체가 저장하고 있는 시각의 분(minute)을 가져오거나 지정한 값으로 설정한다. 파라미터를 입력하면 $Date() 객체에 지정한 분을 설정하고 파라미터를 생략하면 $Date() 객체가 저장하고 있는 시간을 반환한다. 이때 사용되는 분의 범위는 0에서 59 사이의 정수 값이다.
 *
 * @param1 {Void}
 * @return1 {Number} $Date() 객체가 저장하고 있는 시각의 분을 반환한다.
 *
 * @param2 {Numeric} nMon  $Date() 객체에 설정할 분(minute).
 * @return2 {$Date} 새로 설정한 $Date() 객체를 반환.
 *
 * @throws {MobileCommentJindo.$Except.INVALID_DATE} 파라메터나 숫자가 아닌 경우 예외상황 발생.
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getMinutes">Date.getMinutes()</a> - MDN
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/setMinutes">Date.setMinutes()</a> - MDN
 * @example
var oDate = new $Date(Date.now());
oDate.minutes(); // 53, 53분
oDate.minutes(0);
oDate.minutes(); // 0, 0분

 */
MobileCommentJindo.$Date.prototype.minutes = function(nMin) {
	//-@@$Date.minutes-@@//
	var oArgs = MobileCommentJindo.$Date._paramCheck(arguments,"minutes");
	nMin = oArgs.nParm;

	switch(oArgs+""){
		case 's':
			this._date.setMinutes(nMin);
			return this;

		case 'g':
			return this._date.getMinutes();

	}
};
//-!MobileCommentJindo.$Date.prototype.minutes end!-//

//-!MobileCommentJindo.$Date.prototype.seconds start!-//
/**

 * @description seconds() 메서드는 $Date() 객체가 저장하고 있는 시각의 초(second)를 가져오거나 지정한 값으로 설정한다. 파라미터를 입력하면 $Date() 객체에 지정한 초를 설정하고 파라미터를 생략하면 $Date() 객체가 저장하고 있는 시간을 반환한다. 이때 사용되는 초의 범위는 0에서 59 사이의 정수 값이다.
 *
 * @param1 {Void}
 * @return1 {Number} $Date() 객체가 저장하고 있는 시각의 초를 반환한다.
 *
 * @param2 {Numeric} nMon  $Date() 객체에 설정할 초(second).
 * @return2 {$Date} 새로 설정한 $Date() 객체를 반환.
 *
 * @throws {MobileCommentJindo.$Except.INVALID_DATE} 파라메터나 숫자가 아닌 경우 예외상황 발생.
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getSeconds">Date.getSeconds()</a> - MDN
 * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/setSeconds">Date.setSeconds()</a> - MDN
 * @example
var oDate = new $Date(Date.now());
oDate.seconds(); // 23, 23초
oDate.seconds(0);
oDate.seconds(); // 0, 0초

 */
MobileCommentJindo.$Date.prototype.seconds = function(nSec) {
	//-@@$Date.seconds-@@//
	var oArgs = MobileCommentJindo.$Date._paramCheck(arguments,"seconds");
	nSec = oArgs.nParm;

	switch(oArgs+""){
		case 's':
			this._date.setSeconds(nSec);
			return this;

		case 'g':
			return this._date.getSeconds();

	}
};
//-!MobileCommentJindo.$Date.prototype.seconds end!-//

//-!MobileCommentJindo.$Date.prototype.isLeapYear start!-//
/**

 * @description isLeapYear() 메서드는 $Date() 객체가 저장하고 있는 시각의 연도가 윤년인지 검사한다.
 * @return {Boolean} $Date()가 저장하고 있는 시각의 연도가 윤년이면 true를 반환하고 평년이면 false를 반환한다.
 * @see <a href="http://ko.wikipedia.org/wiki/%EC%9C%A4%EB%85%84">윤년</a> - Wikipedia
 * @example
 var oDate = new $Date(Date.now());

oDate.year(); // 2011
oDate.isLeapYear(); // false

oDate.year(1984);
oDate.isLeapYear(); // true

oDate.year(1900);
oDate.isLeapYear(); // false

oDate.year(2000);
oDate.isLeapYear(); // true

 */
MobileCommentJindo.$Date.prototype.isLeapYear = function() {
	//-@@$Date.isLeapYear-@@//
	var y = this._date.getFullYear();

	return !(y%4)&&!!(y%100)||!(y%400);
};
//-!MobileCommentJindo.$Date.prototype.isLeapYear end!-//

//-!MobileCommentJindo.$Date.prototype.compare start!-//
/**

 * @description compare() 메서드는 인자로 받은 날짜와 차이를 숫자로 반환하는 함수이다.
 * @since 2.0.0
 *
 * @param1 {Date+} oDate  비교할 날짜.
 * @return1 {Number} 비교 단위를 기준으로 차이를 숫자로 반환한다.
 *
 * @param2 {Date+} oDate  비교할 날짜.
 * @param2 {String+} sOption  비교할 단위를 지정.(기본 값은 천 분의 1초까지 비교하며, y, m, d, h, i, s등을 넣을 수 있다. 각 옵션은 y는 년, m은 달, d는 날, h는 시, i는 분, s는 초로 한다)
 * @return2 {Number} 비교 단위를 기준으로 차이를 숫자로 반환한다.
 *
 * @example
var oDate = new $Date(new Date());
oDate.compare(oDate);-> 0//같은 경우
var oCurrentDate = new Date();
oDate.compare(oCurrnetDate); -> 3 // 3ms후
$Date(oCurrnetDate).compare(oDate); -> -3 // 3ms전
oDate.compare(oCurrnetDate,"h"); -> 0 //시간은 같기 때문에 0

 */
MobileCommentJindo.$Date.prototype.compare = function(oDate, sType) {
	//-@@$Date.compare-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4dat' : [ 'oDate:Date+'],
		'4str' : [ 'oDate:Date+','sType:String+']
	},"$Date#compare");
	oDate = oArgs.oDate;
	sType = oArgs.sType;

	if(!sType){
		return oDate - this._date;
	}else if(sType === "s"){
		return Math.floor(oDate / 1000) - Math.floor(this._date / 1000);
	}else if(sType === "i"){
		return Math.floor(Math.floor(oDate / 1000)/60) - Math.floor(Math.floor(this._date / 1000)/60);
	}else if(sType === "h"){
		return Math.floor(Math.floor(Math.floor(oDate / 1000)/60)/60) - Math.floor(Math.floor(Math.floor(this._date / 1000)/60)/60);
	}else if(sType === "d"){
		return Math.floor(Math.floor(Math.floor(Math.floor(oDate / 1000)/60)/60)/24) - Math.floor(Math.floor(Math.floor(Math.floor(this._date / 1000)/60)/60)/24);
	}else if(sType === "m"){
		return oDate.getMonth() - this._date.getMonth();
	}else if(sType === "y"){
		return oDate.getFullYear() - this._date.getFullYear();
	}

};
//-!MobileCommentJindo.$Date.prototype.compare end!-//


/**

 * @fileOverView $Window() 객체의 생성자 및 메서드를 정의한 파일
 * @name window.js
 * @author AjaxUI lab

 */

//-!MobileCommentJindo.$Window start!-//
/**

 * @class $Window() 객체는 브라우저가 제공하는 window 객체를 래핑하고, 이를 다루기 위한 여러가지 메서드를 제공한다.
 * @Constructor
 * @description $Window() 객체를 생성하고 생성한다.
 * @param {Hash+} oWindow $Window() 객체로 래핑할 window 객체.

 */
MobileCommentJindo.$Window = function(el) {
	//-@@$Window-@@//
	var cl = arguments.callee;
	if (el instanceof cl) return el;

	if (!(this instanceof cl)){
		try {
			MobileCommentJindo.$Jindo._warn(arguments.length, 1,"$Window");
			return new cl(el||window);
		} catch(e) {
			if (e instanceof TypeError) { return null; }
			throw e;
		}
	}

	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4win' : ['el:Window+']
	},"$Window");

	this._win = el;
};
//-!MobileCommentJindo.$Window end!-//

//-!MobileCommentJindo.$Window.prototype.$value start!-//
/**

 * @description $value() 메서드는 원본 window 객체를 반환한다.
 * @return {$Window} window 객체.
 * @example
     $Window().$value(); // 원래의 window 객체를 반환한다.

 */
MobileCommentJindo.$Window.prototype.$value = function() {
	//-@@$Window.$value-@@//
	return this._win;
};
//-!MobileCommentJindo.$Window.prototype.$value end!-//

//-!MobileCommentJindo.$Window.prototype.resizeTo start!-//
/**

 * @description resizeTo() 메서드는 창의 크기를 지정한 크기로 변경한다. 지정한 크기는 프레임을 포함한 창 전체의 크기를 의미한다. 따라서 실제로 표현하는 컨텐트 사이즈는 브라우저 종류와 설정에 따라 달라질 수 있다. 브라우저에 따라 보안 문제 때문에, 창 크기가 화면의 가시 영역보다 커지지 못하도록 막는 경우도 있다. 이 경우에는 지정한 크기보다 창이 작아질 수 있다. 단위는 픽셀(px) 단위이다.
 * @param {Numeric} nWidth 창의 너비.
 * @param {Numeric} nHeight 창의 높이.
 * @return {$Window} $Window() 객체.
 * @see $Window#resizeBy
 * @example
 // 현재 창의 너비를 400, 높이를 300으로 변경한다.
 $Window.resizeTo(400, 300);

 */
MobileCommentJindo.$Window.prototype.resizeTo = function(nWidth, nHeight) {
	//-@@$Window.resizeTo-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4num' : ['nWidth:Numeric','nHeight:Numeric']
	},"$Window#resizeTo");
	this._win.resizeTo(nWidth, nHeight);
	return this;
};
//-!MobileCommentJindo.$Window.prototype.resizeTo end!-//

//-!MobileCommentJindo.$Window.prototype.resizeBy start!-//
/**

 * @description resizeBy() 메서드는 창의 크기를 지정한 크기만큼 늘리거나 줄인다. 창의 크기를 늘릴 때는 양의 정수를 줄일 때는 음의 정수를 입력한다. 단위는 픽셀(px) 단위이다.
 * @param {Numeric} nWidth 늘이거나 줄일 창의 너비.
 * @param {Numeric} nHeight 늘어날 줄일 창의 높이
 * @return {$Window} $Window() 객체.
 * @see $Window#resizeTo
 * @example
 // 현재 창의 너비를 100, 높이를 50 만큼 늘린다.
 $Window().resizeBy(100, 50);

 */
MobileCommentJindo.$Window.prototype.resizeBy = function(nWidth, nHeight) {
	//-@@$Window.resizeBy-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4num' : ['nWidth:Numeric','nHeight:Numeric']
	},"$Window#resizeBy");
	this._win.resizeBy(nWidth, nHeight);
	return this;
};
//-!MobileCommentJindo.$Window.prototype.resizeBy end!-//

//-!MobileCommentJindo.$Window.prototype.moveTo start!-//
/**

 * @description moveTo() 메서드는 창을 지정한 위치로 이동시킨다. 좌표는 브라우저 프레임을 포함한 창의 왼쪽 위의 모서리를 기준으로 한다. 단위는 픽셀(px) 단위이다.
 * @param {Numeric} nLeft 이동할 X 좌표.
 * @param {Numeric} nTop 이동할 Y좌표.
 * @see $Window#moveBy
 * @return {$Window} $Window() 객체.
 * @example
 *  // 현재 창을 (15, 10) 으로 이동시킨다.
 *  $Window().moveTo(15, 10);

 */
MobileCommentJindo.$Window.prototype.moveTo = function(nLeft, nTop) {
	//-@@$Window.moveTo-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4num' : ['nLeft:Numeric','nTop:Numeric']
	},"$Window#moveTo");
	this._win.moveTo(nLeft, nTop);
	return this;
};
//-!MobileCommentJindo.$Window.prototype.moveTo end!-//

//-!MobileCommentJindo.$Window.prototype.moveBy start!-//
/**

 * @description moveBy() 메서드는 창을 지정한 위치만큼 이동시킨다. 단위는 픽셀(px) 단위이다.
 * @param {Numeric} nLeft 창을 좌우로 이동시킬 크기. 양의 정수를 입력하면 오른쪽으로 이동시키고 음의 정수를 입력하면 왼쪽으로 이동한다.
 * @param {Numeric} nTop 창을 위아래로 이동시킬 크기. 양의 정수를 입력하면 아래로 이동시키고 음의 정수를 입력하면 위로 이동시킨다.
 * @see $Window#moveTo
 * @return {$Window} $Window() 객체.
 * @example
 *  // 현재 창을 좌측으로 15px만큼, 아래로 10px만큼 이동시킨다.
 *  $Window().moveBy(15, 10);

 */
 MobileCommentJindo.$Window.prototype.moveBy = function(nLeft, nTop) {
 	//-@@$Window.moveBy-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4num' : ['nLeft:Numeric','nTop:Numeric']
	},"$Window#moveBy");
	this._win.moveBy(nLeft, nTop);
	return this;
};
//-!MobileCommentJindo.$Window.prototype.moveBy end!-//

//-!MobileCommentJindo.$Window.prototype.sizeToContent start!-//
/**

 * @description sizeToContent() 메서드는 내부 문서의 콘텐츠 크기에 맞추어 창의 크기를 변경한다. 이때 몇 가지 제약 사항을 가진다.<br>
<ul>
	<li>문서가 완전히 로딩된 다음에 메서드를 실행해야 한다.</li>
	<li>창이 내부 문서보다 큰 경우에는 내부 문서의 크기를 구할 수 없으므로, 반드시 창 크기를 내부 문서보다 작게 만든다.</li>
	<li>반드시 body 요소의 사이즈가 있어야 한다.</li>
	<li>HTML의 DOCTYPE이 Quirks일때 MAC 운영체제 환경에는 Opera 10 버전, Windows 운영체제 환경에서는 인터넷 익스플로러 6버전 이상, Opera 10 버전, Safari 4버전에서 정상 동작하지 않는다.</li>
	<li>가능하면 부모 창에서 실행시켜야 한다. 자식 창이 모니터 화면을 벗어나 가려진 경우, 인터넷 익스플로러에서는 가려진 영역을 콘텐츠가 없는 것으로 판단하여 가려진 영역만큼 줄인다.</li>
</ul>
위와 같은 제약 사항에 걸리는 경우 파라미터로 창의 사이즈를 직접 지정할 수 있다.
 * @param {Numeric} nWidth 창의 너비.
 * @param {Numeric} nHeight 창의 높이.
 * @return {$Window} $Window() 객체.
 * @see $Document#renderingMode
 * @example
 // 새 창을 띄우고 자동으로 창 크기를 컨텐트에 맞게 변경하는 함수
 function winopen(url) {
	try {
		win = window.open(url, "", "toolbar=0,location=0,status=0,menubar=0,scrollbars=0,resizable=0,width=250,height=300");
		win.moveTo(200, 100);
		win.focus();
	} catch(e){}

	setTimeout(function() {
		$Window(win).sizeToContent();
	}, 1000);
}

winopen('/samples/popup.html');

 */
MobileCommentJindo.$Window.prototype.sizeToContent = function(nWidth, nHeight) {
	//-@@$Window.sizeToContent-@@//
	var oArgs = MobileCommentJindo.$Jindo.checkVarType(arguments, {
		'4num' : ['nWidth:Numeric','nHeight:Numeric']
	},"$Window#sizeToContent");
	if (this._win.sizeToContent) {
		this._win.sizeToContent();
	} else {
		if(arguments.length != 2){
			// use trick by Peter-Paul Koch
			// http://www.quirksmode.org/
			var innerX,innerY;
			var self = this._win;
			var doc = this._win.document;
			if (self.innerHeight) {
				// all except Explorer
				innerX = self.innerWidth;
				innerY = self.innerHeight;
			} else if (doc.documentElement && doc.documentElement.clientHeight) {
				// Explorer 6 Strict Mode
				innerX = doc.documentElement.clientWidth;
				innerY = doc.documentElement.clientHeight;
			} else if (doc.body) {
				// other Explorers
				innerX = doc.body.clientWidth;
				innerY = doc.body.clientHeight;
			}

			var pageX,pageY;
			var test1 = doc.body.scrollHeight;
			var test2 = doc.body.offsetHeight;

			if (test1 > test2) {
				// all but Explorer Mac
				pageX = doc.body.scrollWidth;
				pageY = doc.body.scrollHeight;
			} else {
				// Explorer Mac;
				//would also work in Explorer 6 Strict, Mozilla and Safari
				pageX = doc.body.offsetWidth;
				pageY = doc.body.offsetHeight;
			}
			nWidth  = pageX - innerX;
			nHeight = pageY - innerY;
		}
		this._win.resizeBy(nWidth, nHeight);
	}

	return this;
};
//-!MobileCommentJindo.$Window.prototype.sizeToContent end!-//



/**

* @fileOverview	다른 프레임웍 없이 jindo만 사용할 경우 편의성을 위해 jindo 객체를 window에 붙임

 */
// copy jindo objects to window
if (typeof window != 'undefined') {
	for (prop in MobileCommentJindo) {
		if (MobileCommentJindo.hasOwnProperty(prop)) {
			window[prop] = MobileCommentJindo[prop];
		}
	}
}
/**
 * Jindo Mobile Component
 * @version 1.1.0
 * NHN_Library:Jindo_Mobile_Component-1.1.0;JavaScript Mobile Components for Jindo;
 *
 * MobileCommentJindo.m.CheckRadioCore
 * effect/MobileCommentJindo.m.Effect
 * MobileCommentJindo.m.CorePagination
 * validator/MobileCommentJindo.m.Validator
 * MobileCommentJindo.m.Touch
 * effect/MobileCommentJindo.m.SlideEffect
 * effect/MobileCommentJindo.m.PopEffect
 * effect/MobileCommentJindo.m.FlipEffect
 * MobileCommentJindo.m.LayerEffect
 * MobileCommentJindo.m.Transition
 * MobileCommentJindo.m.DragArea
 * MobileCommentJindo.m.CoreScroll
 * MobileCommentJindo.m.LayerPosition
 * MobileCommentJindo.m.ScrollEnd
 * effect/MobileCommentJindo.m.FadeEffect
 * validator/MobileCommentJindo.m.NumberValidator
 * MobileCommentJindo.m.Accordion
 * MobileCommentJindo.m.AjaxHistory
 * MobileCommentJindo.m.CircularFlicking
 * MobileCommentJindo.m.CheckBox
 * MobileCommentJindo.m.Datepicker
 * MobileCommentJindo.m.Dialog
 * MobileCommentJindo.m.DropArea
 * MobileCommentJindo.m.Flicking
 * MobileCommentJindo.m.FloatingLayer
 * MobileCommentJindo.m.LayerManager
 * MobileCommentJindo.m.Loading
 * MobileCommentJindo.m.MoreContentButton
 * MobileCommentJindo.m.PageNavigation
 * MobileCommentJindo.m.PreventClickEvent
 * MobileCommentJindo.m.RadioButton
 * MobileCommentJindo.m.Scroll
 * MobileCommentJindo.m.Slider
 * MobileCommentJindo.m.SlideTab
 * MobileCommentJindo.m.Tab
 * MobileCommentJindo.m.TextArea
 * MobileCommentJindo.m.ToggleSlider
 * effect/MobileCommentJindo.m.ExpandEffect
 * MobileCommentJindo.m.TextInput
 * MobileCommentJindo.m.Validation
 * validator/MobileCommentJindo.m.CurrencyValidator
 * validator/MobileCommentJindo.m.DateValidator
 * validator/MobileCommentJindo.m.EmailValidator
 * validator/MobileCommentJindo.m.RequireValidator
 * validator/MobileCommentJindo.m.TelValidator
 * validator/MobileCommentJindo.m.UrlValidator
 */

/**
 * Jindo Component
 * @version 1.0.1
 * NHN_Library:Jindo_Component-1.0.1;JavaScript Components for Jindo;
 *
 * MobileCommentJindo.Component
 */

MobileCommentJindo.Component = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.Component.prototype */

	_htEventHandler : null,
	_htOption : null,

	/**
	 * MobileCommentJindo.Component를 초기화한다.
	 * @class 다른 컴포넌트가 상속해 사용하는 Jindo Component의 Core
	 * @constructs
	 */
	$init : function() {
		var aInstance = this.constructor.getInstance();
		aInstance.push(this);
		this._htEventHandler = {};
		this._htOption = {};
		this._htOption._htSetter = {};
	},

	/**
	 * 옵션값을 설정하거나 가져온다.
	 * htCustomEventHandler 옵션을 선언해서 attach() 메소드를 사용하지 않고 커스텀 이벤트핸들러를 등록할 수 있다.
	 * @param {String} sName 옵션의 이름
	 * @param {String} sValue 옵션의 값
	 * @return {this} 컴포넌트 객체 자신
	 * @example
var MyComponent = MobileCommentJindo.$Class({
	method : function() {
		alert(this.option("foo"));
	}
}).extend(MobileCommentJindo.Component);

var oInst = new MyComponent();
oInst.option("foo", 123); // 또는 oInst.option({ foo : 123 });
oInst.method(); // 결과 123
	 * @example
//커스텀이벤트핸들러 등록예제
oInst.option("htCustomEventHandler", {
	test : function(oCustomEvent) {

	}
});

//이미 "htCustomEventHandler" 옵션이 설정되어있는 경우에는 무시된다.
oInst.option("htCustomEventHandler", {
	change : function(oCustomEvent) {

	}
});
	 */
	option : function(sName, vValue) {
		switch (typeof sName) {
			case "undefined" :
				return this._htOption;
			case "string" :
				if (typeof vValue != "undefined") {
					if (sName == "htCustomEventHandler") {
						if (typeof this._htOption[sName] == "undefined") {
							this.attach(vValue);
						} else {
							return this;
						}
					}

					this._htOption[sName] = vValue;
					if (typeof this._htOption._htSetter[sName] == "function") {
						this._htOption._htSetter[sName](vValue);
					}
				} else {
					return this._htOption[sName];
				}
				break;
			case "object" :
				for(var sKey in sName) {
					if (sKey == "htCustomEventHandler") {
						if (typeof this._htOption[sKey] == "undefined") {
							this.attach(sName[sKey]);
						} else {
							continue;
						}
					}

					this._htOption[sKey] = sName[sKey];
					if (typeof this._htOption._htSetter[sKey] == "function") {
						this._htOption._htSetter[sKey](sName[sKey]);
					}
				}
				break;
		}
		return this;
	},

	/**
	 * 옵션의 setter 함수를 설정하거나 가져온다.
	 * 옵션의 setter 함수는 지정된 옵션이 변경되면 수행되는 함수이다.
	 * @param {String} sName setter의 이름
	 * @param {Function} fSetter setter 함수
	 * @return {this} 컴포넌트 객체 자신
	 * @example
oInst.option("sMsg", "test");
oInst.optionSetter("sMsg", function(){
	alert("sMsg 옵션값이 변경되었습니다.");
});
oInst.option("sMsg", "change"); -> alert발생
	 * @example
//HashTable 형태로 설정가능
oInst.optionSetter({
	"sMsg" : function(){
	},
	"nNum" : function(){
	}
});
	 */
	optionSetter : function(sName, fSetter) {
		switch (typeof sName) {
			case "undefined" :
				return this._htOption._htSetter;
			case "string" :
				if (typeof fSetter != "undefined") {
					this._htOption._htSetter[sName] = MobileCommentJindo.$Fn(fSetter, this).bind();
				} else {
					return this._htOption._htSetter[sName];
				}
				break;
			case "object" :
				for(var sKey in sName) {
					this._htOption._htSetter[sKey] = MobileCommentJindo.$Fn(sName[sKey], this).bind();
				}
				break;
		}
		return this;
	},

	/**
	 * 이벤트를 발생시킨다.
	 * @param {Object} sEvent 커스텀이벤트명
	 * @param {Object} oEvent 커스텀이벤트 핸들러에 전달되는 객체.
	 * @return {Boolean} 핸들러의 커스텀이벤트객체에서 stop메소드가 수행되면 false를 리턴
	 * @example
//커스텀 이벤트를 발생시키는 예제
var MyComponent = MobileCommentJindo.$Class({
	method : function() {
		this.fireEvent('happened', {
			sHello : 'world',
			sAbc : '123'
		});
	}
}).extend(MobileCommentJindo.Component);

var oInst = new MyComponent().attach({
	happened : function(oCustomEvent) {
		alert(eCustomEvent.sHello + '/' + oCustomEvent.nAbc); // 결과 : world/123
	}
};

<button onclick="oInst.method(event);">Click me</button>
	 */
	fireEvent : function(sEvent, oEvent) {
		oEvent = oEvent || {};
		var fInlineHandler = this['on' + sEvent],
			aHandlerList = this._htEventHandler[sEvent] || [],
			bHasInlineHandler = typeof fInlineHandler == "function",
			bHasHandlerList = aHandlerList.length > 0;

		if (!bHasInlineHandler && !bHasHandlerList) {
			return true;
		}
		aHandlerList = aHandlerList.concat(); //fireEvent수행시 핸들러 내부에서 detach되어도 최초수행시의 핸들러리스트는 모두 수행

		oEvent.sType = sEvent;
		if (typeof oEvent._aExtend == 'undefined') {
			oEvent._aExtend = [];
			oEvent.stop = function(){
				if (oEvent._aExtend.length > 0) {
					oEvent._aExtend[oEvent._aExtend.length - 1].bCanceled = true;
				}
			};
		}
		oEvent._aExtend.push({
			sType: sEvent,
			bCanceled: false
		});

		var aArg = [oEvent],
			i, nLen;

		for (i = 2, nLen = arguments.length; i < nLen; i++){
			aArg.push(arguments[i]);
		}

		if (bHasInlineHandler) {
			fInlineHandler.apply(this, aArg);
		}

		if (bHasHandlerList) {
			var fHandler;
			for (i = 0, fHandler; (fHandler = aHandlerList[i]); i++) {
				fHandler.apply(this, aArg);
			}
		}

		return !oEvent._aExtend.pop().bCanceled;
	},

	/**
	 * 커스텀 이벤트 핸들러를 등록한다.
	 * @param {Object} sEvent
	 * @param {Object} fHandlerToAttach
	 * @return {this} 컴포넌트 객체 자신
	 * @example
//이벤트 등록 방법 예제
//아래처럼 등록하면 appear 라는 사용자 이벤트 핸들러는 총 3개가 등록되어 해당 이벤트를 발생시키면 각각의 핸들러 함수가 모두 실행됨.
//attach 을 통해 등록할때는 이벤트명에 'on' 이 빠지는 것에 유의.
function fpHandler1(oEvent) { .... };
function fpHandler2(oEvent) { .... };

var oInst = new MyComponent();
oInst.onappear = fpHandler1; // 직접 등록
oInst.attach('appear', fpHandler1); // attach 함수를 통해 등록
oInst.attach({
	appear : fpHandler1,
	more : fpHandler2
});
	 */
	attach : function(sEvent, fHandlerToAttach) {
		if (arguments.length == 1) {

			MobileCommentJindo.$H(arguments[0]).forEach(MobileCommentJindo.$Fn(function(fHandler, sEvent) {
				this.attach(sEvent, fHandler);
			}, this).bind());

			return this;
		}

		var aHandler = this._htEventHandler[sEvent];

		if (typeof aHandler == 'undefined'){
			aHandler = this._htEventHandler[sEvent] = [];
		}

		aHandler.push(fHandlerToAttach);

		return this;
	},

	/**
	 * 커스텀 이벤트 핸들러를 해제한다.
	 * @param {Object} sEvent
	 * @param {Object} fHandlerToDetach
	 * @return {this} 컴포넌트 객체 자신
	 * @example
//이벤트 해제 예제
oInst.onappear = null; // 직접 해제
oInst.detach('appear', fpHandler1); // detach 함수를 통해 해제
oInst.detach({
	appear : fpHandler1,
	more : fpHandler2
});
	 */
	detach : function(sEvent, fHandlerToDetach) {
		if (arguments.length == 1) {
			MobileCommentJindo.$H(arguments[0]).forEach(MobileCommentJindo.$Fn(function(fHandler, sEvent) {
				this.detach(sEvent, fHandler);
			}, this).bind());

			return this;
		}

		var aHandler = this._htEventHandler[sEvent];
		if (aHandler) {
			for (var i = 0, fHandler; (fHandler = aHandler[i]); i++) {
				if (fHandler === fHandlerToDetach) {
					aHandler = aHandler.splice(i, 1);
					break;
				}
			}
		}

		return this;
	},

	/**
	 * 등록된 모든 커스텀 이벤트 핸들러를 해제한다.
	 * @param {String} sEvent 이벤트명. 생략시 모든 등록된 커스텀 이벤트 핸들러를 해제한다.
	 * @return {this} 컴포넌트 객체 자신
	 * @example
//"show" 커스텀이벤트 핸들러 모두 해제
oInst.detachAll("show");

//모든 커스텀이벤트 핸들러 해제
oInst.detachAll();
	 */
	detachAll : function(sEvent) {
		var aHandler = this._htEventHandler;

		if (arguments.length) {

			if (typeof aHandler[sEvent] == 'undefined') {
				return this;
			}

			delete aHandler[sEvent];

			return this;
		}

		for (var o in aHandler) {
			delete aHandler[o];
		}
		return this;
	}
});

/**
 * 다수의 컴포넌트를 일괄 생성하는 Static Method
 * @param {Array} aObject 기준엘리먼트의 배열
 * @param {HashTable} htOption 옵션객체의 배열
 * @return {Array} 생성된 컴포넌트 객체 배열
 * @example
var Instance = MobileCommentJindo.Component.factory(
	cssquery('li'),
	{
		foo : 123,
		bar : 456
	}
);
 */
MobileCommentJindo.Component.factory = function(aObject, htOption) {
	var aReturn = [],
		oInstance;

	if (typeof htOption == "undefined") {
		htOption = {};
	}

	for(var i = 0, el; (el = aObject[i]); i++) {
		oInstance = new this(el, htOption);
		aReturn[aReturn.length] = oInstance;
	}

	return aReturn;
};

/**
 * 컴포넌트의 생성된 인스턴스를 리턴한다.
 * @return {Array} 생성된 인스턴스의 배열
 */
MobileCommentJindo.Component.getInstance = function(){
	if (typeof this._aInstance == "undefined") {
		this._aInstance = [];
	}
	return this._aInstance;
};

/**
 * namespace 변경 중 이슈...
 * 아래 function때문에 혹시 적용하려는 서비스에서 jindo_mobile_component.js 를 include하는 경우, 순서를 해당 jindo_mobile_component이후에 로딩하도록 해야한다.
 * 그렇지 않을 경우엔 아래 if문 모두 주석처리가 필요.
 *
 * RangeError : Maximum call stack size exceeded. 오류가 발생함.
 *
 * @author nhn
 */
if(typeof MobileCommentJindo.m == "undefined" && typeof Node != "undefined" && typeof ___Old__addEventListener___ == "undefined") {
    /**
     * @description addEventListener된 객체를 알기위한 함수
     * A태그에 click 이벤트가 bind될 경우에만 적용
     * @date 2011. 11. 16
     * @author sculove
     */
    var ___Old__addEventListener___ = Node.prototype.addEventListener;
    Node.prototype.addEventListener = function(type, listener, useCapture){
            var callee = arguments.callee;
            if(callee && type === "click" && this.tagName === "A"){
                (this.___listeners___ || (this.___listeners___=[]) ).push({
                    listener : listener,
                    useCapture : useCapture
                });
            }
            return ___Old__addEventListener___.apply(this, arguments);
    };

    /**
     * @description removeEventListener된 객체를 알기위한 함수
     * A태그에 click 이벤트가 unbind될 경우에만 적용
     * @date 2011. 11. 16
     * @author sculove
     */
    var ___Old__removeEventListener___ = Node.prototype.removeEventListener;
    Node.prototype.removeEventListener = function(type, listener, useCapture){
            var callee = arguments.callee;
            if(callee && type === "click" && this.tagName === "A"){
                if(this.___listeners___) {
                    this.___listeners___.pop();
                }
            }
            return ___Old__removeEventListener___.apply(this, arguments);
    };
}

/**
 * <1.0.0 이후 수정사항>
 * http://devcode.nhncorp.com/news/detail.php?news_id=325
 *
 * <1.1.0 이후 수정사항>
 * MobileCommentJindo.m.js 중복 지정시 '무한루프' 문제 수정 (http://devcode.nhncorp.com/projects/jindo-mobile-ui/issue/3156)
 *
 */
MobileCommentJindo.m = (function() {
    // 내부 변수 m
    var __M__ = MobileCommentJindo.$Class({
        /** @lends MobileCommentJindo.m.prototype */
        /**
         * @description 초기화 함수
         * @constructs
         * @static
         * @extends MobileCommentJindo.Component
         */
        $init : function() {
            this._initVar();
            this._initDeviceInfo();
            this._attachEvent();
        },

        /**
         * @description 초기화
         */
        _initVar : function() {
            /** MOVE 타입 */
            this.MOVETYPE = {
                0 : 'hScroll',
                1 : 'vScroll',
                2 : 'dScroll',
                3 : 'tap',
                4 : 'longTap',
                5 : 'doubleTap'
            };
            this._isVertical = null;
            this._nPreWidth = -1;
            this._nRotateTimer = null;
            this._htHandler = {};
            this._htDeviceInfo = {};
        },

        /**
         * @description resize 이벤트 정제해서 리턴.
         * @return {String} 이벤트명
         * @date 2011. 11. 11
         * @author sculove
         */
        _getOrientationChangeEvt : function(){
            var bEvtName = 'onorientationchange' in window ? 'orientationchange' : 'resize';
            var htInfo = this.getDeviceInfo();
            /**
             * andorid 버그
             * 2.3에서는 orientationchange 이벤트가 존재하나, orientationchange를 적용할 경우, width와 height가 바꿔서 나옴 (setTimeout 500ms 필요)
             *  : 삼성안드로이드 2.3에서는 방향전환을 resize 이벤트를 이용하여 확인할 경우,
             *    만약, 사용자가 window에 resize이벤트를 bind할 경우 브라우저가 죽는 버그가 있음
             * 2.2에서는 orientationchange 이벤트가 2번 발생함. (처음에는 width,height가 바뀌고, 두번째는 정상적으로 나옴)
             * 그 이하는 resize로 처리
             * 갤럭시탭2인 경우 orientationchange 버그가 존재함
             *
             * in-app 버그
             * in-app인 경우 orientationChange발생시, width,height값이 바꿔서 나옴 (setTimeout 200ms 필요)
             */
            if( (htInfo.android && htInfo.version === "2.1") || htInfo.galaxyTab2) {
                bEvtName = 'resize';
            }
            return bEvtName;
        },

        /**
         * @description 디바이스 기기의 가로,세로 여부를 판단함.
         * @date 2011. 11. 11
         * @author sculove
         */
        _getVertical : function() {
            var bVertical = null,
                sEventType = this._getOrientationChangeEvt();
            if(sEventType === "resize") {
                var screenWidth = document.documentElement.clientWidth;
                if (screenWidth < this._nPreWidth) {
                    bVertical = true;
                } else if (screenWidth == this._nPreWidth) {
                    bVertical = this._isVertical;
                } else {
                    bVertical = false;
                }
                this._nPreWidth = screenWidth;
                // console.log("getVertical : resize로 판별 -> " + bVertical);
            } else {
                var windowOrientation = window.orientation;
                if (windowOrientation === 0 || windowOrientation == 180) {
                    bVertical = true;
                } else if (windowOrientation == 90 || windowOrientation == -90) {
                    bVertical = false;
                }
                // console.log("getVertical : orientationChange로 판별 -> " + bVertical);
            }
            return bVertical;
        },

        /**
         * @description MobileCommentJindo.m. 공통 이벤트 attach
         * @date 2011. 11. 11
         * @author sculove
         */
        _attachEvent : function() {
            this._rotateEvent = MobileCommentJindo.$Fn(this._onOrientationChange, this).attach(window, this._getOrientationChangeEvt()).attach(window, "load");
            this._pageShowEvent = MobileCommentJindo.$Fn(this._onPageshow, this).attach(window, "pageshow");
        },

        /**
         * @description 브라우저 정보와 버전 정보를 갖는 this._htDeviceInfo를 초기화한다
         * @date 2011. 11. 11
         * @modify 2012.03.05 bInapp 추가
         * @author oyang2, sculove
         */
        _initDeviceInfo : function() {
            var sName = navigator.userAgent;
            var ar = null;
            function f(s,h) {
                return ((h||"").indexOf(s) > -1);
            }
            this._htDeviceInfo.iphone = f('iPhone', sName);
            this._htDeviceInfo.ipad = f('iPad', sName);
            this._htDeviceInfo.android = f('Android', sName);
            this._htDeviceInfo.galaxyTab = f('SHW-M180S', sName) || f('SHW-M180K', sName) || f('SHW-M180L', sName);
            this._htDeviceInfo.galaxyTab2 = f('SHW-M380S', sName) || f('SHW-M380K', sName);
            this._htDeviceInfo.galaxyK = f('SHW-M130K',sName);
            this._htDeviceInfo.galaxyU = f('SHW-M130L',sName);
            this._htDeviceInfo.galaxyS = f('SHW-M110S',sName) ||  f('SHW-M110K',sName) ||  f('SHW-M110L',sName);
            this._htDeviceInfo.galaxyS2 = f('SHW-M250S',sName) || f('SHW-M250K',sName) || f('SHW-M250L',sName);
            this._htDeviceInfo.version = '';
            this._htDeviceInfo.bChrome = this._htDeviceInfo.android && f('CrMo',sName);
            this._htDeviceInfo.bInapp = false;

            if(this._htDeviceInfo.iphone || this._htDeviceInfo.ipad){
                ar = sName.match(/OS\s([\d|\_]+\s)/i);
                if(ar !== null&& ar.length > 1){
                    this._htDeviceInfo.version = ar[1];
                }
            } else if(this._htDeviceInfo.android){
                ar = sName.match(/Android\s(\d\.\d)/i);
                if(ar !== null&& ar.length > 1){
                    this._htDeviceInfo.version = ar[1];
                }
            }
            this._htDeviceInfo.version = this._htDeviceInfo.version.replace(/\_/g,'.');

            // device name 설정
            for(var x in this._htDeviceInfo){
                if (typeof this._htDeviceInfo[x] == "boolean" && this._htDeviceInfo[x] && this._htDeviceInfo.hasOwnProperty(x)) {
                    this._htDeviceInfo.name = x;
                }
            }
          //inapp여부 추가.true 일경우는 확실한 inapp이며,false - 웹브라우저 혹은 알수없는 경우
        	if(this._htDeviceInfo.iphone || this._htDeviceInfo.ipad){
        		 if(!f('Safari', sName)){
        			 this._htDeviceInfo.bInapp = true;
        		 }
        	}else if(this._htDeviceInfo.android){
        		sName =sName.toLowerCase();
        		if( f('inapp', sName) || f('app', sName.replace('applewebkit',''))){
        			this._htDeviceInfo.bInapp = true;
        		}
        	}
        },

        /**
         * @description 가로,세로 변경 여부 확인
         * @date 2011. 11. 11
         * @author sculove
         */
        _onOrientationChange : function(we) {
            var self = this;
            if(we.type === "load") {
            	this._nPreWidth = document.documentElement.clientWidth;
                /**
                 * 웹 ios에서는 사이즈가 아닌 orientationChange로 확인
                 * 왜? iphone인 경우, '개발자콘솔'이 설정된 경우 초기 처음 오동작
                 */
                if(!this._htDeviceInfo.bInapp && ( this._htDeviceInfo.iphone || this._htDeviceInfo.ipad )) {    // 웹ios인 경우
                    this._isVertical = this._getVertical();
                } else {
                    if(this._nPreWidth > document.documentElement.clientHeight) {
                        this._isVertical = false;
                    } else {
                        this._isVertical = true;
                    }
                }
                // console.log("Rotate init isVertical : " + this._isVertical);
				return;
            }
            if (this._getOrientationChangeEvt() === "resize") { // android 2.1 이하...
                // console.log("Rotate Event is resize");
                setTimeout(function(){
                    self._orientationChange(we);
                }, 0);
            } else {
                //console.log("Rotate Event is orientationChange");
                var nTime = 200;
                if(this.getDeviceInfo().android) {  // android 2.2이상
                    nTime = 500;
                }
                clearTimeout(this._nRotateTimer);
                    this._nRotateTimer = setTimeout(function() {
                        self._orientationChange(we);
                },nTime);
            }
        },

        /**
         * @description 현재 폰의 위치가 가로인지 세로인지 확인
         * @date 2011. 11. 11
         * @author sculove
         */
        _orientationChange : function(we) {
            var nPreVertical = this._isVertical;
            this._isVertical = this._getVertical();
            //console.log("회전 : " + nPreVertical + " -> " + this._isVertical);
            if (MobileCommentJindo.$Agent().navigator().mobile || MobileCommentJindo.$Agent().os().ipad) {
                if (nPreVertical !== this._isVertical) {
                    this.fireEvent("mobilerotate", {
                        isVertical: this._isVertical
                    });
                }
            } else {    // PC일 경우, 무조건 호출
                this.fireEvent("mobilerotate", {
                    isVertical: this._isVertical
                });
            }
        },

        /**
         * @description 모바일 기기 회전시, 적용할 함수를 bind 함
         * @date 2011. 11. 11
         * @example
         * var f = MobileCommentJindo.$Fn(this.setSize, this).bind();
         * // bind함
         * MobileCommentJindo.m.bindRotate(f);
         *
         * // unbind함
         * MobileCommentJindo.m.unbindRotate(f);
         * @param {Object} fHandlerToBind
         * @author sculove
         */
        bindRotate : function(fHandlerToBind) {
            var aHandler = this._htHandler["mobilerotate"];
            if (typeof aHandler == 'undefined'){
                aHandler = this._htHandler["mobilerotate"] = [];
            }
            aHandler.push(fHandlerToBind);
            this.attach("mobilerotate", fHandlerToBind);
        },

        /**
         * @description 모바일 기기 회전시, 적용할 함수를 unbind 함
         * @date 2011. 11. 11
         * @example
         * var f = MobileCommentJindo.$Fn(this.setSize, this).bind();
         * // bind함
         * MobileCommentJindo.m.bindRotate(f);
         *
         * // unbind함
         * MobileCommentJindo.m.unbindRotate(f);
         * @param {Object} fHandlerToUnbind
         * @author sculove
         */
        unbindRotate : function(fHandlerToUnbind) {
            var aHandler = this._htHandler["mobilerotate"];
            if (aHandler) {
                for (var i = 0, fHandler; (fHandler = aHandler[i]); i++) {
                    if (fHandler === fHandlerToUnbind) {
                        aHandler.splice(i, 1);
                        this.detach("mobilerotate", fHandlerToUnbind);
                        break;
                    }
                }
            }
        },

        /**
         * @description pageShow 이벤트
         * @date 2011. 11. 11
         * @author sculove
         */
        _onPageshow : function(we) {
            var self = this;
            setTimeout(function() {
                self.fireEvent("mobilePageshow", {
                });
            },300);
        },

        /**
         * @description pageshow호출, 함수 bind
         * @date 2011. 11. 11
         * @example
         * var f = MobileCommentJindo.$Fn(this.setSize, this).bind();
         * // bind함
         * MobileCommentJindo.m.bindPageshow(f);
         *
         * // unbind함
         * MobileCommentJindo.m.unbindPageshow(f);
         * @param {Object} fHandlerToBind
         * @author sculove
         */
        bindPageshow : function(fHandlerToBind) {
            var aHandler = this._htHandler["mobilePageshow"];
            if (typeof aHandler == 'undefined'){
                aHandler = this._htHandler["mobilePageshow"] = [];
            }
            aHandler.push(fHandlerToBind);
            this.attach("mobilePageshow", fHandlerToBind);
        },

        /**
         * @description pageshow호출, 함수 unbind
         * @date 2011. 11. 11
         * @example
         * var f = MobileCommentJindo.$Fn(this.setSize, this).bind();
         * // bind함
         * MobileCommentJindo.m.bindPageshow(f);
         *
         * // unbind함
         * MobileCommentJindo.m.unbindPageshow(f);
         * @param {Object} fHandlerToBind
         * @author sculove
         */
        unbindPageshow : function(fHandlerToUnbind) {
            var aHandler = this._htHandler["mobilePageshow"];
            if (aHandler) {
                for (var i = 0, fHandler; (fHandler = aHandler[i]); i++) {
                    if (fHandler === fHandlerToUnbind) {
                        aHandler.splice(i, 1);
                        this.detach("mobilePageshow", fHandlerToUnbind);
                        break;
                    }
                }
            }
        },

        /**
         * @description 브라우저 정보와 버전 정보를 제공한다.
         * @date 2011. 11. 11
         * @example
         *  MobileCommentJindo.m.getDeviceInfo().android     //안드로이드 여부
         *  MobileCommentJindo.m.getDeviceInfo().iphone      //아이폰 여부
         *  MobileCommentJindo.m.getDeviceInfo().ipad        //아이패드 여부
         *  MobileCommentJindo.m.getDeviceInfo().galaxyTab   //갤럭시탭 여부
         *  MobileCommentJindo.m.getDeviceInfo().galaxyTab2  //갤럭시탭2 여부
         *  MobileCommentJindo.m.getDeviceInfo().galaxyK     //갤럭시K 여부
         *  MobileCommentJindo.m.getDeviceInfo().galaxyU     //갤럭시U 여부
         *  MobileCommentJindo.m.getDeviceInfo().galaxyS     //갤럭시S 여부
         *  MobileCommentJindo.m.getDeviceInfo().galaxyS2    //갤럭시S2 여부
         *  MobileCommentJindo.m.getDeviceInfo().version     //안드로이드, 아이폰시 버젼정보 제공
         *  MobileCommentJindo.m.getDeviceInfo().bChrome     //크롬 브라우저 여부
         *  MobileCommentJindo.m.getDeviceInfo().bInapp      //인앱여부, true- 인앱, false - 웹브라우저 혹은 알수없는 경우
         *  MobileCommentJindo.m.name                        //현재 단말기기 정보제공
         *
         * @return {HashTable}
         * @author oyang2, sculove
         */
        getDeviceInfo : function(){
            return this._htDeviceInfo;
        },

        /**
         * @description 현재 모바일기기의 가로,세로 여부를 반환한다.
         * @date 2011. 11. 11
         * @example
         * MobileCommentJindo.m.isVertical; // 수직여부 반환
         * @author sculove
         */
        isVertical : function() {
            return this._isVertical;
        },

        /**
         * @description TextNode를 제외한 상위노드를 반환한다.
         * @date 2011. 11. 11
         * @example
         * var elParent=MobileCommentJindo.m.getNodeElement(el); // TextNode를 제외한 상위노드를 반환한다.
         * @return {HTMLElement} el
         * @author oyang2
         */
        getNodeElement : function(el){
            while(el.nodeType != 1){
                el = el.parentNode;
            }
            return el;
        },

        /**
         * @description 현재 스크롤 Element의 offet을 구한다.
         * @date 2011. 11. 11
         * @example
         * var oObject=MobileCommentJindo.m.getCssOffset(el); // CSSOffset을 반환한다.
         * @param {HTMLElement} element  ComputedStyle 값을 이용하여 offset을 얻는 함수
         * @return {HashTable} {top,left}
         * @author sculove
         */
        getCssOffset : function(element){
            var htOffset;
            /** Andorid 3.0대에서는 WebKitCSSMatrix가 있지만, 안됨. 버그 */
           if(MobileCommentJindo.m.getDeviceInfo().android && parseInt(MobileCommentJindo.m.getDeviceInfo().version,10) === 3) {
               htOffset = MobileCommentJindo.m._getCssOffsetFromStyle(element);
           } else {
               if('WebKitCSSMatrix' in window && 'm11' in new WebKitCSSMatrix()){
                  htOffset = MobileCommentJindo.m._getCssOffsetFromCSSMatrix(element);
               } else {
                  htOffset = MobileCommentJindo.m._getCssOffsetFromStyle(element);
               }
           }
           return htOffset;
        },

        /**
         * @description transform에서 translate,translate3d의 left와 top 값을 추출
         * @return {HashTable} top,left
         */
        _getCssOffsetFromStyle : function(element) {
            var nTop = nLeft = 0,
            s = element.style[MobileCommentJindo.m.getCssPrefix() + "Transform"];
            if(!!s && s.length >0){
                aTemp = s.match(/translate.{0,2}\((.*)\)/);
                if(!!aTemp && aTemp.length >1){
                    var a = aTemp[1].split(',');
                    if(!!a && a.length >1){
                        nTop = parseInt(a[1],10);
                        nLeft = parseInt(a[0],10);
                    }
                }
            }
            return {
                top : nTop,
                left : nLeft
            };
        },

        /**
         * @description WebKitCSSMatrix를 이용하여 left, top 값을 추출
         * @return {HashTable} top, left
         */
        _getCssOffsetFromCSSMatrix : function(element) {
            var curTransform  = new WebKitCSSMatrix(window.getComputedStyle(element).webkitTransform);
            return {
                top : curTransform.m42,
                left : curTransform.m41
             };
        },

        /**
         * @description TransitionEnd 이벤트 bind
         * @date 2011. 11. 11
         * @param {HTMLElement} element attach할 엘리먼트
         * @param {Function} fHandlerToBind attach할 함수
         * @example
         *  MobileCommentJindo.m.attachTransitionEnd(el, function() { alert("attach"); }); // el에 transitionEnd 이벤트를 attach한다.
         *  MobileCommentJindo.m.detachTransitionEnd(el, function() { alert("detach"); }); // el에 transitionEnd 이벤트를 detach한다.
         * @author sculove
         */
        attachTransitionEnd : function(element,fHandlerToBind) {
            var nVersion = + MobileCommentJindo.$Jindo().version.replace(/[a-z.]/gi,"");
            // console.log(nVersion);
            /* 진도 1.5.1에서 정상 동작. 그 이하버젼은 버그 */
            if(nVersion >= 151) {   // J
                element._jindo_fn_ = MobileCommentJindo.$Fn(fHandlerToBind,this).attach(element, "transitionend");
            } else {
                element.addEventListener('webkitTransitionEnd', fHandlerToBind, false);
            }
        },

        /**
         * @description TransitionEnd 이벤트 unbind
         * @date 2011. 11. 11
         *  @example
         *  MobileCommentJindo.m.attachTransitionEnd(el, function() { alert("attach"); }); // el에 transitionEnd 이벤트를 attach한다.
         *  MobileCommentJindo.m.detachTransitionEnd(el, function() { alert("detach"); }); // el에 transitionEnd 이벤트를 detach한다.
         * @param {HTMLElement} element dettach할 엘리먼트
         * @param {Function} fHandlerToUnbind dettach할 함수
         * @author sculove
         */
        detachTransitionEnd : function(element, fHandlerToUnbind) {
            var nVersion = + MobileCommentJindo.$Jindo().version.replace(/[a-z.]/gi,"");
            // console.log(nVersion);
            /* 진도 1.5.1에서 정상 동작. 그 이하버젼은 버그 */
            if(nVersion >= 151) {   // J
                if(element._jindo_fn_) {
                    element._jindo_fn_.detach(element, "transitionend");
                    delete element._jindo_fn_;
                }
            } else {
                element.removeEventListener('webkitTransitionEnd', fHandlerToUnbind, false);
            }
        },

        /**
         * @description 브라우저 CssPrefix를 얻는 함수
         * @date 2011. 11. 11
         * @example
         * MobileCommentJindo.m.getCssPrefix(); // 브라우저별 prefix를 반환한다.
         * @return {String} return cssPrefix를 반환. webkit, Moz, O,...
         * @author sculove
         */
        getCssPrefix : function() {
            var sCssPrefix = "";
            if(typeof document.body.style.MozTransition !== "undefined") {
                sCssPrefix = "Moz";
            } else if(typeof document.body.style.webkitTransition !== "undefined") {
                sCssPrefix = "webkit";
            } else if(typeof document.body.style.OTransition !== "undefined") {
                sCssPrefix = "O";
            }
            return sCssPrefix;
        },

        /**
	     * @description 자신을 포함하여 부모노드중에 셀렉터에 해당하는 가장 가까운 엘리먼트를 구함
	     * @date 2012. 02. 20
         * @example
         *  MobileCommentJindo.m.getClosest("cssName", elParent);   // elParent하위에 cssName 클래스명이 아닌 첫번째 Element를 반환한다.
	     * @param {String} sSelector CSS클래스명 또는 태그명
	     * @param {HTMLElement} elBaseElement 기준이 되는 엘리먼트
	     * @return {HTMLElement} 구해진 HTMLElement
	     * @author sculove
         */
	    getClosest : function(sSelector, elBaseElement) {
	        //console.log("[_getClosest]", sSelector, elBaseElement)
	        var elClosest;
	        var welBaseElement = MobileCommentJindo.$Element(elBaseElement);

	        var reg = /<\/?(?:h[1-5]|[a-z]+(?:\:[a-z]+)?)[^>]*>/ig;
	        if (reg.test(sSelector)) {
	            // 태그 일경우
	             if("<" + elBaseElement.tagName.toUpperCase() + ">" == sSelector.toUpperCase()) {
	                 elClosest = elBaseElement;
	             } else {
	                 elClosest = welBaseElement.parent(function(v){
	                     if("<" + v.$value().tagName.toUpperCase() + ">" == sSelector.toUpperCase()) {
	                        //console.log("v", v)
	                        return v;
	                    }
	                });
	                elClosest = elClosest.length ? elClosest[0].$value() : false;
	             }
	        } else {
	        	//클래스명일 경우
	        	 if(sSelector.indexOf('.') == 0){sSelector = sSelector.substring(1,sSelector.length)}
	             if(welBaseElement.hasClass(sSelector)) {
	                elClosest = elBaseElement;
	             } else {
	                elClosest = welBaseElement.parent(function(v){
	                    if(v.hasClass(sSelector)) {
	                        //console.log("v", v)
	                        return v;
	                    }
	                });
	                elClosest = elClosest.length ? elClosest[0].$value() : false;
	            }
	        }
	        //console.log("elClosest", elClosest)
	        return elClosest;
	    }
    }).extend(MobileCommentJindo.Component);

    return new __M__();
})();
/**
 * Jindo Component
 * @version 1.0.1
 * NHN_Library:Jindo_Component-1.0.1;JavaScript Components for Jindo;
 *
 * MobileCommentJindo.UIComponent
 */

MobileCommentJindo.UIComponent = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.UIComponent.prototype */

	/**
	 * MobileCommentJindo.UIComponent를 초기화한다.
	 * @constructs
	 * @class UI Component에 상속되어 사용되는 Jindo Component의 Core
	 * @extends MobileCommentJindo.Component
	 */
	$init : function() {
		this._bIsActivating = false; //컴포넌트의 활성화 여부
	},

	/**
	 * 컴포넌트의 활성여부를 가져온다.
	 * @return {Boolean}
	 */
	isActivating : function() {
		return this._bIsActivating;
	},

	/**
	 * 컴포넌트를 활성화한다.
	 * _onActivate 메소드를 수행하므로 반드시 상속받는 클래스에 _onActivate 메소드가 정의되어야한다.
	 * @return {this}
	 */
	activate : function() {
		if (this.isActivating()) {
			return this;
		}
		this._bIsActivating = true;

		if (arguments.length > 0) {
			this._onActivate.apply(this, arguments);
		} else {
			this._onActivate();
		}

		return this;
	},

	/**
	 * 컴포넌트를 비활성화한다.
	 * _onDeactivate 메소드를 수행하므로 반드시 상속받는 클래스에 _onDeactivate 메소드가 정의되어야한다.
	 * @return {this}
	 */
	deactivate : function() {
		if (!this.isActivating()) {
			return this;
		}
		this._bIsActivating = false;

		if (arguments.length > 0) {
			this._onDeactivate.apply(this, arguments);
		} else {
			this._onDeactivate();
		}

		return this;
	}
}).extend(MobileCommentJindo.Component);

/**
* @(#)MobileCommentJindo.m.CheckRadioCore.js 2011. 11. 1.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sshyun
* @since 2011. 11. 1.
* @description
*/

MobileCommentJindo.m.CheckRadioCore = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.CheckRadioCore.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {Varient} el Layout Wrapper
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
	 */
	$init : function(el, htUserOption) {
	},
	/**
	 * @description MobileCommentJindo.m.CheckRadioCore 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar : function(sFormType, sFormClass) {
		this._sFormType = sFormType;
		this._sFormFixClass = sFormClass;
		this._sUnitClass = this.option("sClassPrefix") + sFormClass +"-unit";
		this._sOnClass = this.option("sClassPrefix")+ sFormClass + "-on";
		this._sFormClass = this.option("sClassPrefix") + sFormClass;
		this._sDisableClass = this.option("sClassPrefix")+ sFormClass + "-disable";
		var oDeviceInfo = MobileCommentJindo.m.getDeviceInfo();
		this._bMobile = (oDeviceInfo.iphone || oDeviceInfo.ipad || oDeviceInfo.android);

		this._sClickEvent = (this._bMobile) ? "touchend" : "click";
		this._bMove = false;

	},

	/**
	 * @description MobileCommentJindo.m.CheckRadioCore 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement : function(el, sPrefix) {

		this._htWElement = {};
		this._aWElUnitList = [];
		this._aWElFormList = [];

		el = (typeof el == "string" ? MobileCommentJindo.$(el) : el);
		this._htWElement["base"] = MobileCommentJindo.$Element(el);
		this._htWElement["container"] = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle('.' + sPrefix + this._sFormFixClass +'-cont', el));

		var aUnitList = this._htWElement["container"].queryAll('.' + this._sUnitClass);
		var aFormList = this._htWElement["container"].queryAll('.' + this._sFormClass);
		// 각 체크박스 엘리먼트와 Wrapper 엘리먼트를 가져온다.

		for ( var i = 0; i < aUnitList.length; i++) {
			this._aWElUnitList[i] = MobileCommentJindo.$Element(aUnitList[i]);
			this._aWElFormList[i] = MobileCommentJindo.$Element(aFormList[i]);
		}
	},
	/**
	 * @description MobileCommentJindo.m.CheckRadioCore 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this._attachEvent();
	},
	/**
	 * @description MobileCommentJindo.m.CheckRadioCore 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
	},
	/**
	 * @description MobileCommentJindo.m.CheckRadioCore 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};
		this._htEvent["form_touchmove"] = {
				el  : this._htWElement["container"].$value(),
				ref : MobileCommentJindo.$Fn(this._onTouchMove, this).attach( this._htWElement["container"].$value(), "touchmove")
		};
		this._htEvent["form_"+this._sClickEvent] = {
				el  : this._htWElement["container"].$value(),
				ref : MobileCommentJindo.$Fn(this._onCheck, this).attach( this._htWElement["container"].$value(), this._sClickEvent)
		};

		if(this._bMobile){
			for ( var i = 0; i < this._aWElFormList.length; i++) {
				this._htEvent["form"+i+"_click"] = {
						el  : this._aWElFormList[i].$value(),
						ref : MobileCommentJindo.$Fn(this._onFormClick, this).attach( this._aWElFormList[i].$value(), "click")
				};
			}

		}
	},
	/**
	 * @description MobileCommentJindo.m.CheckRadioCore 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		for(var p in this._htEvent) {
			var ht = this._htEvent[p];
			ht.ref.detach(ht.el, p.substring(p.lastIndexOf("_")+1));
		}
		this._htEvent = null;
	},
	/**
	 * @description container 에서 TouchMove 이벤트 처리.
	 * @param {Object} we 이벤트 객체.
	 */
	_onTouchMove : function(we){
		this._bMove = true;
	},
	/**
	 * @description CheckBox/RadioButton 에서 Click 이벤트 처리.
	 * @param {Object} we 이벤트 객체.
	 */
	_onFormClick : function(we){
		var sClassName = this._sUnitClass;
		var welElement = MobileCommentJindo.$Element(we.element);
		welElement = welElement.parent(function(v){
			return v.hasClass(sClassName);
		})[0];

		var bCurrentChecked = we.element.checked;
		var sChecked = welElement.attr("data-cb-checked");
		var bChecked = (sChecked && sChecked == "on") ? true : false;

		if(bCurrentChecked != bChecked){
			we.element.checked = bChecked;
		}
	},

	/**
	 * @description  CheckBox/RadioButton container 에서 클릭이벤트 처리.
	 * @param {Object} we 이벤트 객체.
	 */
	_onCheck : function(we){
		if(we.element && !this._bMove) {
			var elEventElement = MobileCommentJindo.m.getNodeElement(we.element);
			var welElement = MobileCommentJindo.$Element(elEventElement);

			var sClassName = this._sUnitClass;
			var sTagName = elEventElement.tagName.toLowerCase();
			var sType = elEventElement.getAttribute("type");
			sType = (sType) ? sType : "";
			// Container 하위 에서 클릭 되었는지 체크
			if(this._htWElement["container"].isParentOf(welElement) &&
					!welElement.hasClass(sClassName)){
				welElement = welElement.parent(function(v){
					return v.hasClass(sClassName);
				})[0];
			} else if((welElement.$value() === this._htWElement["container"].$value())){
				return false;
			}

			if((welElement.hasClass(this._sDisableClass))){
				return false;
			}

			var bClickOverForm = false;
			if(sTagName == "input" && sType.toLowerCase() == this._sFormType) {
				bClickOverForm = true;
			}
			this._afterCheck(welElement, bClickOverForm);
		}
		this._bMove = false;
	},

	/**
	 *  @description CheckBox/RadioButton 클릭후 처리 함수
	 *  각 컴포넌트에서 Override 하여 사용.
	 */
	_afterCheck : function(welElement, bClickOverForm){
	},

	/**
	 * @description 체크박스 Element 의 배열의 index 배열을 반환.
	 * @param {Variant} checkbox Element.
	 * @return {Array} Index 배열값
	 */
	_getFormIdx : function(vElement){
		var aIdxList = [];
		var aElList = [];
		var sUnitClassName = this._sUnitClass;
		var sFormClassName = this._sFormClass;
		var waElUnitList = MobileCommentJindo.$A(this._aWElUnitList);
		var waElFormList = MobileCommentJindo.$A(this._aWElFormList);

		if(vElement instanceof Array){
			aElList = vElement;
		} else if(typeof vElement == "object"){
			aElList.push(vElement);
		} else if(!vElement || vElement === null){
			var nLength = this._aWElUnitList.length;
			for ( var i = 0; i < nLength; i++) {
				aIdxList.push(i);
			}
		}

		// Unit Element 와 Form Element 배열에서 특정 Element 의 Index 를 검색.
		var nIdx = -1;
		if(aElList.length > 0){
			waElUnitList.forEach(function(welElement, nElIdx){
				for ( var i = 0; i < aElList.length; i++) {
					if(aElList[i] === welElement.$value()){
						aIdxList.push(nElIdx);
					}
				}
			});

			if(aElList.length > aIdxList.length){
				waElFormList.forEach(function(welElement, nElIdx){
					for ( var i = 0; i < aElList.length; i++) {
						if(aElList[i] === welElement.$value()){
							aIdxList.push(nElIdx);
						}
					}
				});
			}
		}
		return aIdxList;
	},

	/**
	 * @description CheckBox/RadioButton 활성화 처리
	 * @param {Variant} vElement 체크를 설정할 CheckBox/RadioButton Element.
	 * @param {boolean} bUse 활성화 여부
	 */
	_useSettingForm : function(vElement, bUse){
		var aIdx = this._getFormIdx(vElement);
		var aElFormList = [];
		var aElUnitList = [];
		var sEvent = (bUse) ? "enable" : "disable";

		for ( var i = 0; i < aIdx.length; i++) {
			this._setUsedForm(bUse, this._aWElFormList[aIdx[i]].$value(), this._aWElUnitList[aIdx[i]]);
			aElFormList[i] = this._aWElFormList[aIdx[i]].$value();
			aElUnitList[i] = this._aWElUnitList[aIdx[i]].$value();
		}
		return {
			aFormList: aElFormList,
			aUnitList: aElUnitList
		};
	},
	/**
	 * @description CheckBox 활성화 지정. CheckBox disabled와 Unit css Class 지정.
	 * @param {Variant} vElement 체크를 설정할 checkbox Element.
	 * @param {boolean} bUse 활성화 여부
	 */
	_setUsedForm : function(bEnable, elForm, welUnit){
		if(!bEnable){
			welUnit.addClass(this._sDisableClass);
			elForm.disabled = true;
		} else {
			welUnit.removeClass(this._sDisableClass);
			elForm.disabled = false;
		}
	},

	/**
	 * @description  MobileCommentJindo.m.CheckRadioCore 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy : function() {
		this.deactivate();

		for ( var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		this._htWElement = null;
		this._sUnitClass = null;
		this._sOnClass = null;
		this._sFormClass = null;
		this._sDisableClass = null;
		this._aWElUnitList = null;
		this._aWElFormList = null;
	}
}).extend(MobileCommentJindo.UIComponent);
/**
* @(#)MobileCommentJindo.m.Effect.js 2011. 12. 13.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author "oyang2"
* @since 2011. 12. 13.
* @description
*/
MobileCommentJindo.m.Effect = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.Effect.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 */
	$init : function(){
		this._sCssPrefix = MobileCommentJindo.m.getCssPrefix();
		var htDInfo = MobileCommentJindo.m.getDeviceInfo();
		this.bIos = (htDInfo.iphone || htDInfo.ipad);
		this.bIos3 = htDInfo.iphone && (htDInfo.version.length > 0) && (htDInfo.version.substring(0,1)== '3');
		this.bAndroid = htDInfo.android;
		this.bAndroid3Up  = htDInfo.android && (htDInfo.version.length > 0) && (htDInfo.version.substring(0,1)>= '3');
		this.bAndroid2_1  = htDInfo.android && (htDInfo.version.length > 0) && (htDInfo.version === '2.1');
		this.sTranOpen =  (this.bIos )?'translate3d(' : 'translate(';
		this.sTranEnd =  (this.bIos)?',0px)' : ')';
		this._initVar();

	},

	_initVar : function(){
		this._htLayerInfo = {};
	},

	setLayerInfo : function(htInfo){
		this._htLayerInfo = {};

		for(var p in htInfo){
			this._htLayerInfo[p] = htInfo[p];
		}

		//console.log('이펙트에서 설정해용', this._htLayerInfo);
	},

	getTransitionTask : function(){
		return null;
	},

	getBeforeCommand : function(){
		return null;
	}
});
/**
* @(#)MobileCommentJindo.m.CorePagination.js 2011. 7. 20.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author "oyang2"
* @since 2011. 7. 20.
* @description
*/

MobileCommentJindo.m.CorePagination = MobileCommentJindo.$Class({
	/**
	 * 현재 페이지
	 */
	_nCurrentPage : 1,

	/** @lends MobileCommentJindo.m.CorePagination.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
     */
	$init : function(htUserOption) {
		this.option({
			nItem : 10,
			nItemPerPage : 10,
			nPage : 1,
			bActivateOnload : true
		});
		this.option(htUserOption || {});
		this._nCurrentPage = this.option('nPage');
	},

	getItemCount : function(){
		return this.option('nItem');
	},

	getItemPerPage : function(){
		return this.option('nItemPerPage');
	},


	/**
	 * 현재 페이지를 리턴한다.
	 * @return {Number} 현재 페이지
	 */
	getCurrentPage : function(){
		return this._nCurrentPage;
	},
	/**
	 * 전체 아이템 개수를 설정한다.
	 * @param {Number} n 아이템 개수
	 */
	setItemCount : function(n){
		this.option('nItem', n);
	},

	/**
	 * 한페이지당 아이템 개수를 설정한다
	 * @param {Number} n 한 페이지당 아이템 개수
	 */
	setItemPerPage : function(n){
		this.option('nItemPerPage',n);
	},

	/**
	 * n 페이지로 이동한다.
	 * @param {Number} n
	 */
	movePageTo : function(n){
		var nBefore = this._nCurrentPage;

		var nPage = this._convertToAvailPage(n);
		if(nPage != this._nCurrentPage){
			this._nCurrentPage = nPage;
		}
	},

	/**
	 * 현재 페이지의 다음 페이지로 이동한다.
	 */
	nextPageTo : function(){
		var nPage = this._nCurrentPage +1;
		this.movePageTo(nPage);
	},

	/**
	 * 현재 페이지의 다음 페이지로 이동한다.
	 */
	previousPageTo : function(){
		var nPage = this._nCurrentPage-1;
		this.movePageTo(nPage);
	},

	/**
	 * 다음 페이지가 있는지 리턴한다.
	 * @return {Boolean}
	 */
	hasNextPage : function(){
		var nPage =this.getCurrentPage(),
			totalPage = this.getTotalPages();

		return nPage&& (nPage < totalPage);
	},

	/**
	 * 이전 페이지가 있는지 리턴한다.
	 * @return {Boolean}
	 */
	hasPreviousPage : function(){
		return (this.getCurrentPage() > 1);
	},

	/**
	 * 전체 페이지 수를 리턴한다.
	 * @return {Number}
	 */
	getTotalPages : function(){
		var nTotal = this.option('nItem'),
			nCount = this.option('nItemPerPage');

		if(!nCount){
			return null;
		}

		return Math.ceil(nTotal/nCount);
	},

	/**
	 * n 페이지의 아이템들의 start, end 인덱스를 리턴한다.
	 * @param {Number} n
	 * @return {HashTable}
	 * @example
var htIndex = oCorePagination.getPageIntemIndex(2);
htIndex.nStart //2페이지의 아이템의 시작 인덱스
htIndex.nEnd //2페이지의 아이템의 끝 인덱스
	 */
	getPageItemIndex : function(nPage){
		nPage = this._convertToAvailPage(nPage);

		var nTotal = this.option('nItem'),
			nCount = this.option('nItemPerPage'),
			start, end;

		if(!nPage || !nCount){
			return null;
		}

		start = (nPage-1) * nCount;
		end = Math.min(start+ nCount, nTotal)-1;

		return {
			nStart :  start,
			nEnd : end
		};
	},

	/**
	 * n번째 아이템이 몇번째 페이지인지 구한다.
	 * @param {Number} n
	 * @return {Number}
	 */
	getPageOfItem : function(n){
		return Math.ceil(n / this.getItemPerPage());
	},

	_convertToAvailPage : function(nPage){
		var nLastPage = this.getTotalPages();

		nPage = Math.max(nPage, 1);
		nPage = Math.min(nPage, nLastPage);

		return nPage;
	}
}).extend(MobileCommentJindo.UIComponent);
/**
* @(#)MobileCommentJindo.m.Validator.js 2011. 11. 23.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sculove
* @since 2011. 11. 23.
* @description
*/
MobileCommentJindo.m.Validator = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.Validator.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @extends MobileCommentJindo.UIComponent
	 */

	/**
	 * @description validate 한다.
	 * @return {HashTable}  {bValid, sCorrectedValue}
	 */
	validate : function(sValue, sFormat) {
		var sCorrectedValue = this._getCorrectedValue(sValue, sFormat),
			htResult = {
				bValid : this._isValid(sCorrectedValue, sFormat),
				sCorrectedValue : null
			};
		if(sCorrectedValue !== sValue) {
			htResult.sCorrectedValue = sCorrectedValue;
		}
		return htResult;
	}
});

/**
* @(#)MobileCommentJindo.m.Touch.js 2011. 8. 24.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
 * @author oyang2
 * @since 2011. 8. 24.
 * @version 0.0.1
 * @description 모바일 터치 컴포넌트
 */
MobileCommentJindo.m.Touch = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.Touch.prototype */
	/**
	 * @constructs
	 * @class Touch 이벤트를 분석하는 컴포넌트
	 * @extends MobileCommentJindo.UIComponent
	 * @param {String | HTMLElement} Touch이벤트를 분석할 타켓 엘리먼트 혹은 아이디.
	 * @param {HashTable} htOption 초기화 옵션 설정을 위한 객체.
	 * @example
var oPagination = new MobileCommentJindo.m.Touch('layer1', {
		nMomentumDuration :350, //가속도를 발생시키는 기준 ms
		nMoveThreshold : 7, //move event 발생시키는 기준 거리
		nSlopeThreshold : 25, //현재 움직임이 swipe, scroll인지 판단하는 거리
		nLongTapDuration : 1000, //longtap을 판단하는 시간
		nDoubleTapDuration : 400, //doubletap을 판단하는 시간
		nTapThreshold : 5, //tap임을 판단하는 움직이는 거리의 기준
		bActivateOnload : true // 활성화여부
	}).attach({
		'touchStart' : function(oCustomEvt){
		},
		'touchMove' : function(oCustomEvt){
		},
		'touchEnd' : function(oCustomEvt){
		},
		'tap' : function(oCustomEvt){
		},
		'longTap' : function(oCustomEvt){
		},
		'doubleTap' : function(oCustomEvt){
		},
		'hScroll': function(oCustomEvt){
		},
		'vScroll' : function(oCustomEvt){
		},
		'dScroll' : function(oCustomEvt){
		}
	})
	 */
	$init : function(sId, htUserOption){
		this._el = MobileCommentJindo.$(sId);

		var htDefaultOption = {
			nMomentumDuration :350,
			nMoveThreshold : 7,
			nSlopeThreshold : 25,
			nLongTapDuration : 1000,
			nDoubleTapDuration : 400,
			nTapThreshold : 6,
			bActivateOnload : true
		};

		this.option(htDefaultOption);
		this.option(htUserOption || {});

		this._initVariable();
		this._setSlope();
		//활성화
		if(this.option("bActivateOnload")) {
			this.activate(); //컴포넌트를 활성화한다.
		}

	},

	/**
	 * @description MobileCommentJindo.m.Touch 인스턴스 변수를 초기화한다.
	 */
	_initVariable : function(){
		this._hasTouchEvent = 'ontouchstart' in window;

		this._htMoveInfo={
			nStartX : 0,
			nStartY :0,
			nBeforeX : 0,
			nBeforeY : 0,
			nStartTime :0,
			nBeforeTime : 0
		};

		this.bStart = false;
		this.bMove = false;
		this.nMoveType = -1;
		this.htEndInfo ={};
		this._nVSlope = 0;
		this._nHSlope = 0;
		this.bSetSlope = false;
	},

	/**
	 * @description MobileCommentJindo.m.Touch 사용하는 이벤트 attach 한다
	 */
	_attachEvents : function(){
		this._htEvent = {};
		var bTouch = this._hasTouchEvent;

		this._htEvent[bTouch? 'touchstart':'mousedown'] = {
			ref: MobileCommentJindo.$Fn(this._onStart, this).attach(this._el, (bTouch? 'touchstart':'mousedown')),
			el : this._el
		};

		this._htEvent[bTouch? 'touchmove':'mousemove'] = {
			ref: MobileCommentJindo.$Fn(this._onMove, this).attach(this._el, (bTouch? 'touchmove':'mousemove')),
			el : this._el
		};

		this._htEvent[bTouch? 'touchend':'mouseup'] = {
			ref: MobileCommentJindo.$Fn(this._onEnd, this).attach(this._el, (bTouch? 'touchend':'mouseup')),
			el : this._el
		};

		//resize event
		this._htEvent["rotate"] = MobileCommentJindo.$Fn(this._onResize, this).bind();
		MobileCommentJindo.m.bindRotate(this._htEvent["rotate"]);

		if(bTouch){
			this._htEvent['touchcancel'] = {
				ref: MobileCommentJindo.$Fn(this._onCancle, this).attach(this._el, 'touchcancel'),
				el : this._el
			};
		}
	},

	/**
	 * @description MobileCommentJindo.m.Touch 사용하는 이벤트 detach 한다
	 */
	_detachEvents : function(){
		for(p in this._htEvent){
			var htTargetEvent = this._htEvent[p];
			if (htTargetEvent.ref) {
				htTargetEvent.ref.detach(htTargetEvent.el, p);
			}
		}
		MobileCommentJindo.m.unbindRotate(this._htEvent["rotate"]);
		this._htEvent = null;
	},

	/**
	 * @description touchcancle 발생시에 touchEnd이벤트로 바로 호출한다.
	 * ios3 에서는 클립보드 활성화 되면 바로 touchcancle 발생
	 * android 계열에서 빠르고 짧게 스크롤 하면 touchcancle 발생함
	 * @param {$Event}  MobileCommentJindo.$Event
	 */
	_onCancle : function(oEvent){
		this._onEnd(oEvent);
	},


	/**
	 * @description touchstart(mousedown) 이벤트 핸들러
	 * @param {$Event}  MobileCommentJindo.$Event
	 */
	_onStart : function(oEvent){
		//touch 정보들의 초기화
		this._resetTouchInfo();

		var htInfo = this._getTouchInfo(oEvent);

		if(!this._fireCustomEvent('touchStart', {
			element : htInfo.el,
			nX : htInfo.nX,
			nY : htInfo.nY,
			oEvent : oEvent
		})){
			return;
		}

		//touchstart 플래그 세팅
		this.bStart = true;

		//move info update
		this._htMoveInfo.nStartX = htInfo.nX;
		this._htMoveInfo.nBeforeX = htInfo.nX;
		this._htMoveInfo.nStartY = htInfo.nY;
		this._htMoveInfo.nBeforeY = htInfo.nY;
		this._htMoveInfo.nStartTime = htInfo.nTime;

		this._startLongTapTimer(htInfo, oEvent);
	},

	/**
	 * @description touchMove(mousemove) 이벤트 핸들러
	 * @param {$Event}  MobileCommentJindo.$Event
	 */
	_onMove : function(oEvent){
		if(!this.bStart){
			return;
		}
		this.bMove = true;

		var htInfo = this._getTouchInfo(oEvent);

		if(this.nMoveType < 0 || this.nMoveType == 3 || this.nMoveType == 4){
			this.nMoveType = this._getMoveType(htInfo.nX, htInfo.nY);
		}

		//longtap timer 삭제
		if((typeof this._nLongTapTimer != 'undefined') && this.nMoveType != 3){
			this._deleteLongTapTimer();
		}

		//커스텀 이벤트에 대한 파라미터 생성.
		var htParam = this._getCustomEventParam(htInfo, false);
		htParam.oEvent = oEvent;

		var nDis = 0;
		if(this.nMoveType == 0){ //hScroll일 경우
			nDis = Math.abs(htParam.nVectorX);
		}else if(this.nMoveType == 1){ //vScroll일 경우
			nDis = Math.abs(htParam.nVectorY);
		}else{ //dScroll 일 경우
			nDis = Math.abs(htParam.nVectorX) + Math.abs(htParam.nVectorY);
		}

		//move간격이 옵션 설정 값 보다 작을 경우에는 커스텀이벤트를 발생하지 않는다
		if(nDis < this.option('nMoveThreshold')){
			return;
		}

		if(!this.fireEvent('touchMove', htParam)){
			this.bStart = false;
			return;
		}

		//touchInfo 정보의  before 정보만 업데이트 한다.
		this._htMoveInfo.nBeforeX = htInfo.nX;
		this._htMoveInfo.nBeforeY = htInfo.nY;
		this._htMoveInfo.nBeforeTime = htInfo.nTime;
	},

	/**
	 * @description touchend(mouseup) 이벤트 핸들러
	 * @param {$Event}  MobileCommentJindo.$Event
	 */
	_onEnd : function(oEvent){
		if(!this.bStart){
			return;
		}
		this._deleteLongTapTimer();

		//touchMove이벤트가 발생하지 않고 현재 롱탭이 아니라면 tap으로 판단한다.
		if(!this.bMove && (this.nMoveType != 4)){
			this.nMoveType = 3;
		}

		//touchEnd 시점에 판단된  moveType이 없으면 리턴한다.
		if(this.nMoveType < 0){
			return;
		}

		var htInfo = this._getTouchInfo(oEvent);

		//현재 touchEnd시점의 타입이 doubleTap이라고 판단이 되면
		if(this._isDblTap(htInfo.nX, htInfo.nY, htInfo.nTime)){
			clearTimeout(this._nTapTimer);
			delete this._nTapTimer;
			this.nMoveType = 5; //doubleTap 으로 세팅
		}

		//커스텀 이벤트에 대한 파라미터 생성.
		var htParam = this._getCustomEventParam(htInfo, true);
		htParam.oEvent = oEvent;
		var sMoveType = htParam.sMoveType;

		//doubletap 핸들러가  있고, 현재가  tap 인 경우
		if( (typeof this._htEventHandler[MobileCommentJindo.m.MOVETYPE[5]] != 'undefined' && (this._htEventHandler[MobileCommentJindo.m.MOVETYPE[5]].length > 0))&& (this.nMoveType == 3) ){
			var self = this;
			this._nTapTimer = setTimeout(function(){
				self.fireEvent('touchEnd', htParam);
				self._fireCustomEvent(sMoveType, htParam);
				delete self._nTapTimer;
			}, this.option('nDoubleTapDuration'));

		}else{
			this.fireEvent('touchEnd', htParam);
			if(this.nMoveType != 4){
				this._fireCustomEvent(sMoveType, htParam);
			}
		}

		this._updateTouchEndInfo(htInfo);
		this._resetTouchInfo();
	},

	/**
	 * @description sEvent 명으로 커스텀 이벤트를 발생시킨다
	 * @param {String} sEvent
	 * @param {HashTable} 커스텀이벤트 파라미터
	 * @return {Boolean} fireEvent의 리턴값
	 */
	_fireCustomEvent :  function(sEvent, htOption){
		return this.fireEvent(sEvent, htOption);
	},

	/**
	 * 커스텀이벤트를 발생시킬 때 필요한 파라미터를 생성한다.
	 * @param {HashTable} 현재 터치 정보들을 담고 있는 해시테이블
	 * @param {Boolean} touchEnd 시점인지 여부, touchEnd일 경우 가속에 대한 추가 정보를 필요로 한다.
	 * @return {HashTable}
	 *  - {HTMLElement} element 현재 이벤트 객체의 대상 엘리먼트
	 *  - {Number} nX x좌표
	 *  - {Number} nY y좌표
	 *  - {Number} nVectorX 이전 x 좌표와의 차이
	 *  - {Number} nVectorY 이전 y 좌표와의 차이
	 *  - {Number} nDistanceX touchstart와의 x 좌표 거리
	 *  - {Number} nDistanceY touchstart와의 y 좌표 거리
	 *  - {String} sMoveType 현재 분석된 움직임의 이름
	 *  - {Number} nStartX touchstart시점의 x 좌표
	 *  - {Number} nStartY touchstart시점의 y 좌표
	 *  - {Number} nStartTimeStamp touchstart시점의 timestamp
	 *  - {Number} nMomentumX x 좌표의 가속 값 (touchEnd일경우에만 발생)
	 *  - {Number} nMomentumY y 좌표의 가속 값 (touchEnd일경우에만 발생)
	 *  - {Number} nSpeedX x 좌표의 속도값 (touchEnd일경우에만 발생)
	 *  - {Number} nSpeedY y 좌표의 속도값 (touchEnd일경우에만 발생)
	 *  - {Number} nDuration touchstart와 touchEnd사이의 시간값
	 */
	_getCustomEventParam : function(htTouchInfo, bTouchEnd){

		var sMoveType = MobileCommentJindo.m.MOVETYPE[this.nMoveType];
		var nDuration = htTouchInfo.nTime - this._htMoveInfo.nStartTime;
		var nVectorX = nVectorY = nMomentumX = nMomentumY = nSpeedX= nSpeedY = nDisX= nDisY= 0;

		nDisX = (this.nMoveType === 1)? 0 : htTouchInfo.nX - this._htMoveInfo.nStartX; //vScroll
		nDisY = (this.nMoveType === 0)? 0 : htTouchInfo.nY -this._htMoveInfo.nStartY ; //hScroll

		nVectorX = htTouchInfo.nX - this._htMoveInfo.nBeforeX;
		nVectorY = htTouchInfo.nY - this._htMoveInfo.nBeforeY;

		//scroll 이벤트만 계산 한다
		if(bTouchEnd && (this.nMoveType == 0 || this.nMoveType == 1 || this.nMoveType == 2 )){
			if(nDuration <= this.option('nMomentumDuration')){
				nSpeedX = Math.abs(nDisX)/nDuration ;
				nMomentumX = (nSpeedX*nSpeedX) / 2;

				nSpeedY = Math.abs(nDisY)/nDuration ;
				nMomentumY =  (nSpeedY*nSpeedY) / 2;
			}
		}

		var htParam  = {
			element : htTouchInfo.el,
			nX : htTouchInfo.nX,
			nY : htTouchInfo.nY,
			nVectorX : nVectorX,
			nVectorY : nVectorY,
			nDistanceX : nDisX,
			nDistanceY : nDisY,
			sMoveType : sMoveType,
			nStartX : this._htMoveInfo.nStartX,
			nStartY : this._htMoveInfo.nStartY,
			nStartTimeStamp : this._htMoveInfo.nStartTime
		};

		//touchend 에는 가속에 대한 계산값을 추가로 더 필요로 한다.
		if(bTouchEnd){
			htParam.nMomentumX = nMomentumX;
			htParam.nMomentumY = nMomentumY;
			htParam.nSpeedX = nSpeedX;
			htParam.nSpeedY = nSpeedY;
			htParam.nDuration = nDuration;
		}

		return htParam;
	},

	/**
	 * @description doubleTap을 판단하기 위해서 마지막 touchend의 정보를 업데이트 한다.
	 *  doubleTap을 분석 할 경우 가장 마지막의 touch에 대한 정보를 비교해야 하기 때문에 이 값을 업데이트 한다.
	 *  @param {HashTable} touchEnd에서의 좌표 및 엘리먼트 정보 테이블
	 *   - {HTMLElement} touchEnd시점의 엘리먼트
	 *   - {Number} touchEnd timestamp
	 *   - {Number} touchEnd의 x 좌표
	 *   - {Number} touchEnd의 y 좌표
	 */
	_updateTouchEndInfo : function(htInfo){
		this.htEndInfo = {
			element: htInfo.el,
			time : htInfo.nTime,
			movetype : this.nMoveType,
			nX : htInfo.nX,
			nY : htInfo.nY
		};
	},

	/**
	 * @description longTap 타이머를 삭제한다.
	 */
	_deleteLongTapTimer : function(){
		if(typeof this._nLongTapTimer != 'undefined'){
			clearTimeout(this._nLongTapTimer);
			delete this._nLongTapTimer;
		}
	},

	/**
	 * @description longTap 커스텀 핸들러가 존재 할 경우 longTap 타이머를 시작한다.
	 * @param {HashTable} longTap에 대한 정보 객체
	 * @param {HashTable} event 객체
	 */
	_startLongTapTimer : function(htInfo, oEvent){
		var self = this;

		//long tap handler 가 있을경우
		if((typeof this._htEventHandler[MobileCommentJindo.m.MOVETYPE[4]] != 'undefined') && (this._htEventHandler[MobileCommentJindo.m.MOVETYPE[4]].length > 0)){
			self._nLongTapTimer = setTimeout(function(){
				self.fireEvent('longTap',{
					element :  htInfo.el,
					oEvent : oEvent,
					nX : htInfo.nX,
					nY : htInfo.nY
				});
				delete self._nLongTapTimer;
				//현재 moveType 세팅
				self.nMoveType = 4;
			}, self.option('nLongTapDuration'));
		}
	},

	/**
	 * @description 화면 전환시에 스크롤 기준 값을 다시 구한다.
	 */
	_onResize : function(){
		this._setSlope();
	},

	/**
	 * @description 이전 탭의 정보와 비교하여 현재 동작이 더블탭임을 판단한다
	 * @param {Number} nX pageX 좌표
	 * @param {Number} nY pageY 좌표
	 * @param {Number} nTimeStamp 이벤트 timestamp
	 */
	_isDblTap : function(nX, nY, nTime){
		if((typeof this._nTapTimer != 'undefined') && this.nMoveType == 3){
			var nGap = this.option('nTapThreshold');
			if( (Math.abs(this.htEndInfo.nX - nX) <= nGap) && (Math.abs(this.htEndInfo.nY-nY) <= nGap) ){
				return true;
			}
		}
		return false;
	},

	/**
	 * @description vScroll, hScroll을 판단하는 기준 기울기를 계산한다
	 * 단말기 스크린을 기준으로 계산한다
	 * hScroll = (세로/2)/가로
	 * vScroll = 세로/(가로/2)
	 */
	_setSlope : function(){
		if(!this.bSetSlope){
			this._nHSlope = ((window.innerHeight/2) / window.innerWidth).toFixed(2)*1;
			this._nVSlope = (window.innerHeight / (window.innerWidth/2)).toFixed(2)*1;
		}
	},

	/**
	 * @description vScroll, hScroll을 판단하는 기준 기울기를 설정한다.
	 * nVSlope 기울기 보다 클 경우 수직 스크롤로 판단한다.
	 * nHSlope 기울기 보다 작을 경우 수평 스크롤로 판단한다.
	 * nVSlope와 nHSlope 사이값인 경우 대각선 스크롤로 판단한다.
	 * @param {Number} nVSlope 수직스크롤 판단 기울기
	 * @param {Number} nHSlope 수평스크롤 판단 기울기
	 */
	setSlope : function(nVSlope, nHSlope){
		this._nHSlope = nHSlope;
		this._nVSlope = nVSlope;

		this.bSetSlope = true;
	},

	/**
	 * @description vScroll, hScroll을 판단하는 기준 기울기를 리턴한다
	 * @return {HashTable} elBody 아코디언 블럭의 body 엘리먼트
	 * - {Number} nVSlope 수직스크롤 판단 기울기
	 * - {Number} nHSlope 수평스크롤 판단 기울기
	 */
	getSlope : function(){
		return{
			nVSlope :  this._nVSlope,
			nHSlope : this._nHSlope
		}
	},

	/**
	 * @description 터치의 기본정보를 모두 초기화 한다.
	 */
	_resetTouchInfo : function(){
		for(var x in this._htMoveInfo){
			this._htMoveInfo[x] = 0;
		}
		this.bStart = false;
		this.bMove = false;
		this.nMoveType = -1;
	},

	/**
	 * @description 현재 x,y 좌표값으로 현재 움직임이 무엇인지 판단한다.
	 * @param {Number} x
	 * @param {Number} y
	 */
	_getMoveType : function(x,y){
		var nType = this.nMoveType;

		var nX = Math.abs(this._htMoveInfo.nStartX - x);
		var nY = Math.abs(this._htMoveInfo.nStartY - y);
		var nDis = nX + nY;

		//tap정의
		var nGap = this.option('nTapThreshold');
		if((nX <= nGap) && (nY <= nGap)){
			nType = 3;
		}else{
			nType = -1;
		}

		if(this.option('nSlopeThreshold') <= nDis){
			var nSlope = parseFloat((nY/nX).toFixed(2),10);
			if((this._nHSlope === -1) && (this._nVSlope === -1)){
				nType = 2;
			}else{
				if(nSlope <= this._nHSlope){
					nType = 0;
				}else if(nSlope >= this._nVSlope){
					nType = 1;
				}else {
					nType = 2;
				}
			}

		}

		return nType;
	},

	/**
	 * @description touch 이벤트에서 필요한 좌표값과 엘리먼트, timestamp를 구한다
	 * @param {$Event} MobileCommentJindo.$Event
	 */
	_getTouchInfo : function(oEvent){
		var e = this._hasTouchEvent? oEvent.$value().changedTouches[0] : oEvent;

		var el =  this._hasTouchEvent? MobileCommentJindo.m.getNodeElement(e.target) : e.element;
		var x = this._hasTouchEvent? e.pageX : e.pos().pageX;
		var y = this._hasTouchEvent? e.pageY : e.pos().pageY;

		return {
			el: el,
			nX : x,
			nY : y,
			nTime : oEvent.$value().timeStamp
		}
	},

	/**
	 * @description 기준엘리먼트를 el을 리턴한다.
	 * @return {HTMLElement} el
	 */
	getBaseElement : function(el){
		return this._el;
	},

	/**
	 * @description MobileCommentJindo.m.Touch 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function(){
		this._detachEvents();
	},

	/**
	 * @description MobileCommentJindo.m.Touch 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function(){
		this._attachEvents();
	},

	/**
	 * @description  MobileCommentJindo.m.Touch 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this.deactivate();

		this._el = null;

		for(var p in this._htMoveInfo){
			this._htMoveInfo[p] = null;
		}
		this._htMoveInfo = null;

		for(var p in this.htEndInfo){
			this.htEndInfo[p] = null;
		}
		this.htEndInfo = null;

		this.bStart = null;
		this.bMove = null;
		this.nMoveType = null;
		this._nVSlope = null;
		this._nHSlope = null;
		this.bSetSlope = null;
	}

}).extend(MobileCommentJindo.UIComponent);
/**
 * @fileOverview 특정 연/월의 달력 출력을 위한 컴포넌트
 * @author senxation
 */

MobileCommentJindo.Calendar = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.Calendar.prototype */
	/**
	 * Calendar 컴포넌트를 생성한다.
	 * 달력이 출력 될때 토요일, 일요일은 각각 해당 셀에 sat, sun로 className을 설정한다.
	 * 이전달의 마지막주의 날짜 셀은 prev-mon, 다음달의 첫주의 날짜 셀은 next_mon로 className을 설정한다.
	 * 공휴일 정보는 draw 커스텀 이벤트에서 클래스명 정의를 통해 작성해야한다.
	 * @constructs
	 * @class 특정 연/월의 달력 출력을 위한 컴포넌트
	 * @extends MobileCommentJindo.UIComponent
	 * @param {String | HTMLElement} sLayerId 달력을 출력할 레이어의 id 혹은 레이어 자체.
	 * @param {HashTable} htOption 초기화 옵션 설정을 위한 객체.
	 * @example
var oCalendar = new MobileCommentJindo.Calendar("calendar_layer", {
	sClassPrefix : "calendar-",
	nYear : 1983,
	nMonth : 5,
	nDate : 12,
	sTitleFormat : "yyyy-mm", //설정될 title의 형식
	sYearTitleFormat : "yyyy", //설정될 연 title의 형식
	sMonthTitleFormat : "m", //설정될 월 title의 형식
	aMonthTitle : ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"], //월의 이름을 설정 "title" 세팅시 적용
	bDrawOnload : true //로딩과 동시에 바로 그릴것인지 여부
}).attach({
	beforeDraw : function(oCustomEvent) {
		//달력을 새로 그리기 전 발생
		//전달되는 이벤트 객체 oCustomEvent = {
		//	nYear : (Number) 연 (ex. 2009)
		//	nMonth : (Number) 월 (ex. 5)
		//}
		//oCustomEvent.stop()을 실행하면 draw 커스텀 이벤트가 발생하지 않는다.
	},
	draw : function(oCustomEvent) {
		//달력을 새로 그리는 중 발생
		//전달되는 이벤트 객체 oCustomEvent = {
		//	elDate : (HTMLElement) 날짜가 쓰여질 목표 엘리먼트
		//  elDateContainer : (HTMLElement) week의 child 엘리먼트로 날짜가 쓰여질 목표 엘리먼트를 감싸고 있는 상위 엘리먼트. (element와 같을 수도 있음)
		//	nYear : (Number) 연 (ex. 2009)
		//	nMonth : (Number) 월 (ex. 5)
		//	nDate : (Number) 일 (ex. 12)
		//	bPrevMonth : (Boolean) 그려질 날이 이전달의 날인지 여부
		//	bNextMonth : (Boolean) 그려질 날이 다음달의 날인지 여부
		//}
	},
	afterDraw : function(oCustomEvent) {
		//달력을 그린 이후 발생
		//전달되는 이벤트 객체 oCustomEvent = {
		//	nYear : (Number) 연 (ex. 2009)
		//	nMonth : (Number) 월 (ex. 5)
		//}
	}
});
	 * @example
옵션의 sTitleFormat은 날짜의 형식으로 title 엘리먼트에 표현될 형식을 지정한다.
다음의 형식을 조합하여 사용할 수 있다.
ex) "yyyy.m", "yyyy년 m월", "yy/m" ...
연도 : yyyy(4자리 숫자, ex "2001"), yy(2자리 숫자, ex "01")
월 : mm(2자리 숫자, ex "01"), m(1자리 숫자, ex "1"), M(aMonthTitle에 설정된 값으로 보여줌 ex "JAN")
	 */
	$init : function(sLayerId, htOption) {
		var htToday = this.constructor.getToday();
		this.setToday(htToday.nYear, htToday.nMonth, htToday.nDate);
		this._elLayer = MobileCommentJindo.$(sLayerId);
		this._htDefaultOption = {
			sClassPrefix : "calendar-",
			nYear : this._htToday.nYear,
			nMonth : this._htToday.nMonth,
			nDate : this._htToday.nDate,

			sTitleFormat : "yyyy-mm",
			sYearTitleFormat : "yyyy",
			sMonthTitleFormat : "m",

			aMonthTitle : ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"],
			bDrawOnload : true
		};

		this.option(this._htDefaultOption);
		this.option(htOption || {});

		this._assignHTMLElements();
		this.activate();
		this.setDate(this.option("nYear"), this.option("nMonth"), this.option("nDate"));
		if (this.option("bDrawOnload")) {
			this.draw();
		}
	},

	/**
	 * 기준 엘리먼트(달력 레이어 엘리먼트)를 가져온다.
	 * @return {HTMLElement} 달력 레이어
	 */
	getBaseElement : function() {
		return this._elLayer;
	},

	/**
	 * 현재 설정된 날짜를 가져온다.
	 * @return {HashTable}
	 * @example
oCalendar.getDate() -> { nYear : 2000, nMonth : 1, nDate : 31 }
	 */
	getDate : function() {
		return this._htDate;
	},

	/**
	 * 그려진 달력의 날짜엘리먼트로 해당하는 날짜를 구한다.
	 * @param {HTMLElement} el week엘리먼트의 자식노드로 존재하는 7개의 엘리먼트중 하나
	 * @return {HashTable}
	 * @example
oCalendar.getDateOfElement(el) -> { nYear : 2000, nMonth : 1, nDate : 31 }
	 */
	getDateOfElement : function(el) {
		var nDateIndex = MobileCommentJindo.$A(this._aDateContainerElement).indexOf(el);
		if (nDateIndex > -1) {
			return this._aMetaData[nDateIndex];
		}
		return null;
	},

	/**
	 * 오늘 정보를 설정한다.
	 * JavaScript의 new Date()는 사용자 로컬환경의 시간을 따르므로, 서버에서 내려주는 오늘의 정보를 설정하기 위해 사용한다.
	 * @param {Number} nYear 년
	 * @param {Number} nMonth 월
	 * @param {Number} nDate 일
	 * @return {this}
	 */
	setToday : function(nYear, nMonth, nDate) {
		if (!this._htToday) {
			this._htToday = {};
		}
		this._htToday.nYear = nYear;
		this._htToday.nMonth = nMonth;
		this._htToday.nDate = nDate;
		return this;
	},

	/**
	 * 오늘의 정보를 가지는 Hash Table을 가져온다.
	 * @return {HashTable}
	 * @example
oCalendar.getToday() -> { nYear : 2000, nMonth : 1, nDate : 31 }
	 */
	getToday : function() {
		return {
			nYear : this._htToday.nYear,
			nMonth : this._htToday.nMonth,
			nDate : this._htToday.nDate
		};
	},

	/**
	 * 현재 달력의 날짜를 설정한다.
	 * @param {Number} nYear 연도 값 (ex. 2008)
	 * @param {Number} nMonth 월 값 (1 ~ 12)
	 * @param {Number} nDate 일 값 (1 ~ 31)
	 */
	setDate : function(nYear, nMonth, nDate) {
		this._htDate = {
			nYear : nYear,
			nMonth : (nMonth * 1),
			nDate : (nDate * 1)
		};
	},

	/**
	 * 현재 표시된 달력의 날짜를 가져온다.
	 * @remark 기본으로 설정된 날짜 또는 setDate로 설정된 날짜와 다른 경우, nDate 값은 1이다.
	 * @return {HashTable}
	 * @example
oCalendar.getShownDate() -> { nYear : 2000, nMonth : 1, nDate : 1 }
	 */
	getShownDate : function() {
		return this._getShownDate();
	},

	_getShownDate : function() {
		return this.htShownDate || this.getDate();
	},

	_setShownDate : function(nYear, nMonth) {
		this.htShownDate = {
			nYear : nYear,
			nMonth : (nMonth * 1),
			nDate : 1
		};
	},

	_assignHTMLElements : function() {
		var sClassPrefix = this.option("sClassPrefix"),
			elLayer = this.getBaseElement();

		if ((this.elBtnPrevYear = MobileCommentJindo.$$.getSingle(("." + sClassPrefix + "btn-prev-year"), elLayer))) {
			this.wfPrevYear = MobileCommentJindo.$Fn(function(oEvent){
				oEvent.stop(MobileCommentJindo.$Event.CANCEL_DEFAULT);
				this.draw(-1, 0, true);
			}, this);
		}
		if ((this.elBtnPrevMonth = MobileCommentJindo.$$.getSingle(("." + sClassPrefix + "btn-prev-mon"), elLayer))) {
			this.wfPrevMonth = MobileCommentJindo.$Fn(function(oEvent){
				oEvent.stop(MobileCommentJindo.$Event.CANCEL_DEFAULT);
				this.draw(0, -1, true);
			}, this);
		}
		if ((this.elBtnNextMonth = MobileCommentJindo.$$.getSingle(("." + sClassPrefix + "btn-next-mon"), elLayer))) {
			this.wfNextMonth = MobileCommentJindo.$Fn(function(oEvent){
				oEvent.stop(MobileCommentJindo.$Event.CANCEL_DEFAULT);
				this.draw(0, 1, true);
			}, this);
		}
		if ((this.elBtnNextYear = MobileCommentJindo.$$.getSingle(("." + sClassPrefix + "btn-next-year"), elLayer))) {
			this.wfNextYear = MobileCommentJindo.$Fn(function(oEvent){
				oEvent.stop(MobileCommentJindo.$Event.CANCEL_DEFAULT);
				this.draw(1, 0, true);
			}, this);
		}

		this.elTitle = MobileCommentJindo.$$.getSingle(("." + sClassPrefix + "title"), elLayer);
		this.elTitleYear = MobileCommentJindo.$$.getSingle(("." + sClassPrefix + "title-year"), elLayer);
		this.elTitleMonth = MobileCommentJindo.$$.getSingle(("." + sClassPrefix + "title-month"), elLayer);
		var elWeekTemplate = MobileCommentJindo.$$.getSingle("." + sClassPrefix + "week", elLayer);
		this.elWeekTemplate = elWeekTemplate.cloneNode(true);
		this.elWeekAppendTarget = elWeekTemplate.parentNode;
	},

	_setCalendarTitle : function(nYear, nMonth, sType) {
		if (nMonth < 10) {
			nMonth = ("0" + (nMonth * 1)).toString();
		}

		var elTitle = this.elTitle,
			sTitleFormat = this.option("sTitleFormat"),
			sTitle;

		if (typeof sType != "undefined") {
			switch (sType) {
				case "year" :
					elTitle = this.elTitleYear;
					sTitleFormat = this.option("sYearTitleFormat");
					sTitle = sTitleFormat.replace(/yyyy/g, nYear).replace(/y/g, (nYear).toString().substr(2,2));
				break;
				case "month" :
					elTitle = this.elTitleMonth;
					sTitleFormat = this.option("sMonthTitleFormat");
					sTitle = sTitleFormat.replace(/mm/g, nMonth).replace(/m/g, (nMonth * 1)).replace(/M/g, this.option("aMonthTitle")[nMonth-1]);
				break;
			}
		} else {
			sTitle = sTitleFormat.replace(/yyyy/g, nYear).replace(/y/g, (nYear).toString().substr(2,2)).replace(/mm/g, nMonth).replace(/m/g, (nMonth * 1)).replace(/M/g, this.option("aMonthTitle")[nMonth-1] );
		}

		MobileCommentJindo.$Element(elTitle).text(sTitle);
	},

	/**
	 * Calendar를 그린다.
	 * @function
	 * @param {Number} nYear 연도 값 (ex. 2008)
	 * @param {Number} nMonth 월 값 (1 ~ 12)
	 * @param {Boolean} bRelative 연도와 월 값이 상대값인지 여부, 생략 가능
	 * @example
oCalendar.draw(); //현재 설정된 날짜의 달력을 그린다.
oCalendar.draw(2008,12); //2008년 12월 달력을 그린다.
oCalendar.draw(null,12); //현재 표시된 달력의 12월을 그린다.
oCalendar.draw(2010,null); //2010년 현재 표시된 달력의 월을 그린다.
oCalendar.draw(0,1,true); //현재 표시된 달력의 다음 달을 그린다.
oCalendar.draw(-1,null,true); //현재 표시된 달력의 이전 연도를 그린다.
	 */
	draw : function(nYear, nMonth, bRelative) {
		var sClassPrefix = this.option("sClassPrefix"),
			htDate = this.getDate(),
			oShownDate = this._getShownDate();

		if (oShownDate && typeof bRelative != "undefined" && bRelative) {
			var htRelativeDate = this.constructor.getRelativeDate(nYear, nMonth, 0, oShownDate);
			nYear = htRelativeDate.nYear;
			nMonth = htRelativeDate.nMonth;
		} else if (typeof nYear == "undefined" && typeof nMonth == "undefined" && typeof bRelative == "undefined") {
			nYear = htDate.nYear;
			nMonth = htDate.nMonth;
		} else {
			nYear = nYear || oShownDate.nYear;
			nMonth = nMonth || oShownDate.nMonth;
		}

		if (this.fireEvent("beforeDraw", {
			nYear: nYear,
			nMonth: nMonth
		})) {
			if (this.elTitle) {
				this._setCalendarTitle(nYear, nMonth);
			}
			if (this.elTitleYear) {
				this._setCalendarTitle(nYear, nMonth, "year");
			}
			if (this.elTitleMonth) {
				this._setCalendarTitle(nYear, nMonth, "month");
			}

			this._clear(MobileCommentJindo.Calendar.getWeeks(nYear, nMonth));
			this._setShownDate(nYear, nMonth);

			var htToday = this.getToday(),
				nFirstDay = this.constructor.getFirstDay(nYear, nMonth),
				nLastDay = this.constructor.getLastDay(nYear, nMonth),
				nLastDate = this.constructor.getLastDate(nYear, nMonth),
				nDay = 0,
				htDatePrevMonth = this.constructor.getRelativeDate(0, -1, 0, {nYear:nYear, nMonth:nMonth, nDate:1}),
				htDateNextMonth = this.constructor.getRelativeDate(0, 1, 0, {nYear:nYear, nMonth:nMonth, nDate:1}),
				nPrevMonthLastDate = this.constructor.getLastDate(htDatePrevMonth.nYear, htDatePrevMonth.nMonth),
				aDate = [],
				bPrevMonth,
				bNextMonth,
				welDateContainer,
				nTempYear,
				nTempMonth,
				oParam,
				nIndexOfLastDate,
				elWeek,
				i;

			var nWeeks = this.constructor.getWeeks(nYear, nMonth);

			for (i = 0; i < nWeeks; i++) {
				elWeek = this.elWeekTemplate.cloneNode(true);
				MobileCommentJindo.$Element(elWeek).appendTo(this.elWeekAppendTarget);
				this._aWeekElement.push(elWeek);
			}
			this._aDateElement = MobileCommentJindo.$$("." + sClassPrefix + "date", this.elWeekAppendTarget);
			this._aDateContainerElement = MobileCommentJindo.$$("." + sClassPrefix + "week > *", this.elWeekAppendTarget);
			if (nFirstDay > 0) {
				for (i = nPrevMonthLastDate - nFirstDay; i < nPrevMonthLastDate; i++) {
					aDate.push(i + 1);
				}
			}
			for (i = 1; i < nLastDate + 1; i++) {
				aDate.push(i);
			}
			nIndexOfLastDate = aDate.length - 1;

			for (i = 1; i < 7 - nLastDay; i++) {
				aDate.push(i);
			}

			for (i = 0; i < aDate.length; i++) {
				bPrevMonth = false;
				bNextMonth = false;
				welDateContainer = MobileCommentJindo.$Element(this._aDateContainerElement[i]);
				nTempYear = nYear;
				nTempMonth = nMonth;

				if (i < nFirstDay) {
					bPrevMonth = true;
					welDateContainer.addClass(sClassPrefix + "prev-mon");
					nTempYear = htDatePrevMonth.nYear;
					nTempMonth = htDatePrevMonth.nMonth;
				} else if (i > nIndexOfLastDate) {
					bNextMonth = true;
					welDateContainer.addClass(sClassPrefix + "next-mon");
					nTempYear = htDateNextMonth.nYear;
					nTempMonth = htDateNextMonth.nMonth;
				} else {
					nTempYear = nYear;
					nTempMonth = nMonth;
				}

				if (nDay === 0) {
					welDateContainer.addClass(sClassPrefix + "sun");
				}
				if (nDay == 6) {
					welDateContainer.addClass(sClassPrefix + "sat");
				}
				if (nTempYear == htToday.nYear && (nTempMonth * 1) == htToday.nMonth && aDate[i] == htToday.nDate) {
					welDateContainer.addClass(sClassPrefix + "today");
				}

				oParam = {
					elDate : this._aDateElement[i],
					elDateContainer : welDateContainer.$value(),
					nYear : nTempYear,
					nMonth : nTempMonth,
					nDate : aDate[i],
					bPrevMonth : bPrevMonth,
					bNextMonth : bNextMonth,
					sHTML : aDate[i]
				};
				MobileCommentJindo.$Element(oParam.elDate).html(oParam.sHTML.toString());

				this._aMetaData.push({
					nYear : nTempYear,
					nMonth : nTempMonth,
					nDate : aDate[i]
				});

				nDay = (nDay + 1) % 7;

				this.fireEvent("draw", oParam);
			}
			this.fireEvent("afterDraw", {
				nYear : nYear,
				nMonth : nMonth
			});
		}
	},

	_clear : function(nWeek) {
		this._aMetaData = [];
		this._aWeekElement = [];
		MobileCommentJindo.$Element(this.elWeekAppendTarget).empty();
	},

	/**
	 * @deprecated activate()
	 */
	attachEvent : function() {
		this.activate();
	},

	/**
	 * @deprecated deactivate()
	 */
	detachEvent : function() {
		this.deactivate();
	},

	_onActivate : function() {
		if (this.elBtnPrevYear) {
			this.wfPrevYear.attach(this.elBtnPrevYear, "click");
		}
		if (this.elBtnPrevMonth) {
			this.wfPrevMonth.attach(this.elBtnPrevMonth, "click");

		}
		if (this.elBtnNextMonth) {
			this.wfNextMonth.attach(this.elBtnNextMonth, "click");
		}
		if (this.elBtnNextYear) {
			this.wfNextYear.attach(this.elBtnNextYear, "click");
		}
	},

	_onDeactivate : function() {
		if (this.elBtnPrevYear) {
			this.wfPrevYear.detach(this.elBtnPrevYear, "click");
		}
		if (this.elBtnPrevMonth) {
			this.wfPrevMonth.detach(this.elBtnPrevMonth, "click");
		}
		if (this.elBtnNextMonth) {
			this.wfNextMonth.detach(this.elBtnNextMonth, "click");
		}
		if (this.elBtnNextYear) {
			this.wfNextYear.detach(this.elBtnNextYear, "click");
		}
	}

}).extend(MobileCommentJindo.UIComponent);

/**
 * 오늘 정보를 설정한다.
 * JavaScript의 new Date()는 사용자 로컬환경의 시간을 따르므로, 서버에서 내려주는 오늘의 정보를 설정하기 위해 사용한다.
 * @param {Number} nYear 년
 * @param {Number} nMonth 월
 * @param {Number} nDate 일
 * @return {this}
 */
MobileCommentJindo.Calendar.setToday = function(nYear, nMonth, nDate) {
	if (!this._htToday) {
		this._htToday = {};
	}
	this._htToday.nYear = nYear;
	this._htToday.nMonth = nMonth;
	this._htToday.nDate = nDate;
	return this;
};

/**
 * 오늘의 정보를 가지는 Hash Table을 가져온다.
 * @return {HashTable}
 * @example
oCalendar.getToday() -> { nYear : 2000, nMonth : 1, nDate : 31 }
 */
MobileCommentJindo.Calendar.getToday = function() {
	var htToday = this._htToday || this.getDateHashTable(new Date());
	return {
		nYear : htToday.nYear,
		nMonth : htToday.nMonth,
		nDate : htToday.nDate
	};
};

/**
 * Date 객체를 구한다.
 * @example
MobileCommentJindo.Calendar.getDateObject({nYear:2010, nMonth:5, nDate:12});
MobileCommentJindo.Calendar.getDateObject(2010, 5, 12); //연,월,일
 * @param {HashTable} htDate 날짜 객체
 * @return {Date}
 */
MobileCommentJindo.Calendar.getDateObject = function(htDate) {
	if (arguments.length == 3) {
		return new Date(arguments[0], arguments[1] - 1, arguments[2]);
	}
	return new Date(htDate.nYear, htDate.nMonth - 1, htDate.nDate);
};

/**
 * 연월일을 포함한 HashTable 객체를 구한다.
 * @example
MobileCommentJindo.Calendar.getDateHashTable(2010, 5, 12);
=> {nYear:2010, nMonth:5, nDate:12}
MobileCommentJindo.Calendar.getDateHashTable();
=> {nYear:2010, nMonth:5, nDate:12}
MobileCommentJindo.Calendar.getDateHashTable(new Date(2009,1,2));
=> {nYear:2009, nMonth:2, nDate:1}
 * @param {Date} Date 날짜 객체
 * @return
 */
MobileCommentJindo.Calendar.getDateHashTable = function(oDate) {
	if (arguments.length == 3) {
		return {
			nYear : arguments[0],
			nMonth : arguments[1],
			nDate : arguments[2]
		};
	}
	if (arguments.length <= 1) {
		oDate = oDate || new Date();
	}
	return {
		nYear : oDate.getFullYear(),
		nMonth : oDate.getMonth() + 1,
		nDate : oDate.getDate()
	};
};

/**
 * 연월일을 포함한 HashTable로부터 유닉스타임을 구한다.
 * @param {HashTable} htDate
 * @example
MobileCommentJindo.Calendar.getTime({nYear:2010, nMonth:5, nDate:12}); => 1273590000000
 * @return {Number}
 */
MobileCommentJindo.Calendar.getTime = function(htDate) {
	return this.getDateObject(htDate).getTime();
};

/**
 * 해당 연월의 첫번째 날짜의 요일을 구한다.
 * @param {Number} nYear
 * @param {Number} nMonth
 * @return {Number} 요일 (0~6)
 */
MobileCommentJindo.Calendar.getFirstDay = function(nYear, nMonth) {
	return new Date(nYear, nMonth - 1, 1).getDay();
};

/**
 * 해당 연월의 마지막 날짜의 요일을 구한다.
 * @param {Number} nYear
 * @param {Number} nMonth
 * @return {Number} 요일 (0~6)
 */
MobileCommentJindo.Calendar.getLastDay = function(nYear, nMonth) {
	return new Date(nYear, nMonth, 0).getDay();
};

/**
 * 해당 연월의 마지막 날짜를 구한다.
 * @param {Number} nYear
 * @param {Number} nMonth
 * @return {Number} 날짜 (1~31)
 */
MobileCommentJindo.Calendar.getLastDate = function(nYear, nMonth) {
	return new Date(nYear, nMonth, 0).getDate();
};

/**
 * 해당 연월의 주의 수를 구한다.
 * @param {Number} nYear
 * @param {Number} nMonth
 * @return {Number} 주 (4~6)
 */
MobileCommentJindo.Calendar.getWeeks = function(nYear, nMonth) {
	var nFirstDay = this.getFirstDay(nYear, nMonth),
		nLastDate = this.getLastDate(nYear, nMonth);

	return Math.ceil((nFirstDay + nLastDate) / 7);
};

/**
 * 연월일을 포함한 HashTable로부터 상대적인 날짜의 HashTable을 구한다.
 * @param {Number} nYear 상대적인 연도 (+/-로 정의)
 * @param {Number} nMonth 상대적인 월 (+/-로 정의)
 * @param {Number} nDate 상대적인 일 (+/-로 정의)
 * @param {HashTable} 연월일 HashTable
 * @return {HashTable}
 * @example
MobileCommentJindo.Calendar.getRelativeDate(1, 0, 0, {nYear:2000, nMonth:1, nDate:1}); => {nYear:2001, nMonth:1, nDate:1}
MobileCommentJindo.Calendar.getRelativeDate(0, 0, -1, {nYear:2010, nMonth:1, nDate:1}); => {nYear:2009, nMonth:12, nDate:31}
 */
MobileCommentJindo.Calendar.getRelativeDate = function(nYear, nMonth, nDate, htDate) {
	return this.getDateHashTable(new Date(htDate.nYear + nYear, htDate.nMonth + nMonth - 1, htDate.nDate + nDate));
};

/**
 * 유효한 날짜인지 확인힌다.
 * @param {Number} nYear
 * @param {Number} nMonth
 * @param {Number} nDate
 * @return {Boolean}
 */
MobileCommentJindo.Calendar.isValidDate = function(nYear, nMonth, nDate) {
	if (nMonth <= 12 && nDate <= this.getLastDate(nYear, nMonth)) {
		return true;
	} else {
		return false;
	}
};

/**
 * 연월일을 포함한 HashTable이 비교대상 HashTable보다 과거인지 확인한다.
 * @param {HashTable} htDate 비교를 원하는 날
 * @param {HashTable} htComparisonDate 비교할 기준
 * @return {Boolean}
 */
MobileCommentJindo.Calendar.isPast = function(htDate, htComparisonDate) {
	if (this.getTime(htDate) < this.getTime(htComparisonDate)) {
		return true;
	}
	return false;
};

/**
 * 연월일을 포함한 HashTable이 비교대상 HashTable보다 미래인지 확인한다.
 * @param {HashTable} htDate 비교를 원하는 날
 * @param {HashTable} htComparisonDate 비교할 기준
 * @return {Boolean}
 */
MobileCommentJindo.Calendar.isFuture = function(htDate, htComparisonDate) {
	if (this.getTime(htDate) > this.getTime(htComparisonDate)) {
		return true;
	}
	return false;
};

/**
 * 연월일을 포함한 HashTable이 비교대상 HashTable과 같은 날인지 확인한다.
 * @param {HashTable} htDate 비교를 원하는 날
 * @param {HashTable} htComparisonDate 비교할 기준
 * @return {Boolean}
 */
MobileCommentJindo.Calendar.isSameDate = function(htDate, htComparisonDate) {
	if (this.getTime(htDate) == this.getTime(htComparisonDate)) {
		return true;
	}
	return false;
};

/**
 * 연월일을 포함한 HashTable이 특정 두 날 사이에 존재하는지 확인한다..
 * @param {HashTable} htDate 비교를 원하는 날
 * @param {HashTable} htFrom 시작 날짜
 * @param {HashTable} htTo 끝 날짜
 * @return {Boolean}
 * @example
MobileCommentJindo.Calendar.isBetween({nYear:2010, nMonth:5, nDate:12}, {nYear:2010, nMonth:1, nDate:1}, {nYear:2010, nMonth:12, nDate:31}); => true
 */
MobileCommentJindo.Calendar.isBetween = function(htDate, htFrom, htTo) {
	if (this.isFuture(htDate, htTo) || this.isPast(htDate, htFrom)) {
		return false;
	} else {
		return true;
	}
};
/**
* @(#)MobileCommentJindo.m.SlideEffect.js 2011. 12. 15.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author "oyang2"
* @since 2011. 12. 15.
* @description
* <2012.01.16 수정사항>
* - android3.0, android4.0 대응 추가
*/

MobileCommentJindo.m.SlideEffect = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.SlideEffect.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @extends MobileCommentJindo.m.Effect
	 * @requires MobileCommentJindo.m.LayerEffect
	 *
	 */
	sEffectName : "slide",

	/**
	 * @description 레이어를 설정된 방향으로 움직인다
	 * @param {HTMLElement} el slide 대상 엘리먼트
	 * @param {HashTable} slide 옵션
	 * 		- sDirection : 'left', //'left, 'right, 'up', 'down' 설정가능하다
	 *		- nDuration : 500, //효과 애니메이션 적용시간 (ms)
	 *		- nSize : 200, //slide 할 거리, 디폴트 값은 레이어 크기가 됨 (px)
	 *		- sTransitionTimingFunction : 'ease-in-out', //효과 effect ('ease', 'linear', ease-in', 'ease-out', 'ease-in-out')
	 *		- elBaseLayer : MobileCommentJindo.$('wrapper'), //기준 뷰가 되는 엘리먼트, 없을 경우 설정하지 않는다.
	 *		- htTo : {opacity : 1} , //레이어의 slide 이후의 css를 설정
	 *		- htFrom : {opacity : 0.7}  //레이어의 slide 이전의 css를 설정
	 */
	getCommand : function(el, htOption){
		var sDirection = htOption.sDirection? htOption.sDirection :'left';

		var htCurOffset = MobileCommentJindo.m.getCssOffset(el);

		var toX = htCurOffset.left;
		var toY = htCurOffset.top;

		var nW = (typeof htOption.nSize != 'undefined')? htOption.nSize : this._htLayerInfo['nWidth'];
		var nH =  (typeof htOption.nSize != 'undefined')? htOption.nSize : this._htLayerInfo['nHeight'];

		if(sDirection == 'up' || sDirection == 'down'){
			toY  += ((sDirection == 'up')? nH*-1 : nH);
		}

		if(sDirection == 'left' || sDirection == 'right'){
			toX += ((sDirection == 'left')? nW*-1 : nW);
		}

		var htTransform = {};

		if(typeof htOption.elBaseLayer != 'undefined'){
			toX = 0;
			toY = 0;
			var welBaseLayer = MobileCommentJindo.$Element(htOption.elBaseLayer);
			var wel = MobileCommentJindo.$Element(el);
			var nH = (typeof htOption.nSize != 'undefined')? htOption.nSize : welBaseLayer.height();
			var nW = (typeof htOption.nSize != 'undefined')? htOption.nSize : welBaseLayer.width();

			if(sDirection == 'up' || sDirection == 'down'){
				toY = (sDirection == 'down')?  nH * -1 : nH;
			}

			if(sDirection == 'left' || sDirection == 'right'){
				toX = (sDirection == 'left')? nW: nW*-1;
			}
			toX = toX*-1;
			toY = toY*-1;
		}

		htTransform["transform"] = this.sTranOpen + toX + 'px, ' + toY + 'px'+ this.sTranEnd;

		//fCallback 등록
		var sPosition = this._htLayerInfo["sPosition"];
		var bAndroid = this.bAndroid;
		var bAndroid3Up = this.bAndroid3Up;
		var sClassHighligting = this._htLayerInfo['sClassHighligting'];
		var bAndroid2_1 = this.bAndroid2_1;

		var wel = MobileCommentJindo.$Element(el);

		return {
			sTaskName : this.sEffectName+"-"+ sDirection,
			htStyle : htOption.htTo || {},
			htTransform : htTransform
			,fCallback : function(){
				var htCurOffset = MobileCommentJindo.m.getCssOffset(el);
				var top = wel.css('top').replace('px','')*1;
				var left = wel.css('left').replace('px','')*1;
				top = isNaN(top)? 0 : top;
				left = isNaN(left)? 0 : left;

				//console.log('before '+top+" , "+left);
				if(sPosition == "relative"){
					wel.css("position", 'relative');
				}else{
					wel.css("position","absolute");
				}

				var sPrefix = MobileCommentJindo.m.getCssPrefix();
				wel.css(sPrefix+'Transform','');

				//안드로이드 4.0버그 left, top을 설정하기 전에 offset을 호출해야 설정이 된다.
				if(bAndroid3Up){
					wel.offset();
				}
				wel.$value().style.top = parseInt((top+htCurOffset.top),10)+"px";
				wel.$value().style.left = parseInt((htCurOffset.left+ left),10)+"px";


				if(bAndroid && !bAndroid3Up){
				//if(bAndroid){
					var elFocus = MobileCommentJindo.$$.getSingle('.'+ sClassHighligting, wel.$value());
					if(elFocus){
						if(bAndroid2_1){
							setTimeout(function(){
								elFocus.focus();
							},5);
						}else{
							elFocus.focus();
						}
					}
				}
			}
		}
	},

	/**
	 * @description 레이어를 설정된 방향으로 움직이기 전에 미리 설정해야 할 옵션들을 설정한다.
	 * @param {HTMLElement} el slide 대상 엘리먼트
	 * @param {HashTable} slide 옵션
	 * 		- sDirection : 'left', //'left, 'right, 'up', 'down' 설정가능하다
	 *		- nDuration : 500, //효과 애니메이션 적용시간 (ms)
	 *		- nSize : 200, //slide 할 거리, 디폴트 값은 레이어 크기가 됨 (px)
	 *		- sTransitionTimingFunction : 'ease-in-out', //효과 effect ('ease', 'linear', ease-in', 'ease-out', 'ease-in-out')
	 *		- elBaseLayer : MobileCommentJindo.$('wrapper'), //기준 뷰가 되는 엘리먼트, 없을 경우 설정하지 않는다.
	 *		- htTo : {opacity : 1} , //레이어의 slide 이후의 css를 설정
	 *		- htFrom : {opacity : 0.7}  //레이어의 slide 이전의 css를 설정
	 */
	getBeforeCommand : function(el, htOption){
		var sDirection = htOption.sDirection? htOption.sDirection :'left';

		var htBeforeStyle = htOption.htFrom || {};
		var htTransform = {};

		var wel = MobileCommentJindo.$Element(el);

		if(typeof htOption.elBaseLayer != 'undefined'){
			var welBaseLayer = MobileCommentJindo.$Element(htOption.elBaseLayer);

			if(!welBaseLayer.isParentOf(wel)){
				welBaseLayer.append(wel);
				var sPosition = wel.css('position');
				if(!(sPosition == 'relative' || sPosition == 'absolute') ){
					wel.css('position', 'absolute');
				}
				wel.css('opacity',0);
			}

			var fromX = 0, fromY = 0;

			var nH = welBaseLayer.height();
			var nW = welBaseLayer.width();


			if(sDirection == 'up' || sDirection == 'down'){
				fromY = (sDirection == 'down')?  nH * -1 : nH;
			}

			if(sDirection == 'left' || sDirection == 'right'){
				fromX = (sDirection == 'left')? nW: nW*-1;
			}
			welBaseLayer.css('overflow','hidden');
			htBeforeStyle["left"] = fromX+"px";
			htBeforeStyle["top"] = fromY +"px";

			//console.log('beforedddd', welBaseLayer.offset());
			htBeforeStyle["opacity"] = this._htLayerInfo['nOpacity'];
			//htTransform["transform"] = this.sTranOpen + fromX + 'px, ' + fromY+ 'px'+ this.sTranEnd;

		}
		return {
			htStyle : htBeforeStyle ,
			htTransform : htTransform
		}
	}


}).extend(MobileCommentJindo.m.Effect);


/**
* @(#)MobileCommentJindo.m.PopEffect.js 2011. 12. 15.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author "oyang2"
* @since 2011. 12. 15.
* @description
* @2012.01.05
* - Android 3.0 대응 pop-in 코드 삽입 (0.1~1로 추가되도록 수정)
*/

MobileCommentJindo.m.PopEffect = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.PopEffect.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @extends MobileCommentJindo.m.Effect
	 * @requires MobileCommentJindo.m.LayerEffect
	 */

	sEffectName : "pop",

	getCommand : function(el, htOption){
		var sDirection = htOption.sDirection? htOption.sDirection :'in';

		var htStyle = htOption.htTo || {};
		if(typeof htStyle["opacity"] === 'undefined'){
			htStyle["opacity"] = (sDirection == 'in')? 1 : 0.1;
		}
		//htStyle["opacity"] = (sDirection == 'in')? 1 : 0.1;

		var nScale = (sDirection == 'in')? 1 : ((this.bIos3 || this.bAndroid3Up)? 0.1: 0);
		var htCallback = {};
		if(sDirection == 'out'){
			htCallback.htStyle ={};
			htCallback.htStyle["display"]  = "none";
			htCallback.htStyle["opacity"]  = this._htLayerInfo['nOpacity'];
			htCallback.htTransform = {};
			htCallback.htTransform["transform"] = "scale(1)";
		}

		var sTransform = 'scale('+nScale+')';
		if(this.bAndroid3Up){
			sTransform += ' scaleZ(1.0)';
		}

		return {
			sTaskName : this.sEffectName + "-" +sDirection,
			htStyle : htStyle,
			htTransform : {
				'transform' : sTransform,
				'transform-origin' : '50% 50%'
			},
			fCallback : htCallback
		};
	},

	getBeforeCommand : function(el, htOption){
		var sDirection = htOption.sDirection? htOption.sDirection :'in';

		var htBeforeStyle = htOption.htFrom || {};
		if(typeof htBeforeStyle["opacity"] === 'undefined'){
			htBeforeStyle["opacity"] = (sDirection == 'in')? 0.1 : 1;
		}

		htBeforeStyle["display"] = this._htLayerInfo['sDisplay'];

		var nScale = (sDirection == 'in')? ((this.bIos3||this.bAndroid3Up)? 0.1: 0) : 1;

		var sTransform = 'scale('+nScale+')';
		if(this.bAndroid3Up){
			sTransform += ' scaleZ(1.0)';
		}

		return {
			htStyle : htBeforeStyle ,
			htTransform : {
				'transform' : sTransform,
				'transform-origin' : '50% 50%'
			}
		};
	}
}).extend(MobileCommentJindo.m.Effect);
/**
* @(#)MobileCommentJindo.m.FlipEffect.js 2011. 12. 15.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author "oyang2"
* @since 2011. 12. 15.
* @description
*/

MobileCommentJindo.m.FlipEffect = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.FlipEffect.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @extends MobileCommentJindo.m.Effect
	 * @requires MobileCommentJindo.m.LayerEffect
	 */
	sEffectName : "flip",

	getCommand : function(el, htOption){
		var sDirection = htOption.sDirection? htOption.sDirection :"left";

		var sCoord = 'Y';
		if(sDirection == 'up' || sDirection == 'down'){
			sCoord = 'X';
		}

		var htStyle = htOption.htTo || {};


		var welFrom = htOption.elFlipFrom? MobileCommentJindo.$Element(htOption.elFlipFrom) : MobileCommentJindo.$Element(el);
		var welTo =   htOption.elFlipTo? MobileCommentJindo.$Element(htOption.elFlipTo) : null;

		var htTo = this._getCssRotate(this._getCssTransfrom(welFrom));

		htTo[sCoord] = htTo[sCoord]+ ((sDirection == 'left' || sDirection == 'down')?180*-1 : 180);
		var sTransfrom = 'rotateX('+ htTo.X+'deg) rotateY('+htTo.Y+'deg)';

		if(welTo){
			welTo.$value().style[this._sCssPrefix +"Transform"] = 'rotate'+sCoord+'(0deg)';
			sTransfrom = 'rotate'+sCoord+'(0deg)';
		}

		return {
			sTaskName : this.sEffectName + "-" + sDirection,
			htStyle : htStyle,
			htTransform : {
				"transform-style" : "preserve-3d",
				"transform" : sTransfrom
			}
		}
	},

	getBeforeCommand : function(el, htOption){
		var sDirection = htOption.sDirection? htOption.sDirection :"left";

		var htBeforeStyle = htOption.htFrom || {};

		var sCoord = "Y",
			nFrom = 0;

		if(sDirection == 'up' || sDirection == 'down'){
			sCoord = "X";
		}

		var welFrom = htOption.elFlipFrom? MobileCommentJindo.$Element(htOption.elFlipFrom) : MobileCommentJindo.$Element(el);
		var welTo =   htOption.elFlipTo? MobileCommentJindo.$Element(htOption.elFlipTo) : null;

		var elParent = welFrom.$value().parentNode;
		elParent.style.webkitPerspective = '1200';

		var htFrom = this._getCssRotate(this._getCssTransfrom(welFrom));
		var sTransfrom = 'rotateX('+ htFrom.X+'deg) rotateY('+htFrom.Y+'deg)';

		if(welTo){
			welTo.$value().style[this._sCssPrefix +"Transform"] = 'rotate'+sCoord+'(-180deg)';
			sTransfrom = 'rotate'+sCoord+'(-180deg)';
		}

		return {
			htStyle : htBeforeStyle ,
			htTransform : {
				"perspective" : "1200",
				"transform-style" : "preserve-3d",
				"transform" : sTransfrom
			}
		}
	},



	_getCssRotate : function(str){
		var sRotate = str;

		var htReturn ={
			X : 0,
			Y : 0
		};

		if(!sRotate){
			return htReturn;
		}

		var aTemp = sRotate.match(/rotateX\((\-?\d*)deg/);

		if(aTemp && aTemp.length >1){
			htReturn['X'] =aTemp[1]*1;
			if(htReturn['X']%360 == 0){
				htReturn['X'] = 0;
			}
		}

		aTemp = sRotate.match(/rotateY\((\-?\d*)deg/);
		if(aTemp && aTemp.length >1){
			htReturn['Y'] =aTemp[1]*1;
			if(htReturn['Y']%360 == 0){
				htReturn['Y'] = 0;
			}
		}

		return htReturn;
	},

	_getCssTransfrom : function(wel){

		return wel.css(this._sCssPrefix +"Transform") || "";
	}

}).extend(MobileCommentJindo.m.Effect);
/**
* @(#)MobileCommentJindo.m.LayerEffect.js 2011. 12. 13.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author "oyang2"
* @since 2011. 12. 13.
* @description
* <1.1.0 릴리즈, 코드수정>
* - clearLeffect() 함수 추가
*/

MobileCommentJindo.m.LayerEffect = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.LayerEffect.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
	 * @requires MobileCommentJindo.m.Transition
     */
	$init : function(el, htUserOption) {
		this.option({
			nDuration : 250,
			bActivateOnload : true
		});
		this.option(htUserOption || {});
		this._initVar();
		this.setLayer(el);

		this._initTransition();

		if(this.option("bActivateOnload")) {
			this.activate();
		}
	},

	_htEffect :{
		'expand' : "MobileCommentJindo.m.ExpandEffect",
		'contract' : "MobileCommentJindo.m.ContractEffect",
		"fade" : "MobileCommentJindo.m.FadeEffect",
		"pop" : "MobileCommentJindo.m.PopEffect",
		"slide" : "MobileCommentJindo.m.SlideEffect",
		"flip" : "MobileCommentJindo.m.FlipEffect"
	},

	/**
	 * @description MobileCommentJindo.m.LayerEffect 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar: function() {
		this._htEffectInstance  = {};
		this._htLayerInfo = {};
		this._htWElement = {}; //MobileCommentJindo.m.LayerEffect에서 사용하는 엘리먼트 참조

		this.bAndroid = MobileCommentJindo.m.getDeviceInfo().android;
		this.sClassHighligting = '_effct_hide_highlighting_tmp';
	},

	_initTransition : function(){
		this._oTransition = new MobileCommentJindo.m.Transition();
	},

	_createEffect : function(sType){
		if(this._htEffect[sType] && !this._htEffectInstance[sType]) {

			//console.log("객체 생성 : new " +this._htEffect[sType] + "()" );
			try{
				this._htEffectInstance[sType] = eval("new " + this._htEffect[sType] + "()");
			}catch(e){
				//console.log(e);
			}

			this._htEffectInstance[sType].setLayerInfo(this._htLayerInfo);
		}
	},

	/**
	 * @param {HashTable} htOption
	 * @description 높이나 넓이값을 조정하여 레이어를 확대한다. 현재 레이어가 안보이는 상태일 경우 레이어를 보이게 하고 애니메이션을 수행한다.
	 * @example
oLayerEffect.expand() //아래쪽으로 높이값을 조정하여 확대한다.
	 * @example
oLayerEffect.expand({
	sDirection : 'up',  // 'up','down','left',right'설정가능하며 기본값은 'down'이다
	nDuration : 500, //효과 애니메이션 적용시간 (ms)
	sTransitionTimingFunction : 'ease-in-out', //효과 effect ('ease', 'linear', ease-in', 'ease-out', 'ease-in-out')
	htFrom : {opacity : 0, zIndex: 10}, //expand 이전의 css를 설정한다.
	htTo : {opacity : 1, zIndex: 20} //expand 이후의 css를 설정한다.
});
	 */
	expand : function(htOption){
		var sType = 'expand';
		this._run(sType, htOption);
	},

	/**
	 * @param {HashTable} htOption
	 * @description 높이나 넓이값을 조정하여 레이어를 축소한다. 현재 레이어가 안보이는 상태일 경우 레이어를 보이게 하고 애니메이션을 수행한다.
	 * @example
oLayerEffect.contract() //레이어를 아래쪽으로 방향으로 축소한다.
	 * @example
oLayerEffect.contract({
	sDirection : 'up',  // 'up','down','left',right'설정가능하며 기본값은 'down'이다
	nDuration : 500, //효과 애니메이션 적용시간 (ms)
	sTransitionTimingFunction : 'ease-in-out', //효과 effect ('ease', 'linear', ease-in', 'ease-out', 'ease-in-out')
	htFrom : {opacity : 0, zIndex: 10}, //contract 이전의 css를 설정한다.
	htTo : {opacity : 1, zIndex: 20} //contract 이후의 css를 설정한다.
});
	 */
	contract : function(htOption){
		var sType = 'contract';
		this._run(sType, htOption);
	},

	/**
	 * @description 레이어의 투명도를 조정하여 숨기거나 보여준다. fadeOut 이후에는 레이어를 감춘다.
	 * @param {HashTable} htOption
	 * @example
oLayerEffect.fade(); //기본으로 fade In 효과 투명도를 높여 보여주는 효과를 준다
	 * @example
oLayerEffect.fade({
	sDirection : 'out',  // 'in' 또는 'out'을 정할수 있으며 기본값은 'in' 이다.
	nDuration : 500, //효과 애니메이션 적용시간 (ms)
	sTransitionTimingFunction : 'ease-in-out', //효과 effect ('ease', 'linear', ease-in', 'ease-out', 'ease-in-out')
	htFrom : {opacity : 0, z-index: 10}, //fade 이전의 css를 설정한다. opacity 설정하지 않을 경우 기본값은 0이다
	htTo : {opacity : 1, z-index: 20} //fade 이후의 css를 설정한다.  opacity 설정하지 않을 경우 기본값은 1이다
});
	 */
	fade : function(htOption){
		var sType = "fade";
		//console.log('\\\\\\ Fade', htOption );
		this._run(sType, htOption);
	},

	/**
	 * @param {HashTable}
	 * @description scale 조정을 통해 pop 효과를 낸다. popOut 이후에는 레이어를 감춘다.
	 * 	- ios3의 경우 scale 값이 0이 아닌 0.1로 세팅합니다.
	 * 	- htFrom과 htTo의 scale을 설정하지 않으면 'in'일 경우 0-1로 설정하며 'out'일 경우 1-0으로 설정합니다.(ios3 예외)
	 * @example
oLayerEffect.pop() //pop in 효과를내며 scale을 점점 줄여서 레이어가 없어지는 효과를 낸다.
	 * @example
oLayerEffect.pop({
	sDirection : 'in',  // 'in','out' 설정가능하며 기본값은 'in'이다
	nDuration : 500, //효과 애니메이션 적용시간 (ms)
	sTransitionTimingFunction : 'ease-in-out', //효과 effect ('ease', 'linear', ease-in', 'ease-out', 'ease-in-out')
	htFrom : {opacity : 0, zIndex: 10}, //pop 이전의 css를 설정한다. opacity의 기본값은 'in'의 경우 0.1이며 'out'의 경우 1이다
	htTo : {opacity : 1, zIndex: 20} //pop 이후의 css를 설정한다. opacity의 기본값은 'in'의 경우 1이며 'out'의 경우 0.1이다
});
	 */
	pop : function(htOption){
		var sType = "pop";
		this._run(sType, htOption);
	},

	/**
	 * @param {HashTable} htOption
	 * @description 레이어를 설정된 방향으로 움직인다
	 * @example
oLayerEffect.slide(); //기본방향이 왼쪽이기 때문에 왼쪽으로 레이어의 넓이만큼 움직인다.
	 * @example
oLayerEffect.slide({
	elBaseLayer :  MobileCommentJindo.$('wrapper') //기준 뷰 엘리먼트를 설정할 경우 레이어는 기준뷰를 중심으로 slide 동작을 합니다.
});
	 * @example
oLayerEffect.slide({
	sDirection : 'left', //'left, 'right, 'up', 'down' 설정가능하다
	nDuration : 500, //효과 애니메이션 적용시간 (ms)
	nSize : 200, //slide 할 거리, 디폴트 값은 레이어 크기가 됨 (px)
	sTransitionTimingFunction : 'ease-in-out', //효과 effect ('ease', 'linear', ease-in', 'ease-out', 'ease-in-out')
	elBaseLayer : MobileCommentJindo.$('wrapper'), //기준 뷰가 되는 엘리먼트, 없을 경우 설정하지 않는다.
	htTo : {opacity : 1} , //레이어의 slide 이후의 css를 설정
	htFrom : {opacity : 0.7}  //레이어의 slide 이전의 css를 설정
});
	 */
	slide : function(htOption){
		var sType = "slide";
		this._run(sType, htOption);
	},

	/**
	 * @param{HashTable} htOption
	 * @description  레이어을 방향에 따라 뒤집는 효과를 낸다. (iOS 전용)
	 * @example
oLayerEffect.flip(); //현재 레이어 엘리먼트를 좌우로 뒤집는다
	 * @example
oLayerEffect.flip({
	sDirection : 'up',  // 'up','down','left',right'설정가능하며 기본값은 'left'이다
	nDuration : 500, //효과 애니메이션 적용시간 (ms)
	sTransitionTimingFunction : 'ease-in-out', //효과 effect ('ease', 'linear', ease-in', 'ease-out', 'ease-in-out')
	elFlipFrom : MobileCommentJindo.$('flip'), //두개의 레이어가 뒤집히는 효과를 낼때 뒤쪽으로 뒤집히는 엘리먼트, 한개 레이어 효과가 필요할때는 설정하지 않는다.
	elFlipTo : MobileCommentJindo.$('layer1') //두개의 레이어가 뒤집히는 효과를 낼때 앞쪽으로 뒤집히는 엘리먼트, 한개 레이어 효과가 필요할때는 설정하지 않는다
	htFrom : {opacity : 0, zIndex: 10}, //flip 이전의 css를 설정한다. opacity 값은 기본값은 0이다
	htTo : {opacity : 1, zIndex: 20} //flip 이후의 css를 설정한다. opacity 값은 기본값은 1이다
});
	 */
	flip: function(htOption){
		var sType = "flip";
		this._run(sType, htOption);
	},

	/**
	 * @description 현재 effect가 실행 여부를 리턴한다
	 * @return {Boolean}
	 */
	isPlaying : function(){
		return this._oTransition.isPlaying();
	},


	_fireCustomEvent : function(sType, htOption){
		return this.fireEvent(sType, htOption);
	},

	_run : function(sType, htOption){
		if(!this._isAvailableEffect()){
			return;
		}

		this._createEffect(sType);

		if(typeof htOption === 'undefined'){
			htOption = {};
		}

		var oEffect = this._htEffectInstance[sType];

		var el = this.getLayer();
		var nDuration = (typeof htOption.nDuration  === 'undefined')? this.option('nDuration') : parseInt(htOption.nDuration,10);
		var htBefore = oEffect.getBeforeCommand(el, htOption);
		var htCommand = oEffect.getCommand(el, htOption);

		//customEvent
		if(!this._fireCustomEvent("beforeEffect", {
			elLayer : el,
			sEffect :htCommand.sTaskName,
			nDuration :nDuration
		})){
			return;
		}

		//console.log('LAYER=------- , rund');

		if(htBefore){
			this._oTransition.queue(this.getLayer(), 0, htBefore);
		}

		this._oTransition.queue(this.getLayer(), nDuration , htCommand);

		this._oTransition.start();
	},

	/**
	 * @param {HTMLElement} el
	 * @description el을 을 effect 대상 레이어로 설정한다.
	 */
	setLayer : function(el){
		this._htWElement["el"] = MobileCommentJindo.$(el);
		this._htWElement["wel"] = MobileCommentJindo.$Element(this._htWElement["el"]);

		//android 하이라이팅 문제로 인하여 엘리먼트 추가;
		if(!!this.bAndroid){
			var elFocus = MobileCommentJindo.$$.getSingle('.'+this.sClassHighligting, this._htWElement['el']);

			if(!elFocus){
				var sTpl = '<a href="javascript:void(0)" style="position:absolute" class="'+this.sClassHighligting+'"></a>';
				var elFocus = MobileCommentJindo.$(sTpl);
				this._htWElement['wel'].append(elFocus);
				elFocus.style.opacity = '0';
				elFocus.style.width= 0;
				elFocus.style.height= 0;
				elFocus.style.left = "-1000px";
				elFocus.style.top = "-1000px";
			}
		}

		this.setSize();
	},

	/**
	 * @description 현재 트랜지션을 멈춘다. bAfter 가 true일 경우 이펙트 이후 상태로 멈추고, false 일경우 이펙트 이전 상태로 되돌린다.
	 * @return {Boolean} bAfter
	 */
	stop : function(bAfter){
		if(typeof bAfter === 'undefined'){
			bAfter = true;
		}
		if(this._oTransition){
			this._oTransition.stop(bAfter);
		}
	},

	/**
	 * @description 현재 큐에 쌓여있는 모든 effect 실행을 삭제한다.현재 이펙트가 실행중이면 중지하고 삭제한다.
	 * bAfter 가 true일 경우 이펙트 이후 상태로 멈추고, false 일경우 이펙트 이전 상태로 되돌린다.
	 * @return {Boolean} bAfter
	 */
	clearEffect : function(bAfter){
		if(this._oTransition){
			this._oTransition.clear(bAfter);
		}
	},
	/**
	 * @return {HTMLElement}
	 * @description 현재 레이어를 리턴한다.
	 */
	getLayer : function(){
		return this._htWElement["el"];
	},

	/**
	 * @description 레이어를 사이즈 및 CSS 정보를 설정한다.
	 */
	setSize : function(){
		var elToMeasure = this._htWElement['el'].cloneNode(true);
		var welToMeasure = MobileCommentJindo.$Element(elToMeasure);
		welToMeasure.opacity(0);
		this._htWElement['wel'].after(welToMeasure);
		welToMeasure.show();

		this._htLayerInfo["nWidth"] = this._htWElement["wel"].width();
		this._htLayerInfo["nHeight"] = this._htWElement["wel"].height();

		welToMeasure.css({
			position : "absolute",
			top : "0px",
			left : "0px"
		});

		this._htLayerInfo['nMarginLeft'] = parseInt(welToMeasure.css('marginLeft'),10);
		this._htLayerInfo['nMarginTop'] = parseInt(welToMeasure.css('marginTop'),10);
		this._htLayerInfo['nOpacity'] = this._htWElement["wel"].opacity();
		this._htLayerInfo['sPosition'] = this._htWElement["wel"].css('position');
		var sDisplay = this._htWElement['wel'].css('display');

		sDisplay = ((sDisplay === 'none') || (sDisplay.length === 0))? 'block' : sDisplay;
		this._htLayerInfo['sDisplay'] = sDisplay;
		this._htLayerInfo['sClassHighligting'] = this.sClassHighligting;

		welToMeasure.leave();

		this._setEffectLayerInfo();

		//console.log('/////setSize', this._htLayerInfo);
	},


	_setEffectLayerInfo : function(){
		for(var p in this._htEffectInstance){
			this._htEffectInstance[p].setLayerInfo(this._htLayerInfo);
		}
	},

	_onTransitionEnd : function(oCustomEvent){
		if(oCustomEvent.sTaskName){
			this._fireCustomEvent("afterEffect", {
				elLayer : oCustomEvent.element,
				sEffect : oCustomEvent.sTaskName,
				nDuration : oCustomEvent.nDuration
			});
		}
	},

	/**
	 * @description 현재 effect를 실행 시킬수 있는 상태인지 리턴한다
	 * @return {Boolean}
	 */
	_isAvailableEffect : function(){
		return this.isActivating();
	},

	/**
	 * @description MobileCommentJindo.m.LayerEffect 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this._attachEvent();
	},

	/**
	 * @description MobileCommentJindo.m.LayerEffect 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
	},

	/**
	 * @description MobileCommentJindo.m.LayerEffect 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};
		this._htEvent["end"] = MobileCommentJindo.$Fn(this._onTransitionEnd, this).bind();

		if(this._oTransition){
			this._oTransition.attach({
				"end" : this._htEvent["end"]
			});
		}
	},

	/**
	 * @description MobileCommentJindo.m.LayerEffect 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		this._htEvent = null;

		if(this._oTransition){
			this._oTransition.detachAll();
		}
	},

	/**
	 * @description  MobileCommentJindo.m.LayerEffect 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this.deactivate();

		for(var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		this._htWElement = null;

	}
}).extend(MobileCommentJindo.UIComponent);



/**
* @(#)MobileCommentJindo.m.Transition.js 2011. 12. 13.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author "oyang2"
* @since 2011. 12. 13.
* @description
* <1.1.0 릴리즈, 코드수정>
* - 안드로이드 버전에서는 css3+javascript 혼용방식으로 translate를 설정할 수 있도록 수정
* - css timing function을 구현한 MobileCommentJindo.m.TimingFunction을 추가함
* - clear() 함수 추가
*/
if(typeof MobileCommentJindo.m.TimingFunction === 'undefined'){
	 MobileCommentJindo.m.TimingFunction ={};
}

MobileCommentJindo.m.TimingFunction._cubicBezier = function(x1, y1, x2, y2){
	return function(t){
		var cx = 3.0 * x1,
	    	bx = 3.0 * (x2 - x1) - cx,
	    	ax = 1.0 - cx - bx,
	    	cy = 3.0 * y1,
	    	by = 3.0 * (y2 - y1) - cy,
	    	ay = 1.0 - cy - by;

	    function sampleCurveX(t) {
	    	return ((ax * t + bx) * t + cx) * t;
	    }
	    function sampleCurveY(t) {
	    	return ((ay * t + by) * t + cy) * t;
	    }
	    function sampleCurveDerivativeX(t) {
	    	return (3.0 * ax * t + 2.0 * bx) * t + cx;
	    }
	    function solveCurveX(x,epsilon) {
	    	var t0, t1, t2, x2, d2, i;
	    	for (t2 = x, i = 0; i<8; i++) {
	    		x2 = sampleCurveX(t2) - x;
	    		if (Math.abs(x2) < epsilon) {
	    			return t2;
	    		}
	    		d2 = sampleCurveDerivativeX(t2);
	    		if(Math.abs(d2) < 1e-6) {
	    			break;
	    		}
	    		t2 = t2 - x2 / d2;
	    	}
		    t0 = 0.0;
		    t1 = 1.0;
		    t2 = x;
		    if (t2 < t0) {
		    	return t0;
		    }
		    if (t2 > t1) {
		    	return t1;
		    }
		    while (t0 < t1) {
		    	x2 = sampleCurveX(t2);
		    	if (Math.abs(x2 - x) < epsilon) {
		    		return t2;
		    	}
		    	if (x > x2) {
		    		t0 = t2;
		    	} else {
		    		t1 = t2;
		    	}
		    	t2 = (t1 - t0) * 0.5 + t0;
		    }
	    	return t2; // Failure.
	    }
	    return sampleCurveY(solveCurveX(t, 1 / 200));
	};
};

MobileCommentJindo.m.TimingFunction.linear =  MobileCommentJindo.m.TimingFunction._cubicBezier(0.0,0.0,1.0,1.0);
MobileCommentJindo.m.TimingFunction.ease_out =  MobileCommentJindo.m.TimingFunction._cubicBezier(0.0,0.0,0.58,1.0);
MobileCommentJindo.m.TimingFunction.ease_in =  MobileCommentJindo.m.TimingFunction._cubicBezier(0.42,0.0,1.0,1.0);
MobileCommentJindo.m.TimingFunction.ease_in_out =  MobileCommentJindo.m.TimingFunction._cubicBezier(0.42,0.0,0.58,1.0);
MobileCommentJindo.m.TimingFunction.ease_out_in =  MobileCommentJindo.m.TimingFunction._cubicBezier(0.00,0.42,1.0,0.58);
MobileCommentJindo.m.TimingFunction.cubicBezier =  function(x1, y1, x2, y2){
	return  MobileCommentJindo.m.TimingFunction._cubicBezier(x1, y1, x2, y2);
};

MobileCommentJindo.m.Transition = MobileCommentJindo.$Class({
	_aTaskQueue : null,

	/** @lends MobileCommentJindo.m.Transition.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.Component
     */
	$init : function(htUserOption) {
		this.option({
			/**
			 * 기본 속성 지정
			 * @to do
			 */
			sTransitionTimingFunction : 'ease-in-out'
		});
		this.option(htUserOption || {});
		this._initVar();
		this._attachEvent();
	},

	/**
	 * @description MobileCommentJindo.m.Transition 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar: function() {
		this._aTaskQueue = [];
		this._bIsPlaying = false;
		this._sCssPrefix = MobileCommentJindo.m.getCssPrefix();

		this._aBeforeStatus = []; //transition 시작전 element의 style 상태를 저장한 배열

		if(this._sCssPrefix.length > 0){
			this._sCssPrefix = '-' + this._sCssPrefix.toLowerCase()+'-';
		}

		this._bAndroid = MobileCommentJindo.m.getDeviceInfo().android;
		//this._bAndroid = false;
		//alert(this._bAndroid );
		//안드로이드 전용 타이머.
		this._nTimerAnimate = null;
		//@to-do 지울것
		//this._bAndroid = true;

		this._htCurrentTask = null;
	},

	/**
	 * @description Transition 을 시작한다.
	 */
	start : function(){
		if((!this.isPlaying()) && this.isExistTask()){
			this._prepareTask();
		}
	},

	/**
	 * @description 현재 트랜지션이 진행중인지 리턴한다.
	 * @return {Boolean}
	 */
	isPlaying : function(){
		return this._bIsPlaying;
	},


	/**
	 * @description 다음 진행할 트랜지션이 있는지 리턴한다.
	 * @return {Boolean}
	 */
	isExistTask : function(){
		if(!this._aTaskQueue){
			return false;
		}
		var nLen = this._aTaskQueue.length;
		bValue = (nLen > 0)? true : false;

		return bValue;
	},

	/**
	 * @description Transition을 큐에 담는다.
	 * 여러 단계의 Transition을 담아두고 순차적으로 실행시킬때 사용한다. start() 메소드가 호출되기 전까지 수행되지 않는다.
	 * @param {HTMLElement} el 트랜지션 대상 에리먼트
	 * @param {Number} nDuration 트랜지션 수행 시간
	 * @param {HashTable} htCommand 적용할 명령 해시 테이블
	 * @return {this}
	 * @example 여러개의 명령을 지정하는 예제
oTransition.queue(MobileCommentJindo.$('div1'),
		1000, {
			htStyle : {
				"left : "200px",
				"top" : "50px",
				"width" : "200px",
				"height" : "200px",
				"background-color" : "#CCC"
			}
		}
);
	 * @example 여러개의 명령을 지정하는 예제(css3 명령 지정예제)
oTransition.queue(MobileCommentJindo.$('div1'),
		1000, {
			htStyle : {
				"width" : "200px",
				"height" : "200px",
				"background-color" : "#CCC"
			},
			htTransform : {
				"transform" : "translate(100px,100px)"
			}
		}
);
	* @example 콜백함수를 지정하는 예제
oTransition.queue(MobileCommentJindo.$('div1'),
		1000, {
			htStyle : {
				"width" : "200px",
				"height" : "200px",
				"background-color" : "#CCC"
			},
			htTransform : {
				"transform" : "translate(100px,100px)"
			},
			fCallback : function(){
				alert("트랜지션 끝");
			}
		}
);
	 * @example 콜백에 스타일을 지정하는 예제
oTransition.queue(MobileCommentJindo.$('div1'),
		1000, {
			htStyle : {
				"width" : "200px",
				"height" : "200px",
				"background-color" : "#CCC"
			},
			htTransform : {
				"transform" : "translate(100px,100px)"
			},
			fCallback : {
				htStyle : {
					"background-color" : "red"
				},
				htTransform : {
					"transform" : "rotate(30deg)"
				}
			}
		}
);
	 */
	queue : function(elTarget, nDuration, aCommand){
		var htTask = {
			sType : 'style',
			sTaskName : '',
			elTarget : elTarget,
			nDuration : nDuration
		};

		htTask.htDefault = {};
		htTask.htStyle = aCommand.htStyle || {};
		htTask.htTransform = aCommand.htTransform || {};
		htTask.sTaskName = aCommand.sTaskName || null;
		htTask.fCallback =  aCommand.fCallback;

		htTask.htDefault['transition-timing-function'] = (typeof htTask.htTransform['transition-timing-function'] === 'undefined')? this._getDefaultTransition().sTransitionTimingFunction : htTask.htTransform['transition-timing-function'];
		htTask.htDefault['transition-property'] = (typeof htTask.htTransform['transition-property'] === 'undefined')? "all" : htTask.htTransform['transition-property'];
		htTask.htDefault['transition-duration']  = nDuration+"ms";

		this._pushTask(htTask);
		return this;
	},

	/**
	 * @description 현재 트랜지션을 중지한다. bAfter가 true이면 현재 트랜지션이 완료된 상태로 중지한다.
	 * false 값이면 현재 트랜지션 이전 상태로 중지한다.
	 * @param {Boolean} bAfter
	 */
	stop : function(bAfter){
		//console.log('stop! ' + this._bIsPlaying);
		if(!this.isPlaying()){
			return;
		}
		//console.log('STOP!2 호출');
		if(typeof bAfter === 'undefined'){
			bAfter = true;
		}


		if(!this._fireCustomEvent('stop', {
			element : this._htCurrentTask.elTarget,
			sTaskName : this._htCurrentTask.sTaskName,
			nDuration : this._htCurrentTask.nDuration
		})){
			return;
		}

		this._stopTransition(bAfter);
	},

	/**
	 * @description 현재 queue에 쌓여있는 모든 태스크를 삭제한다. 현재 트랜지션이 실행중이면 중지하고 삭제한다.
	 * bStopAfter가 true이면 현재 트랜지션이 완료된 상태로 중지하고 false 값이면 현재 트랜지션 이전 상태로 중지한다.
	 * @param {Boolean} bStopAfter
	 */
	clear : function(bStopAfter){
		this.stop(bStopAfter);
		this._aTaskQueue = [];
		//console.log('TranslateCrear!');
	},

	/**
	 * @description 현재 태스크를 재시작한다.
	 */
	_resume : function(){
		if(this._htCurrentTask){
			this._doTask();
		}
	},

	/**
	 * @description 현재 진행중인 태스크를 중지한다. bAfter가 true 이면 태스크 이후의 설정으로 바꾸고 false 이면 태스크 전의 설정으로 바꿔준다.
	 * @param {Boolean} bAfter
	 */
	_stopTransition : function(bAfter){
		//console.log('Stop!');
		this._detachTransitionEnd();

		this._elCurrent.style[this._sCssPrefix+'transition-property'] = 'none';
		this._initTransition();

		//transition 이전 상태로 되돌려야 할 경우
		if(!bAfter){
			//console.log(this._elCurrent);
			var nIndex = this._getBeforeStatusElement(this._elCurrent);
			if(nIndex > -1){
				//console.log(this._aBeforeStatus[nIndex].style);
				MobileCommentJindo.$Element(this._elCurrent).attr('style', this._aBeforeStatus[nIndex].style);
			}
		}

		this._htCurrentTask = null;
		this._bIsPlaying = false;
	},

	/**
	 * @description 진행할 태스크를 준비하고 실행한다.
	 */
	_prepareTask : function(){
		var htTask = this._popTask();

		if(htTask === null || !htTask){
			this._bIsPlaying = false;
			return;
		}
		this._htCurrentTask = htTask;

		this._resume();
	},

	/**
	 * @description htTask를 queue에 추가 한다.
	 * @param {HashTable}
	 */
	_pushTask : function(htTask){
		this._aTaskQueue.push(htTask);
	},

	/**
	 * @description 현재 queue 에저장된 작업에서 진행 해야 할 작업을 리턴한다,
	 * @return {HashTable | null}
	 */
	_popTask : function(){
		if(!this.isExistTask()){
			return null;
		}

		var htTask = this._aTaskQueue.shift();
		if(htTask){
			return htTask;
		}else{
			return null;
		}

	},

	/**
	 * @description 현재 태스크를 실행한다.
	 */
	_doTask : function(){
		//console.log('//// doTask ' +this._htCurrentTask.sTaskName);
		if(this._htCurrentTask){
			this._bIsPlaying = true;

			if(!this._fireCustomEvent('start', {
				element : this._htCurrentTask.elTarget,
				sTaskName : this._htCurrentTask.sTaskName,
				nDuration : this._htCurrentTask.nDuration
			})){
				//this._htCurrentTask;
				return;
			}

			var el = this._htCurrentTask.elTarget;
			var wel = MobileCommentJindo.$Element(el);
			this._elCurrent = el;

			this._setBeforeStatus(wel);

			var nDuration = this._htCurrentTask.nDuration;

			var bAttachEvt = this._bAttachTransitionEvt();
			if(bAttachEvt){
				this._attachTransitionEnd(el);
			}

			//기본 transition을 설정한다.
			this._setDefaultTransition(wel,bAttachEvt);

			var bDiff = false;
			bDiff = this._setTransform(wel);

			bDiff = this._setStyle(wel, this._htCurrentTask.htStyle) || bDiff;
			//console.log('Translate!, ' + nDuration + ", "+bDiff + " , " + this._htCurrentTask.sTaskName);
			//if(!this._bAndroid && (nDuration == 0)){
			if(nDuration === 0){
				this._onTransitionEnd();
			}else {
				if(!bDiff){
					var self = this;
					setTimeout(function(){
						self._onTransitionEnd();
					}, nDuration);
				}
			}
		}
	},

	/**
	 * @description 트랜지션 기본값을 설정한다
	 * @param {Element} wel
	 */
	_setDefaultTransition : function(wel, bAttachEvt){
		for(var p in this._htCurrentTask.htDefault){
			var sValue = this._htCurrentTask.htDefault[p];

			if(!(p.indexOf('duration') > -1 && !bAttachEvt)){
				wel.$value().style[this._sCssPrefix+p] = sValue;
			}
		}
	},

	/**
	 * @description wel에 스타일을 설정한다.
	 * @param {Element} wel
	 * @param {HashTable{
	 */
	_setStyle : function(wel, htOption){
		var bDiff = false;
		for(var p in htOption){
			var sCurrent = wel.css(p);

			if(sCurrent != htOption[p]){
				bDiff = true;
			}
			//wel.offset();
			wel.css(p, htOption[p]);
			//console.log(p,  htOption[p]);
			//wel.$value().style[p] = htOption[p];
		}

		return bDiff;

	},


	_setStyleForAndroid : function(){

	},

	/**
	 * @description wel에 css3의 transform을 설정한다.
	 */
	_setTransform : function(wel){
		var bDiff = false;
		if(this._bAndroid){ //안드로이드 전용 transform
			bDiff = this._setTransformForAnrdoid(wel);
		}else{
			bDiff = this._setTransformForIos(wel);
		}

		return bDiff;
	},

	/**
	 * @description css3의 transfrom을 설정한다.
	 */
	_setTransformForIos : function(wel){
		var bDiff = false;
		for (var p in this._htCurrentTask.htTransform){
			var sValue = this._htCurrentTask.htTransform[p];
			wel.$value().style[this._sCssPrefix+p] = sValue;
			bDiff = true;
		}
		return bDiff;
	},

	/**
	 * @description css3와 javascript 방식으로 translate 시키는 로직
	 */
	_setTransformForAnrdoid : function(wel){
		var bDiff = false;
		var el = wel.$value();
		//console.log('//', this._htCurrentTask.htTransform);

		for (var p in this._htCurrentTask.htTransform){
			var sValue = this._htCurrentTask.htTransform[p];

			if(sValue.indexOf('translate') > -1){
				var nDuration = this._htCurrentTask.nDuration;

				var reg = new RegExp(/(translate.*)\((.*)\)/);
				var aMatch = sValue.match(reg);
				var sPreValue = aMatch[1];
				var aTemp = aMatch[2].replace(/px/g,'').split(',');
				var sTransfrom = "transform";
				var htBeforeOffset = MobileCommentJindo.m.getCssOffset(el);
				//console.log(sValue);
				var startTime = Date.now();
				var self = this;
				(function translate(){
					//console.log('translate');
					var now = Date.now();
					//console.log(now - (startTime + nDuration));
					if(now >= (startTime + nDuration) ){
						clearTimeout(self._nTimerAnimate);
						//최종px 움직이기
						el.style[self._sCssPrefix+sTransfrom] = sValue;
						self._onTransitionEnd();
						return;
					}
					//debugger;
					var nGap = (now - startTime);
					var nX = ((sPreValue.indexOf('X')> -1) || (aTemp.length >1))? aTemp[0] : null;
					var nY = null;
					if(sPreValue.indexOf('Y')> -1){
						nY = aTemp[0];
					}else if(aTemp.length > 1){
						nY = aTemp[1];
					}
					var nZ = null;
					if(sPreValue.indexOf('Z')> -1){
						nZ = aTemp[0];
					}else if(aTemp.length > 2){
						nZ = aTemp[2];
					}
					var aText =[];
					var sX = (nX !== null)? self._getcubicBeziserPosition(htBeforeOffset.left, nX, nDuration, nGap)+"px" : null;
					var sY = (nY !== null)? self._getcubicBeziserPosition(htBeforeOffset.top, nY, nDuration, nGap)+"px" : null;
					var sZ = (nZ !== null)? nZ+"px" : null;
					//debugger;
					if(sX !== null) {aText.push(sX);}
					if(sY !== null) {aText.push(sY);}
					if(sZ !== null) {aText.push(sZ);}
					//console.log(aText.join(","));

					//el.style[self._sCssPrefix+sTransfrom] = sPreValue+"("+sX+"px,"+sY+"px)";
					el.style[self._sCssPrefix+sTransfrom] = sPreValue+"("+aText.join(",")+")";
					//console.log(self._sCssPrefix+sTransfrom, sPreValue+"("+aText.join(",")+")");
					self._nTimerAnimate = setTimeout(translate, 1);
				})();

			}else{
				wel.$value().style[this._sCssPrefix+p] = sValue;
			}
			bDiff = true;
		}
		return bDiff;
	},

	/**
	 * @description transitionEnd 이벤트를 걸어야 하는지에 대한 여부를 리턴한다.
	 * - duration이 0일 경우에는 이벤트를 걸지 않는다.
	 * - anroid 방식일 경우에도 걸지 않는다.
	 * @retrun {Boolean}
	 */
	_bAttachTransitionEvt : function(){
		var bValue = true;
		if(this._htCurrentTask.nDuration === 0) {
			bValue = false;
		}else{
			if(this._bAndroid){
				for (var p in this._htCurrentTask.htTransform){
					var sValue = this._htCurrentTask.htTransform[p];
					if(sValue.indexOf('translate') > -1){
						bValue = false;
					}
				}
			}
		}

		return bValue;
	},

	/**
	 * @description wel의 태스크 실행전 css로 복구한다.
	 * @param {Element}wel
	 */
	_setBeforeStatus : function(wel){
		var nIndex = this._getBeforeStatusElement(wel.$value());

		if(nIndex > -1){
			this._aBeforeStatus[nIndex].style = wel.attr('style');
		}else{
			this._aBeforeStatus.push({
				el : wel.$value(),
				style : wel.attr('style')
			});
		}
	},

	/**
	 * @description 저장된 이전 task에서 el에 관련된 task의 index를 리턴한다.
	 * @param {HTMLElement} el
	 * @return {Number} index
	 */
	_getBeforeStatusElement : function(el){
		var nIndex = -1;

		for(var i=0,nLen = this._aBeforeStatus.length; i<nLen; i++){
			if(this._aBeforeStatus[i].el === el){
				nIndex = i;
				break;
			}
		}

		return nIndex;
	},

	/**
	 * @description 현재 트랜지션의 기본설정값을 리턴한다.
	 */
	_getDefaultTransition : function(){

		return {
			sTransitionTimingFunction : this.option('sTransitionTimingFunction'),
			TransitionProperty : 'all'
		};
	},

	/**
	 * @description 커스텀 이벤트를 발생시킨다.
	 * @param {String} 커스텀 이벤트 이름
	 * @param {HashTable} 커스텀 이벤트 파라미터
	 */
	_fireCustomEvent : function(sName, htParam){
		return this.fireEvent(sName,htParam);
	},

	/**
	 * @description 트랜지션이 모두 종료된 시점에 발생하며 콜백함수가 있으면 콜백을 실행시키고 다음 작업이 있으면 다음 작업을 시작한다.
	 */
	_onTransitionEnd : function(){
		this._detachTransitionEnd();
		//console.log('transitionEND');

		//불필요한  transition css 속성 제거
		this._initTransition();

		if(this._htCurrentTask){
			var sCallbackType = typeof this._htCurrentTask.fCallback;
			if(sCallbackType == 'function'){
				var self = this;
				if(this._bAndroid){
					setTimeout(function(){
						self._htCurrentTask.fCallback();
					},5);
				}else{
					self._htCurrentTask.fCallback();
				}
			}else if(sCallbackType == 'object'){
				var wel = MobileCommentJindo.$Element(this._htCurrentTask.elTarget);
				for (var p in this._htCurrentTask.fCallback.htTransform){
					var sValue = this._htCurrentTask.fCallback.htTransform[p];
					if(p == 'transform'){
						var sPrefix = this._sCssPrefix+p;
						var sText = wel.$value().style[sPrefix];
						if(sText.length > 0){
							//@to-do transform 추가하거나 기존값이면 대체하는 로직 추가할것;
							//sValue = sText + sValue;
							sValue = sValue;
						}
					}
					wel.$value().style[this._sCssPrefix+p] = sValue;
			    }
				for (var p in this._htCurrentTask.fCallback.htStyle) {
					wel.css(p, this._htCurrentTask.fCallback.htStyle[p]);
			    }

			}
		}

		if(this._htCurrentTask){
			this._fireCustomEvent('end',{
				element : this._htCurrentTask.elTarget,
				sTaskName : this._htCurrentTask.sTaskName,
				nDuration : this._htCurrentTask.nDuration
			});
		}

		var self =this;
		setTimeout(function(){
			self._prepareTask();
		},10);
	},

	/**
	 * @description 트랜지션의 기본값으로 설정한다.
	 */
	_initTransition : function(el){
		if(typeof el === 'undefined'){
			el = this._elCurrent;
		}

		//불필요한  transition css 속성 제거
		el.style[this._sCssPrefix +'transition-duration'] = null;
		el.style[this._sCssPrefix +'transition-timing-function'] = null;
		el.style[this._sCssPrefix + 'perspective'] = null;
		el.style[this._sCssPrefix + 'transform-style']  = null;
		el.style[this._sCssPrefix +'transition-property'] = null;

	},

	/**
	 * @description 현재 설정된 timingfunction을 기반으로 시작지점과 끝 지점의 position을 기반으로 현재 시간의 위치를 계산하여 리턴한다.
	 * @param {Number} 시작지점
	 * @param {Number} 끝지점
	 * @param {Number} 트랜지션 duration 시간
	 * @param {Number} 위치를 알고싶은 현재 시점의 시간.
	 * @return {Number} 현재 시간의 계산된 위치
	 */
	_getcubicBeziserPosition : function(nStart, nEnd, nDuration, nCurrentTime){
		nStart = nStart*1;
		nEnd = nEnd*1;
		var sFunction = this.option('sTransitionTimingFunction').replace(/-/g,'_');
		var f  = MobileCommentJindo.m.TimingFunction[sFunction];

		var t = nCurrentTime/nDuration;
		t = (t>1)? 1: t;

		var nCurrent = f(t);
		var nValue = nStart+ ((nEnd-nStart)* nCurrent.toFixed(2));

		return 	nValue;
	},

	/**
	 * @description csstransitionEnd 이벤틀 attach
	 */
	_attachTransitionEnd : function(el){
		this._elTransition = el;
		MobileCommentJindo.m.attachTransitionEnd(this._elTransition, this._htEvent['transitionEnd']);
	},

	/**
	 * @description csstransitionEnd 이벤트 detach
	 */
	_detachTransitionEnd : function(){
		if(this._elTransition){
			MobileCommentJindo.m.detachTransitionEnd(this._elTransition, this._htEvent['transitionEnd']);
			this._elTransition = null;
		}
	},

	/**
	 * @description MobileCommentJindo.m.Transition 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};
		this._htEvent['transitionEnd'] = MobileCommentJindo.$Fn(this._onTransitionEnd, this).bind();
	},

	/**
	 * @description MobileCommentJindo.m.Transition 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		this._detachTransitionEnd();
		this._htEvent = null;
	},

	/**
	 * @description  MobileCommentJindo.m.Transition 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this._detachEvent();

		for(var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		this._htWElement = null;
		this._aTaskQueue = null;
		this._bIsPlaying = null;
		this._sCssPrefix = null;
		this._aBeforeStatus = null;
		this._bAndroid = null;
		this._nTimerAnimate = null;

		this._htCurrentTask = null;
	}
}).extend(MobileCommentJindo.Component);
/**
* @(#)MobileCommentJindo.m.DragArea.js 2012. 2. 7.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author "oyang2"
* @since 2012. 2. 7.
* @description
*/

MobileCommentJindo.m.DragArea = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.DragArea.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class 기준엘리먼트 내의 drag 가능하도록 하는 클래스
	 * @param {HTMLElement | String} el 기준 엘리먼트 (혹은 id)
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
	 * @requires MobileCommentJindo.m.Touch
	 * @example
var  oDrag = new MobileCommentJindo.m.DragArea('layer1', {
		sClassPrefix : 'drag-',
		bFlowOut : false, //기준 엘리먼트 영역 밖으로 이동 가능한지에 대한 여부
		nThreshold : 10, //최초 드래그가 시작되기 위한 최소 사용자 움직임값 (px)
		nMoveThreshold : 3, //드래그 이벤트가 발생되는 사용자 움직임 값(px)
		bActivateOnload : true
	});
     */
	$init : function(el, htUserOption) {
		this.option({
			sClassPrefix : 'drag-',
			bFlowOut : false, //기준 엘리먼트 영역 밖으로 이동 가능한지에 대한 여부
			nThreshold : 10,
			nMoveThreshold : 3,
			bActivateOnload : true
		});

		this.option(htUserOption || {});
		this._initVar();
		this._setWrapperElement(el);
		this._initTouch();
		this._setAnchorElement();

		if(this.option("bActivateOnload")) {
			this.activate();
		}
	},

	/**
	 * @description MobileCommentJindo.m.DragArea 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar: function() {
		this._oTouch = null;
		this._sDragClass = '.'+ this.option('sClassPrefix')+"dragging";
		this._sHandleClass = '.'+this.option('sClassPrefix')+"handle";

		this._htInfo = {
			elDrag : null,
			elHandle : null,
			nStartX : null,
			nStartY : null,
			nX : null,
			nY : null,
			bDragStart : false, //dragStart가 시작되었는지 여부
			nCount : 0, //실제 드래그객체의 offset을 움직인 개수
			bPrepared : false //드래깅할 준비가 되어 있는지 여부
		};

		this._sCssUserSelect = "-"+MobileCommentJindo.m.getCssPrefix()+"-user-select";
		this._sCssUserSelectValue = document.body.style[this._sCssUserSelect];
		var htInfo = MobileCommentJindo.m.getDeviceInfo();
		this._isIos = (htInfo.iphone || htInfo.ipad);

		this._aAnchor = null;
		this._fnDummyFnc = function(){return false;};
		this._bBlocked = false;

		var nVersion = parseFloat(htInfo.version,10);
		this._bTouchStop = false;
		this._bTouchStop = htInfo.android && ((nVersion == 2.1) || (nVersion >= 3 ));
		if(!this._bTouchStop){
			this._bTouchStop = htInfo.iphone && (nVersion >= 3 && nVersion <4 );
		}

	},

	/**
	 * @description MobileCommentJindo.m.DragArea 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement: function(el) {
		this._htWElement = {};
		el = MobileCommentJindo.$(el);
		this._htWElement.base = MobileCommentJindo.$Element(el);
	},

	/**
	 * @description MobileCommentJindo.m.Touch컴포넌트를 초기화 한다.
	 */
	_initTouch : function(){
		if(!this._oTouch){
			this._oTouch = new MobileCommentJindo.m.Touch(this._htWElement.base.$value(),{
				nSlopeThreshold : 1,
				nMoveThreshold : this.option('nMoveThreshold'),
				bActivateOnload : false
			});
			this._oTouch.setSlope(-1,-1);
		}
	},

	/**
	 * @description el 안에 드래깅가능한 엘리먼트인지를 판단하여 리턴한다.
	 */
	_getDragElement : function(el, sClass){
		if (MobileCommentJindo.$$.test(el, "input[type=text], textarea, select")){
			return null;
		}

		var self = this;

		var isChildOfDragArea = function(baseElement, el) {
			if (!el) {
				return false;
			}
			if (baseElement === document ||baseElement === el) {
				return true;
			}
			return MobileCommentJindo.$Element(baseElement).isParentOf(el);
		};

		//var elReturn = MobileCommentJindo.$$.test(el, this._sDragClass) ? el : MobileCommentJindo.$$.getSingle('! ' + this._sDragClass, el);
		var elReturn = MobileCommentJindo.$$.test(el, this._sDragClass) ? el : MobileCommentJindo.m.getClosest(this._sDragClass, el);

		if (!isChildOfDragArea(this._htWElement.base, elReturn)) {
			elReturn = null;
		}
		var elHandle =null;

		if(elReturn){
			try{
				elHandle = MobileCommentJindo.$$.getSingle(this._sHandleClass, elReturn);
			}catch(e){
				//console.log(e);
			}
			if(elHandle){
				if (!isChildOfDragArea(elHandle, el)) {
					elReturn = null;
			//		elHandle = null;
				}
			}
		}
		return {
			elDrag : elReturn,
			elHandle : elHandle
		};
	},

	/**
	 * @description touchstart 이벤트 핸들러
	 */
	_onStart : function(oCustomEvt){
		if(!this.isActivating()){
			return;
		}

		this._initInfo();

		var htElement = this._getDragElement(oCustomEvt.element, this._sHandleClass );

		if(!htElement.elDrag){return;}

		var htParam = {
			elHandle :	 htElement.elHandle,
			elDrag : htElement.elDrag,
			oEvent : oCustomEvt.oEvent
		};

		if(!this.fireEvent('handleDown',htParam)){
			return;
		}

		//안드로이드2.1 , 3.0 버그 픽스
		if(this._bTouchStop){
			oCustomEvt.oEvent.stop();
		}

		//드래깅할 준비 플래그 세팅
		this._htInfo.bPrepared = true;

		//ios일 경우 A태그에 대한 클릭을 방지 코드
		this._clearAnchor();

		this._htInfo.welDrag = MobileCommentJindo.$Element(htParam.elDrag);
		this._htInfo.elHandle = htParam.elHandle;
		var htOffset = this._htInfo.welDrag.offset();
		this._htInfo.nStartX = htOffset.left;
		this._htInfo.nStartY = htOffset.top;


		//롱탭시에 나올수 있는 복사하기를 막기위해 css를 추가한다.
		document.body.style[this._sCssUserSelect] = "none";

		this._oTouch.attach({
			touchMove : this._htEvent["touchMove"],
			touchEnd :  this._htEvent["touchEnd"]
		});



	},

	/**
	 * @description touchmove 이벤트 핸들러
	 */
	_onMove : function(oCustomEvt){
		//드래깅할 준비가 안되어 있다면
		if(!this._htInfo.bPrepared){
			return;
		}

		var nDisX = oCustomEvt.nDistanceX,
			nDisY = oCustomEvt.nDistanceY;

		if((Math.abs(nDisX)+Math.abs(nDisY)) < this.option('nThreshold')){
			return;
		}

		oCustomEvt.oEvent.stop();

		var htOffset = {
			nX : this._htInfo.nStartX+ nDisX,
			nY : this._htInfo.nStartY+ nDisY
		};

		if(!this.option('bFlowOut')){
			var htNewOffset = this._onReCalculateOffset(this._htInfo.welDrag.$value(), htOffset.nX, htOffset.nY);
			htOffset.nX = htNewOffset.nX;
			htOffset.nY = htNewOffset.nY;
		}

		var htParam = {
			nX : htOffset.nX,
			nY : htOffset.nY,
			elDrag : this._htInfo.welDrag.$value(),
			elHandle : this._htInfo.elHandle,
			nGapX : nDisX,
			nGapY :	nDisY,
			nDragCount : this._htInfo.nCount,
			nTouchX : oCustomEvt.nX,
			nTouchY : oCustomEvt.nY
		};

		if(!this._htInfo.bDragStart){
			if(!this.fireEvent('dragStart', htParam)){
				this._htInfo.bPrepared = false;
				return;
			}
		}

		this._htInfo.bDragStart = true;

		if(!this.fireEvent('beforeDrag',htParam)){
			return;
		}

		this._htInfo.welDrag.css('position','absolute');
		this._htInfo.welDrag.offset(htParam.nY,htParam.nX);
		this._htInfo.nX = htParam.nX;
		this._htInfo.nY = htParam.nY;
		this._htInfo.nCount++;

		this.fireEvent('drag', htParam);
	},

	/**
	 * @description 기준엘리먼트 내에 drag 엘리먼트가 벗어날 수 없도록 좌표를 재계산한다.
	 * @param {HTMLElement} drag대상 엘리먼트
	 * @param {Number} nX
	 * @param {Number} nY
	 */
	_onReCalculateOffset : function(elDrag, nX, nY){
		elParent = this._htWElement.base;

		var htOffset = elParent.offset();
		var htParent = {
			nX :  elParent.$value().offsetLeft,
			nY :  elParent.$value().offsetTop,
			nWidth : elParent.$value().offsetWidth,
			nHeight : elParent.$value().offsetHeight
		};

		var htDrag = {
			nWidth : elDrag.offsetWidth,
			nHeight : elDrag.offsetHeight
		};

		var newX = Math.max(nX, htParent.nX);
		newX = Math.min(newX, htParent.nX+htParent.nWidth - htDrag.nWidth);

		var newY = Math.max(nY, htParent.nY);
		newY = Math.min(newY, htParent.nY+htParent.nHeight - htDrag.nHeight);

		return {
			nX : newX,
			nY : newY
		};

	},

	/**
	 * @description touchend 이벤트 핸들러
	 */
	_onEnd : function(oCustomEvt){
		//console.log('onEnd');
		//드래깅할 준비가 안되어 있다면
		if(!this._htInfo.bPrepared){
			return;
		}

		this._stopDrag(false);
		//탭 혹은 롱탭일때

		if (oCustomEvt.sMoveType === MobileCommentJindo.m.MOVETYPE[3] || oCustomEvt.sMoveType === MobileCommentJindo.m.MOVETYPE[4]) {
			this._restoreAnchor();
		}

		if(this._htInfo.welDrag){
			var htParam = {
				elDrag : this._htInfo.welDrag.$value(),
				elHandle : this._htInfo.elHandle
			};

			this.fireEvent('handleUp', htParam);
		}

		this._initInfo();
	},

	/**
	 * @description 현재 드래깅중인지 리턴한다.
	 * @return {Boolean}
	 */
	isDragging : function(){
		return this._htInfo.bDragStart;
	},

	/**
	 * @description 현재 드래깅을 중지한다.
	 */
	stopDragging : function(){
		this._stopDrag(true);
	},

	/**
	 * @description 드래깅을 중지하고 dragEnd 이벤트를 발생한다.
	 * @param {Boolean} bInterupted 터치이벤트가 아닌 사용자 강제 종료 여부
	 */
	_stopDrag : function(bInterupted){
		if (typeof bInterupted === 'undefined'){
			bInterupted = false;
		}

		this._oTouch.detach({
			touchMove : this._htEvent["touchMove"],
			touchEnd :  this._htEvent["touchEnd"]
		});

		//user-select의 부분 되돌리기
		document.body.style[this._sCssUserSelect] = this._sCssUserSelectValue? this._sCssUserSelectValue : "";

		if(this.isDragging()){
			var htParam = {
				nX : parseInt(this._htInfo.welDrag.css("left"), 10) || 0,
				nY : parseInt(this._htInfo.welDrag.css("top"), 10) || 0,
				elDrag : this._htInfo.welDrag.$value(),
				elHandle : this._htInfo.elHandle,
				bInterupted : bInterupted
			};

			this.fireEvent('dragEnd', htParam);
			this._htInfo.bDragStart = false;
		}

	},

	/**
	 * @description flicking 내에 a 엘리먼트를 모두 가져와서 세팅한다. (ios에서만)
	 */
	_setAnchorElement : function(){
		//ios에서만 처리되도록 수정.
		if(this._isIos ){
			this._aAnchor = MobileCommentJindo.$$("A", this._htWElement.base.$value());
		}
	},

	/**
	 * @description Anchor 삭제
	 */
	_clearAnchor : function() {
		if(this._aAnchor && !this._bBlocked) {
			var aClickAddEvent = null;
			for(var i=0, nILength=this._aAnchor.length; i<nILength; i++) {
				if (this._fnDummyFnc !== this._aAnchor[i].onclick) {
					this._aAnchor[i]._onclick = this._aAnchor[i].onclick;
				}
				this._aAnchor[i].onclick = this._fnDummyFnc;
				aClickAddEvent = this._aAnchor[i].___listeners___ || [];
				for(var j=0, nJLength = aClickAddEvent.length; j<nJLength; j++) {
					___Old__removeEventListener___.call(this._aAnchor[i], "click", aClickAddEvent[j].listener, aClickAddEvent[j].useCapture);
				}
			}
			this._bBlocked = true;
		}
	},

	/**
	 * @description Anchor 복원. for iOS
	 */
	_restoreAnchor : function() {
		if(this._aAnchor && this._bBlocked) {
			var aClickAddEvent = null;
			for(var i=0, nILength=this._aAnchor.length; i<nILength; i++) {
				if(this._fnDummyFnc !== this._aAnchor[i]._onclick) {
					this._aAnchor[i].onclick = this._aAnchor[i]._onclick;
				} else {
					this._aAnchor[i].onclick = null;
				}
				aClickAddEvent = this._aAnchor[i].___listeners___ || [];
				for(var j=0, nJLength = aClickAddEvent.length; j<nJLength; j++) {
					___Old__addEventListener___.call(this._aAnchor[i], "click", aClickAddEvent[j].listener, aClickAddEvent[j].useCapture);
				}
			}
			this._bBlocked = false;
		}
	},

	/**
	 * @description 터치 정보를 리셋한다.
	 */
	_initInfo : function(){
		this._htInfo.welDrag = null;
		this._htInfo.elHandle = null;
		this._htInfo.nStartX = null;
		this._htInfo.nStartY = null;
		this._htInfo.nX = null;
		this._htInfo.nY = null;
		this._htInfo.bDragStart = false;
		this._htInfo.nCount = 0;
	},

	/**
	 * @description MobileCommentJindo.m.DragArea 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this._attachEvent();
		this._oTouch.activate();
	},

	/**
	 * @description MobileCommentJindo.m.DragArea 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
		this._oTouch.deactivate();
	},

	/**
	 * @description MobileCommentJindo.m.DragArea 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};
		/* Touch 이벤트용 */
		this._htEvent["touchMove"] = MobileCommentJindo.$Fn(this._onMove, this).bind();
		this._htEvent["touchEnd"] = MobileCommentJindo.$Fn(this._onEnd, this).bind();
		this._htEvent["touchStart"] = MobileCommentJindo.$Fn(this._onStart, this).bind();

		/* Touch attach */
		this._oTouch.attach("touchStart", this._htEvent["touchStart"]);
	},

	/**
	 * @description MobileCommentJindo.m.DragArea 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		/* touch detach */
		this._oTouch.detachAll();

		for(var p in this._htEvent){
			this._htEvent[p] = null;
		}

		this._htEvent = null;
	},

	/**
	 * @description  MobileCommentJindo.m.DragArea 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this.deactivate();

		for(var p in this._htWElement) {
			this._htWElement[p] = null;
		}

		for(var p in this._htInfo) {
			this._htInfo[p] = null;
		}

		this._htWElement = null;
		this._htInfo = null;
		this._isIos = null;
		this._aAnchor = null;
		this._fnDummyFnc = null;
		this._bBlocked = null;
		this._bTouchStop = null;
	}
}).extend(MobileCommentJindo.UIComponent);

/**
* @(#)MobileCommentJindo.m.CoreScroll.js 2011. 8. 18.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
window.requestAnimationFrame = (function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || function(callback) { return setTimeout(callback, 1); };
})();

window.cancelRequestAnimationFrame = (function () {
    return window.cancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || clearTimeout;
})();

/**
* @author sculove
* @since 2011. 8. 18.
* @description
*
* <2차 Release이후, 코드 수정사항>
* http://dev.naver.com/news/detail.php?news_id=732
*
* <V1.0.0 이후 수정사항>
* http://devcode.nhncorp.com/news/detail.php?news_id=325
*
*
*/
MobileCommentJindo.m.CoreScroll = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.CoreScroll.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {String|HTMLElement} el CoreScroll할 Element (필수)
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
	 * @requires MobileCommentJindo.m.Touch
     */
	$init : function(el,htUserOption) {
		this.option({
			 bActivateOnload : true,
			 bUseHScroll : false,
			 bUseVScroll : true,
			 bUseMomentum : (MobileCommentJindo.m.getDeviceInfo().android ? false : true),
			 nDeceleration : 0.0006,
			 nOffsetTop : 0,
			 nOffsetBottom : 0,
			 nHeight : 0,
			 nWidth : 0,
		 	 bUseBounce : true,
			 bUseHighlight : true,
			 sClassPrefix : "scroll_",
			 // @to-do 방식  비교.... to-be로...
		 	 // 1. CSS3 + TimmingFunction
		 	 // 2. CSS3 + setTimeout (AnimationFrame)
		 	 // 3. CSS3 + keyFrame
		 	 bUseTransition : this._isTransDevice()
		});
		this.option(htUserOption || {});
		this._initVar();
		this._setWrapperElement(el);
		if(this.option("bActivateOnload")) {
			this.activate();
		}
	},

	/**
	 * @description MobileCommentJindo.m.CoreScroll 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar: function() {
		this.isAndroid = MobileCommentJindo.m.getDeviceInfo().android;
		this.nVersion = parseInt(MobileCommentJindo.m.getDeviceInfo().version,10);
		this.sCssPrefix = MobileCommentJindo.m.getCssPrefix();
		this.sTranOpen = null;
		this.sTranEnd = null;

		this.nWrapperW = null;
		this.nWrapperH = null;
		this.nScrollW = null;
		this.nScrollH = null;
		this.nMaxScrollLeft = null;
		this.nMaxScrollTop = null;
		this.nMinScrollTop = null;
		this.bUseHScroll = null;
		this.bUseVScroll = null;

		this._oTouch = null;
		this._nLeft = 0;
		this._nTop = 0;
		this._bUseHighlight = this.option("bUseHighlight");
		this._aAni = [];
		this._nAniTimer = null;
		this._nFixedBugTimer = null;

		this._isAnimating = false;		// 순수 animate 처리
		this._isControling = false;		// 사용자가 움직이고 있는가?
		this._isStop = false;
		this._setTrans();

		/**
		 *  하이라이트 기능을 사용할 경우에만 적용됨.
		 *  android 경우, css,offset, translate에 의해 이동된 영역의 하이라이트 및 영역이 갱신되지 않는 문제
		 * translate의 위치를 초기화하고 css, offset에 맞게 위치를 변경해준다. 또한 대상 영역하위의 a tag에 focus를 준다.
		 */
		if(this._bUseHighlight) {
			if(this.isAndroid) {
				this._elDummyTag = null;
			} else {
				/**
				 *  iOS를 위한 anchor 처리
				 * ios일 경우, touchstart시 선택된 영역에 anchor가 있을 경우, touchend 시점에 touchstart영역에 click이 타는 문제
				 * 모든 a link에 bind된, onclick 이벤트를 제거한다.
				 */
				this._aAnchor = null;
				this._fnDummyFnc = function(){return false;};
				this._bBlocked = false;
			}
		}
	},

	/**
	 * @description 3d Trans 또는 Trans를 기기별로 적용
	 */
	_setTrans : function() {
		var htInfo = MobileCommentJindo.m.getDeviceInfo();
		if(this._isTransDevice()) {
		    this.sTranOpen = "3d(";
			this.sTranEnd = ",0)";
		} else {
    		this.sTranOpen = "(";
    		this.sTranEnd = ")";
		}
	},


	/**
	 * @description 현재 포지션을 반환함.
	 * @return {HashTable} nTop, nLeft의 값을 반환한다.
	 */
	getCurrentPos : function() {
		return {
			nTop : this._nTop,
			nLeft : this._nLeft
		};
	},

	/**
	 * @description transition 적용이 안정적인 장비여부 반환
	 */
	_isTransDevice : function() {
		var htInfo = MobileCommentJindo.m.getDeviceInfo();
		return htInfo.iphone || htInfo.ipad || htInfo.galaxyS2; // || (!htInfo.galaxyTab2) && this.option("bUseMomentum"));
	},

	/**
	 * @description wrapper 엘리먼트와 scroller 엘리먼트를 설정한다.
	 * @param {Varient} el 엘리먼트를 가리키는 문자열이나, HTML엘리먼트
	 */
	setLayer : function(el) {
		el = (typeof el == "string" ? MobileCommentJindo.$(el) : el);
		this._htWElement["wrapper"] = MobileCommentJindo.$Element(el);
		this._htWElement["wrapper"].css({
			"position" : "relative",
			"overflow" : "hidden"
		});
		// if(!this._bUseHighlight) {
			// this._htWElement["wrapper"].css(this.sCssPrefix + "TapHighlightColor","rgba(0,0,0,0)");
		// }
		this.setScroller();
	},

	/**
	 * @description 스크롤러관련 엘리먼트를 설정함
	 */
	setScroller : function() {
		/**
		 *  scroller prefix가 있을 경우
		 * 없을경우는 첫번째 엘리먼트 (중복사용시에 문제가됨);
		 */
		// var el = this._htWElement["wrapper"].query("." + this.option("sClassPrefix") + "scroller");
		// if(el) {
			// this._htWElement["scroller"] = MobileCommentJindo.$Element(el);
		// } else {
		this._htWElement["scroller"] = this._htWElement["wrapper"].first();
		// }


		/**
		 * Transform : translate이 초기에 적용될 경우,
		 * ios계열에서 깜빡거리거나, 이벤트 행이 걸리는 문제가 발생함
		 * hide시킨후, 적용을 하면 이러한 현상이 완화됨.
		 *
		 * 따라서, hide -> Transfom : translate 적용 -> show
		 */
		this._htWElement["scroller"].css({
				"position" : "absolute",
				"zIndex" : 1,
				"left" : 0,
				"top" : 0})
			.css(this.sCssPrefix + "TransitionProperty", "-webkit-transform")
			.css(this.sCssPrefix + "TransitionDuration", 0)
			.css(this.sCssPrefix + "Transform", "translate" + this.sTranOpen + "0,0" + this.sTranEnd);
		if(this.option("bUseTransition")) {
			this._htWElement["scroller"].css(this.sCssPrefix + "TransitionTimingFunction", "cubic-bezier(0.33,0.66,0.66,1)");
		}

		// 안드로이드 버그 수정 (android 2.x 이하 버젼)
		if(this._bUseHighlight && this.isAndroid && this.nVersion < 3) {
			this._elDummyTag = MobileCommentJindo.$$.getSingle("._scroller_dummy_atag_", this._htWElement["scroller"].$value());
			if(!this._elDummyTag) {
				this._elDummyTag = MobileCommentJindo.$("<a href='javascript:void(0);' class='_scroller_dummy_atag_'></a>");
				this._elDummyTag.style.position = "absolute";
				this._elDummyTag.style.left = "-1000px";
				this._elDummyTag.style.height = "0px";
				this._elDummyTag.style.width = "0px";
				this._htWElement["scroller"].append(this._elDummyTag);
			}
		}
	},

	/**
	 * @description MobileCommentJindo.m.CoreScroll 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
 	 * @param {Varient} el 엘리먼트를 가리키는 문자열이나, HTML엘리먼트
	 */
	_setWrapperElement: function(el) {
		this._htWElement = {};
		this.setLayer(el);
	},

	/**
	 * @description 스크롤러를 위한 환경을 재갱신함
	 * @param {Object} bNoRepos true 일 경우, 포지션을 갱신하지 않음
	 */
	refresh : function(bNoRepos) {
		if(!this.isActivating()) {
			return;
		}
		// wrapper와 스크롤러의 크기 판별
		// wrappwer 크기 지정
		if(this.option("nWidth")) {
			this._htWElement["wrapper"].width(parseInt(this.option("nWidth"),10));
		}
		if(this.option("nHeight")) {
			this._htWElement["wrapper"].height(parseInt(this.option("nHeight"),10));
		}
		this.nWrapperW = this._htWElement["wrapper"].width();
		this.nWrapperH = this._htWElement["wrapper"].height();
		this.nScrollW = this._htWElement["scroller"].width();
		this.nScrollH = this._htWElement["scroller"].height() - this.option("nOffsetBottom");
		this.nMaxScrollLeft = this.nWrapperW - this.nScrollW;
		this.nMaxScrollTop = this.nWrapperH - this.nScrollH;
		this.nMinScrollTop = -this.option("nOffsetTop");
		//console.log(this.nWrapperW + " , " + this.nWrapperH + "||" + this.nScrollW + "," + this.nScrollH);

		// 모든 A태그
		if(this._bUseHighlight && !this.isAndroid) {
			this._aAnchor = MobileCommentJindo.$$("A", this._htWElement["scroller"].$value());
		}
		// 스크롤 여부 판별
		this.bUseHScroll = this.option("bUseHScroll") && (this.nWrapperW < this.nScrollW);
		this.bUseVScroll = this.option("bUseVScroll") && (this.nWrapperH < this.nScrollH);
//		console.log(this.bUseHScroll, this.bUseVScroll, this._htWElement["wrapper"].height(), this._htWElement["wrapper"].$value().offsetHeight);

		// 스크롤 여부에 따른 스타일 지정
		if(this.bUseHScroll && !this.bUseVScroll) {	// 수평인 경우
			this._htWElement["scroller"].$value().style["height"] = "100%";
		}
		if(!this.bUseHScroll && this.bUseVScroll) {	// 수직인 경우
			this._htWElement["scroller"].$value().style["width"] = "100%";
		}
		if(!this.bUseHScroll && !this.bUseVScroll) { // 스크롤이 발생하지 않은 경우, 안드로이드인경우 포지션을 못잡는 문제
			this._fixedBugForAndroid();
		}
		if(!bNoRepos) {
			this.restorePos(0);
		}
	},

	/**
	 * @description 스크롤의 위치를 지정함
	 * @param {Number} nLeft
	 * @param {Number} nTop
	 */
	_setPos : function(nLeft,nTop) {
		nLeft = this.bUseHScroll ? nLeft : 0;
		nTop = this.bUseVScroll ? nTop : 0;
        // console.log("setPos : " + this._nLeft + ", " + this._nTop + ", (nLeft,nTop) : " + nLeft + ", " + nTop);

		if (this._fireEvent("beforePosition")) {
			this._isControling = true;
			this._nLeft = nLeft;
			this._nTop = nTop;

			if (this._bUseHighlight && this.isAndroid) {
				var htStyleOffset = this.getStyleOffset(this._htWElement["scroller"]);
				nLeft -= htStyleOffset.left;
				nTop -= htStyleOffset.top;
			}
			this._htWElement["scroller"].css(this.sCssPrefix + "Transform", "translate" + this.sTranOpen + nLeft + "px, " + nTop + "px" + this.sTranEnd);
			this._fireEvent("position");
		}
	},

	/**
	 * @description 스크롤영역으로 복원함
	 * @param {Number} nDuration
	 */
	restorePos : function(nDuration) {
		if(!this.bUseHScroll && !this.bUseVScroll) {
			return;
		}
		// 최대, 최소범위 지정
		var nNewLeft = this.getPosLeft(this._nLeft),
			nNewTop = this.getPosTop(this._nTop);

		if (nNewLeft === this._nLeft && nNewTop === this._nTop) {
			/* 최종 종료 시점 */
			this._isControling = false;
			this._fireEvent("afterScroll");
			this._fixedBugForAndroid();
			return;
		} else {
			this.scrollTo(nNewLeft, nNewTop , nDuration);
		}
	},

	/**
	 * @description 모멘텀을 계산하여 앞으로 이동할 거리와 시간을 속성으로 갖는 객체를 반환함
	 * @param {Number} nDistance
	 * @param {Number} nSpeed
	 * @param {Number} nMomentum
	 * @param {Number} nSize
	 * @param {Number} nMaxDistUpper
	 * @param {Number} nMaxDistLower
	 */
	_getMomentum: function (nDistance, nSpeed, nMomentum, nSize, nMaxDistUpper, nMaxDistLower) {
		var nDeceleration = this.option("nDeceleration"),
			nNewDist = nMomentum / nDeceleration,
			nNewTime = 0,
			nOutsideDist = 0;
		//console.log("momentum : " + nDistance + ", " + nSpeed + ", " + nMomentum + ",  " + nSize + ", " + nMaxDistUpper + " , " + nMaxDistLower + ", " + nNewDist);
		if (nDistance < 0 && nNewDist > nMaxDistUpper) {
			nOutsideDist = nSize / (6 / (nNewDist / nSpeed * nDeceleration));
			nMaxDistUpper = nMaxDistUpper + nOutsideDist;
			nSpeed = nSpeed * nMaxDistUpper / nNewDist;
			nNewDist = nMaxDistUpper;
		} else if (nDistance > 0 && nNewDist > nMaxDistLower) {
			nOutsideDist = nSize / (6 / (nNewDist / nSpeed * nDeceleration));
			nMaxDistLower = nMaxDistLower + nOutsideDist;
			nSpeed = nSpeed * nMaxDistLower / nNewDist;
			nNewDist = nMaxDistLower;
		}
		nNewDist = nNewDist * (nDistance > 0 ? -1 : 1);
		nNewTime = nSpeed / nDeceleration;
		//console.log("momentum nSpeed : " + nSpeed + ", nMomentum : " + nMomentum + ", nNewDist : " + nNewDist + ", nTop : " + this._nTop + ", nNewTime : " + nNewTime);
		return {
			nDist: nNewDist,
			nTime: Math.round(nNewTime)
		};
	},

	/**
	 * @description 애니메이션을 초기화한다.
	 */
	_stop : function() {
		if(this.option("bUseTransition") ) {
			MobileCommentJindo.m.detachTransitionEnd(this._htWElement["scroller"].$value(), this._htEvent["TransitionEnd"]);
		} else {
			cancelRequestAnimationFrame(this._nAniTimer);
		}
		this._aAni = [];
		this._isAnimating = false;
	},

	/**
	 * @description 스크롤을 해당 위치(nLeft, nTop)로 이동한다.<br/>
	 * 최상위의 위치는 0,0 이다.<br/>
	 * 스크롤의 내용을 아래로 내리거나, 오른쪽으로 이동하려면 - 값을 주어야 한다.
	 * @param {Number} nLeft -일 경우, 스크롤 내용이 오른쪽으로 이동한다.
	 * @param {Number} nTop -일 경우, 스크롤 내용이 아래로 이동한다.
	 * @param {Number} nDuration
	 */
	scrollTo: function (nLeft, nTop , nDuration) {
		this._stop();
		nLeft = this.bUseHScroll ? nLeft : 0;
		nTop = this.bUseVScroll ? nTop : 0;
		this._aAni.push({
			nLeft: nLeft,
			nTop: nTop,
			nDuration: nDuration || 0
		});
		this._animate();
	},

	/**
	 * @description 동작 여부를 반환
	 * @return {Boolean}  동작 여부
	 */
	isMoving : function() {
		return this._isControling;
	},

	/**
	 * @description 애니메이션을 호출한다.
	 */
	_animate : function() {
		var self = this,
			oStep;
		if (this._isAnimating) {
			return;
		}
		if(!this._aAni.length) {
			this.restorePos(300);
			return;
		}

		// 동일할 경우가 아닐때 까지 큐에서 Step을 뺌.
		do {
			oStep = this._aAni.shift();
			if(!oStep) {
				return;
			}
		} while( oStep.nLeft == this._nLeft && oStep.nTop == this._nTop );

		this._isAnimating = true;
		// Transition을 이용한 animation
		if (this.option("bUseTransition")) {
			this._transitionTime(oStep.nDuration);
			this._setPos(oStep.nLeft, oStep.nTop);
			this._isAnimating = false;

			if (oStep.nDuration) {
				MobileCommentJindo.m.attachTransitionEnd(this._htWElement["scroller"].$value(), this._htEvent["TransitionEnd"]);
			} else {
				this.restorePos(0);
			}
		} else {
			// AnimationFrame을 이용한 animation
			var startTime = Date.now(),
				nStartLeft = this._nLeft, nStartTop = this._nTop;
			(function animate () {
				var now = Date.now(),nEaseOut;
				if (now >= startTime + oStep.nDuration) {
					self._setPos(oStep.nLeft, oStep.nTop);
					self._isAnimating = false;
					self._animate();
					return;
				}
				now = (now - startTime) / oStep.nDuration - 1;
				nEaseOut = Math.sqrt(1 - Math.pow(now,2));
				self._setPos((oStep.nLeft - nStartLeft) * nEaseOut + nStartLeft, (oStep.nTop - nStartTop) * nEaseOut + nStartTop);
				if (self._isAnimating) {
					self._nAniTimer = requestAnimationFrame(animate);
				}
			})();
		}
	},

	/**
	 * @description transition duration 지정
	 * @param {Nubmer} nDuration
	 */
	_transitionTime: function (nDuration) {
		nDuration += 'ms';
		this._htWElement["scroller"].css(this.sCssPrefix + "TransitionDuration", nDuration);
		this._fireEventSetDuration(nDuration);
	},

	/**
	 * @description Anchor 삭제. for iOS
	 */
	_clearAnchorForIos : function() {
		//console.log("clear : " + !!this._aAnchor + " | " + this._bBlocked);
		if(this._aAnchor && !this._bBlocked) {
			var aClickAddEvent = null;
			for(var i=0, nILength=this._aAnchor.length; i<nILength; i++) {
				if (this._fnDummyFnc !== this._aAnchor[i].onclick) {
					this._aAnchor[i]._onclick = this._aAnchor[i].onclick;
				}
				this._aAnchor[i].onclick = this._fnDummyFnc;
				aClickAddEvent = this._aAnchor[i].___listeners___ || [];
				for(var j=0, nJLength = aClickAddEvent.length; j<nJLength; j++) {
					___Old__removeEventListener___.call(this._aAnchor[i], "click", aClickAddEvent[j].listener, aClickAddEvent[j].useCapture);
				}
			}
			this._bBlocked = true;
		}
	},

	/**
	 * @description Anchor 복원. for iOS
	 */
	_restoreAnchorForIos : function() {
		//console.log("restore : " + this._aAnchor + " , " + this._bBlocked);
		if(this._aAnchor && this._bBlocked) {
			var aClickAddEvent = null;
			for(var i=0, nILength=this._aAnchor.length; i<nILength; i++) {
				if(this._fnDummyFnc !== this._aAnchor[i]._onclick) {
					this._aAnchor[i].onclick = this._aAnchor[i]._onclick;
				} else {
					this._aAnchor[i].onclick = null;
				}
				aClickAddEvent = this._aAnchor[i].___listeners___ || [];
				for(var j=0, nJLength = aClickAddEvent.length; j<nJLength; j++) {
					___Old__addEventListener___.call(this._aAnchor[i], "click", aClickAddEvent[j].listener, aClickAddEvent[j].useCapture);
				}
			}
			this._bBlocked = false;
		}
	},

	/**
	 * @description 이동중 멈추는 기능. 이때 멈춘 위치의 포지션을 지정
	 */
	_stopScroll : function() {
		var htCssOffset = MobileCommentJindo.m.getCssOffset(this._htWElement["scroller"].$value()),
			htStyleOffset ={left : 0, top : 0}, nTop, nLeft;

		if(this._bUseHighlight && this.isAndroid) {
			htStyleOffset = this.getStyleOffset(this._htWElement["scroller"]);
		}

		nLeft = htCssOffset.left + htStyleOffset.left;
		nTop = htCssOffset.top + htStyleOffset.top;
		if(nLeft !== this._nLeft || nTop !== this._nTop) {
			this._stop();
			this._isStop = true;
			this._setPos(this.getPosLeft(nLeft), this.getPosTop(nTop));
			this._isControling = false;
			this._fireEvent("afterScroll");
			this._fixedBugForAndroid();
		}
	},

	/**
	 * @description Style의 left,top을 반환함
	 * @param {MobileCommentJindo.$Element} wel
	 */
	getStyleOffset : function(wel) {
		var nLeft = parseInt(wel.css("left"),10),
			  nTop = parseInt(wel.css("top"),10);
		nLeft = isNaN(nLeft) ? 0 : nLeft;
		nTop = isNaN(nTop) ? 0 : nTop;
		return {
			left : nLeft,
			top : nTop
		};
	},

	/**
	 * @description Boundary를 초과하지 않는 X (left) 포지션 반환
	 *  @param {Number{}} nPos
	 */
	getPosLeft : function(nPos) {
		return (nPos >= 0 ? 0 : (nPos <= this.nMaxScrollLeft ? this.nMaxScrollLeft : nPos) );
	},

	/**
	 * @description Boundary를 초과하지 않는 Y (top) 포지션 반환
	 *  @param {Number{}} nPos
	 */
	getPosTop : function(nPos) {
		return (nPos >= this.nMinScrollTop ? this.nMinScrollTop : (nPos <= this.nMaxScrollTop ? this.nMaxScrollTop : nPos) );
	},

	/**
	 * @description setDuration 사용자 이벤트 호출
	 */
	_fireEventSetDuration : function(nDuration) {
		this.fireEvent("setDuration", {
			nDuration: nDuration,
			bUseHScroll : this.bUseHScroll,
			bUseVScroll : this.bUseVScroll
		});
	},

	/**
	 * @description beforeScroll 사용자 이벤트 호출
	 */
	_fireEventbeforeScroll : function(htParam) {
		return this.fireEvent("beforeScroll", htParam);
	},

	/**
	 * @description scroll 사용자 이벤트 호출
	 */
	_fireEventScroll : function(htParam) {
		this.fireEvent("scroll", htParam);
	},

	/**
	 * @description 범용 사용자 이벤트 호출
	 */
	_fireEvent : function(sType) {
		return this.fireEvent(sType, {
			nLeft : this._nLeft,
			nTop : this._nTop,
			nMaxScrollLeft : this.nMaxScrollLeft,
			nMaxScrollTop : this.nMaxScrollTop
		});
	},

	/**
	 * @description 범용 touch 사용자 이벤트
	 */
	_fireTouchEvent : function(sType, we) {
		return this.fireEvent(sType, {
			nLeft : this._nLeft,
			nTop : this._nTop,
			nMaxScrollLeft : this.nMaxScrollLeft,
			nMaxScrollTop : this.nMaxScrollTop,
			oEvent : we
		});
	},

	/**
	 * @description Touchstart시점 이벤트 핸들러
	 * @param {MobileCommentJindo.$Event} we
 	 */
	_onStart : function(we) {
		//console.log	("터치 스타트 (" + we.nX + "," + we.nY + ") this._isAnimating " + this._isAnimating + "," + we.element.getAttribute("id"));
		if(!this.option("bUseHighlight")) {
			we.oEvent.stop(MobileCommentJindo.$Event.DEFAULT_ALL);
		}
		this._clearFixedBug();

		if (this._fireTouchEvent("beforeTouchStart",we)) {
			this._clearAnchorForIos();
			this._isAnimating = false;
			this._isControling = true;
			this._isStop = false;
			if (this.option("bUseTransition")) {
				this._transitionTime(0);
			}
			// 이동중 멈추었을 경우
			this._stopScroll();
			this._oTouch.attach({
				touchMove : this._htEvent["touchMove"],
				touchEnd :  this._htEvent["touchEnd"]
			});
			this._fireTouchEvent("touchStart",we);
		}
	},

	/**
	 * @description 이동시점 이벤트 핸들러
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onMove : function(we) {
		//console.log("터치 이동 (" + we.nX + "," + we.nY + "), Vector (" + we.nVectorX + "," + we.nVectorY + ") sMoveType : " + we.sMoveType + "," + we.element.getAttribute("id"));

		/** 시스템 스크롤 막기 */
		var weParent = we.oEvent;
		if(we.sMoveType === MobileCommentJindo.m.MOVETYPE[0]) {	//수평이고, 수평스크롤인 경우 시스템 스크롤 막기
			if(this.bUseHScroll) {
				weParent.stop(MobileCommentJindo.$Event.CANCEL_ALL);
			} else {
				return true;
			}
		} else if(we.sMoveType === MobileCommentJindo.m.MOVETYPE[1]) {	//수직이고, 수직스크롤인 경우 시스템 스크롤 막기
			if(this.bUseVScroll) {
				weParent.stop(MobileCommentJindo.$Event.CANCEL_ALL);
			} else {
				return true;
			}
		} else if(we.sMoveType === MobileCommentJindo.m.MOVETYPE[2]) {	//대각선일 경우, 시스템 스크롤 막기
			weParent.stop(MobileCommentJindo.$Event.CANCEL_ALL);
		} else {	// 탭, 롱탭인 경우, 다 막기
			weParent.stop(MobileCommentJindo.$Event.CANCEL_ALL);
			return true;
		}

		if (this._fireTouchEvent("beforeTouchMove",we)) {
			var nNewLeft, nNewTop;
			this._clearFixedBug();
			if(this.option("bUseBounce")) {
				nNewLeft = this._nLeft + (this._nLeft >=0 || this._nLeft <= this.nMaxScrollLeft ? we.nVectorX/2 : we.nVectorX);
				nNewTop = this._nTop + (this._nTop >= this.nMinScrollTop || this._nTop <= this.nMaxScrollTop ? we.nVectorY/2 : we.nVectorY);
			} else {
				nNewLeft = this.getPosLeft(this._nLeft + we.nVectorX);
				nNewTop = this.getPosTop(this._nTop + we.nVectorY);
			}
			this._setPos(nNewLeft, nNewTop);
			this._fireTouchEvent("touchMove",we);
		}
	},

	/**
	 * @description Touchend 시점 이벤트 핸들러
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onEnd : function(we) {
		//console.log("터치 끝[" + we.sMoveType + "](" + we.nX + "," + we.nY + "), Vector(" + we.nVectorX + "," + we.nVectorY + "), MomentumY : "+ we.nMomentumY + ", speedY : " + we.nSpeedY);
		if (!this._fireTouchEvent("beforeTouchEnd",we)) {
			return;
		}
		this._clearFixedBug();
		this._oTouch.detach({
			touchMove : this._htEvent["touchMove"],
			touchEnd :  this._htEvent["touchEnd"]
		});

		// 1) 스크롤인 경우
		if (we.sMoveType === MobileCommentJindo.m.MOVETYPE[0] || we.sMoveType === MobileCommentJindo.m.MOVETYPE[1] || we.sMoveType === MobileCommentJindo.m.MOVETYPE[2]) {
			this._endForScroll(we);
		} else {	// 2) 스크롤이 아닌 경우
			// 클릭 이후 페이지 뒤로 돌아왔을 경우, 문제가됨. 동작중인 상태를 초기화함
			this._isControling = false;
			if (!this._isStop) {
				if(!this._bUseHighlight) {
					var sTagName = we.element.tagName;
					if (sTagName != 'SELECT' && sTagName != 'INPUT' && sTagName != 'TEXTAREA') {
						MobileCommentJindo.$Element(we.element).fireEvent("click");
					}
				} else {
					this._restoreAnchorForIos();
				}
			}
//			오K 요청으로... 플리킹에서 클릭시 화면이 쑹~ 바뀌는 문제땜에...
//			this.restorePos(300);
		}
		this._fireTouchEvent("touchEnd",we);
	},

	/**
	 * @description touchEnd 시점 스크롤 처리
	 * @param {MobileCommentJindo.$Event} we
	 */
	_endForScroll : function(we) {
		var htMomentumX = { nDist:0, nTime:0 },
			htMomentumY = { nDist:0, nTime:0 },
			htParam = {
				nMomentumX : we.nMomentumX,
				nMomentumY : we.nMomentumY,
				nDistanceX : we.nDistanceX,
				nDistanceY : we.nDistanceY,
				nLeft : this._nLeft,
				nTop : this._nTop
			};
		if (this.option("bUseMomentum") && (we.nMomentumX || we.nMomentumY) ) {
			if (this.bUseHScroll) {
				htMomentumX = this._getMomentum(-we.nDistanceX, we.nSpeedX, we.nMomentumX, this.nWrapperW, -this._nLeft, -this.nMaxScrollLeft + this._nLeft);
			}
			if (this.bUseVScroll) {
				htMomentumY = this._getMomentum(-we.nDistanceY, we.nSpeedY, we.nMomentumY, this.nWrapperH, -this._nTop, -this.nMaxScrollTop + this._nTop);
			}
			htParam.nNextLeft = this._nLeft + htMomentumX.nDist;
			htParam.nNextTop = this._nTop + htMomentumY.nDist;
			htParam.nTime = Math.max(Math.max(htMomentumX.nTime, htMomentumY.nTime),10);

			if (this._fireEventbeforeScroll(htParam)) {
				if(this.option("bUseBounce")) {
					this.scrollTo(htParam.nNextLeft, htParam.nNextTop, htParam.nTime);
				} else {
					this.scrollTo(this.getPosLeft(htParam.nNextLeft), this.getPosTop(htParam.nNextTop), htParam.nTime);
				}
				this._fireEventScroll(htParam);
			}
		} else {
			htParam.nNextLeft = this._nLeft;
			htParam.nNextTop = this._nTop;
			htParam.nTime = 0;
			if (this._fireEventbeforeScroll(htParam)) {
				if( this._nLeft !== htParam.nNextLeft || this._nTop !== htParam.nNextTop ) {
					this.scrollTo(htParam.nNextLeft, htParam.nNextTop, htParam.nTime);
				} else {
					this.restorePos(300);
				}
				this._fireEventScroll(htParam);
			}
		}
	},

	/**
	 * @description TransitionEnd 이벤트 핸들러
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onTransitionEnd : function(we) {
		MobileCommentJindo.m.detachTransitionEnd(this._htWElement["scroller"].$value(), this._htEvent["TransitionEnd"]);
		this._animate();
	},

	/**
	 * @description 스크롤 도중 scroll 영역 바깥을 선택하였을시, 스크롤을 중지시킴
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onDocumentStart : function(we) {
			if(this._htWElement["wrapper"].visible()) {
				if(this._htWElement["wrapper"].isChildOf(we.element)) {
					return true;
				} else {
					// 전체 스크롤 사용시 막음
					this._stopScroll();
				}
			}
		},

	/**
	 * @description MobileCommentJindo.m.CoreScroll 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		if(!this._oTouch) {
			this._oTouch = new MobileCommentJindo.m.Touch(this._htWElement["wrapper"].$value(), {
				nMoveThreshold : 0,
				nMomentumDuration : (MobileCommentJindo.m.getDeviceInfo().android ? 500 : 200),
				nLongTapDuration : 400,
				nTapThreshold : 1,
				nSlopeThreshold : 5
			});
		} else {
			this._oTouch.activate();
		}
		this._attachEvent();
		this.refresh();
	},

	/**
	 * @description MobileCommentJindo.m.CoreScroll 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
		this._oTouch.deactivate();
	},

	/**
	 * @description MobileCommentJindo.m.CoreScroll 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};
		/* Touch 이벤트용 */
		this._htEvent["touchStart"] = MobileCommentJindo.$Fn(this._onStart, this).bind();
		this._htEvent["touchMove"] = MobileCommentJindo.$Fn(this._onMove, this).bind();
		this._htEvent["touchEnd"] = MobileCommentJindo.$Fn(this._onEnd, this).bind();
		this._htEvent["TransitionEnd"] = MobileCommentJindo.$Fn(this._onTransitionEnd, this).bind();
		this._htEvent["document"] = MobileCommentJindo.$Fn(this._onDocumentStart, this).attach(document, "touchstart");
		this._oTouch.attach("touchStart", this._htEvent["touchStart"]);
	},

	/**
	 * @description 안드로이드 계열 버그
	 * css3로 스타일 변경 후, 하이라이트안되는 문제
	 * [해결법] transition관련 property를 null로 처리
	 *         offset 변경
	 *         a tag focus 하면 됨
	 */
	_fixedBugForAndroid : function() {
		if(this._bUseHighlight && this.isAndroid) {
			var self = this;
			this._clearFixedBug();
			this._nFixedBugTimer = setTimeout(function(){
				if(self._htWElement && self._htWElement["scroller"]) {
					var ele = self._htWElement["scroller"].$value();
					var htCssOffset = MobileCommentJindo.m.getCssOffset(ele);
					var htScrollOffset = self._htWElement["scroller"].offset();
	                ele.style[self.sCssPrefix + "TransitionDuration"] = null;
	                ele.style[self.sCssPrefix + "Transform"] = null;
					//alert(htCssOffset.top + " , " + htCssOffset.left + " --- " + htScrollOffset.top + " , " + htScrollOffset.left);
					self._htWElement["scroller"].offset(htCssOffset.top + htScrollOffset.top, htCssOffset.left + htScrollOffset.left);
					if(self.nVersion < 3) {
						self._elDummyTag.focus();
					}
				}
			}, 200);
		}
	},

	/**
	 * @description android인 경우, 버그수정 timer를 제거
	 */
	_clearFixedBug : function() {
		if(this._bUseHighlight && this.isAndroid) {
			clearTimeout(this._nFixedBugTimer);
			this._nFixedBugTimer = -1;
		}
	},

	/**
	 * @description MobileCommentJindo.m.CoreScroll 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		MobileCommentJindo.m.detachTransitionEnd(this._htWElement["scroller"].$value(), this._htEvent["TransitionEnd"]);
		this._htEvent["document"].detach(document,"touchstart");
		this._oTouch.detachAll();
		if (this._elDummyTag) {
			this._htWElement["scroller"].remove(this._elDummyTag);
		}
	},

	/**
	 * @description  MobileCommentJindo.m.CoreScroll 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this.deactivate();
		for(var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		this._htWElement = null;
		this._oTouch.destroy();
		delete this._oTouch;
	}
}).extend(MobileCommentJindo.UIComponent);
/**
* @(#)MobileCommentJindo.m.LayerPosition.js 2011. 6. 30.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sculove
* @since 2011. 6. 30.
* @description
*
* <2차 Release이후, 코드 수정사항>
* 1. 비동기식 setPosition을 동기식으로
* 2. 메소드 변경
*       getArea -> getPosition,  _clearReposition 삭제
* 3. 내부 소스 변경
*      _fixedLayerSize에서 left,top 변경 로직 제거
*     _ ios4,5 버그 수정
* 4. pageShow 처리 (캐쉬 상태 처리)
*
* <1.0.0 이후 변경 사항>
* 1. Android 3.x, 4.x 대응
*   => position:fixed 적용 (android 3.0이상 부터 position:fixed에서의 하이라이트 문제 해결됨)
*/
MobileCommentJindo.m.LayerPosition = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.LayerPosition.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {Varient} el 대상 엘리먼트 (필수)
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
	 * @example
	 * var oLpBottom = new MobileCommentJindo.m.LayerPosition("layer_bottom", {
	 *		 bActivateOnload : true,
	 *		 bAutoReposition : true,
     *		 sPosition : "center",
     *		 nLeftMargin : 0,
     *		 nRightMargin : 0,
     *		 nTopMargin : 0,
     *		 nBottomMargin : 0
	 * }).attach({
	 *		"beforePosition" :  function(we) {
	 *	     },
	 *		"position" :  function(we) {
	 *	     }
	 * });
     */
	$init : function(el,htUserOption) {
		this.option({
			 bActivateOnload : true,
			 bAutoReposition : true,
			 sPosition : "center",
			 nLeftMargin : 0,
			 nRightMargin : 0,
			 nTopMargin : 0,
			 nBottomMargin : 0
		});
		this.option(htUserOption || {});
		this._initVar();
		this._setWrapperElement(el);
		if(this.option("bActivateOnload")) {
			this.activate();
		}
	},

	/**
	 * fixed  속성을 지원하는지 확인하는 함수
	 * 1. ios
	 *  - ios5부터 지원
	 * 2. android
	 *  - 3.x 부터 지원함 (그전에도 지원했지만, 하이라이트 적용문제로 처리할 수 없었)
	 * @return {Boolean} isFixed
	 */
	_isSupportFixed : function() {
		var htInfo = MobileCommentJindo.m.getDeviceInfo();
		var isFixed = false;
		if(htInfo.android) {
			if(parseInt(htInfo.version,10) >= 3) {
				isFixed = true;
			} else {
				isFixed = false;
			}
		} else if(htInfo.ipad || htInfo.iphone) {
			if(parseInt(htInfo.version,10) >= 5) {
				isFixed = true;
			} else {
				isFixed = false;
			}
		}
		return isFixed;
	},

	/**
	 * @description MobileCommentJindo.m.LayerPosition 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this._isVertical = MobileCommentJindo.m.isVertical();	// 모바일 기기 세로 여부
		if (this.option("bAutoReposition")) {
			this._attachEvent();
		}
		this.setPosition();
	},

	/**
  	 * @description MobileCommentJindo.m.LayerPosition 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		if (this.option("bAutoReposition")) {
			this._detachEvent();
		}
		// this._htWElement["element"].remove(this._elDummyTag);
	},

	/**
	 * @description MobileCommentJindo.m.LayerPosition 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar: function() {
		var nLeft = this.option("nLeftMargin"),
			nTop = this.option("nTopMargin");
		this._htMargin = {
			nLeft: nLeft,
			nRight: this.option("nRightMargin"),
			nTop: nTop,
			nBottom: this.option("nBottomMargin")
		};
		this._sPosition = this.option("sPosition");
		this._htOldPosition = {
			nTop : null,
			nLeft : null,
			nBottom : null
		};
		this._htPosition = {
			nTop : null,
			nLeft : null,
			nBottom : null
		};

		// this._nDocumentWidth = document.width;
		// this._nDocumentHeight = document.height;
		// native fixed를 사용하는 경우
		this._bUseFixedProperty = this.option("bAutoReposition") && this._isSupportFixed();
		this._isVertical = null;	// 모바일 기기 세로 여부
		this._isAndroid = MobileCommentJindo.m.getDeviceInfo().android;
		this._nPreWidth = -1;
		// this._elDummyTag = null;
		// this._nFixedBugTimer  = null;
	},

	/**
	 * 현재 설정된 sPosition 타입을 반환
	 * @return {String} center, top, bottom, all 중 값을 반환함
	 */
	getPosition : function() {
		return this._sPosition;
	},

	/**
	 * 현재 설정된 마진값을 반환
	 * @return {HashTable} {nTop,nLeft,nBottom,nRight} 반환
	 */
	getMargin : function() {
		return this._htMargin;
	},

	/**
	 * 현재 LayerPosition이 적용된 Layer를 반환한다
	 * @return {HTMLElement} Layer 반환
	 */
	getLayer : function() {
		return this._htWElement["element"].$value();
	},

	/**
	 * 현대 Layer의 위치 정보를 반환한다.
	 * @return {HashTable} {nTop, nLeft, nBottom} 형태의 객체 반환
	 */
	getCurrentPosition : function() {
		return this._htPosition;
	},

	/**
	 * @description MobileCommentJindo.m.LayerPosition 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement: function(el) {
		this._htWElement = {};
		this.setLayer(el);
	},

	/**
	 * 보여주고 숨겨줄 레이어 객체를 설정한다.
	 * 설정된 엘리먼트는 document.body에 append된다.
	 * - 지정한 엘리먼트의 position은 absolute로 지정됨
	 * - bAutoReposition이 true이고, fixed속성이 가능한 경우, position은 fixed로 지정됨
	 * @return {this}
	 */
	setLayer : function(el) {
		el = (typeof el == "string" ? MobileCommentJindo.$(el) : el);
		this._htWElement["element"] = MobileCommentJindo.$Element(el);
		if(this._bUseFixedProperty) {
			this._htWElement["element"].css("position", "fixed");
		} else {
			this._htWElement["element"].css("position", "absolute");
		}

		// if (this._isAndroid) {
			// this._elDummyTag = MobileCommentJindo.$$.getSingle("._layerPosition_dummy_atag_", el);
			// if (!this._elDummyTag) {
				// this._elDummyTag = MobileCommentJindo.$("<a href='javascript:void(0);' class='_layerPosition_dummy_atag_'></a>");
				// this._elDummyTag.style.position = "absolute";
				// this._elDummyTag.style.left = "-1000px";
				// el.appendChild(this._elDummyTag);
			// }
		// }

		if (el.parentNode != document.body) {
			document.body.appendChild(el);
		}
		return this;
	},


	/**
	 * 상단 중앙에 위치
	 * @param {HashTable} htMargin {nLeft, nTop}의 상대 위치 지정
	 */
	top : function(htMargin) {
		this.setPosition("top", htMargin);
	},

	/**
	 * 하단 중앙에 위치
	 * @param {HashTable} htMargin {nLeft, nBottom}의 상대 위치 지정
	 */
	bottom : function(htMargin) {
		this.setPosition("bottom", htMargin);
	},

	/**
	 * 중앙에 위치
	 * @param {HashTable} htMargin {nLeft, nTop}의 상대 위치 지정
	 */
	center : function(htMargin) {
		this.setPosition("center", htMargin);
	},

	/**
	 * 전체 화면에 위치
	 * @param {HashTable} htMargin { nTop, nBottom, nLeft, nRight } 의 내부 공간영역지정
	 */
	all : function(htMargin) {
		this.setPosition("all", htMargin);
	},

	/**
	 * Layer의 내부 Margin을 가지는 전체크기를 설정하고, 위치정보를 반환한다
	 * @param {Number} nWidth
	 * @param {Number} nHeight
	 * @return {HashTable} {nTop, nLeft} 형태의 객체 반환
	 */
	_fixedLayerSize : function(nWidth, nHeight) {
		var nLeft = parseInt(this._htMargin.nLeft,10),
			nTop = parseInt(this._htMargin.nTop,10),
			htPadding = {
				"padding-top" : parseInt(this._htWElement["element"].css("padding-top"),10),
				"padding-bottom" : parseInt(this._htWElement["element"].css("padding-bottom"),10),
				"padding-left" : parseInt(this._htWElement["element"].css("padding-left"),10),
				"padding-right" :	parseInt(this._htWElement["element"].css("padding-right"),10)
			}, htBorder = {
				"border-top-width" : parseInt(this._htWElement["element"].css("border-top-width"),10),
				"border-bottom-width" : parseInt(this._htWElement["element"].css("border-bottom-width"),10),
				"border-left-width" : parseInt(this._htWElement["element"].css("border-left-width"),10),
				"border-right-width" : parseInt(this._htWElement["element"].css("border-right-width"),10)
			};
		nWidth -= htPadding["padding-left"] + htPadding["padding-right"] + htBorder["border-left-width"] + htBorder["border-right-width"] + nLeft + parseInt(this._htMargin.nRight,10);
		nHeight -= htPadding["padding-top"] + htPadding["padding-bottom"] + htBorder["border-top-width"] + htBorder["border-bottom-width"] + nTop + parseInt(this._htMargin.nBottom,10);

		// 스크롤여부에 따라 크기 조정
		this._htWElement["element"].css({
			width : nWidth + "px",
			height: nHeight + "px"
		});

		return {
			nTop : nTop,
			nLeft : nLeft
		};
	},

	/**
	 * Position에 맞는 Layer의 Position (top,left)를 구함
	 * (단, All인 경우, Layer의 크기도 변함)
	 */
	_getPosition : function() {
		var el=this._htWElement["element"].$value(),
			// Layer...
			nLayerWidth = el.offsetWidth,
			nLayerHeight = el.offsetHeight,
			htElementPosition = {},
			// View...
			oClientSize = MobileCommentJindo.$Document().clientSize(),
			nWidth = oClientSize.width,
			nHeight = oClientSize.height;
			// nWidth = window.innerWidth;
			// nHeight = window.innerHeight;
			// console.log(nWidth + ", " + nHeight + "... " + document.documentElement.clientWidth + ", " + document.documentElement.clientHeight);

		//Layer에 마진이 있는경우 렌더링 보정.
		nLayerWidth += parseInt(this._htWElement["element"].css('marginLeft'), 10) + parseInt(this._htWElement["element"].css('marginRight'), 10) || 0;
		nLayerHeight += parseInt(this._htWElement["element"].css('marginTop'), 10) + parseInt(this._htWElement["element"].css('marginBottom'), 10) || 0;

		if(this._sPosition === "all") {
			htElementPosition = this._fixedLayerSize(nWidth, nHeight);
		} else {
			htElementPosition.nLeft = parseInt((nWidth - nLayerWidth) / 2,10) + parseInt(this._htMargin.nLeft,10);
			switch (this._sPosition) {
				case "top":
					htElementPosition.nTop = parseInt(this._htMargin.nTop,10);
					break;
				case "center":
					htElementPosition.nTop = parseInt((nHeight - nLayerHeight) / 2,10) + parseInt(this._htMargin.nTop,10);
					break;
				case "bottom":
					if(this._bUseFixedProperty) {
						htElementPosition.nBottom = parseInt(this._htMargin.nBottom,10);
					} else {
						htElementPosition.nTop = parseInt(nHeight - nLayerHeight,10) - parseInt(this._htMargin.nBottom,10);
					}
					break;
			}
			if(!this._bUseFixedProperty) {
				htElementPosition = this._adjustScrollPosition(htElementPosition);
			}
		}
		return htElementPosition;
	},

    /**
     * 스크롤이 있을 경우 Position 수정
     * @param {HashTable} htPosition
     */
    _adjustScrollPosition : function(htPosition) {
        var htScrollPosition = MobileCommentJindo.$Document().scrollPosition();
            //oClientSize = MobileCommentJindo.$Document().clientSize();
            // nMaxTop = this._nDocumentHeight - oClientSize.height,
            // nMaxLeft = this._nDocumentWidth - oClientSize.width;
        /*
         android 3.1에서 화면바깥 영역으로 바운딩하면 화면영역으로 돌아오는데,
         1.화면바깥 영역으로 스크롤하면 UI상 원래 위치로 돌아오지만, 값(pageX/YOffest , scrollX/Y)은  화면 영역밖의 값인-를 반환한다.
			=> 스크롤 영역바깥영역일 경우, 최상단,하단값을 반환하도록 수정
		2.화면의 스크롤 크기를 나타내는 document.scrollWidth/Height, document.Width/Height도 늘어난 화면 영역값을 반환하지만, 화면이 원래 위치로 돌아온 후에는 원래 스크롤 영역이 아닌 늘어난 스크롤 영역을 나타냄
			=> 초기 로딩시, 측정된 스크롤 사이즈를 기준으로 계산

		결국. Android 3.x, 4.x 는 position:fixed로 문제해결!
		*/
        htPosition.nTop += htScrollPosition.top;
        htPosition.nLeft += htScrollPosition.left;
        return htPosition;
    },

	/**
	 * 포지션을 잡음
	 * @param {String} sPosition : Layer Area종류 "top", "center", "bottom", "all" (옵션)
	 * @param {HashTable} htMargin {nTop,nLeft,nBottom,nRight} 객체 (옵션)<br/>
	 *         중앙기준으로 상태좌표 이동 (all인 경우는 내부마진임)<br/>
	 *         top Area인 경우 nTop, nLeft<br/>
	 *         center Area인 경우 nTop, nLeft<br/>
	 *         bottom Area인 경우 nBottom, nLeft<br/>
	 *         all Area인 경우 nTop,nBottom, nLeft, nRight (all인 경우는 내부마진임)<br/>
	 */
	setPosition : function(sPosition, htMargin) {
		if(!this.isActivating()) {
			return;
		}
		this._htMargin = htMargin || this._htMargin;
		this._sPosition = sPosition || this._sPosition;
		if(this._fireEvent("beforePosition")) {
			var bVisible = this._htWElement["element"].visible();
			if (!bVisible) {
				this._htWElement["element"].css({
					left : "-9999px"
				}).show();
			}
			this._htOldPosition = this._htPosition;
			this._htPosition = this._getPosition();

			if (!bVisible) {
				this._htWElement["element"].hide();
			}

			// 기존 포지션과 현재 포지션값이 다를경우 변경. 그렇지 않으면 포지션을 변경하지 않음
			// 안보이는 경우는 무조건 변경함
			if (!bVisible || this._htOldPosition.nLeft !== this._htPosition.nLeft || this._htOldPosition.nTop !== this._htPosition.nTop || this._htOldPosition.nBottom !== this._htPosition.nBottom) {
				if(typeof this._htPosition.nTop === "undefined" ) {
					this._htWElement["element"].$value().style.top = null;
				} else if(typeof this._htPosition.nBottom === "undefined" ) {
					this._htWElement["element"].$value().style.bottom = null;
				}
				this._htWElement["element"].css({
					left : this._htPosition.nLeft + "px",
					top : this._htPosition.nTop + "px",
					bottom : this._htPosition.nBottom + "px"
				});
				// alert(this._htOldPosition.nTop + "...." + this._htPosition.nTop);
				// this._fixedBugForAndroid();
			}
			this._fireEvent("position");
		}
	},

	// /**
	 // * @description 안드로이드 용 포지션 버그 제거
	 // */
	// _fixedBugForAndroid : function() {
		// if(this._isAndroid) {
			// var self = this;
			// this._clearFixedBug();
			// this._nFixedBugTimer = setTimeout(function(){
				// // self._htWElement["element"].$value().focus();
				// self._elDummyTag.focus();
			// }, 200);
		// }
	// },
//
	// /**
	 // * @description android인 경우, 버그수정 timer를 제거
	 // */
	// _clearFixedBug : function() {
		// if(this._isAndroid) {
			// clearTimeout(this._nFixedBugTimer);
			// this._nFixedBugTimer = -1;
		// }
	// },

	/**
	 * @description MobileCommentJindo.m.LayerPosition 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};
		this._htEvent["actionEvent"] = MobileCommentJindo.$Fn(this._onEvent, this);
		this._htEvent["pageShow"] = MobileCommentJindo.$Fn(this._onPageShow, this).bind();
		if(this._bUseFixedProperty) {
			this._htEvent["actionEvent"].attach(window, "resize");
		} else {
			this._htEvent["actionEvent"].attach(window, "scroll").attach(window, "resize");
		}
		MobileCommentJindo.m.bindPageshow(this._htEvent["pageShow"]);

		if(!this._isAndroid) {
			this._htEvent["rotate"] = MobileCommentJindo.$Fn(this._onRotateForIos, this).attach(window, "orientationchange");
		}
	},

	/**
	 * @description MobileCommentJindo.m.LayerPosition 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		this._htEvent["actionEvent"].detach(window, "scroll")
					.detach(window, "resize");
		MobileCommentJindo.m.unbindPageshow(this._htEvent["pageShow"]);
		if(!this._isAndroid) {
			this._htEvent["rotate"].detach(window, "orientationchange");
		}
		this._htEvent = null;
	},

	/**
	 * 재포지션을 잡는 이벤트
	 * onScroll, onResize에서 처리함
	 * 단, fixed 지원기기일 경우, onResize에서 처리됨
	 */
	_onEvent : function(we) {
		if (this._htWElement["element"].visible()){
			this.setPosition();
		}
	},

	/**
	 * 화면 전환 이벤트
	 */
	_onRotateForIos : function() {
		if (this._htWElement["element"].visible()){
			var self = this;
			/*
			 * 레이어의 width가 100%로 되었을경우, 가로로 로딩후, 세로로 변경시 레이어가 깨지는 문제가 발생함.
			 * 변경시 기존 값을 저장하고 width에 맞게 조절하는 기능을 함
			 */
			if(window.innerWidth < this._htWElement["element"].width() ) {
				this._nPreWidth = this._htWElement["element"].width();
				this._htWElement["element"].width(window.innerWidth);
			} else {
				if(this._nPreWidth !== -1) {
					 this._htWElement["element"].width(this._nPreWidth);
				}
			}
			this._htWElement["element"].hide();
			this.setPosition();
			/*
			 * iOS5인 경우, 화면전환시 천천히 끌려가며 포지션을 잡는 현상이 발생
			 * reflow 강제 발생후 처리
			 */
			setTimeout(function() {
				// self._htWElement["element"].width(nWidth);
				self._htWElement["element"].show();
			},0);
		}
	},

	/**
	 * History Backk 했을 경우
	 */
	_onPageShow : function() {
		if(this.isActivating()) {
			this.deactivate();
			this.activate();
		}
	},

	/**
	 * 사용자 이벤트 호출
	 */
	_fireEvent : function(sType) {
		return this.fireEvent(sType, {
			elLayer : this.getLayer(),
			htMargin : this.getMargin(),
			htPosition : this.getCurrentPosition()
		});
	},

	/**
	 * @description  MobileCommentJindo.m.LayerPosition 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this.deactivate();
		for(var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		delete this._htWElement;
		delete this._htMargin;
		delete this._sPosition;
		delete this._htPosition;
		delete this._htOldPosition;
		delete this._bUseFixedProperty;
	}
}).extend(MobileCommentJindo.UIComponent);

/**
* @(#)MobileCommentJindo.m.CoreScroll.js 2011. 12. 05.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sculove
* @since 2011. 12. 05.
*
* @description
*
* <1.0.0 이후 변경 사항>
* 1. Android 3.x, 4.x 대응
*  : 연속적인 scroll 이벤트 후 touchend는 발생하지 않음
*/
MobileCommentJindo.m.ScrollEnd = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.ScrollEnd.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @extends MobileCommentJindo.Component
     */
	$init : function(el,htUserOption) {
		this._initVar();
		this._setWrapperElement(el);
		this._attachEvent();
	},

	/**
	 * @description 변수 초기화
	 */
	_initVar : function() {
		// Type 0: iOS, 1: Android (2.x), 2: Android (3.x이상 )
		if(MobileCommentJindo.m.getDeviceInfo().android) {
            if(parseInt(MobileCommentJindo.m.getDeviceInfo().version,10) >= 3) {
                this._nType = 2;
                this._nScrollTimer = -1;
            } else {
                this._nType = 1;
            }
		} else {
		  this._nType = 0;
		}
		this._isTouched = false;
		this._isMoved = false;
		this._nObserver = null;
		this._nScrollEndTimer = null;
		this._nPreLeft = null;
		this._nPreTop = null;
		this._isTop = false;
	},

	/**
	 * @description 객체 초기화
	 */
	_setWrapperElement : function(el) {
		this._htElement = {};
		this._htElement["body"] = document.body;
	},

	/**
	 * @description 이벤트 활성화
	 */
	_attachEvent : function() {
		this._htEvent = {};
		this._htEvent["event_scroll"] = {
			ref : MobileCommentJindo.$Fn(this._onScroll, this).attach(document, "scroll"),
			el : document
		};

		if(this._nType == 1) {
			this._htEvent["event_touchstart"] = {
				ref : MobileCommentJindo.$Fn(this._onStartForAndroid, this).attach(this._htElement["body"], "touchstart"),
				el : this._htElement["body"]
			};
			this._htEvent["event_touchmove"] = {
				ref : MobileCommentJindo.$Fn(this._onMoveForAndroid, this).attach(this._htElement["body"], "touchmove"),
				el : this._htElement["body"]
			};
			this._htEvent["event_touchend"] = {
				ref : MobileCommentJindo.$Fn(this._onEndForAndroid, this).attach(this._htElement["body"], "touchend"),
				el : this._htElement["body"]
			};
		}
	},

	/**
	 * @description 이벤트 비활성화
	 */
	_detachEvent : function() {
		for(var p in this._htEvent) {
			var ht = this._htEvent[p];
			ht.ref.detach(ht.el, p.substring(p.lastIndexOf("_")));
		}
	},

	/**
	 * @description 이벤트 감시자 시작
	 */
	_startObserver : function() {
		var self = this;
		this._stopObserver();
		this._nObserver = setInterval(function() {
			self._observe();
		},100);
	},

	/**
	 * @description 이벤트 감시
	 */
	_observe : function() {
		if(this._isTouched || (this._nPreTop !== window.pageYOffset || this._nPreLeft !== window.pageXOffset) ) {
			this._nPreTop = window.pageYOffset;
			this._nPreLeft = window.pageXOffset;
		} else {
			this._stopObserver();
			//console.log("옵저버끝 " + window.pageYOffset);
			this._fireEventScrollEnd();
		}
	},

	/**
	 * @description 이벤트 감시자 중지
	 */
	_stopObserver : function() {
		clearInterval(this._nObserver);
		this._nObserver = null;
	},

	/**
	 * @description scroll 이벤트  핸들러
	 */
	_onScroll : function(we) {
		// ios에서 scroll은 무조선 scrollEnd
		switch(this._nType) {
		    case 0 : this._fireEventScrollEnd(); break;
		    case 1 : this._startObserver(); break;
		    case 2 : var self = this;
                  clearTimeout(this._nScrollTimer);
                  this._nScrollTimer = setTimeout(function() {
                      self._fireEventScrollEnd();
                  },350);
                  break;
		}
	},

	/**
	 * @description touchstart 이벤트  핸들러
	 */
	_onStartForAndroid : function(we) {
		this._stopObserver();
		this._isTouched = true;
		this._isMoved = false;

		this._nPreTop = null;
		this._nPreLeft = null;

		if(window.pageYOffset === 0) {
			this._isTop = true;
		} else {
			this._isTop = false;
		}
	},

	/**
	 * @description touchstart 이벤트  핸들러
	 */
	_onMoveForAndroid : function(we) {
		this._isMoved = true;
	},

	/**
	 * @description touchend 이벤트  핸들러
	 */
	_onEndForAndroid : function(we) {
		this._isTouched = false;
		/*
		 * android인 경우, 주소창이 보이면 scroll이벤트가 발생하지 않음.
		 * 주소창이 보여서 스크롤이 발생하여도 window.pageYOffset 0이므로,
		 * touchstart시점이 0 에서 시작할 경우, 움직임이 있고,
		 * 200ms이후, window.pageYOffset 위치가 0일 경우, 스크롤 End를 호출한다.
		 */

		//addConsole("[touchend] isTop : " + this._isTop + ", isMoved : " + this._isMoved);
		if(this._isTop && this._isMoved) {
			this._startObserver();
		}
	},


	/**
	 * @description scrollEnd 사용자 이벤트 호출
	 */
	_fireEventScrollEnd : function() {
		this.fireEvent("scrollEnd", {
			nTop : window.pageYOffset,
			nLeft : window.pageXOffset
		});
	},

	_fireEventScrollEndForAndroid : function() {
		var self = this;
		clearTimeout(this._nScrollEndTimer);
		this._nScrollEndTimer = setTimeout(function() {
			self._fireEventScrollEnd();
		},500);
	},

	/**
	 * @description 객체 초기화
	 */
	destroy: function() {
	 	this._detachEvent();
	 	this._nType = -1;
		this._isTouched = null;
		this._isMoved = null;
		this._nObserver = null;
		this._nPreLeft = null;
		this._nPreTop = null;
	}
}).extend(MobileCommentJindo.Component);

/**
* @(#)MobileCommentJindo.m.FadeEffect.js 2011. 12. 15.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author "oyang2"
* @since 2011. 12. 15.
* @description
*/

MobileCommentJindo.m.FadeEffect = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.FadeEffect.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @extends MobileCommentJindo.m.Effect
	 * @requires MobileCommentJindo.m.LayerEffect
	 */
	sEffectName : "fade",

	getCommand : function(el, htOption){
		var sDirection = htOption.sDirection? htOption.sDirection :'in';


		var htStyle = htOption.htTo || {};
		var nOpacity = (sDirection == 'in')? 1 : 0;

		htStyle["opacity"] = (typeof htStyle.opacity !== 'undefined')? htStyle.opacity : nOpacity;

		var htCallback = {};
		if(sDirection == 'out'){
			htCallback.htStyle ={};
			htCallback.htStyle["display"]  = "none";
			htCallback.htStyle["opacity"] = this._htLayerInfo['nOpacity'];
		}

		return {
			sTaskName : this.sEffectName + "-"+sDirection,
			htStyle : htStyle,
			htTransform : {},
			fCallback : htCallback
		};
	},

	getBeforeCommand : function(el, htOption){
		var sDirection = htOption.sDirection? htOption.sDirection :'in';
		//debugger;

		var htBeforeStyle = htOption.htFrom || {};
		var nOpacity  = (sDirection == 'in')? 0 : 1;
		htBeforeStyle["display"] = this._htLayerInfo['sDisplay'];

		htBeforeStyle["opacity"] = (typeof htBeforeStyle.opacity == 'undefined')? nOpacity : htBeforeStyle.opacity;

		return {
			htStyle : htBeforeStyle ,
			htTransform : {}
		};
	}

}).extend(MobileCommentJindo.m.Effect);
/**
* @(#)MobileCommentJindo.m.NumberValidator.js 2011. 11. 23.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sculove
* @since 2011. 11. 23.
* @description
*/
MobileCommentJindo.m.NumberValidator = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.NumberValidator.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @extends MobileCommentJindo.m.Validator
	 */
	rx :  /^[+-]?(\d{1,3},)?(\d{3},)*(\d)+(\.\d+)?$/,

	_isValid : function(sValue, sFormat) {
		return this.rx.test(sValue);
	},

	_getCorrectedValue : function(sValue, sFormat) {
		// 숫자 형식 필터링
		sValue = this._filterNumber(sValue);
		// 포맷 적용
		if(sFormat) {
			sValue = this._applyComma(sValue);
		}
		return sValue;
	},

	/**
	 * @description 숫자에 ,를 붙이는 함수
	 */
	_applyComma : function(sValue) {
		var sResult = "",
			nIdx = 0,
			ch = null,
			chCode = null,
			nDotIdx = sValue.indexOf("."),
			sIntValue = ( nDotIdx !== -1  ? sValue.substring(0,nDotIdx) : sValue ),
			sPointValue = ( nDotIdx !== -1 ? sValue.substr(nDotIdx) : "");

//		console.log(sValue + " --" + sIntValue + " || " + sPointValue);
		if(sIntValue.length > 3) {
			for(var i=sIntValue.length-1; i>=0; i--, nIdx++) {
				ch = sIntValue.charAt(i);
				chCode = sIntValue.charCodeAt (i);
				sResult = (nIdx !==0 && nIdx %3 === 0 && (chCode > 47 && chCode < 58) ? ch + "," + sResult : ch + sResult);
			}
			return (sPointValue !== "" ? sResult + sPointValue : sResult);
		} else {
			return sValue;
		}
	},

	/**
	 * @description 숫자를 추출하는 함수(-와 숫자로만 구성된값)
	 */
	_filterNumber : function(sValue) {
		var cFirst, aValue, sIntValue, sPointValue;
		// 불필요한 문자 제거
		sValue = sValue.replace(/[^\d\.\-]/g,"");
		//.replace(/\.{2,}/g,"").replace(/-{2,}/g,"");

		// 맞지 않는 - 제거
		cFirst = sValue.charAt(0);
		sValue = sValue.replace(/-/g,"");
		sValue = ( cFirst === "-" ? cFirst + sValue : sValue );
		if( sValue.length <= 0 || sValue === "-") {
			return sValue;
		}
		// 맞지 않는 . 제거, 정수부분 정수로 변경
		aValue = sValue.split('.');
		if(aValue.length > 1) {
			sIntValue = aValue.shift();
			//console.log(sIntValue);
			cFirst = sIntValue.charAt(0);
			sIntValue = (sIntValue === "" ? 0 : parseInt(sIntValue,10));
			if(cFirst === "-" && sIntValue === 0) {
				sIntValue = "-" + sIntValue;
			}
			sPointValue = aValue.join("");
			sValue = sIntValue + "." + sPointValue;
		} else {
			sValue = String(parseFloat(aValue.join(""),10));
		}
		return sValue;
	}
}).extend(MobileCommentJindo.m.Validator);
/**
* @(#)MobileCommentJindo.m.Accordion.js 2011. 7. 13.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
 * @author hjoh modified by icebelle
 * @since 2011. 7. 13.
 * @version 0.0.1
 * @description 모바일 전용 아코디언
 */

MobileCommentJindo.m.Accordion = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.Accordion.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {String|HTMLElement} el Accordion 컴포넌트를 적용한 레이어의 id 혹은 HTMLElement
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
	 */
	$init : function(el,htUserOption) {
		var htDefaultOption = {
			bActivateOnload : true,
			sClassPrefix : 'accordion-',
			sDirection : 'vertical',
			nDefalutIndex :  -1,
			bUseToggle : false,
			sTransitionTimingFunction : "ease",
			nDuration : 500
		};
		this.option(htDefaultOption);
		this.option(htUserOption || {});

		this._initVar(el);

		this._setWrapperElement();
		if(this.option("bActivateOnload")) {
			this.activate();
		}

		this._setSize();
		this._setDefaultExpand();
	},

	/**
	 * @description 변수 초기화 함수
	 * @description 인스턴스 변수를 초기화한다.
	 * @param {String|HTMLElement} el Accordion 컴포넌트를 적용한 레이어의 id 혹은 HTMLElement
	 */
	_initVar : function(el) {
		this._elContainer = (typeof el == "string") ? MobileCommentJindo.$(el) : el;
		this._aAccordionBlock = MobileCommentJindo.$$("." + this.option("sClassPrefix") + "block", this._elContainer);

		var htInfo = MobileCommentJindo.m.getDeviceInfo();
		var nVersion = parseFloat(htInfo.version,10);
		if(htInfo.android && (nVersion <3) ){
			var elDummyTag = MobileCommentJindo.$$.getSingle("._accordion_dummy_atag_", this._elContainer);
			if(!elDummyTag){
				elDummyTag = MobileCommentJindo.$("<a href='javascript:void(0);' class='_accordion_dummy_atag_'></a>");
				elDummyTag.style.position = "absolute";
				elDummyTag.style.left = "-1000px";
				elDummyTag.style.top = "-1000px";
				elDummyTag.style.width = 0;
				elDummyTag.style.height = 0;
				MobileCommentJindo.$Element(this._elContainer).append(elDummyTag);
			}
		}

		this._nExpand = -1;
		this._wfTransitionEnd = MobileCommentJindo.$Fn(this._onTransitionEnd, this).bind();
	},

	/**
	 * @description MobileCommentJindo.m.Accordion 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement : function() {

	},

	/**
	 * @description MobileCommentJindo.m.Accordion 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this._attachEvent();
	},

	/**
	 * @description MobileCommentJindo.m.Accordion 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
	},

	/**
	 * @description MobileCommentJindo.m.Accordion 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};

		MobileCommentJindo.$A(this._aAccordionBlock).forEach(function(el, index, array){
			this._htEvent["click_" + index] = {
				ref : MobileCommentJindo.$Fn(this._onClick, this).attach(this.getHandler(index), "click"),
				el	: this.getHandler(index)
			};
		}, this);
	},

	/**
	 * @description 특정 이벤트를 해제한다.
	 * @param {String} sEventKey 이벤트 키
	 */
	_detachEvent : function(sEventKey) {
		if(sEventKey) {
			var htTargetEvent = this._htEvent[sEventKey];
			htTargetEvent.ref.detach(htTargetEvent.el, sEventKey.substring(0, sEventKey.indexOf("_")));
		}
	},

	/**
	 * @description MobileCommentJindo.m.Accordion 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEventAll : function() {
		for(var p in this._htEvent) {
			this._detachEvent(p);
		}

		this._htEvent = null;
	},

	/**
	 * 아코디언 핸들클릭시 이벤트 핸들러
	 * @param {MobileCommentJindo.$Event} we 랩핑된 이벤트객체
	 * @ignore
	 */
	_onClick : function(we){
		we.stop();
		var elBlock = this._getBlock(we.element);
		var nIndex = (elBlock) ? MobileCommentJindo.$A(this._aAccordionBlock).indexOf(elBlock) : null;

		var nCurrentIndex = this.getExpandIndex();
		var bUseToggle = this.option("bUseToggle");
		if(typeof nIndex == 'number'){
			if(nIndex == nCurrentIndex) {
				if(bUseToggle) {
					this.collapse(nCurrentIndex);
					this._nExpand = -1;
				}
			} else {
				this.expand(nIndex);
				if(nCurrentIndex > -1) {
					this.collapse(nCurrentIndex);
				}
			}
		}
	},

	/**
	 * 아코디언 블럭의 각 사이즈 정보세팅함수
	 */
	_setSize : function() {
		this._htBlockSize = {};
		var nHeaderSize, nBodySize;
		MobileCommentJindo.$A(this._aAccordionBlock).forEach(function(el, index, array){
			nHeaderSize = this._getHeaderSize(index);
			nBodySize = this._getBodySize(index);
			this._htBlockSize[index] = {
				nHeaderSize : nHeaderSize,
				nBodySize : nBodySize
			};

			if(this.option("sDirection") == "vertical") {
				MobileCommentJindo.$Element(el).height(nHeaderSize);
			} else {
				MobileCommentJindo.$Element(el).width(nHeaderSize);
			}
		}, this);
	},

	/**
	 * 아코디언 블럭의 헤더 사이즈 반환함수
	 * param {Number} nIndex 아코디언 블럭의 인덱스
	 * @return {Number} nSize 아코디언 nIndex번째 블럭의 헤더 사이즈
	 */
	_getHeaderSize : function(nIndex) {
		var welHead = MobileCommentJindo.$Element(this.getHead(nIndex));
		var nHeaderSize = (this.option("sDirection") == "vertical") ? welHead.height() : welHead.width();
		return nHeaderSize;
	},

	/**
	 * 아코디언 블럭의 바디 사이즈 반환함수
	 * param {Number} nIndex 아코디언 블럭의 인덱스
	 * @return {Number} nSize 아코디언 nIndex번째 블럭의 바디 사이즈
	 */
	_getBodySize : function(nIndex) {
		var welBody = MobileCommentJindo.$Element(this.getBody(nIndex));
		var nBodySize = (this.option("sDirection") == "vertical") ? welBody.height() : welBody.width();
		return nBodySize;
	},

	/**
	 * 아코디언 블럭의 전체 사이즈(header + body) 반환함수
	 * @param {Number} nIndex 아코디언 블럭의 인덱스
	 * @return {Number} nSize 아코디언 nIndex번째 블럭의 사이즈
	 */
	_getSize : function(nIndex) {
		if(!this._htBlockSize || !this._htBlockSize[nIndex]) {
			this._setSize();
		}
		var nSize = this._htBlockSize[nIndex]["nHeaderSize"] + this._htBlockSize[nIndex]["nBodySize"];
		return nSize;
	},

	/**
	 *  디폴트로 Expnad할 블럭 처리함수
	 */
	_setDefaultExpand : function() {
		var nDefaultIndex = this.option("nDefalutIndex");
		if(nDefaultIndex > -1) {
			setTimeout(MobileCommentJindo.$Fn(function() {
				this.expand(nDefaultIndex);
			}, this).bind(),100);
		}
	},

	/**
	 * 아코디언 블럭의 헤더 반환함수
	 * @param {Number} nIndex 아코디언 블럭의 인덱스
	 * @return {HTMLElement} elBody 아코디언 블럭의 header 엘리먼트
	 */
	getHead : function(nIndex){
		return MobileCommentJindo.$$.getSingle('dt', this._aAccordionBlock[nIndex]);
	},

	/**
	 * 아코디언 블럭의 바디 반환함수
	 * @param {Number} nIndex 아코디언 블럭의 인덱스
	 * @return {HTMLElement} elBody 아코디언 블럭의 body 엘리먼트
	 */
	getBody : function(nIndex){
		return MobileCommentJindo.$$.getSingle('dd', this._aAccordionBlock[nIndex]);
	},

	/**
	 * 아코디언 블럭 반환함수
	 * @param {HTMLElement} el 아코디언 블럭의 핸들 엘리먼트
	 * @return {MobileCommentJindo.$Element} wel 랩핑된 엘리먼트 객체
	 */
	_getBlock : function(el){
		var sClassPrefix = this.option("sClassPrefix") +"block";
		//return MobileCommentJindo.$Element(el).hasClass('.'+sClassPrefix)? el: MobileCommentJindo.$$.getSingle("! ." + sClassPrefix, el);

		//var elBlock = this._getClosest(sClassPrefix, el);
		var elBlock = MobileCommentJindo.m.getClosest(sClassPrefix, el);
		return elBlock;
	},

	/**
	 * 아코디언 블럭의 핸들러 반환함수
	 * @param {Number} nIndex 아코디언 블럭의 인덱스
	 * @return {HTMLElement} elHandler 아코디언 블럭의 핸들러 엘리먼트
	 */
	getHandler : function(nIndex){
		var elHead = this.getHead(nIndex);
		return MobileCommentJindo.$$.getSingle('.'+this.option('sClassPrefix')+'handler', elHead) || elHead;
	},

	/**
	 * 현재 Expand되어 있는 아코디언 블럭의 Index 반환함수
	 * @return {Number} nIndex 아코디언 블럭의 Index(전체가 collapse되어있는 경우 -1을 반환한다.)
	 */
	getExpandIndex : function(){
		return this._nExpand;
	},

	/**
	 * 아코디언 블럭 Expand 처리함수
	 * @param {Number} nIndex 아코디언 블럭의 인덱스
	 */
	expand : function(nIndex){
		this._elBlock = this._aAccordionBlock[nIndex];
		if(typeof this._elBlock == 'undefined'){ return;}

		if(!this.fireEvent("beforeExpand", {
			sType : "beforeExpand",
			elBlock : this._elBlock,
			nBeforeIndex : this._nExpand,
			nIndex : nIndex
		})){ return; }

		this._setTransition(this._elBlock, this._getSize(nIndex));
		this._nExpand = nIndex;

		this.fireEvent("expand", {
			sType : "expand",
			elBlock : this._elBlock,
			nIndex : nIndex
		});
	},

	/**
	 * 아코디언 블럭 collapse 처리함수
	 * @param {Number} nIndex 아코디언 블럭의 인덱스
	 */
	collapse : function(nIndex){
		this._elBlock = this._aAccordionBlock[nIndex];
		if(typeof this._elBlock == 'undefined'){ return;}

		if(!this.fireEvent("beforeCollapse", {
			sType : "beforeCollapse",
			elBlock : this._elBlock,
			nIndex : nIndex
		})){ return; }

		this._setTransition(this._elBlock, this._getHeaderSize(nIndex));
		if(this._nExpand == nIndex) { this._nExpand = -1; }

		this.fireEvent("collapse", {
			sType : "collapse",
			elBlock : this._elBlock,
			nIndex : nIndex
		});
	},

	/**
	 * 전체 Collapse 처리함수
	 */
	collapseAll  : function(){
		var nIndex = this.getExpandIndex();

		if(nIndex > -1){
			this.collapse(nIndex);
		}

		this._nExpand = -1;
	},

	/**
	 * Effect 설정함수
	 * @param {HashTable} htEffect 이펙트 옵션
	 * - {String} sTransitionTimingFunction Effect Type (ease|linear|ease-in|ease-out|ease-in-out)
	 * - {Number} nDuration Effect 처리시간(단위 ms)
	 */
	setEffect : function(htEffect) {
		if(htEffect.sTransitionTimingFunction && (htEffect.sTransitionTimingFunction == "ease" || htEffect.sTransitionTimingFunction == "linear" || htEffect.sTransitionTimingFunction == "ease-in" || htEffect.sTransitionTimingFunction == "ease-out" || htEffect.sTransitionTimingFunction == "ease-in-out")) {
			this.option("sTransitionTimingFunction", htEffect.sTransitionTimingFunction);
		}

		if(htEffect.nDuration && htEffect.nDuration > 0) {
			this.option("nDuration", htEffect.nDuration);
		}
	},

	/**
	 * 아코디언 블럭의 Expand/Collapse 처리시 Effect 처리함수
	 * @param {HTMLElement} elBlock 아코디언 블럭 엘리먼트
	 * @param {Number} nBlockSize 아코디언 블럭 사이즈
	 * @param {String} sTransitionTimingFunction Effect Type (ease|linear|ease-in|ease-out|ease-in-out)
	 * @param {Number} nDuration Effect 처리시간(단위 ms)
	 */
	_setTransition : function(elBlock, nBlockSize, sTransitionTimingFunction, nDuration){
		sTransitionTimingFunction = sTransitionTimingFunction || this.option("sTransitionTimingFunction");
		nDuration = nDuration || this.option("nDuration");

		if(nDuration > 0){
			this._attachTransitionEnd(elBlock);
		}

		var sTransition = "";
		var sDirection = this.option("sDirection");
		elBlock.style.webkitTransition = "";
		elBlock.style.mozTransition = "";

		if(sDirection === "vertical") {
			sTransition  = "height " + nDuration + "ms " + sTransitionTimingFunction;
			elBlock.style.webkitTransition = sTransition;
			elBlock.style.mozTransition = sTransition;
			elBlock.style.height = nBlockSize + "px";
		} else if(sDirection === "horizontal") {
			sTransition  = "width " + nDuration + "ms " + sTransitionTimingFunction;
			elBlock.style.webkitTransition = sTransition;
			elBlock.style.mozTransition = sTransition;
			elBlock.style.width = nBlockSize + "px";
		}

		if(nDuration === 0) {
			this._onTransitionEnd({srcElement: elBlock});
		}
	},

	/**
	 * 아코디언 블럭의 Expand/Collapse 처리시 Effect 처리 종료함수
	 */
	_attachTransitionEnd : function(elBlock){
		this._elTransition = elBlock;
		this._elTransition.addEventListener('webkitTransitionEnd', this._wfTransitionEnd, false);
	},

	/**
	 * Effect 처리와 관련된 이벤트 해제 처리함수
	 */
	_detachTransitionEnd : function(el){
		el.removeEventListener('webkitTransitionEnd', this._wfTransitionEnd, false);
		this._elTransition = null;

	},

	/**
	 * TransitionEnd 이벤트 핸들러
	 */
	_onTransitionEnd : function(evt){

		//리랜더링을 하게 끔..
		var elDummyTag = MobileCommentJindo.$$.getSingle("._accordion_dummy_atag_", this._elContainer);
		if(elDummyTag){
			elDummyTag.focus();
		}

		this._detachTransitionEnd(evt.srcElement);

	},

	/**
	 * @description 객체를 release 시킨다.
	 */
	destroy : function() {
		this._detachEventAll();

		this._elContainer = null;
		this._aAccordionBlock = null;
		this._elBlock = null;
		this._htBlockSize = null;
		this._nExpand = null;
	}
}).extend(MobileCommentJindo.UIComponent);





/**
* @(#)MobileCommentJindo.m.AjaxHistory.js 2011. 9. 20.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author "oyang2"
* @since 2011. 9. 20.
* @description
* * <1.1.0 릴리즈, 코드수정>
*  - bUseHash 옵션추가
*/
MobileCommentJindo.m.AjaxHistory = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.AjaxHistory.prototype */

	/**
	 * hashchange 이벤트 사용여부
	 * @type {Boolean}
	 */
	bHashEvent : false,
	/**
	 * pushState 이벤트 사용여부
	 * @type {Boolean}
	 */
	bPushState : false,
	/**
	 * setInterval()의 리턴 값
	 * @type {Number}
	 */
	_nIntervalId : 0,
	/**
	 * 히스토리 데이터 저장 객체
	 * @type {HashTable}
	 */
	_htLastState : {},

	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.Component
	 * @example
	 * var oAjaxHistoryInstance;
	 *
	 * oAjaxHistoryInstance = new MobileCommentJindo.m.AjaxHistory({	 *
	 *     nCheckInterval : 100, // setInterval()을 이용하여 로케이션 변경을 체크 시, 체크 주기
	 *     bUseHash :  false //무조건 해시값을 사용할지 여부
	 * }).attach({
	 * 		//초기 load 이벤트에는 addHistory가 아닌 loadHistory를 이용해서 데이터를 추가하여야 한다
	 * 		'load' : function(){
	 * 			oAjaxHistoryInstance.loadHistory({
	 * 				"sPageNumber" : "1",
	 * 				"aParameter" : [1,2,3]
	 * 			});
	 * 		},
	 * 		'change' : function(oCustomEvt){
	 * 			oAjaxHistoryInstance.addHistory({
	 * 				"sPageNumber" : "2",
	 * 				"aParameter" : [4,5,6]
	 * 			});
	 * 		}
	 * });
	 *
	 * oAjaxHistoryInstance.initialize(); //초기화
	 *
     */

	$init : function(htUserOption) {
		this.option({
			nCheckInterval : 100,
			bUseHash : false //
		});
		this.option(htUserOption || {});
	},

	/**
	 * 컴포넌트 초기화 후에, 로케이션 변경 체크 및 초기 이벤트 발생을 위한 초기화 함수
	 * @return {this}
	 */
	initialize : function(){
		this._initVar();
		this._attachEvent();
		var sHash = this._getHash();

		if(sHash){
			this._htLastState = this._getDecodedData(sHash);
			this.fireEvent("change", {
				htHistoryData : this._htLastState
			});
		}else{
			this.fireEvent('load');
		}

		return this;
	},

	/**
	 * @description MobileCommentJindo.m.AjaxHistory 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar: function() {
		var htInfo = MobileCommentJindo.m.getDeviceInfo();

		this.bHashEvent = 'onhashchange' in window;
		/* ios4.2 버전에서 pusthState, replaceState는 지원이 되지만 버그가 있기 때문에 사용하지 않는다 */
		this.bPushState = (typeof window.history !== 'undefined')&& (typeof window.history.pushState !== 'undefined') && (typeof window.history.replaceState !== 'undefined') && !((htInfo.iphone || htInfo.ipad)&& (parseFloat(htInfo.version,10) < 4.3));

		this._nIntervalId = 0;
		this._oAgent = MobileCommentJindo.$Agent().navigator();

		this._bAndroid =  htInfo.android;

		if(this.option('bUseHash')){
			this.bPushState = false;
		}
	},

	/**
	 * @description MobileCommentJindo.m.AjaxHistory 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};

		if(this.bPushState){
			this._htEvent['popstate'] ={
				ref : MobileCommentJindo.$Fn(this._onPopState, this).attach(window,'popstate'),
				el : window
			};
		}else if(this.bHashEvent){
			//hashchange event supports
			this._htEvent["hashchange"] = {
				ref : MobileCommentJindo.$Fn(this._onHashChange, this).attach(window, "hashchange"),
				el	: window
			};
		}else{
			//ios3.x bug fix
			clearInterval(this._nIntervalId);
			this._nIntervalId = setInterval(MobileCommentJindo.$Fn(this._onHashChange, this).bind(), this.option("nCheckInterval"));
		}
	},


	_onPopState : function(event){
		var state = event.$value().state;
		if(state){
			var htData = this._cloneObject(state);

			if(!this._compareData(htData, this._htLastState)){
				this._htLastState = htData;
				this._onChange();
			}
		}
	},

	_onHashChange : function(){
		var htData = this._getDecodedData(this._getHash());
		if(!this._compareData(htData, this._htLastState)){
			this._htLastState = htData;
			this._onChange();
		}
	},

	_onChange : function(){
		// change 이벤트 발생
		this.fireEvent("change", {
			htHistoryData : this._htLastState
		});
	},

	/**
	 * htData 브라우저의 히스토리에 추가
	 *
	 * @param {HashTable} htData 추가할 히스토리 데이터 객체
	 * @param {Boolean} bLoad 초기 load 인지 여부
	 */
	addHistory : function(htData, bLoad){
		if(typeof bLoad === 'undefined'){
			bLoad = false;
		}
		if(htData && typeof(htData) == "object" && MobileCommentJindo.$H(htData).length() > 0){
			this._htLastState = this._cloneObject(htData);
			var sHash = this._getEncodedData(this._htLastState);
			if(this.bPushState){
				if(bLoad){
					this._replaceState(this._htLastState);
				}else{
					this._pushState(this._htLastState);
				}
			}else{
				var self = this;
				if(this._bAndroid ){
					setTimeout(function(){
						self._setHash(sHash);
					},0);
				}else{
					this._setHash(sHash);
				}
			}
		}
	},

	_replaceState : function(htData){
		history.replaceState( htData, document.title, location.href );
	},

	_pushState : function(htData){
		history.pushState(htData, document.title, location.href);
	},


	_setHash : function(sHash){
		location.hash = sHash;
	},

	/**
	 * 두 데이터 객체를 비교하여 결과를 리턴
	 * - 하위 데이터가 Object나 Array일 경우, 재귀적으로 비교
	 *
	 * @param {HashTable} htBase 비교 기준 객체
	 * @param {HashTable} htComparison 비교 객체
	 * @param {Boolean} 비교 결과
	 */
	_compareData : function(htBase, htComparison){
		if(htBase && htComparison){
			if(MobileCommentJindo.$H(htBase).length() == MobileCommentJindo.$H(htComparison).length()){
				for(var x in htBase){
					if(typeof(htBase[x]) == "object"){
						if(!arguments.callee(htBase[x], htComparison[x])){
							return false;
						}
					}else{
						if(htBase[x] != htComparison[x]){
							return false;
						}
					}
				}

				return true;
			}else{
				return false;
			}
		}else{
			return false;
		}
	},

	/**
	 * htHistoryData 객체를 Json 문자열로 변환 후, 인코딩하여 리턴
	 * - JSON.stringify() 함수를 브라우저에서 지원할 경우, 해당 함수 사용
	 * - 위의 함수를 지원하지 않을 경우, MobileCommentJindo.$Json().toString() 함수 사용
	 *
	 * @param {HashTable} htHistoryData 히스토리 데이터 객체
	 * @return {String} Json 문자열로 변환 후, 인코딩한 문자열
	 */
	_getEncodedData : function(htHistoryData){
		if(htHistoryData){
			// JSON.stringify() 함수를 지원하는 경우
			if(typeof(JSON) == "object" && typeof(JSON.stringify) == "function"){
				return encodeURIComponent(JSON.stringify(htHistoryData));
			}else{
				return encodeURIComponent(MobileCommentJindo.$Json(htHistoryData).toString());
			}
		}else{
			return "";
		}
	},

	/**
	 * 인코딩된 히스토리 데이터를 HashTable 객체로 변환 후, 리턴
	 * - JSON.parse() 함수를 브라우저에서 지원할 경우, 해당 함수 사용
	 * - 위의 함수를 지원하지 않을 경우, MobileCommentJindo.$Json().toObject() 함수 사용
	 *
	 * @param {String} sEncodedHash 인코딩된 히스토리 데이터
	 * @return {HashTable} 디코딩 후, HashTable로 변환한 객체
	 */
	_getDecodedData : function(sEncodedHash){
		try {
			if(sEncodedHash){
				var sHashString = decodeURIComponent(sEncodedHash);
				// JSON.parse() 함수를 지원하는 경우
				if(typeof(JSON) == "object" && typeof(JSON.parse) == "function"){
					return JSON.parse(sHashString);
				}else{
					return MobileCommentJindo.$Json(sHashString).toObject();
				}
			}
		} catch (e) {}
		return {};
	},

	_cloneObject : function(htObj){
		var hash, newHash;

		if(htObj){
			hash = MobileCommentJindo.$Json(htObj).toString();
			newHash = MobileCommentJindo.$Json(hash).toObject();
		}else{
			newHash = {};
		}

		return newHash;
	},

	_getHash : function(){
		return this._oAgent.firefox ? encodeURIComponent(location.hash.substring(1)) : location.hash.substring(1);

	},


	/**
	 * @description MobileCommentJindo.m.AjaxHistory 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		for(var p in this._htEvent) {
			var htTargetEvent = this._htEvent[p];
			htTargetEvent.ref.detach(htTargetEvent.el, p);
		}

		this._htEvent = null;
	},


	/**
	 * @description  MobileCommentJindo.m.AjaxHistory 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this._detachEvent();

		clearInterval(this._nIntervalId);
		this._nIntervalId = null;
	}
}).extend(MobileCommentJindo.Component);
/**
* @(#)MobileCommentJindo.m.CircularFlicking.js 2011. 11. 01.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author "oyang2"
* @since 2011. 11. 01.
* @description
*  <2차 Release이후, 코드 수정사항>
*  - 옵션 bUseFocus 삭제
*  - pageshow이벤트의 setTimeout 삭제
*  - 커스텀 이벤트의 파라미터중 bLeft 값을 세로 모드에서는 bTop값으로 수정
*  - _aAnchor 에 a태그를 엘리먼트를 추가할때 ios에서만 하도록 수정(_bBlocked 플래그값 추가)
*  - 내부 엘리먼트 변수이름 wrapper 를 container로 수정
*  - moveNext, movePrev에 파라미터 nDuration 추가
*  - 옵션명 nItem -> nTotalContents 이름 수정
*  - 내부변수 및 메소드에서 content -> panel 로 수정
*  - 내부변수 및 메소드에서 Item -> content 로 수정
*  <안드로이드 3.0이상 대응 코드 수정사항>
*  - 안드로이드 포커스를 대응하기 위한 더미태그가 3.0이상부터는 필요없음
*  - 안드로이드에서도 3d를 사용함
*  - 깜박이는걸 방지하기 위해 transitionEnd 이후에 translateZ(0px)을 삽입함.
*  <1.1.0 릴리즈, 코드수정>
*  - bUsePreserve3dForAndorid 옵션 삭제
*  - 안드로이드에서 css3 + javascript 혼용방식으로 수정
*  - getPanelElement()메소드 추가
*  - getRightPanelElement() 메소드 추가
*  - getLeftPanelElement() 메소드 추가
*  <1.1.0 , 갤럭시s2 코드 수정>
*  - preserved-3d 옵션제거.
*  - animationFrame 형식에서 마지막에 위치 잡아주는 코드 추가
*/
MobileCommentJindo.m.CircularFlicking = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.CircularFlicking.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class 3개의 패널을 순환적으로 플리킹하는 클래스
	 * @param {HTMLElement | String} el 플리킹 기준 엘리먼트 (혹은 id)
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
	 * @requires MobileCommentJindo.m.Touch
	 * @example
var oFlicking = new MobileCommentJindo.m.Flicking('layer1', {
		bHorizontal : true,  //가로 플리킹 여부 세로 플리킹일 경우 false
		sClassPrefix : 'flick-',
		nDuration : 200,//flicking 타임
		nFlickThreshold : 40, //페이지 단위로 옮길때 최소 move 거리
		nTotalContents : 3,
		bActivateOnload : true
	});
     */
	$init : function(sId, htUserOption) {
		this.option({
			bHorizontal : true,
			sClassPrefix : 'flick-',
			nFlickThreshold : 40,
			nDuration : 100,
			nTotalContents : 3,
			bActivateOnload : true
		});

		this.option(htUserOption || {});

		this._initVar();
		this._setWrapperElement(sId);
		this._setElementSize();
		this._updatePanelPosition();
		this._initTouch();
		this._setAnchorElement();
		this._focusFixedBug();

		if(this.option("bActivateOnload")) {
			this.activate();
		}
	},
	/**
	 * @description MobileCommentJindo.m.CircularFlicking 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar: function() {
		this._oTouch = null;
		this._bFlickLeft = null;
		this._elTransition = null;

		this._htIndexInfo = {
			nPanelIndex : 0,
			nContentIndex : 0,
			nNextPanelIndex :0,
			nNextContentIndex : 0
		};

		//현재 각 컨텐츠들의 css transform으로 움직인 포지션 정보
		this._aCurrentPosition = [0,0,0];

		var htInfo = MobileCommentJindo.m.getDeviceInfo();
		var nVersion = parseInt(htInfo.version.substring(0,1),10);
		//this._isAndroid3Up = htInfo.android &&  ( (htInfo.version.length>0)&&  (nVersion >= 3));

		this.sTransformStart = "translate(";
		this.sTransformEnd = ")";

		if(htInfo.iphone || htInfo.ipad){
			this.sTransformStart = "translate3d(";
			this.sTransformEnd = ",0px)";
		}
		this._isAndroid = htInfo.android;

		this._isIos = (htInfo.iphone || htInfo.ipad );

		this._sCssPrefix = MobileCommentJindo.m.getCssPrefix();

		this._wfTransitionEnd = MobileCommentJindo.$Fn(this._onTransitionEnd, this).bind();

		this._aAnchor = null;
		this._fnDummyFnc = function(){return false;};
		this._bBlocked = false;
		this._isFlicking = false;

		//안드로이드용 animationFrame 설정하기위한 속성.
		this._initAnimationStep();
	},

	_initAnimationStep : function(){
		this._htAnimationStep = {
				nPosPerTime : 0,
				nAnimateTime : 0,
				nBeforeTime : 0,
				nPos :0
		};
	},

	/**
	 * @description Touch 컴포넌트 초기화 한다.
	 */
	_initTouch : function(){
		this._oTouch = new MobileCommentJindo.m.Touch(this._htWElement.container.$value(),{
			nSlopeThreshold : 4,
			nMoveThreshold : 0,
			bActivateOnload : false
		});
	},

	/**
	 * @description MobileCommentJindo.m.CircularFlicking 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement: function(el) {
		this._htWElement = {};
		el = MobileCommentJindo.$(el);
		var sClass = '.'+ this.option('sClassPrefix');

		this._htWElement.base = MobileCommentJindo.$Element(el);

		this._htWElement.container = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle(sClass+'container',el));
		this._htWElement.container.css('overflow', 'hidden').css('position','absoulte');

		// WRAPPER -> CONTAINER로 수정
		var aPanel = MobileCommentJindo.$$(sClass+"panel", el);
		this._htWElement.aPanel = MobileCommentJindo.$A(aPanel).forEach(function(value,index, array){
			var wel = MobileCommentJindo.$Element(value);
			array[index] = wel;
			wel.css('position', 'absolute').css('width','100%').css('height','100%');
		}).$value();

		//android3.0이상부터는 포커스를 위한 더미 태그가 필요하지 않는다.
		if(this._isAndroid) {
			this._htWElement.aDummyTag = [];
			for(var i=0,nLen = this._htWElement.aPanel.length;i<nLen;i++){
				var wel =this._htWElement.aPanel[i];
				var elDummyTag = MobileCommentJindo.$$.getSingle("._cflick_dummy_atag_", wel.$value());
				if(!elDummyTag){
					elDummyTag = MobileCommentJindo.$("<a href='javascript:void(0);' class='_cflick_dummy_atag_'></a>");
					elDummyTag.style.position = "absolute";
					elDummyTag.style.left = "-1000px";
					elDummyTag.style.top = "-1000px";
					elDummyTag.style.width = 0;
					elDummyTag.style.height = 0;
					wel.append(elDummyTag);
				}
				this._htWElement.aDummyTag.push(elDummyTag);
			}
		}
	},

	/**
	 * @description ios에서 3d 속성을 설정한다.
	 * - 미리 한번만 설정하면 translate 설정할때마다 해줄 필요가 없기 때문에 초기 한번만 설정한다.
	 */
	_prepareTransition : function(){
		//초기에 한번만 실행되도록 수정
		if(this._isIos){
			for(var i=0,nLen = this._htWElement.aPanel.length; i<nLen; i++){
				this._htWElement.aPanel[i].css(this._sCssPrefix+'TransformStyle', "preserve-3d");
			}
		}
	},

	/**
	 * @description 가로 세로 모드에 따라 container 의 넓이 혹은 높이를 설정한다
	 */
	_setElementSize : function(){
		if(this.option('bHorizontal')){
			this._htWElement.container.width(this._htWElement.base.width() * 3).height(this._htWElement.base.height());
		}else{
			this._htWElement.container.height(this._htWElement.base.height() * 3).width(this._htWElement.base.width());
		}
	},

	/**
	 * @description flicking 내에 a 엘리먼트를 모두 가져와서 세팅한다. (ios에서만)
	 */
	_setAnchorElement : function(el){
		//ios에서만 처리되도록 수정.
		if(this._isIos ){
			this._aAnchor = MobileCommentJindo.$$("A", this._htWElement.container.$value());
		}
	},

	/**
	 * @description 3개의 panel의 위치를 다시 계산한다.
	 */
	_updatePanelPosition : function(){
		this._aCtPosition = [];
		//var nW = this.option('bHorizontal')? this._htWElement.base.width() : this._htWElement.base.height();
		var el = this._htWElement.base.$value();
		var nW = this.option('bHorizontal')? el.clientWidth : el.clientHeight;

		this._htPositionInfo = {
			left : nW*-1,
			center : 0,
			right : nW*1
		};
	},

	/**
	 * @description 화면 전환시에 처리 로직
	 * 각 contents의 포지션을 다시 구하고 포지션 이동
	 */
	_onResize : function(){
		this.refresh(this.getPanelIndex(), true);
	},

	/**
	 * @description 현재 화면 중앙에 보이는 영역에 Panel의 인덱스를 리턴한다.
	 * @return {Number} n
	 */
	getPanelIndex : function(){
		return this._htIndexInfo.nPanelIndex;
	},

	/**
	 * @description 현재 화면 중앙에 보이는 영역에 Panel의 엘리먼트를 래핑된 형태로 리턴한다.
	 * @return {MobileCommentJindo.$Element}
	 */
	getPanelElement : function(){
		return this._htWElement.aPanel[this.getPanelIndex()];
	},

	/**
	 * @description 현재 화면에서 오른쪽(아래쪽) 영역에 Panel의 인덱스를 리턴한다.
	 * @return {Number} n
	 */
	getRightPanelIndex : function(){
		var n = this.getPanelIndex() +1;
		n = (n > 2 )? 0 : n;

		return n;
	},

	/**
	 * @description 현재 화면에서 오른쪽(아래쪽) 영역에 Panel 엘리먼트를 래핑된 형태로 리턴한다.
	 * @return {MobileCommentJindo.$Element}
	 */
	getRightPanelElement : function(){
		return this._htWElement.aPanel[this.getRightPanelIndex()];
	},


	/**
	 * @description 현재 화면 왼쪽(위쪽) 영역에 Panel의 인덱스를 리턴한다.
	 * @return {Number} n
	 */
	getLeftPanelIndex : function(){
		var n = this.getPanelIndex() -1;
		n = (n <0 )? 2 : n;

		return n;
	},

	/**
	 * @description 현재 화면 왼쪽(위쪽) 영역에 Panel 엘리먼트를 래핑된 형태로 리턴한다.
	 * @return {MobileCommentJindo.$Element}
	 */
	getLeftPanelElement : function(){
		return this._htWElement.aPanel[this.getLeftPanelIndex()];
	},

	/**
	 * @description 현재 중앙에 보이는 컨텐츠의 인덱스를 n으로 설정한다.
	 * @param {Number} n
	 * @param {Boolean} panel의 위치를 다시 잡을지에 대한 여부
	 */
	setContentIndex : function(n, bRefresh){
		if(!this.isActivating()){
			return;
		}
		if(typeof bRefresh === 'undefined'){
			bRefresh = true;
		}

		n = parseInt(n,10);
		if(n < 0 || n > (this.option('nTotalContents')-1)){
			return;
		}

		if(bRefresh){
			if(!this._fireCustomEvent('beforeMove',{
				nPanelIndex : this.getPanelIndex(),
				nContentIndex : this.getContentIndex(),
				nNextPanelIndex : n%3,
				nNextContentIndex: n
			})){
				return;
			}
		}

		this._htIndexInfo.nContentIndex = n;
		this._htIndexInfo.nPanelIndex = n % 3;
		this._htIndexInfo.nNextContentIndex = n;
		this._htIndexInfo.nNextPanelIndex = n % 3;

		if(bRefresh){
			this.refresh(this._htIndexInfo.nPanelIndex, false, true);
		}
	},

	/**
	 * @description 컴포넌트의 옵션값 nTotalContent을 기준으로 현재 화면에 보이는 콘텐츠 영역의 Content의 인덱스를 반환한다.
	 * Panel의 인덱스가 아닌 Content의 인덱스를 리턴한다.
	 * @return {Number} n
	 */
	getContentIndex : function(){
		return this._htIndexInfo.nContentIndex;
	},

	/**
	 * @description 오른쪽(아래쪽) Panel의 content의 인덱스를 리턴한다
	 * @return {Number} n
	 */
	getRightContentIndex : function(){
		var n = this.getContentIndex()+1;
		n = ((n+1) > this.option('nTotalContents'))? 0 : n;

		return n;
	},

	/**
	 * @description 왼쪽(위쪽) Panel의 content의 인덱스를 리턴한다
	 * @return {Number} n
	 */
	getLeftContentIndex : function(){
		var n = this.getContentIndex()-1;
		n =  (n <0)? (this.option('nTotalContents')-1): n;

		return n;
	},

	/**
	 * @description touchStart 발생 처리
	 */
	_onStart : function(oCustomEvt){
		if(!this.fireEvent('touchStart', oCustomEvt)){
			return;
		}

		this._clearAnchor();

		this._oTouch.attach({
			touchMove : this._htEvent["touchMove"],
			touchEnd :  this._htEvent["touchEnd"],
			longTap :  this._htEvent["longTap"]
		});

	},

	/**
	 * @description touchMove가 발생할때 처리
	 */
	_onMove : function(oCustomEvt){
		var bH = this.option('bHorizontal');

		/** 시스템 스크롤 막기 */
		var weParent = oCustomEvt.oEvent;
		if(oCustomEvt.sMoveType === MobileCommentJindo.m.MOVETYPE[0]) {	//수평이고,수평스크롤인 경우 시스템 스크롤 막기
			if(bH) {
				weParent.stop(MobileCommentJindo.$Event.CANCEL_ALL);
			}else{
				return;
			}
		} else if(oCustomEvt.sMoveType === MobileCommentJindo.m.MOVETYPE[1]) {	//수직이고, 수직스크롤인 경우 시스템 스크롤 막기
			if(!bH) {
				weParent.stop(MobileCommentJindo.$Event.CANCEL_ALL);
			}else{
				return;
			}
		}else if(oCustomEvt.sMoveType === MobileCommentJindo.m.MOVETYPE[2]) { //대각선 일때 시스템 스크롤 막기
			weParent.stop(MobileCommentJindo.$Event.CANCEL_ALL);
		}

		if(this._isFlicking){
			return;
		}

		this.fireEvent('touchMove', oCustomEvt);

		var nDis = bH? oCustomEvt.nVectorX : oCustomEvt.nVectorY;

		this._movePanels(nDis);
	},

	/**
	 * @description touchEnd 가 발생할때 처리
	 */
	_onEnd : function(oCustomEvt, nTime){
		this._oTouch.detach({
			touchMove : this._htEvent["touchMove"],
			touchEnd :  this._htEvent["touchEnd"],
			longTap :  this._htEvent["longTap"]
		});

		this._isFlicking = true;

		var htInfo = this._getSnap(oCustomEvt.nDistanceX, oCustomEvt.nDistanceY, nTime);

		//탭 혹은 롱탭일때
		if (oCustomEvt.sMoveType === MobileCommentJindo.m.MOVETYPE[3] || oCustomEvt.sMoveType === MobileCommentJindo.m.MOVETYPE[4]) {
			this._restoreAnchor();
		}
		var nPanelIndex = this.getPanelIndex();

		if(nPanelIndex == htInfo.nPanelIndex){
			this._onTransitionEnd();
			return;
		}

		var htParam = {
				nPanelIndex : nPanelIndex,
				nContentIndex : this.getContentIndex(),
				nNextPanelIndex : htInfo.nPanelIndex,
				nNextContentIndex: htInfo.nContentIndex
		};

		if(this._bFlickLeft !== null){
			//가로일때는   bLeft,  세로일때는 bTop 으로
			if(this.option('bHorizontal')){
				htParam.bLeft = this._bFlickLeft;
			}else{
				htParam.bTop = this._bFlickLeft;
			}
		}

		if(!this._fireCustomEvent('beforeFlicking',htParam)){
			return;
		}

		var nDis = this.option('bHorizontal')? htInfo.nX: htInfo.nY;
		//this._movePanels(nDis, htInfo.nTime, false);

		this._htIndexInfo.nNextPanelIndex = htInfo.nPanelIndex;
		this._htIndexInfo.nNextContentIndex = htInfo.nContentIndex;
		this._movePanels(nDis, htInfo.nTime, false);

		this.fireEvent('touchEnd', oCustomEvt);
	},

	/**
	 * @description 세개의 panel 영역을 nPos 만큼 움직인다.
	 * @param {Number} npos
	 * @param {Number} duration
	 * @param {Boolean}
	 */
	_movePanels : function(nPos, nTime, bMove){
		if(typeof nTime === 'undefined'){
			nTime = 0;
		}

		if(typeof bMove === 'undefined'){
			bMove = true;
		}

		var aPanel = this._htWElement.aPanel;

		//@to-do animationframe 스타일로
		if(this._isIos ||(!this._isIos && (nTime === 0))){
			for(var i=0,nLen = aPanel.length; i<nLen;i++){
				var nNewPos = (bMove)? this._aCurrentPosition[i]+ nPos : nPos;
				this._setPosition(aPanel[i], nNewPos, nTime);
				this._aCurrentPosition[i] =  nNewPos;
			}
		}else{
			var nPosPerTime = (nPos - this._aCurrentPosition[1])/nTime;

			this._htAnimationStep.nPosPerTime = nPosPerTime;
			this._htAnimationStep.nAnimateTime = nTime;
			var startTime = Date.now();
			this._htAnimationStep.nBeforeTime = startTime;
			this._htAnimationStep.nPos = nPos;
			var self = this;

			(function animate(){
				var now = Date.now();
				if(now >= (startTime + self._htAnimationStep.nAnimateTime)){
					for(var i=0,nLen =  self._htWElement.aPanel.length; i<nLen;i++){
						self._setPosition( self._htWElement.aPanel[i], self._htAnimationStep.nPos, 0);
					}
					clearTimeout(self._nTimerAnimate);
					self._initAnimationStep();
					self._onTransitionEnd();
					return;
				}

				var nGap = (now - self._htAnimationStep.nBeforeTime);
				self._htAnimationStep.nBeforeTime = now;
				var nPos = self._htAnimationStep.nPosPerTime * nGap;
				var aPanel = self._htWElement.aPanel;
				for(var i=0,nLen = aPanel.length; i<nLen;i++){
					var nNewPos =self._aCurrentPosition[i]+ nPos;
					self._setPosition(aPanel[i], nNewPos, 0);
					self._aCurrentPosition[i] =  nNewPos;
				}

				self._nTimerAnimate = setTimeout(animate, 1);
			})();


		}
	},

	/**
	 * @description 안드로이드에서 css 속성을 사용해서 transform 이후에 포커스를 잃는 현상의 버그 수정하는 코드
	 */
	_focusFixedBug : function(){
		if(typeof this._htWElement.aDummyTag === 'undefined'){
			return;
		}

		for(var i=0,nLen= this._htWElement.aDummyTag.length;i<nLen;i++){
			this._htWElement.aDummyTag[i].focus();
		}
	},

	/**
	 * @description 플리킹 이후에 움직여야하는 거리와 컨텐트 인덱스를 구한다
	 * @return {HashTable}
	 */
	_getSnap : function(nDistanceX, nDistanceY, nDuration){
		var nFinalDis = this.option('bHorizontal')? nDistanceX : nDistanceY;

		var nNewPos = this._htPositionInfo.center;
		var nTime = (typeof nDuration != 'undefined')? nDuration : this.option('nDuration');
		var nPanelIndex = this.getPanelIndex();
		var nContentIndex = this.getContentIndex();

		if(Math.abs(nFinalDis) > this.option('nFlickThreshold') ){
			if(nFinalDis < 0 ){ //왼쪽 방향 혹은 위쪽 방향으로 밀고 있을 때
				nNewPos = this._htPositionInfo.left;
				nPanelIndex = this.getRightPanelIndex();
				nContentIndex =  this.getRightContentIndex();
				this._bFlickLeft = true; // 이름   어쩌지...
			}else{ //오른쪽 방향 혹은 아래 방향으로 밀때
				nNewPos = this._htPositionInfo.right;
				nPanelIndex = this.getLeftPanelIndex();
				nContentIndex = this.getLeftContentIndex();
				this._bFlickLeft = false;
			}
		}

		return {
			nX : nNewPos,
			nY : nNewPos,
			nTime : nTime,
			nPanelIndex : nPanelIndex,
			nContentIndex : nContentIndex
		};
	},

	/**
	 * @description wel에 translate를 설정한다.(가로모드일 경우 x좌표, 세로모드일 경우 y좌표)
	 * @param {Element} wel
	 * @param {Number} nPos
	 * @param {Number} n css3 duration
	 *
	 */
	_setPosition : function(wel, nPos, nTime){
		if(typeof nTime == 'undefined'){
			nTime = 0;
		}

		var nX = this.option('bHorizontal')? nPos : 0;
		var nY = this.option('bHorizontal')? 0 : nPos;

		if(nTime > 0){
			this._attachTransitionEnd(wel.$value());
		}

		if(nTime !== 0){
			nTime +="ms";
		}

		var htCss = {};
		htCss[this._sCssPrefix+'TransitionProperty'] = "-webkit-transform";
		htCss[this._sCssPrefix+'TransitionDuration'] = nTime;
		htCss[this._sCssPrefix+'Transform'] = this.sTransformStart + nX +"px,"+nY+"px" +this.sTransformEnd;

		wel.css(htCss);
	},

	/**
	 * @description Anchor 삭제
	 */
	_clearAnchor : function() {
		if(this._aAnchor && !this._bBlocked) {
			var aClickAddEvent = null;
			for(var i=0, nILength=this._aAnchor.length; i<nILength; i++) {
				if (this._fnDummyFnc !== this._aAnchor[i].onclick) {
					this._aAnchor[i]._onclick = this._aAnchor[i].onclick;
				}
				this._aAnchor[i].onclick = this._fnDummyFnc;
				aClickAddEvent = this._aAnchor[i].___listeners___ || [];
				for(var j=0, nJLength = aClickAddEvent.length; j<nJLength; j++) {
					___Old__removeEventListener___.call(this._aAnchor[i], "click", aClickAddEvent[j].listener, aClickAddEvent[j].useCapture);
				}
			}
			this._bBlocked = true;
		}
	},

	/**
	 * @description Anchor 복원. for iOS
	 */
	_restoreAnchor : function() {
		if(this._aAnchor && this._bBlocked) {
			var aClickAddEvent = null;
			for(var i=0, nILength=this._aAnchor.length; i<nILength; i++) {
				if(this._fnDummyFnc !== this._aAnchor[i]._onclick) {
					this._aAnchor[i].onclick = this._aAnchor[i]._onclick;
				} else {
					this._aAnchor[i].onclick = null;
				}
				aClickAddEvent = this._aAnchor[i].___listeners___ || [];
				for(var j=0, nJLength = aClickAddEvent.length; j<nJLength; j++) {
					___Old__addEventListener___.call(this._aAnchor[i], "click", aClickAddEvent[j].listener, aClickAddEvent[j].useCapture);
				}
			}
			this._bBlocked = false;
		}
	},

	/**
	 * @description nDuration 시간만큼 다음(오른쪽 콘텐츠, 아래)로 이동한다.
	 * @param {Number} nDuration
	 */
	moveNext : function(nDuration){
		if(!this.isActivating()){
			return;
		}
		var n = this.option('nFlickThreshold')*-1;

		this._onEnd({
			nDistanceX : n-10,
			nDistanceY : n-10
		}, nDuration);
	},

	/**
	 * @description nDuration 시간만큼 이전(왼쪽 콘텐츠, 위쪽)로 이동한다.
	 *  @param {Number} nDuration  추가
	 */
	movePrev : function(nDuration){
		if(!this.isActivating()){
			return;
		}
		var n = this.option('nFlickThreshold');

		this._onEnd({
			nDistanceX : n+10,
			nDistanceY : n+10
		}, nDuration);
	},

	/**
	 * @description n배열이 중앙에 오도록 panel을 다시 좌우 배열해서 배치한다.
	 * @param {Number} n 현재 화면에 보여져야할 content의 인덱스
	 * @param {Boolean} bResize 화면 크기가 변화되어 다시 사이즈를 업데이트 해야 할경우
	 * @param {Boolean} 커스텀이벤트 발생여부
	 */
	refresh : function(n, bResize, bFireEvent){
		if(!this.isActivating()){
			return;
		}

		if(typeof bResize === 'undefined'){
			bResize = false;
		}
		if(typeof bFireEvent === 'undefined'){
			bFireEvent = false;
		}

		if(bResize){
			this._setElementSize();
			this._updatePanelPosition();
		}

		if(typeof n === 'undefined'){
			n = this.getPanelIndex();
		}

		if(this._htIndexInfo.nPanelIndex != n){
			this._htIndexInfo.nPanelIndex = n;
		}

		var nCenter = this.getPanelIndex();
		var nLeft = this.getLeftPanelIndex();
		var nRight = this.getRightPanelIndex();

		var sPosition = this.option('bHorizontal')? 'left':'top';

		this._htWElement.aPanel[nCenter].css(sPosition, this._htPositionInfo.center).css('zIndex',10);
		this._htWElement.aPanel[nLeft].css(sPosition, this._htPositionInfo.left).css('zIndex',1);
		this._htWElement.aPanel[nRight].css(sPosition, this._htPositionInfo.right).css('zIndex',1);

		if(bFireEvent){
			this._fireCustomEvent('move');
		}
	},
	/**
	 * @description transitionEnd 이후에 코드
	 * - css transition을 없앤다
	 * - 각 pannel의 offset을 수정한다.(refresh 함수 호출)
	 * - 안드로이드의 focus 버그 픽스
	 * - 커스텀이벤트 발생
	 */
	_onTransitionEnd : function(evt){
		this._detachTransitionEnd();

		//$Element의 css 속성으로 설정할 경우 깜박거리는 이슈 생김.
		//HTMLElement의 style로 접근시에는 안 깜박 거림
		MobileCommentJindo.$A(this._htWElement.aPanel).forEach(function(value, i, array){
			value.$value().style[this._sCssPrefix +'TransitionDuration'] = null;
			value.$value().style[this._sCssPrefix +'TransitionProperty'] = '';
			value.$value().style[this._sCssPrefix +'Transform'] = '';
		},this);

		var bFireEvent = false;

		if(this._htIndexInfo.nPanelIndex != this._htIndexInfo.nNextPanelIndex){
			bFireEvent = true;
		}

		this.refresh(this._htIndexInfo.nNextPanelIndex);

		//현재 컨텐츠 다시 세팅
		this._htIndexInfo.nContentIndex = this._htIndexInfo.nNextContentIndex;

		//android css transform 이후에 포커싱 안되는 문제를 해결하기 위한 코드
		this._focusFixedBug();

		//현재 flicking 중인것 풀기
		this._isFlicking = false;

		if(bFireEvent){
			this._fireCustomEvent('afterFlicking');
		}

		this._bFlickLeft = null;

		//현재 각 컨텐츠의 css transform 포지션 리세팅
		this._aCurrentPosition = [0,0,0];
		this._setAnchorElement(this._htWElement.aPanel[this.getPanelIndex()].$value());
	},

	/**
	 * @description 커스텀이벤트 발생시킨다
	 * @return {Boolean}
	 */
	_fireCustomEvent : function(sEventName, htParam){
		if(typeof htParam === 'undefined'){
			htParam =  {
				nPanelIndex : this.getPanelIndex(),
				nContentIndex : this.getContentIndex(),
				nContentLeftIndex : this.getLeftContentIndex(),
				nContentRightIndex : this.getRightContentIndex(),
				nPanelLeftIndex : this.getLeftPanelIndex(),
				nPanelRightIndex : this.getRightPanelIndex()
			};
			//가로일때는   bLeft,  세로일때는 bTop 으로
			if(this.option('bHorizontal')){
				htParam.bLeft = this._bFlickLeft;
			}else{
				htParam.bTop = this._bFlickLeft;
			}
		}

		return this.fireEvent(sEventName,htParam);
	},

	/**
	 * @description transitionEnd 이벤트 attach
	 */
	_attachTransitionEnd : function(el){
		if(el === this._htWElement.aPanel[this.getPanelIndex()].$value()){
			this._elTransition = el;
			MobileCommentJindo.m.attachTransitionEnd(this._elTransition, this._wfTransitionEnd);
		}
	},

	/**
	 * @description transitionEnd 이벤트 detach
	 */
	_detachTransitionEnd : function(){
		if(this._elTransition){
			MobileCommentJindo.m.detachTransitionEnd(this._elTransition, this._wfTransitionEnd);
		}
	},

	/**
	 * @description MobileCommentJindo.m.Flicking 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this._attachEvent();
		this._oTouch.activate();
		this._prepareTransition();
		this.refresh();
	},

	/**
	 * @description MobileCommentJindo.m.Flicking 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
		this._oTouch.deactivate();
	},

	/**
	 * @description MobileCommentJindo.m.Flicking 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};
		//TRANSITIONeND  추가

		// resize 이벤트  처리
		this._htEvent["rotate"] = MobileCommentJindo.$Fn(this._onResize, this).bind();
		MobileCommentJindo.m.bindRotate(this._htEvent["rotate"]);

		/* Touch 이벤트용 */
		this._htEvent["touchMove"] = MobileCommentJindo.$Fn(this._onMove, this).bind();
		this._htEvent["touchEnd"] = MobileCommentJindo.$Fn(this._onEnd, this).bind();
		this._htEvent["touchStart"] = MobileCommentJindo.$Fn(this._onStart, this).bind();


		/* Touch attach */
		this._oTouch.attach("touchStart", this._htEvent["touchStart"]);

		/* pageshow 이벤트 처리 */
		this._htEvent["pageshow"] = MobileCommentJindo.$Fn(this._onPageShow, this).bind();
		MobileCommentJindo.m.bindPageshow(this._htEvent["pageshow"]);
	},

	/**
	 * @description pageshow 이벤트 처리 부분
	 * pageshow 는 실제로 캐시된 페이지에서 랜더링 완료 이전에 이벤트가 발생되기 때문에 setTimeout을 이용하여 resize를 호출한다
	 */
	_onPageShow : function(){
		this._onResize();
	},


	/**
	 * @description MobileCommentJindo.m.CircularFlicking 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		/* resize event unbind */
		MobileCommentJindo.m.unbindRotate(this._htEvent["rotate"]);
		/* pageshow event unbind */
		MobileCommentJindo.m.unbindPageshow(this._htEvent["pageshow"]);

		/* touch detach */
		this._oTouch.detachAll();

		this._htEvent = null;
	},

	/**
	 * @description  MobileCommentJindo.m.Flicking 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this.deactivate();

		for(var p in this._htWElement) {
			this._htWElement[p] = null;
		}

		for(var p in this._htIndexInfo){
			this._htIndexInfo[p] = null;
		}

		this._oTouch.destroy();

		this._elTransition = null;
		this._oTouch = null;
		this._bFlickLeft = null;
		this._isAndroid  = null;
		this._aCurrentPosition = null;
		this.sTransformStart = null;
		this.sTransformEnd  = null;
		this._isIos = null;
		this._aAnchor = null;
		this._fnDummyFnc = null;
		this._sCssPrefix = null;
		this._bBlocked = null;
		this._isFlicking  = null;

		for(var p in this._htAnimationStep){
			this._htAnimationStep[p] = null;
		}

		this._htAnimationStep  = null;
	}
}).extend(MobileCommentJindo.UIComponent);
/**
* @(#)MobileCommentJindo.m.CheckBox.js 2011. 9. 16.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sshyun
* @since 2011. 9. 16.
* @description
*/
MobileCommentJindo.m.CheckBox = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.CheckBox.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {Varient} el Checkbox Layout Wrapper
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.m.CheckRadioCore
	 */
	$init : function(el, htUserOption) {
		this.option({
			sClassPrefix	: "fcb-",
			sType			: "v",
			bActivateOnload : true,
			sUncheckBgColor : "transparent"
		});
		this.option(htUserOption || {});
		this._initVar();
		this._setWrapperElement(el, this.option("sClassPrefix"));
		this._initCheckLoad();
		if(this.option("bActivateOnload")) {
			this.activate();
		}

	},
	/**
	 * @description MobileCommentJindo.m.CheckBox 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar : function() {
		this.$super._initVar("checkbox", "checkbox");
	},
	/**
	 * @description 초기 체크 박스 체크 여부 확인.
	 */
	_initCheckLoad : function(){
		var aCheckUnit = this._htWElement["container"].queryAll('.' + this._sUnitClass);
		var welUnit, elCheckbox;
		for ( var i = 0; i < aCheckUnit.length; i++) {
			welUnit = MobileCommentJindo.$Element(aCheckUnit[i]);
			//elCheckbox = welUnit.query("input[type=checkbox]");
			elCheckbox = MobileCommentJindo.$$.getSingle("input[type=checkbox]", welUnit.$value());
			this._setChecked(elCheckbox.checked, elCheckbox, welUnit);
		}
		welUnit = elCheckbox = null;
	},

	/**
	 * @description CheckBox Toggle 효과 처리. List 에서 클릭시.
	 * @param {Object} welElement List Wrapper 엘리먼트.
	 */
	_afterCheck : function(welElement, bClickOverForm){
		var elCheckbox = MobileCommentJindo.$$.getSingle("." + this._sFormClass, welElement.$value());
		var sChecked = welElement.attr("data-cb-checked");
		var bChecked = (sChecked && sChecked == "on") ? false : true;
		//체크박스와 설정을 맞추기 위해 무조건 체크박스를 다시 설정한다.
	//	if(!bClickOverForm){
			elCheckbox.checked = bChecked;
	//	}
		this._setChecked(bChecked, elCheckbox, welElement);
	},
	/**
	 * @description 체크여부 설정 처리.
	 * @param {boolean} bChecked 체크여부
	 * @param {Element} elCheckbox CheckBox 엘리먼트
	 * @param {$Element} welUnit  CheckBox Wrapper 엘리먼트
	 */
	_setChecked : function(bChecked, elCheckbox, welUnit){
		var sEvent = "unchecked";
		var sBgColor = this.option("sCheckBgColor");
		// 체크해제 경우
		if(!bChecked){
			sBgColor = (sBgColor) ? this.option("sUncheckBgColor") : null;
			welUnit.removeClass(this._sOnClass);
			welUnit.attr("data-cb-checked", "off");
		//체크 경우
		} else {
			welUnit.addClass(this._sOnClass);
			welUnit.attr("data-cb-checked", "on");
			sEvent = "checked";
		}
		(sBgColor) ? welUnit.css("backgroundColor", sBgColor + " !important") : null;

		this.fireEvent(sEvent, {
			elCheckBoxUnit : welUnit.$value(),
			elCheckBox : elCheckbox
		});
	},
	/**
	 * @description check 된 항목값을 반환한다.
	 * @return {Array} 체크된 값의 배열 정보.
	 * @example
	 *
	 * var aValues = oCheckBox.getCheckedValue();
	 * for(var i = 0 ; i < aValues.length ; i++){
	 * 		alert(aValues[i]);
	 * }
	 */
	getCheckedValue : function(){
		var aValue = [];
		var aCheckBoxList = this._aWElFormList;
		var elTempCheck = null;
		for ( var i = 0; i < aCheckBoxList.length; i++) {
			elTempCheck = aCheckBoxList[i].$value();
			if(!elTempCheck.disabled && elTempCheck.checked){
				aValue.push(elTempCheck.value);
			}
		}
		return aValue;
	},
	/**
	 * @description 입력한 CheckBox 엘리먼트를 선택 / 선택해제 시킨다.
	 * @param {boolean} bChecked check 여부
	 * @param {Variant} vElement 체크를 설정할 checkbox Element.
	 * CheckBox input 엘리먼트 배열 또는 CheckBox Unit 엘리먼트 배열 또는 단일 엘리먼트가 입력 될수 있고,
	 * 입력값이 없을시 모든 CheckBox 엘리먼트가 기준이 된다.
	 * @example
	 * // 배열 선택시
	 * oCheckBox.setCheckedBox(true, [MobileCommentJindo.$("unit1"),MobileCommentJindo.$("unit2")]);
	 * // 단일 선택시
	 * oCheckBox.setCheckedBox(true, MobileCommentJindo.$("unit1"));
	 * // 전체 선택시
	 * oCheckBox.setCheckedBox(true);
	 *
	 * // 배열 선택해제시
	 * oCheckBox.setCheckedBox(false, [MobileCommentJindo.$("unit1"),MobileCommentJindo.$("unit2")]);
	 * // 단일 선택해제시
	 * oCheckBox.setCheckedBox(false, MobileCommentJindo.$("unit1"));
	 * // 전체 선택해제시
	 * oCheckBox.setCheckedBox(false);
	 *
	 */
	setCheckedBox : function(bChecked, vElement){
		var aIdx = this._getFormIdx(vElement);
		var elInput = null;
		for ( var i = 0; i < aIdx.length; i++) {
			elInput = this._aWElFormList[aIdx[i]].$value();
			if(!elInput.disabled){
				elInput.checked = bChecked;
				this._setChecked(bChecked, elInput, this._aWElUnitList[aIdx[i]]);
			}
		}
	},
	/**
	 * @description CheckBox 를 활성화 시킨다.
	 * @param {Variant} vElement 활성화 할 checkbox Element.
	 * CheckBox input 엘리먼트 배열 또는 CheckBox Unit 엘리먼트 배열 또는 단일 엘리먼트가 입력 될수 있고,
	 * 입력값이 없을시 모든 체크박스 엘리먼트가 기준이 된다.
	 * @example
	 * // 배열 활성화
	 * oCheckBox.enable([MobileCommentJindo.$("unit1"),MobileCommentJindo.$("unit2")]);
	 * // 단일 활성화
	 * oCheckBox.enable(MobileCommentJindo.$("unit1"));
	 * // 전체 활성화
	 * oCheckBox.enable();
	 *
	 */
	enable : function(vElement){
		var htElForm = this._useSettingForm(vElement, true);

		this.fireEvent("enable", {
			aCheckBoxList: htElForm.aFormList,
			aCheckBoxUnitList: htElForm.aUnitList
		});
	},
	/**
	 * @description CheckBox 를 비활성화 시킨다.
	 * @param {Variant} vElement 비활성화 할 checkbox Element.
	 * CheckBox input 엘리먼트 배열 또는 CheckBox Unit 엘리먼트 배열 또는 단일 엘리먼트가 입력 될수 있고,
	 * 입력값이 없을시 모든 체크박스 엘리먼트가 기준이 된다.
	 * @example
	 * // 배열 비활성화
	 * oCheckBox.disable([MobileCommentJindo.$("unit1"),MobileCommentJindo.$("unit2")]);
	 * // 단일 비활성화
	 * oCheckBox.disable(MobileCommentJindo.$("unit1"));
	 * // 전체 비활성화
	 * oCheckBox.disable();
	 */
	disable : function(vElement){
		var htElForm = this._useSettingForm(vElement, false);

		this.fireEvent("disable", {
			aCheckBoxList: htElForm.aFormList,
			aCheckBoxUnitList: htElForm.aUnitList
		});
	},
	/**
	 * @description index 번호로 CheckBox Element 를 반환한다.
	 * @param {Number} nIdx 가져올 index 번호.
	 * @return {Object} CheckBox Element 객체 {elCheckBox, elCheckBoxUnit} 으로 구성된 객체를 반환
	 * @example
	 *
	 *  // 0번째 CheckBox 가져오기.
	 *  var oCheckBox = oCheckBox.geElementtByIdx(0);
	 *  oCheckBox.elCheckBoxUnit; // CheckBox Unit Element 객체
	 *  oCheckBox.elCheckBox; // CheckBox Element 객체
	 */
	geElementtByIndex : function(nIdx){
		return {
			elCheckBox: this._aWElFormList[nIdx].$value(),
			elCheckBoxUnit: this._aWElUnitList[nIdx].$value()
		};
	},
	/**
	 * @description  MobileCommentJindo.m.CheckBox 에서 사용하는 모든 객체를 release 시킨다.
	 * @example
	 * oCheckBox.destroy();
	 */
	destroy : function() {
		this.$super.destroy();
	}
}).extend(MobileCommentJindo.m.CheckRadioCore);
/**
* @(#)MobileCommentJindo.m.Datepicker.js 2011. 9. 22.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
 * 수정 sculove 2012. 1.3
 * DatePicker 의 반환값에 요일 정보를 추가하는 인터페이스 적용작업
 *
 * sFormat에 day라는 옵션을 주면 요일을 반환한다.
 */
/**
* @author sshyun, sculove
* @since 2011. 9. 22.
* @description
* <V1.0.0 이후, 손찬욱 수정>
* 1.버그 수정
*  .다중인스턴스일시 동일월인 경우, 날짜표시가 갱신되지 않음
*  . 2012년 1월 31일 선택후, 2012년 2월 달 달력으로 이동시 31일 자리에 선택 표시가 나오는 문제 수정
*  . 전 달이나, 이후 달에 오늘날짜가 마지막주나 첫주에 있을 경우, 오늘날짜위치에  오늘날짜 표시가 되는 문제 수정
*  . 오늘날자와 선택 날짜가 동일 날짜에 선태되는 경우, 선택날짜가 표기되도록 수정
*
* * 2. 기능 추가
*  . Datepicker "요일" 표기되도록 기능 추가 (day) 추가
*
*  3. jindo V2.0 대응
*
*/
MobileCommentJindo.m.Datepicker = MobileCommentJindo.$Class({
    /** @lends MobileCommentJindo.m.Datepicker.prototype */
    /**
     * @description 초기화 함수
     * @constructs
     * @class
     * @param {Varient} el input 엘리먼트 또는 ID
     * @param {HashTable} htUserOption 추가 옵션 (생략가능)
     * @extends MobileCommentJindo.UIComponent
     * @requires MobileCommentJindo.Calendar
     */
    $init : function(el, htUserOption) {
        this.option({
            sClassPrefix : "calendar-",
            sFormat : "yyyy-mm-dd",
            sTitleFormat : "yyyy.mm", //달력의 제목부분에 표시될 형식
            aMonthTitle : ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"], //월 이름
            bUseEffect :false,
            nEffectDuration : 200,
            bActivateOnload : true,
            bAutoHide : false
        });
        this.option(htUserOption || {});
        this._initVar();
        this._setWrapperElement(el);
        this._initCalendar();

        if(this.option("bActivateOnload")) {
            this.activate();
        }
    },

    $static : {
    	INDEX_ATTR : "data-datepickerid"
    },

    /**
     * @description MobileCommentJindo.m.Datepicker 에서 사용하는 모든 인스턴스 변수를 초기화한다.
     */
    _initVar : function() {
        var htDeviceInfo = MobileCommentJindo.m.getDeviceInfo();
        this._oCalendar = null;
        this._htDatePickerSet = {};
        this._htSelectedDatePickerSet = null;
        this._bActivate = false;
        this._bMove = false;
        this._bCalendarVisible = false;
        this._sClickEvent = (htDeviceInfo.iphone || htDeviceInfo.ipad || htDeviceInfo.android) ? "touchend" : "click";
        this._aDayInfo = [];
    },
    /**
     * @description MobileCommentJindo.m.Datepicker 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
     * @param {Varient} el Calendar Base 엘리먼트 또는 ID
     */
    _setWrapperElement : function(el) {
        var sClassPrefix = this.option("sClassPrefix"),
        	aTh, elCloseBtn;

        if(!el){
            this._welCalendarBase = this._insertCalendarTemplate();
        } else {
            el = (typeof el == "string" ? MobileCommentJindo.$(el) : el);
            this._welCalendarBase = MobileCommentJindo.$Element(el);
        }
        // 날짜 정보 추출
        aTh = this._welCalendarBase.queryAll("th");
        for(var i=0, nLength=aTh.length; i<nLength; i++) {
          this._aDayInfo.push(MobileCommentJindo.$Element(aTh[i]).text());
        }
        this._welCalendarBase.css("position","absolute");
        this._welCalendarBase.hide();
        elCloseBtn = this._welCalendarBase.query("."+ sClassPrefix + "btn-close");
        this._welCloseBtn = (elCloseBtn) ? MobileCommentJindo.$Element(elCloseBtn) : null;

    },

    /**
     * @description Calendar 템플릿을 생성 한다.
     */
    _insertCalendarTemplate : function(){
        var aHtml = [],
      	  sClassPrefix = this.option("sClassPrefix");
        aHtml.push('<div>');
        aHtml.push('<a href="javascript:void(0)" class="' + sClassPrefix + 'btn ' + sClassPrefix + 'btn-prev-year">&lt;&lt;</a>');
        aHtml.push('<a href="javascript:void(0)" class="' + sClassPrefix + 'btn ' + sClassPrefix + 'btn-prev-mon">&lt;</a>');
        aHtml.push('<strong class="' + sClassPrefix + 'title"></strong>');
        aHtml.push('<a href="javascript:void(0)" class="' + sClassPrefix + 'btn ' + sClassPrefix + 'btn-next-mon">&gt;</a>');
        aHtml.push('<a href="javascript:void(0)" class="' + sClassPrefix + 'btn ' + sClassPrefix + 'btn-next-year">&gt;&gt;</a>');
        aHtml.push('</div><table cellspacing="0" cellpadding="0" style="');
        aHtml.push('-' + MobileCommentJindo.m.getCssPrefix() + '-tap-highlight-color:rgba(0,0,0,0);"><thead><tr>');
        aHtml.push('<th class="' + sClassPrefix + 'sun">일</th><th>월</th><th>화</th><th>수</th><th>목</th><th>금</th><th class="sat">토</th>');
        aHtml.push('</tr></thead><tbody>');
        aHtml.push('<tr class="' + sClassPrefix + 'week">');
        aHtml.push('<td><a href="javascript:void(0)" class="' + sClassPrefix + 'date"></a></td>');
        aHtml.push('<td><a href="javascript:void(0)" class="' + sClassPrefix + 'date"></a></td>');
        aHtml.push('<td><a href="javascript:void(0)" class="' + sClassPrefix + 'date"></a></td>');
        aHtml.push('<td><a href="javascript:void(0)" class="' + sClassPrefix + 'date"></a></td>');
        aHtml.push('<td><a href="javascript:void(0)" class="' + sClassPrefix + 'date"></a></td>');
        aHtml.push('<td><a href="javascript:void(0)" class="' + sClassPrefix + 'date"></a></td>');
        aHtml.push('<td><a href="javascript:void(0)" class="' + sClassPrefix + 'date"></a></td>');
        aHtml.push('</tr></tbody></table>');
        aHtml.push('<div class="' + sClassPrefix + 'bottom"><a href="javascript:void(0)" class="' + sClassPrefix + 'btn ' + sClassPrefix + 'btn-close">닫기</a></div>');
        document.body.appendChild(MobileCommentJindo.$('<div id="jmc_calt" class="' + sClassPrefix + 'base" style="position:absolute"></div>'));
        var welCalendar = MobileCommentJindo.$Element("jmc_calt").hide();
        welCalendar.html(aHtml.join(""));
        return welCalendar;
    },

    /**
     * @description Calendar 객체를 초기화 한다.
     */
    _initCalendar : function(){
        /**
         * 달력 오브젝트
         * @type Object MobileCommentJindo.Calendar 컴포넌트
         * @see MobileCommentJindo.Calendar
         */
        var self = this,
        	oDate = new Date(),
        	htToday = {nYear:oDate.getFullYear() , nMonth:oDate.getMonth() + 1 , nDate: oDate.getDate()},
        	// Calendar 옵션설정.
        	htCalendarOption = {
                sClassPrefix : this.option("sClassPrefix"),
                nYear : htToday.nYear,
                nMonth : htToday.nMonth,
                nDate : htToday.nDate,
                sTitleFormat : this.option("sTitleFormat"), //달력의 제목부분에 표시될 형식
                aMonthTitle : this.option("aMonthTitle")
        	};

        this._oCalendar = new MobileCommentJindo.Calendar(this._welCalendarBase.$value(), htCalendarOption).attach({
            beforeDraw : function(oCustomEvent) {
                var oMoveDate, oOldDate = this.getShownDate();
                oOldDate = {nYear : oOldDate.nYear, nMonth : oOldDate.nMonth};
                oMoveDate = {nYear : oCustomEvent.nYear, nMonth : oCustomEvent.nMonth};

                this._htOldDate = oOldDate;
                this._htMoveDate = oMoveDate;
                oCustomEvent.oOldDate = oOldDate;
                oCustomEvent.oMoveDate = oMoveDate;
                if(!self.fireEvent("beforeDraw", oCustomEvent)) {
                    oCustomEvent.stop();
                }

                if((oOldDate.nYear != oMoveDate.nYear ||
                        oOldDate.nMonth != oMoveDate.nMonth)){
                    if(!self.fireEvent("beforeMoveDate", oCustomEvent)) {
                        oCustomEvent.stop();
                    }
                }
            },

            draw : function(oCustomEvent) {
                //선택한 날짜 class명 부여
                //oCustomEvent.elDate.setAttribute("onclick", "function(e){e.preventDefault(); return false;}");
                if(!self.fireEvent("draw", oCustomEvent)) {
                    oCustomEvent.stop();
                }
            },

            afterDraw : function(oCustomEvent) {
                self._drawCalendarSelectDate(oCustomEvent.nYear, oCustomEvent.nMonth);
                if(self._bCalendarVisible){
                    self._fPosition();
                }
                oCustomEvent.oOldDate = this._htOldDate;
                oCustomEvent.oMoveDate = this._htMoveDate;
                self.fireEvent("afterDraw", oCustomEvent);

                if((this._htOldDate.nYear != this._htMoveDate.nYear ||
                        this._htOldDate.nMonth != this._htMoveDate.nMonth)){
                    if(!self.fireEvent("moveDate", oCustomEvent)) {
                        oCustomEvent.stop();
                    }
                }
            }
        });
    },

    /**
     * @description 그려진 Calendar 의 선택 날짜를 표시.
     */
   _drawCalendarSelectDate : function(nYear, nMonth){
        if(!this._oCalendar) {
            return;
        }
        var sClassPrefix = this.option("sClassPrefix"),
        	aCells = this._welCalendarBase.queryAll("."+ sClassPrefix + "date"),
        	htToday = this._oCalendar.getToday(),
        	elDateCell;

        // 오늘 날짜의 달력이 그려지는 것이 아니면...
        if(htToday.nYear != nYear || htToday.nMonth != nMonth) {
 			var elToday = this._welCalendarBase.query("."+ sClassPrefix + "today");
 			if(elToday) {
 				MobileCommentJindo.$Element(elToday).removeClass(sClassPrefix + "today");
 			}
        }
        // 그려진 날짜를 비교하여 선택 한날짜에 CSS 클래스 적용.
        for (var i = 0, nLength = aCells.length; i<nLength; i++) {
        	elDateCell = this._getDateCellElement(aCells[i]);
            if(!elDateCell) {
            	continue;
            }
            htDate = this._oCalendar.getDateOfElement(elDateCell);
            if( (nYear === htDate.nYear && nMonth === htDate.nMonth) &&
            	MobileCommentJindo.Calendar.isSameDate(htDate, this._htSelectedDatePickerSet)) {
                // today와 select가 중복될 경우는 today를 지우고, selected를 표기
                MobileCommentJindo.$Element(elDateCell)
                	.removeClass(sClassPrefix + "today")
                	.addClass(sClassPrefix + "selected");
            }
        }
    },

    /**
     * 선택가능한 날짜인지 확인한다.
     * @param {HashTable} htDatePickerSet
     * @param {HashTable} htDate
     */
    _isSelectable : function(htDatePickerOption, htDate) {
        var bIsSelected =  MobileCommentJindo.Calendar.isBetween(htDate, htDatePickerOption["htSelectableDateFrom"], htDatePickerOption["htSelectableDateTo"]);
        return bIsSelected;
    },

    /**
     * DatePicker를 적용할 셋을 추가한다.
     * @param {Element} elInput 날짜가 입력될 input 엘리먼트
     * @param {Hashtable} htOption Datepicker Calendar Option 정보
     * @return {this} this
     * @example
oDatePicker.addDatePickerSet(
    MobileCommentJindo.$("input"), //날짜가 입력될 input 엘리먼트
    {
        nYear : 1983, //기본으로 설정될 연도
        nMonth : 5, //기본으로 설정될 월
        nDate : 12, //기본으로 설정될 일
        htSelectableDateFrom : { //선택가능한 첫 날짜
            nYear : 1900,
            nMonth : 1,
            nDate : 1
        },
        htSelectableDateTo : { //선택가능한 마지막 날짜
            nYear : 2100,
            nMonth : 12,
            nDate : 31
        },
        sPosition: "bottomLeft", // Calendar 위치
        zIndex: 50              // Calendar 가 나타날 경우 z-index 값
    }
);
     */
    addDatePickerSet : function(elInput, htOption) {
    	 if (typeof elInput == "undefined") {
            return this;
        }
        var sDatePikerSetId = "DATEPICKER_" + (new Date()).getTime() +"_" + Math.floor((Math.random() * 100)),
        	welInput,
        	htCalendarOption = this._oCalendar.option(),
	            htDefaultOption = {
	                nYear : htCalendarOption.nYear,
	                nMonth : htCalendarOption.nMonth,
	                nDate : htCalendarOption.nDate,
	                htSelectableDateFrom : { //선택가능한 첫 날짜
	                    nYear : 1900,
	                    nMonth : 1,
	                    nDate : 1
	                },
	                htSelectableDateTo : { //선택가능한 마지막 날짜
	                    nYear : 2100,
	                    nMonth : 12,
	                    nDate : 31
	                },
	                sPosition: "bottomLeft",
	                zIndex: 50
	            };

        if (typeof htOption != "undefined") {
            //빈 값은 기본값으로 셋팅해줌.
            for (var value in htOption) {
                if (typeof htDefaultOption[value] != "undefined") {
                    htDefaultOption[value] = htOption[value];
                }
            }
        }
        htOption = htDefaultOption;

        welInput = MobileCommentJindo.$Element(elInput);
        welInput.replace("<span style='position:relative;display:inline-block;'>" + welInput.toString() + "</span>");
        welInput = MobileCommentJindo.$Element(elInput);
        welInput.attr("readOnly",true)
       		.attr(MobileCommentJindo.m.Datepicker.INDEX_ATTR, sDatePikerSetId);
        htOption.wfFocusFunc = MobileCommentJindo.$Fn(this._onFocus,this).attach(elInput,"focus");
        htOption.elInput = welInput.$value();
        this._htDatePickerSet[sDatePikerSetId] = htOption;
        return this;
    },

    /**
     * DatePicker를 적용할 셋을 제거한다.
     * @param {Element} elInput Datepicker를 제거할 input 엘리먼트
     * @return {this} this
     * @example
var elInput = MobileCommentJindo.$("input") //Datepicker를 제거할 input 엘리먼트
oDatePicker.removeDatePickerSet(elInput);
     */
    removeDatePickerSet : function(elInput) {
        var welInput = MobileCommentJindo.$Element(elInput),
        	sDatePikerSetId = welInput.attr(MobileCommentJindo.m.Datepicker.INDEX_ATTR),
        	htDatePickerSet = this._htDatePickerSet[sDatePikerSetId];

        htDatePickerSet.wfFocusFunc.detach(welInput.$value(),"focus");

        if (htDatePickerSet == this._htSelectedDatePickerSet) {
            this._htSelectedDatePickerSet = null;
        }
        delete this._htDatePickerSet[sDatePikerSetId];
        return this;
    },

    /**
     * @description MobileCommentJindo.m.Datepicker 컴포넌트를 활성화한다.
     * activate 실행시 호출됨
     */
    _onActivate : function() {
        this._attachEvent();
        this._bActivate = true;
    },
    /**
     * @description MobileCommentJindo.m.Datepicker 컴포넌트를 비활성화한다.
     * deactivate 실행시 호출됨
     */
    _onDeactivate : function() {
        if(this._bCalendarVisible){
            this.hide();
        }
        this._detachEvent();
        this._bActivate = false;

    },
    /**
     * @description MobileCommentJindo.m.Datepicker 에서 사용하는 모든 이벤트를 바인드한다.
     */
    _attachEvent : function() {
        this._htEvent = {};

        this._htEvent["document_" + this._sClickEvent] = {
                el  : document,
                ref : MobileCommentJindo.$Fn(this._onDocumentClick, this).attach( document, this._sClickEvent)
        };
        this._htEvent["document_touchmove"] = {
                el  : document,
                ref : MobileCommentJindo.$Fn(this._onDocumentScroll, this).attach( document, "touchmove")
        };

        this._htEvent["date_click"] = {
                el  : this._welCalendarBase.$value(),
                ref : MobileCommentJindo.$Fn(this._onClickDate, this).attach( this._welCalendarBase.$value(), this._sClickEvent)
        };

        if(this._welCloseBtn){
            this._htEvent["close_click"] = {
                    el  : this._welCloseBtn.$value(),
                    ref : MobileCommentJindo.$Fn(this._onClickCloseCalendar, this).attach( this._welCloseBtn.$value(), "click")
            };
        }

    },
    /**
     * @description MobileCommentJindo.m.Calendar 에서 사용하는 모든 이벤트를 해제한다.
     */
    _detachEvent : function(){
        for(var p in this._htEvent) {
            var ht = this._htEvent[p];
            ht.ref.detach(ht.el, p.substring(p.lastIndexOf("_")+1));
        }
        this._htEvent = null;
    },
    /**
     * @description input 에 포커스 이벤트 처리. Calendar를 생성하여 디스플레이 해준다.
     */
    _onFocus : function(we){
        if(!this._bActivate){
            return false;
        }

        var elInput = we.element;
        this.show(elInput);
    },

    /**
     * @description Document Touch 이벤트 처리
     */
    _onDocumentClick : function(we){
        var elElment = we.element;
        var welElment = MobileCommentJindo.$Element(elElment);
        var oCalendar = MobileCommentJindo.m.Datepicker.oCalendarInstance;
        var sDatepickerId = this._welCalendarBase.attr(MobileCommentJindo.m.Datepicker.INDEX_ATTR);
        var elInput = (sDatepickerId) ? this._htDatePickerSet[sDatepickerId].elInput : null;

        // 움직이고 난 후에는 blur 처리 하지 않는다.
        if(this._bMove){
            this._bMove = false;
            return;
        }

        if(this.option("bAutoHide") && this._bCalendarVisible &&
            this._welCalendarBase.$value() != elElment &&
            !this._welCalendarBase.isParentOf(welElment) &&
            elInput != elElment){
            this.hide();
            elInput.blur();
        }
        this._bMove = false;
        return true;
    },
    /**
     * @description Document Touch Move 이벤트 처리
     */
    _onDocumentScroll : function(we){
        this._bMove = true;
    },
    /**
     * @description Calendar 날짜 선택 이벤트 핸들러.
     */
    _onClickDate : function(we){
        we.stopDefault();
        if(this._bMove){
            return false;
        }
        var sClassPrefix =  this.option("sClassPrefix");
        var elTargetElement = MobileCommentJindo.m.getNodeElement(we.element);
        var sDatepickerId = this._welCalendarBase.attr(MobileCommentJindo.m.Datepicker.INDEX_ATTR);
        var elInput = this._htDatePickerSet[sDatepickerId].elInput;
        var elDate = this._getDateCellElement(elTargetElement);

        if(elDate){
            var welDate = MobileCommentJindo.$Element(elDate);
            if(welDate.hasClass(sClassPrefix + "next-mon") ||
                welDate.hasClass(sClassPrefix + "prev-mon")){
                return false;
            }
            var htDate = this._oCalendar.getDateOfElement(elDate);
            if (this._isSelectable(this._htSelectedDatePickerSet, htDate)) {
                this.setDate(elInput, htDate);
                elInput.blur();
                this.fireEvent("selectDate", {
                    oSelectDate : htDate,
                    oCalendar : this._oCalendar
                });
                this.hide();
            }
        }
        return false;
    },

    /**
     * @description Date Cell 엘리먼트를 찾아 TD 반환
     */
    _getDateCellElement : function(elElement){
        var welElement = MobileCommentJindo.$Element(elElement),
        	sClassPrefix =  this.option("sClassPrefix"),
        	elDateCell, welWeek,
        	welDate = (welElement.hasClass(sClassPrefix + "date")) ? welElement : MobileCommentJindo.$$.getSingle("."+ sClassPrefix + "date", welElement.$value());
        if (welDate) {	// A태그
        	welDate = MobileCommentJindo.$Element(welDate);
            welWeek = MobileCommentJindo.m.getClosest(sClassPrefix + "week", welDate);
	        if (welWeek) {	// TD 태그
                welWeek = MobileCommentJindo.$Element(welWeek);
                elDateCell = welDate.$value();
                while(!MobileCommentJindo.$Element(elDateCell.parentNode).hasClass(sClassPrefix + "week")) {
                    elDateCell = elDateCell.parentNode;
                }
                if (MobileCommentJindo.$Element(elDateCell).hasClass(sClassPrefix + "unselectable")) {
                    elDateCell = null;
                }
            }
        }
        return elDateCell;
    },

    /**
     * @description 닫기 버튼 이벤트 핸들러.
     */
    _onClickCloseCalendar : function(){
        this.hide();
    },
    /**
     * @description Calendar 노출시 Effect 효과 삽입.
     */
    _displayEffect : function(sType, wfPosition){
        this._sEffectDirection = sType;
        var elBase = this._welCalendarBase.$value();
        var sCssFix = MobileCommentJindo.m.getCssPrefix();
        var sEvent =  (sCssFix == "webkit") ? "webkitTransitionEnd" : "transitionend";
        // 이펙트 효과가 있을경우 Duration 값으로 처리
        var sDuration = this.option("nEffectDuration")+"ms";

        this._welCalendarBase.show();
        elBase.style.opacity = (sType == "fade-in") ? 0 : 1;
        if(wfPosition){ wfPosition();}

        this._fnTransitionEnd = MobileCommentJindo.$Fn(this._TransitionEnd, this).bind();
        elBase.addEventListener(sEvent, this._fnTransitionEnd, false);

        setTimeout(function(){
            elBase.style.webkitTransitionDuration = sDuration;
            elBase.style.webkitTransitionProperty = "all";
            elBase.style.webkitTransitionTimingFunction = "ease-in-out";
            if(sType == "fade-in"){
                elBase.style.opacity = 1;
            } else if(sType == "fade-out"){
                elBase.style.opacity = 0;
            }
        },10);
    },
    /**
     * @description Calendar 노출시 Effect 효과 TransitionEnd 이벤트 핸들러.
     */
    _TransitionEnd : function(evt){
        var elBase = evt.currentTarget;
        var sCssFix = MobileCommentJindo.m.getCssPrefix();
        var sEvent =  (sCssFix == "webkit") ? "webkitTransitionEnd" : "transitionend";
        var htDatePickerSet = this._htSelectedDatePickerSet;

        elBase.style.webkitTransitionDuration = null;
        elBase.style.webkitTransitionProperty = null;
        elBase.style.webkitTransitionTimingFunction = null;
        elBase.removeEventListener(sEvent, this._fnTransitionEnd, false);
        this._fnTransitionEnd = null;


        if(this._sEffectDirection == "fade-in"){
            this._bCalendarVisible = true;
            this.fireEvent("showCalendar",{
                oDrawDate  : {"nYear" : htDatePickerSet.nYear,
                    "nMonth" : htDatePickerSet.nMonth,
                    "nDate" : htDatePickerSet.nDate},
                oCalendar : this._oCalendar
            });
        } else if(this._sEffectDirection == "fade-out"){
            this._bCalendarVisible = false;
            elBase.style.zIndex = 0;
            elBase.style.display = "none";
            var bHide = this.fireEvent("hideCalendar", {
                oSelectDate  : {"nYear" : htDatePickerSet.nYear,
                    "nMonth" : htDatePickerSet.nMonth,
                    "nDate" : htDatePickerSet.nDate},
                oCalendar : this._oCalendar
            });
        }
    },
    /**
     * @description 날짜 표시 형식 변환 후 반환.
     */
    _formatDate : function(htDate){
        var oDate = new Date(htDate.nYear, htDate.nMonth-1, htDate.nDate),
           sDay = this._aDayInfo[oDate.getDay()],
          sDateStr = this.option("sFormat").replace(/(yyyy|yy|mm|dd|day)/gi,
            function($1){
                switch ($1){
                    case 'yyyy': return oDate.getFullYear();
                    case 'yy': return oDate.getFullYear().toString().substr(2);
                    case 'mm':
                    	var sMonth = (oDate.getMonth()+1) + "";
                    	sMonth = sMonth.length === 1 ? '0' + sMonth : sMonth;
                    	return sMonth;
                    case 'dd':
                    	var sDate = oDate.getDate() + "";
                        sDate = sDate.length === 1 ? '0' + sDate : sDate;
                    	return sDate;
                    case 'day' : return sDay;
                }
            }
        );
        return sDateStr;
    },
    /**
     * @description Datepicker Calendar 위치 값을 설정.<br>
     * bottomLeft : Calenadr 를 input 의 아래 왼쪽에 위치<br>
     * bottomRight : Calenadr 를 input 의 아래 오른쪽끝에 위치<br>
     * topLeft : Calenadr 를 input 의 위쪽 왼쪽에 위치<br>
     * topRight : Calenadr 를 input 의 위쪽 오른쪽끝에 위치<br>
     * leftTop : Calenadr 를 input 의 왼쪽에 상단에 위치<br>
     * leftBottom : Calenadr 를 input 의 왼쪽에 하단에 위치<br>
     * rightTop : Calenadr 를 input 의 오른쪽에 상단에 위치<br>
     * rightBottom : Calenadr 를 input 의 오른쪽에 하단에 위치<br>
     * @param {Element} elInput 변경 Datepicker Input 엘리먼트
     * @param {String} sPosition Position 정보
     * @example
     *
     * var elInput = MobileCommentJindo.$("input");
     * oDatepicker.setPosition(elInput, "bottomLeft");
     */
    setPosition : function(elInput, sPosition){
        var sDatepickerId = elInput.getAttribute(MobileCommentJindo.m.Datepicker.INDEX_ATTR);
        this._htDatePickerSet[sDatepickerId].sPosition = sPosition;
        if(this._isCurrentDatePicker(elInput) && this._bCalendarVisible){
            this._fPosition = MobileCommentJindo.$Fn(function(){
                this._setCalendarPosition(elInput, sPosition);
            },this).bind();
            this._setCalendarPosition(elInput, sPosition);
        }
    },

    /**
     * @description Calelndar를 위치할 Position 설정.
     */
    _setCalendarPosition : function(elInput, sPosition){
        var welInput = MobileCommentJindo.$Element(elInput);
        var welCalendarBase = this._welCalendarBase;
        var nCalendarHeight = welCalendarBase.height();
        var nCalendarWidth = welCalendarBase.width();
        var nInputHeight = welInput.height();
        var nInputWidth = welInput.width();
        var htCss = {};
        var elCalendarBase = welCalendarBase.$value();
        elCalendarBase.style.left = null;
        elCalendarBase.style.right = null;
        elCalendarBase.style.top = null;

        switch (sPosition) {
        case "leftTop":
            htCss.top = "0px";
            htCss.left = "-" + nCalendarWidth + "px";
            break;
        case "leftBottom":
            htCss.top = "-" + (nCalendarHeight - nInputHeight) + "px";
            htCss.left = "-" + nCalendarWidth + "px";
            break;
        case "rightTop":
            htCss.top = "0px";
            htCss.left = nInputWidth + "px";
            break;
        case "rightBottom":
            htCss.top = "-" + (nCalendarHeight - nInputHeight) + "px";
            htCss.left = nInputWidth + "px";
            break;
        case "bottomLeft":
            htCss.top = nInputHeight + "px";
            htCss.left = "0px";
            break;
        case "bottomRight":
            htCss.top = nInputHeight + "px";
            htCss.right = "0px";
            break;
        case "topLeft":
            htCss.top = "-" + nCalendarHeight + "px";
            htCss.left = "0px";
            break;
        case "topRight":
            htCss.top = "-" + nCalendarHeight + "px";
            htCss.right = "0px";
            break;

        }
        welCalendarBase.css(htCss);

    },
    /**
     * @description Datepicker Calendar 선택 날짜를 설정 한다.
     * @param {Element} elInput 변경 Datepicker Input 엘리먼트
     * @param {Hashtable} htDate 설정, 날짜 {nYear : 2011, nMonth : 9, nDate : 30} 형식
     * @example
     *
     * var elInput = MobileCommentJindo.$("input");
     * var htDate = {nYear : 2011, nMonth : 9, nDate : 30};
     * oDatepicker.setDate(elInput, htDate);
     */
    setDate : function(elInput, htDate){
        var sDatepickerId = (elInput) ? elInput.getAttribute(MobileCommentJindo.m.Datepicker.INDEX_ATTR) : null;
        var htDatePickerSet = this._htDatePickerSet[sDatepickerId];

        if(!sDatepickerId || !this._bActivate || !this._isSelectable(htDatePickerSet, htDate)){
            return false;
        }
        elInput.value = this._formatDate(htDate);

        htDatePickerSet.nYear = htDate.nYear;
        htDatePickerSet.nMonth = htDate.nMonth;
        htDatePickerSet.nDate = htDate.nDate;
        this._htDatePickerSet[sDatepickerId] = htDatePickerSet;

        if(this._isCurrentDatePicker(elInput) && this._bCalendarVisible){
            this._oCalendar.draw(htDate.nYear, htDate.nMonth);
        }
    },
    /**
     * @description Datepicker에서 선택 한 날짜를 삭제한다.
     * @param {Element} elInput 변경 Datepicker Input 엘리먼트
     * @example
     *
     * var elInput = MobileCommentJindo.$("input");
     * oDatepicker.deleteDate();
     */
    deleteDate : function(elInput){
        if(!elInput){ return;}

        var welInput = MobileCommentJindo.$Element(elInput);
        var htDatePickerSet = this._htDatePickerSet;
        var sDatepickerId = welInput.attr(MobileCommentJindo.m.Datepicker.INDEX_ATTR);
        var oDate = new Date();
        var htToday = {nYear:oDate.getFullYear() , nMonth:oDate.getMonth() + 1 , nDay: oDate.getDate()};

        welInput.$value().value = "";
        htDatePickerSet[sDatepickerId].nYear = oDate.getFullYear();
        htDatePickerSet[sDatepickerId].nMonth = oDate.getMonth() + 1;
        htDatePickerSet[sDatepickerId].nDate = oDate.getDate();

        if(this._isCurrentDatePicker(welInput.$value()) && this._bCalendarVisible){
            this.hide();
        }

        this.fireEvent("clear",{
            oCalendar : this._oCalendar
        });
    },

    /**
     * @description 현재 데이터 피커가 자신에 할당되어 있는지 여부 반
     */
    _isCurrentDatePicker : function(elInput){
        var sDatepickerId = (elInput) ? elInput.getAttribute(MobileCommentJindo.m.Datepicker.INDEX_ATTR) : null;
        var sSelectDatepickerId = this._welCalendarBase.attr(MobileCommentJindo.m.Datepicker.INDEX_ATTR);
        var bIsCurrentDatePicker = (sDatepickerId == sSelectDatepickerId);
        return bIsCurrentDatePicker;
    },
    /**
     * @description Datepicker 객체를 활성화 한다.
     * @param {Element} elInput 변경 Datepicker Input 엘리먼트. 없을 경우 등록된 모든 Input에 대해 활성화.
     * @example
     *
     * var elInput = MobileCommentJindo.$("input");
     * oDatepicker.enable(elInput);
     *
     * //등록된 모든 Input 에 대해 활성화
     *  oDatepicker.enable();
     */
    enable : function(elInput){
        var htDatePickerSet = this._htDatePickerSet;

        if(elInput){
            var welInput = MobileCommentJindo.$Element(elInput);
            welInput.$value().disabled = false;
        } else {
            for ( var sKey in htDatePickerSet) {
                htDatePickerSet[sKey].elInput.disabled = false;
            }
            this.activate();
        }

        this.fireEvent("enable",{
            oCalendar : this._oCalendar
        });
    },
    /**
     * @description Datepicker 객체를 비활성화 한다.
     * @param {Element} elInput 변경 Datepicker Input 엘리먼트. 없을 경우 등록된 모든 Input에 대해 비활성화.
     * @example
     *
     * var elInput = MobileCommentJindo.$("input");
     * oDatepicker.disable(elInput);
     *
     * //등록된 모든 Input 에 대해 비활성화
     * oDatepicker.disable();
     */
    disable : function(elInput){
        var htDatePickerSet = this._htDatePickerSet;
        var bHideCalendar = false;
        if(elInput){
            var welInput = MobileCommentJindo.$Element(elInput);
            welInput.$value().disabled = true;
            bHideCalendar = (this._bCalendarVisible && this._isCurrentDatePicker(welInput.$value()));
        } else {
            for ( var sKey in htDatePickerSet) {
                htDatePickerSet[sKey].elInput.disabled = true;
            }
            this.deactivate();
            bHideCalendar = true;
        }

        if(bHideCalendar && this._bCalendarVisible){
            this.hide();
        }

        this.fireEvent("disable",{
            oCalendar : this._oCalendar
        });
    },

    /**
     * @description Datepicker 달력을 보여준다.
     *  @param {Element} elInput Calendar를 보여줄 Datepicker Input 엘리먼트.
     * @example
     *
     *  var elInput = MobileCommentJindo.$("input");
     * oDatepicker.show(elInput);
     */
    show : function(elInput){
    	var welInput = MobileCommentJindo.$Element(elInput),
    		welBaseUnit = welInput.parent(),
    		sDatepickerId = welInput.attr(MobileCommentJindo.m.Datepicker.INDEX_ATTR),
        	htDatePickerSet = this._htDatePickerSet[sDatepickerId];
    	if(!this.fireEvent("beforeShowCalendar",{
	            oDrawDate  : {"nYear" : htDatePickerSet.nYear, "nMonth" : htDatePickerSet.nMonth, "nDate" : htDatePickerSet.nDate},
	            oCalendar : this._oCalendar
	        })) {
	        return false;
	    }
        this._htSelectedDatePickerSet = htDatePickerSet;
        this._welCalendarBase.attr(MobileCommentJindo.m.Datepicker.INDEX_ATTR, sDatepickerId);

		/**
		 * getShownDate는 일은 무조건 1일로 나온다.
		 */
        //if(!MobileCommentJindo.Calendar.isSameDate(this._oCalendar.getShownDate(), htDatePickerSet)) {
        	this._oCalendar.draw(htDatePickerSet.nYear, htDatePickerSet.nMonth);
        //}
        welBaseUnit.append(this._welCalendarBase.$value());
        if(this._isCurrentDatePicker(elInput) && this._bCalendarVisible){
            return;
        }

        this._fPosition = MobileCommentJindo.$Fn(function(){
            this._setCalendarPosition(elInput, htDatePickerSet.sPosition);
        },this).bind();

        if(htDatePickerSet.zIndex != "none"){
            this._welCalendarBase.css("zIndex", htDatePickerSet.zIndex);
        }

        if(this.option("bUseEffect")){
            this._displayEffect("fade-in", this._fPosition);
        } else {
            this._welCalendarBase.show();
            this._fPosition();

            this._bCalendarVisible = true;
            this.fireEvent("showCalendar",{
                oDrawDate  : {"nYear" : htDatePickerSet.nYear, "nMonth" : htDatePickerSet.nMonth, "nDate" : htDatePickerSet.nDate},
                oCalendar : this._oCalendar
            });
        }
    },
    /**
     * @description Datepicker 달력을 닫는다.
     * @example
     *
     * oDatepicker.hide();
     */
    hide : function(){
        var htDatePickerSet = this._htSelectedDatePickerSet;
        var bHide = this.fireEvent("beforeHideCalendar", {
            oSelectDate  : {"nYear" : htDatePickerSet.nYear,
                "nMonth" : htDatePickerSet.nMonth,
                "nDate" : htDatePickerSet.nDate},
            oCalendar : this._oCalendar
        });
        if(!bHide){return false;}

        // 이펙트 사용.
        if(this.option("bUseEffect")){
            this._displayEffect("fade-out");
        } else {
            this._welCalendarBase.hide();
            this._bCalendarVisible = false;
            this.fireEvent("hideCalendar", {
                oSelectDate  : {"nYear" : htDatePickerSet.nYear,
                    "nMonth" : htDatePickerSet.nMonth,
                    "nDate" : htDatePickerSet.nDate},
                oCalendar : this._oCalendar
            });
        }
    },

    /**
     * @description  MobileCommentJindo.m.Datepicker 에서 사용하는 모든 객체를 release 시킨다.
     * @example
     *
     * oDatepicker.destroy();
     */
    destroy : function() {
        this.deactivate();
        this._oCalendar = null;
        this._htDatePickerSet = null;
        this._htSelectedDatePickerSet = null;
        this._bActivate = false;
        this._bMove = false;
        this._bCalendarVisible = false;
        this._sClickEvent = null;
        this._aDayInfo = null;
    }
}).extend(MobileCommentJindo.UIComponent);
/**
* @(#)MobileCommentJindo.m.Dialog.js 2011. 8. 5.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author icebelle
* @since 2011. 8. 5.
* @description
*/

MobileCommentJindo.m.Dialog = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.Dialog.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
	 * @requires MobileCommentJindo.m.SlideEffect
	 * @requires MobileCommentJindo.m.PopEffect
	 * @requires MobileCommentJindo.m.FlipEffect
	 */
	$init : function(htUserOption) {
		//console.log("$init")
		var htDefaultOption = {
			bActivateOnload : true,
			sClassPrefix : "dialog-",
			sPosition : "center",
			bUseEffect : true,
			bAutoClose : false,
			bAutoReposition : true,
			sFoggyColor : "gray",
			nFoggyOpacity : 0.5,
			sEffectType : "pop",
			nEffectDuration : 500
		};
		this.option(htDefaultOption);
		this.option(htUserOption || {});

		this._setWrapperElement();
		this._initVar();
		this._setDeviceSize();
		this._initElement();

		if(this.option("bActivateOnload")) {
			this.activate();
		}
	},

	/**
	 * @description MobileCommentJindo.m.Dialog 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement : function() {
		this._htWElement = {};
		this._htWElement["dialog_container"] =  MobileCommentJindo.$Element('<div class="' + this.option("sClassPrefix") + 'container"></div>');
		this._htWElement["dialog_foggy"] =  MobileCommentJindo.$Element('<div class="' + this.option("sClassPrefix") + 'fog"></div>');
		this._htWElement["dialog_layer"] =  MobileCommentJindo.$Element('<div class="' + this.option("sClassPrefix") + 'layer"></div>');
		this._htWElement["dialog_clone"] =  MobileCommentJindo.$Element('<div class="' + this.option("sClassPrefix") + 'clone"></div>');
	},

	/**
	 * @description 인스턴스 변수를 초기화한다.
	 */
	_initVar : function() {
		this._htDialogSize = {
			width : 0,
			height : 0
		};

		this._sTemplate = null;
		this._bIsShown = false;
		this._bProcessingShow = false;
		this._bProcessingHide = false;
		this._htDeviceInfo = MobileCommentJindo.m.getDeviceInfo();
		this._bIOS = (this._htDeviceInfo.iphone || this._htDeviceInfo.ipad) ? true : false;
		this._bAndroid = this._htDeviceInfo.android ? true : false;
	},

	/**
	 * @description 디바이스의 View영역 사이즈를 구한다.
	 */
	_setDeviceSize : function() {
		if (this._bIOS || (this._bAndroid) || !MobileCommentJindo.$Agent().navigator().mobile) {
			this._htDeviceSize = MobileCommentJindo.$Document().clientSize();
		} else {
			this._htDeviceSize = {
				width : window.screen.width,
				height : window.screen.height
			};
		}
	},

	/**
	 * @description 다이얼로그 컨테이너의 초기위치를 설정한다.
	 */
	_initContainerTop : function() {
		//console.log("_initContainerTop")
		var nTop = 0;
		var bUseEffect = this.option("bUseEffect");
		var sEffectType = this.option("sEffectType");

		if(bUseEffect && (sEffectType == "slide-up" || sEffectType == "slide-down")) {
			// 슬라이드 효과일경우 화면 상단/하단에 위치하도록 설정한다.
			nTop = this._htDeviceSize.height * ((sEffectType == "slide-up") ? 1 : -1);
		}
		// 페이지가 스크롤된 만큼 보정처리한다.
		nTop += window.pageYOffset;

		this._htWElement["dialog_container"].css("top", nTop + "px");
	},

	/**
	 * @description Element를 초기화한다.
	 */
	_initElement : function() {
		// 포그레이어 초기화
		this._htWElement["dialog_foggy"].css({
			position : "absolute",
			padding : "0px",
			margin : "0px",
			border : "0px",
			backgroundColor : this.option("sFoggyColor"),
			opacity : this.option("nFoggyOpacity"),
			width : this._htDeviceSize.width + "px",
			height : this._htDeviceSize.height + "px",
			left : "0px",
			top : "0px"
		});
		this._htWElement["dialog_foggy"].appendTo(this._getContainer());

		// 다이얼로그 창 초기화
		this._htWElement["dialog_layer"].css({
			position : "relative",
			backgroundColor : "white"
		});
		this._htWElement["dialog_layer"].appendTo(this._getContainer());

		// 다이얼로그 컨테이너 초기화
		this._htWElement["dialog_container"].css({
			position : "absolute",
			overflow : "hidden",
			width : this._htDeviceSize.width + "px",
			height : this._htDeviceSize.height + "px",
			left : "0px",
			zIndex : 100
		});
		this._initContainerTop();
		this._htWElement["dialog_container"].hide();
		this._htWElement["dialog_container"].appendTo(document.body);

		if(this.option("bUseEffect")) {
			this._oLayerEffect = new MobileCommentJindo.m.LayerEffect(this._getContainer());
		}

		// 다이얼로그 클론창 초기화
		this._htWElement["dialog_clone"].css({
			position : "absolute",
			left : "-1000px",
			top : "-1000px"
		});
		this._htWElement["dialog_clone"].appendTo(document.body);
		this._htWElement["dialog_clone"].hide();
	},

	/**
	 * @description MobileCommentJindo.m.Dialog 컴포넌트를 활성화한다.
	 */
	_onActivate : function() {
		this._attachEvent();
	},

	/**
	 * @description MobileCommentJindo.m.Dialog 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEventAll();
	},

	/**
	 * @description MobileCommentJindo.m.Dialog 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};
		/*this._htEvent["click"] = {
			ref : MobileCommentJindo.$Fn(this._onClick, this).attach(this._getContainer(), "click"),
			el	: this._getContainer()
		};*/

		// click event 처리
		this._htEvent["click"] = {
			ref : MobileCommentJindo.$Fn(this._onClick, this).attach(this.getDialog(), "click"),
			el	: this.getDialog()
		};

		this._htEvent["touchend"] = {
			ref : MobileCommentJindo.$Fn(this._onClick, this).attach(this._getFoggy(), "touchend"),
			el	: this._getFoggy()
		};

		/*
		this._htEvent["touchstart"] = {
			ref : MobileCommentJindo.$Fn(this._onTouchStart, this).attach(this._getContainer(), "touchstart"),
			el	: this._getContainer()
		};*/

		// 스크롤 방지 처리
		this._htEvent["touchmove"] = {
			ref : MobileCommentJindo.$Fn(this._onTouchMove, this).attach(this._getContainer(), "touchmove"),
			el	: this._getContainer()
		};

		/*
		this._htEvent["touchmove"] = {
			ref : MobileCommentJindo.$Fn(this._onTouchMove, this).attach(document, "touchmove"),
			el	: document
		};*/

		// 리사이즈 처리
		if (this.option("bAutoReposition")) {
			this._htEvent["rotate"] = MobileCommentJindo.$Fn(this._onResize, this).bind();
			MobileCommentJindo.m.bindRotate(this._htEvent["rotate"]);
		}
	},

	/**
	 * @description 특정 이벤트를 해제한다.
	 * @param {String} sEventKey 이벤트 키
	 */
	_detachEvent : function(sEventKey) {
		if(sEventKey) {
			var htTargetEvent = this._htEvent[sEventKey];
			if (htTargetEvent.ref) {
				htTargetEvent.ref.detach(htTargetEvent.el, sEventKey);
			}
		}
	},

	/**
	 * @description MobileCommentJindo.m.Dialog 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEventAll : function() {
		for(var p in this._htEvent) {
			this._detachEvent(p);
		}
		MobileCommentJindo.m.unbindRotate(this._htEvent["rotate"]);
		this._htEvent = null;
	},

	/**
	 * @description 다이얼로그 레이어 내부에서 닫기, 확인, 취소 버튼을 처리하기위한 핸들러
	 * @param {MobileCommentJindo.$Event} we 랩핑된 이벤트객체
	 */
	_onClick : function(we) {
		var sClassPrefix = this.option("sClassPrefix");
		var elClosestClose, elClosestConfirm, elClosestCancel, elClosestLayer, elClosestAnchor;

		if ((elClosestClose = MobileCommentJindo.m.getClosest(("." + sClassPrefix + "close"), we.element))) {
			// 닫기버튼 클릭
			if(this.fireEvent("close", {
				sType : "close",
				elLayer : this.getDialog()
			})) {
				this.hide();
			}
		} else if ((elClosestConfirm = MobileCommentJindo.m.getClosest(("." + sClassPrefix + "confirm"), we.element))) {
			// 확인버튼 클릭
			if(this.fireEvent("confirm", {
				sType : "confirm",
				elLayer : this.getDialog()
			})) {
				this.hide();
			}
		} else if ((elClosestCancel = MobileCommentJindo.m.getClosest(("." + sClassPrefix + "cancel"), we.element))) {
			// 취소버튼 클릭
			if (this.fireEvent("cancel", {
				sType : "cancel",
				elLayer : this.getDialog()
			})) {
				this.hide();
			}
		} else if ((elClosestLayer = MobileCommentJindo.m.getClosest(("." + sClassPrefix + "layer"), we.element))) {
			// 다이얼로그 안쪽영역 클릭
			if ((elClosestAnchor = MobileCommentJindo.m.getClosest(("a"), we.element))) {
				// 링크가 클릭된 경우
				return false;
			}
		} else {
			// 다이얼로그 외 바깥영역 클릭
			if(this.option("bAutoClose")) { this.hide(); }
		}
		we.stop();
		return false;
	},

	/**
	 * @description 터치스타트 이벤트를 처리하기위한 핸들러 - 롱탭/하이라이팅 막기
	 * @param {MobileCommentJindo.$Event} we 랩핑된 이벤트객체
	 */
	_onTouchStart : function(we) {
		var sClassPrefix = this.option("sClassPrefix");
		var elClosestLayer;
		if (!(elClosestLayer = MobileCommentJindo.m.getClosest(("." + sClassPrefix + "layer"), we.element))) {
			we.stop(MobileCommentJindo.$Event.CANCEL_ALL);
			return false;
		}
	},

	/**
	 * @description 터치무브 이벤트를 처리하기위한 핸들러 - 스크롤 막기
	 * @param {MobileCommentJindo.$Event} we 랩핑된 이벤트객체
	 */
	_onTouchMove : function(we) {
		we.stop(MobileCommentJindo.$Event.CANCEL_ALL);
		return false;
	},

	/**
	 * @description 리사이즈를 처리하기위한 핸들러
	 * @param {MobileCommentJindo.$Event} we 랩핑된 이벤트객체
	 */
	_onResize : function(we) {
		// Show/Hide를 처리하는 중에 리사이즈 발생시
		if(this._bProcessingShow || this._bProcessingHide) {
			if(this.option("bUseEffect")) {
				this._getLayerEffect().stop();
			} else {
				if(this._bProcessingShow) {
					this._endShowEffect();
				} else {
					this._endHideEffect();
				}
			}
		}

		if(this._oTimeout) {
			clearTimeout(this._oTimeout);
			this._oTimeout = null;
		}

		if (this.isShown() && this._bIOS) {
			this._htWElement["dialog_container"].hide();
		}

		this._oTimeout = setTimeout(MobileCommentJindo.$Fn(function() {
			this._resizeDocument();

			if (this.isShown() && this._bIOS) {
				this._htWElement["dialog_container"].show();
			}
		}, this).bind(), 300);
	},

	/**
	 * @description 리사이즈를 처리한다.
	 */
	_resizeDocument : function() {
		this._setDeviceSize();

		// Container Resize
		this._htWElement["dialog_container"].css({
			width : this._htDeviceSize.width + "px",
			height : this._htDeviceSize.height + "px"
		});
		// FogLayer Resize
		this._htWElement["dialog_foggy"].css({
			width : this._htDeviceSize.width + "px",
			height : this._htDeviceSize.height + "px"
		});

		// Dialog Resize
		this._resizeDialog(true);

		// LayerEffect Resize
		if(this.option("bUseEffect")) { this._getLayerEffect().setSize(); }
	},

	/**
	 * @description setTemplate등으로 다이얼로그가 수정되었을경우 다이얼로그의 리사이즈를 처리한다.
	 * @param (Boolean} bForced 무조건 _repositionDialog()를 수행할지 여부
	 */
	_resizeDialog : function(bForced) {
		//console.log("_resizeDialog")
		if(this._setDialogSize() || bForced) {
			// Dialog Reposition
			this._repositionDialog();
		}
	},
	/**
	 * 생성된 LayerEffect 컴포넌트의 인스턴스를 가져온다.
	 * @return {MobileCommentJindo.m.LayerEffect} LayerEffect 컴포넌트의 인스턴스
	 */
	_getLayerEffect : function() {
		return this._oLayerEffect;
	},

	/**
	 * @description 다이얼로그 컨테이너 엘리먼트를 반환한다.
	 * @return {HTMLElement} elDialogContainer 다이얼로그 컨테이너 엘리먼트
	 */
	_getContainer : function() {
		return this._htWElement["dialog_container"].$value();
	},

	/**
	 * @description Foggy 엘리먼트를 반환한다.
	 * @return {HTMLElement} Foggy 엘리먼트
	 */
	_getFoggy : function() {
		return this._htWElement["dialog_foggy"].$value();
	},

	/**
	 * @description 다이얼로그 엘리먼트를 반환한다.
	 * @return {HTMLElement} elDialog 다이얼로그 엘리먼트
	 */
	getDialog : function() {
		return this._htWElement["dialog_layer"].$value();
	},

	/**
	 * @description 다이얼로그 레이어에 대한 템플릿을 설정한다.
	 * 다이얼로그 레이어의 내용을 동적으로 설정하기 위해 템플릿 형태로 설정한다.
	 * @remark Jindo의 MobileCommentJindo.$Template 참고
	 * @param {String} sTemplate 템플릿 문자열
	 * @example
	 * 	oDialog.setTemplate('<div><a href="#" class="dialog-close"><img width="15" height="14" alt="레이어닫기" src="http://static.naver.net/common/btn/btn_close2.gif"/></a></div><div style="position:absolute;top:30px;left:10px;">{=text}</div><div style="position:absolute;bottom:10px;right:10px;"><button type="button" class="dialog-confirm">확인</button><button type="button" class="dialog-cancel">취소</button></div></div>');
	 */
	setTemplate : function(sTemplate) {
		this._sTemplate = sTemplate;
		this._oTemplate = MobileCommentJindo.$Template(this._sTemplate);


		this._htWElement["dialog_clone"].html(sTemplate);
		this._resizeDialog();
	},

	/**
	 * @description 설정된 다이얼로그 레이어의 템플릿을 가져온다.
	 * @return {String} sTemplate 설정된 템플릿 문자열
	 */
	getTemplate : function() {
		return this._sTemplate;
	},

	/**
	 * @description 다이얼로그 레이어의 사이즈를 저장한다.
	 */
	_setDialogSize : function() {
		//console.log("_setDialogSize")
		var nLayerWidth;
		var nLayerHeight;
		if(this.option("sPosition") == "all") {
			// 다이얼로그 레이어의 사이즈를 디바이스 사이즈로 설정한다.
			nLayerWidth = this._htDeviceSize.width;
			nLayerHeight = this._htDeviceSize.height;
		} else {
			// 실제 다이얼로그 레이어의 사이즈를 구하기위해 클론을 사용한다.
			this._htWElement["dialog_clone"].show();
			nLayerWidth = Math.min(this._htWElement["dialog_clone"].width(), this._htDeviceSize.width);
			nLayerHeight = Math.min(this._htWElement["dialog_clone"].height(), this._htDeviceSize.height);
			this._htWElement["dialog_clone"].hide();
		}

		// 기존에 설정해놨던 사이즈와 동일할 경우 return false; 처리한다.
		if(this._htDialogSize.width == nLayerWidth && this._htDialogSize.height == nLayerHeight) {
			return false;
		}

		// 새로 구한 사이즈를 저장한다.
		this._htDialogSize = {
			width : nLayerWidth,
			height : nLayerHeight
		};

		// 다이얼로그 레이어의 사이즈를 설정한다.
		this._htWElement["dialog_layer"].css({
			width : nLayerWidth + "px",
			height : nLayerHeight + "px"
		});

		return this._htDialogSize;
	},

	/**
	 * @description 다이얼로그 레이어의 사이즈를 반환한다.
	 * @return {HashTable} htDialogSize 다이얼로그 레이어 사이즈정보
	 */
	_getDialogSize : function() {
		return this._htDialogSize;
	},

	/**
	 * @description 다이얼로그의 위치를 재계산한다.
	 */
	_repositionDialog : function() {
		//console.log("_repositionDialog")

		var htLayerPosition = this._getDialogPosition();
		this._htWElement["dialog_layer"].css({
			top : htLayerPosition.top + "px",
			left : htLayerPosition.left + "px"
		});

		this._htWElement["dialog_container"].css({
			top : window.pageYOffset + "px",
			left : window.pageXOffset + "px"
		});

		if(!this.isShown()) {
			var sEffectType = this.option("sEffectType");
			if(sEffectType == "slide-up" || sEffectType == "slide-down") {
				this._initContainerTop();
			}
		}
	},

	/**
	 * @description 다이얼로그 레이어의 위치를 반환한다.
	 * @return {HashTable} htLayerPosition 다이얼로그 레이어 위치정보
	 */
	_getDialogPosition : function() {
		var nWidth = this._htDeviceSize.width;
		var nHeight = this._htDeviceSize.height;
		var nLayerWidth = this._getDialogSize().width;
		var nLayerHeight = this._getDialogSize().height;

		var htLayerPosition = {};
		switch(this.option("sPosition")) {
		case "top":
			htLayerPosition.top = 0;
			htLayerPosition.left = parseInt((nWidth - nLayerWidth) / 2, 10);
			break;
		case "center":
			htLayerPosition.top = parseInt((nHeight - nLayerHeight) / 2, 10);
			htLayerPosition.left = parseInt((nWidth - nLayerWidth) / 2, 10);
			break;
		case "bottom":
			htLayerPosition.top = parseInt(nHeight - nLayerHeight,10);
			htLayerPosition.left = parseInt((nWidth - nLayerWidth) / 2, 10);
			break;
		case "all" :
			htLayerPosition.top = 0;
			htLayerPosition.left = 0;
			break;
		}

		return htLayerPosition;
	},

	/**
	 * 다이얼로그 레이어에 위치를 설정한다.
	 * @param {String} sPosition ("top"|"center"|"bottom"|"all")
	 */
	setPosition : function(sPosition) {
		if(sPosition == "top" || sPosition == "center" || sPosition == "bottom" || sPosition == "all") {
			this.option("sPosition", sPosition);
		}

		this._resizeDialog();
	},

	/**
	 * @description 이펙트 사용을 설정한다.
	 */
	useEffect : function() {
		if(this.option("bUseEffect")) { return false; }
		this.option("bUseEffect", true);
		this._initContainerTop();
	},

	/**
	 * @description 이펙트 효과를 없앤다.
	 */
	unuseEffect : function() {
		if(!this.option("bUseEffect")) { return false; }
		this.option("bUseEffect", false);
		this._initContainerTop();
	},

	/**
	 * @description 이펙트 타입을 설정한다.
	 * @param {String} sEffectType 이펙트 타입
	 */
	setEffectType : function(sEffectType) {
		this.useEffect();

		if(sEffectType == "pop" || sEffectType == "slide-up" || sEffectType == "slide-down" || sEffectType == "flip") {
			this.option("sEffectType", sEffectType);
			this._initContainerTop();
		}
	},

	/**
	 * @description 이펙트 지속시간을 설정한다.
	 * @param {Number} nEffectDuration 이펙트 지속시간 (ms단위)
	 */
	setEffectDuration : function(nEffectDuration) {
		this.useEffect();

		if(nEffectDuration && nEffectDuration > 99) {
			this.option("nEffectDuration", nEffectDuration);
		}
	},


	/**
	 * @description 이펙트 효과를 설정한다.
	 * @param {HashTable} htEffectOption 이펙트 효과 정보(이펙트 종류, 시간)
	 */
	setEffect : function(htEffectOption) {
		this.useEffect();

		if(htEffectOption.type) {
			this.setEffectType(htEffectOption.type);
		}

		if(htEffectOption.duration) {
			this.setEffectDuration(htEffectOption.duration);
		}
	},

	/**
	 * @description 다이얼로그 레이어가 보여지고 있는지 가져온다.
	 * @return {Boolean} 다이얼로그 레이어의 노출여부
	 */
	isShown : function() {
		return this._bIsShown;
	},

	/**
	 * @description 다이얼로그를 보여준다.
	 * @param {HashTable} htTemplate 다이얼로그 템플릿 Text치환 정보
	 * @param {HashTable} htEventHandler 커스텀 이벤트 정보
	 */
	show : function(htTemplate, htEventHandler) {
		//console.log("show")
		if(this.isShown()) { return false; }

		this._bProcessingShow = true;

		// 다이얼로그가 보이는 동안에 스크롤을 막기
		this._htEvent["touchstart"] = {
			ref : MobileCommentJindo.$Fn(this._onTouchStart, this).attach(document, "touchstart"),
			el	: document
		};

		// custom event attach
		if(htEventHandler) {
			this._showAttachedEvent = htEventHandler;
			this.attach(htEventHandler);
		}

		// Dialog가 뜬 상태에서는 스크롤 불가처리
		this._resizeDocument();

		// Template처리
		if(typeof htTemplate == "undefined") {
			htTemplate = {};
		} else {
			this._htWElement["dialog_clone"].html(this._oTemplate.process(htTemplate));
			this._resizeDialog();
		}
		this._htWElement["dialog_layer"].html(this._oTemplate.process(htTemplate));

		// fire beforeshow
		if(!this.fireEvent("beforeShow", {
			sType : "beforeShow",
			elLayer : this.getDialog()
		})) { return; }

		this._showDialogLayer();
	},

	/**
	 * @description 이펙트 사용여부에 따라 분기처리한다.
	 */
	_showDialogLayer : function() {
		//console.log("_showDialogLayer")

		if(this.option("bUseEffect")) {
			this._getLayerEffect().attach("afterEffect", MobileCommentJindo.$Fn(this._endShowEffect, this).bind());
			this._startShowEffect();
		} else {
			// Effect 효과 없음
			this._htWElement["dialog_container"].show();
			this._endShowEffect();
		}
	},

	/**
	 * @description Show시 보여줄 이펙트효과를 시작한다.
	 */
	_startShowEffect : function() {
		//console.log("_startShowEffect")

		var sEffectType = this.option("sEffectType");
		var nEffectDuration = this.option("nEffectDuration");

		switch(sEffectType) {
		case "slide-up":
			this._htWElement["dialog_container"].show();
			this._getLayerEffect().setSize();
			this._getLayerEffect().slide({
				sDirection : "up",
				nDuration : nEffectDuration
			});
			break;
		case "slide-down":
			this._htWElement["dialog_container"].show();
			this._getLayerEffect().setSize();
			this._getLayerEffect().slide({
				sDirection : "down",
				nDuration : nEffectDuration
			});
			break;
		case "pop":
			this._getLayerEffect().pop({
				sDirection : "in",
				nDuration : nEffectDuration,
				htFrom : {opacity : 1}
			});
			break;
		case "flip":
			this._htWElement["dialog_container"].show();
			this._getLayerEffect().flip({
				nDuration : nEffectDuration,
				elFlipFrom : this._getContainer(),
				elFlipTo : this._getContainer(),
				htFrom : {opacity : 0},
				htTo : {opacity : 1}
			});
			//this._htWElement["dialog_container"].show();
			break;
		}
	},

	/**
	 * @description Show시 보여줄 이펙트효과를 끝낸다.
	 */
	_endShowEffect : function() {
		//console.log("_endShowEffect")

		if(this.option("bUseEffect")) { this._getLayerEffect().detachAll("afterEffect"); }

		// fire show
		this.fireEvent("show", {
			sType : "show",
			elLayer : this.getDialog()
		});

		this._bIsShown = true;
		this._bProcessingShow = false;
	},

	/**
	 * @description 다이얼로그를 숨긴다.
	 */
	hide : function() {
		//console.log("hide")
		if(!this.isShown()) { return false; }

		this._bProcessingHide = true;

		if(!this.fireEvent("beforeHide", {
			sType : "beforeHide",
			elLayer : this.getDialog()
		})) { return; }

		this._hideDialogLayer();
	},

	/**
	 * @description 이펙트 사용여부에 따라 분기처리한다.
	 */
	_hideDialogLayer : function() {
		//console.log("_hideDialogLayer")

		if(this.option("bUseEffect")) {
			this._getLayerEffect().attach("afterEffect", MobileCommentJindo.$Fn(this._endHideEffect, this).bind());
			this._startHideEffect();
		} else {
			// Effect 효과 없음
			this._htWElement["dialog_container"].hide();
			this._endHideEffect();
		}
	},

	/**
	 * @description Hide시 보여줄 이펙트효과를 시작한다.
	 */
	_startHideEffect : function() {
		//console.log("_startHideEffect")

		var sEffectType = this.option("sEffectType");
		var nEffectDuration = this.option("nEffectDuration");

		switch(sEffectType) {
		case "slide-up":
			this._getLayerEffect().slide({
				sDirection : "down",
				nDuration : nEffectDuration
			});
			break;
		case "slide-down":
			this._getLayerEffect().slide({
				sDirection : "up",
				nDuration : nEffectDuration
			});
			break;
		case "pop":
			this._getLayerEffect().pop({
				sDirection : "out",
				nDuration : nEffectDuration,
				htTo : {opacity : 0}
			});
			break;
		case "flip":
			this._getLayerEffect().flip({
				nDuration : nEffectDuration,
				elFlipFrom : this._getContainer(),
				elFlipTo : this._getContainer(),
				htTo : {opacity : 0}
			});
			break;
		}
	},

	/**
	 * @description Hide시 보여줄 이펙트효과를 끝낸다.
	 */
	_endHideEffect : function() {
		//console.log("_endHideEffect")

		if(this.option("bUseEffect")) { this._getLayerEffect().detachAll("afterEffect"); }

		// fire show
		this.fireEvent("hide", {
			sType : "hide",
			elLayer : this.getDialog()
		});

		// custom event detach
		if(this._showAttachedEvent) {
			for(var evt in this._showAttachedEvent) {
				//console.log(evt)
				this.detachAll(evt);
			}
			this._showAttachedEvent = null;
		}

		// 다이얼로그가 보이는 동안에 스크롤을 막기 해제
		this._detachEvent("touchstart");

		this._htWElement["dialog_container"].hide();
		this._htWElement["dialog_container"].css("opacity", 1);

		if(window.pageYOffset || window.pageXOffset) {
			this._htWElement["dialog_container"].css({
				top : "0px",
				left : "0px"
			});
		}

		this._bIsShown = false;
		this._bProcessingHide = false;
	},

	/**
	 * @description 객체를 release 시킨다.
	 */
	destroy : function() {
		this._detachEventAll();

		if(this.option("bUseEffect")) {
			this._getLayerEffect().destroy();
			this._oLayerEffect = null;
		}

		this._htWElement["dialog_container"].leave();
		this._htWElement["dialog_clone"].leave();
		this._htWElement = null;
		this._htDeviceSize = null;
		this._htDialogSize = null;
		this._sTemplate = null;
		this._oTemplate = null;
		this._bIsShown = null;
		this._bProcessingShow = null;
		this._bProcessingHide = null;
		this._oTimeout = null;
		this._htDeviceInfo = null;
		this._bIOS = null;
		this._bAndroid = null;
	}
}).extend(MobileCommentJindo.UIComponent);
/**
* @(#)MobileCommentJindo.m.DropArea.js 2012. 2. 20.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author "oyang2"
* @since 2012. 2. 20.
* @description
*/
MobileCommentJindo.m.DropArea = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.DropArea.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class 기준엘리먼트 내의 drop 가능하도록 하는 클래스
	 * @param {HTMLElement | String} el 기준 엘리먼트 (혹은 id)
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
	 * @requires MobileCommentJindo.m.DragArea
	 * @example
var  oDrop = new MobileCommentJindo.m.DropArea('layer1', {
		sClassPrefix : 'drop-',
		oDragInstance : null, //MobileCommentJindo.m.DragArea 인스턴스
		bUseTouchPoint : false, //드롭엘리먼트 영역에 OVER를 감지 할때 터치 포인트를 사용할지에 대한 여부
		bActivateOnload : true
	});
     */
	$init : function(el, htUserOption) {
		this.option({
			sClassPrefix : 'drop-',
			oDragInstance : null,
			bActivateOnload : true,
			bUseTouchPoint : false
		});
		this.option(htUserOption || {});

		this._initVar();
		this._setWrapperElement(el);

		if(this.option("bActivateOnload")) {
			this.activate();
		}
	},

	/**
	 * @description MobileCommentJindo.m.DropArea 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar: function() {
		this._waOveredDroppableElement = MobileCommentJindo.$A([]);
		this._sEvent = 'ontouchstart' in window? 'touchmove' : 'mousemove';
		this._sDropClassName = '.' + this.option('sClassPrefix')+"area";

		this._aItem = null;
		this._aItemRect = null;
		this._elHandle = null;
		this._elDragging = null;
	},

	/**
	 * @description MobileCommentJindo.m.DropArea 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement: function(el) {
		this._htWElement = {};
		var el = MobileCommentJindo.$(el);
		this._htWElement["base"] = MobileCommentJindo.$Element(el);
	},

	/**
	 * @description el의 offset 범위를 구해서 리턴한다.
	 * @param {HTMLElement} el
	 * @return {HashTable}
	 */
	_getRectInfo : function(el){
		var htOffset = MobileCommentJindo.$Element(el).offset();

		return {
			nLeft : htOffset.left,
			nTop : htOffset.top,
			nRight : htOffset.left + el.offsetWidth,
			nBottom : htOffset.top + el.offsetHeight
		};
	},

	/**
	 * @description 기준레이어내의 모든 드롭엘리먼트를 구하고 각 드롭엘리먼트의 위치범위를 저장한다.
	 */
	_reCalculate : function() {

		var elBase = this._htWElement["base"].$value();
		var aItem = MobileCommentJindo.$$(this._sDropClassName , elBase);

		if (elBase.tagName && MobileCommentJindo.$$.test(elBase, this._sDropClassName )) {
			aItem.push(elBase);
		}
		//console.log('다시구해 ' + aItem.length);
		this._aItem = aItem;
		this._aItemRect = [];

		for (var i = 0, el; (el = aItem[i]); i++) {
			this._aItemRect.push(this._getRectInfo(el));
		}
	},
	/**
	 * @description el을 기준으로 현재 위치에 맞는 drop area를 찾는다.
	 */
	_findDroppableElement : function(el) {
		var elDroppable = MobileCommentJindo.$$.test(el, this._sDropClassName ) ? el : MobileCommentJindo.m.getClosest(this._sDropClassName , el);

		if (!this._isChildOfDropArea(el)) { //기준 엘리먼트가 document인 경우 Magnetic일때 문서밖으로 커서이동시 event 발생!
			elDroppable = null;
		}
		return elDroppable;
	},

	/**
	 * @description el이 기준 엘리먼트내의 자식 노드인지 확인한다.
	 * @param {HTMLElement}
	 */
	_isChildOfDropArea : function(el) {
		if (this._el === document || this._el === el){
			return true;
		}
		return this._htWElement["base"].isParentOf(el);
	},


	_isDropMove : function(nLeft, nTop, nRight, nBottom){
		var aItem = this._aItem;
		var aItemRect = this._aItemRect;

		if(!this.option('bUseTouchPoint')){
			for (var i = 0, htRect, el; ((htRect = aItemRect[i]) && (el = aItem[i])); i++) {
				var bHOver = this._checkOverArea({nMin: htRect.nLeft, nMax : htRect.nRight}, {nMin : nLeft, nMax : nRight});
				var bVOver = this._checkOverArea({nMin: htRect.nTop, nMax : htRect.nBottom}, {nMin : nTop, nMax : nBottom});

				if(bHOver && bVOver){
					this._addOveredDroppableElement(el);
					this._fireMoveEvent(el, htRect, {nX : nLeft,nY: nTop});
				}else{
					this._removeOveredDroppableElement(el);
				}

			}
		}else{
			//console.log('터치 포인트로 게산해여');
			for (var i = 0, htRect, el; ((htRect = aItemRect[i]) && (el = aItem[i])); i++) {
				if ( htRect.nLeft <= nLeft && nLeft <= htRect.nRight && htRect.nTop <= nTop && nTop <= htRect.nBottom ) {
					this._addOveredDroppableElement(el);
					this._fireMoveEvent(el, htRect, {nX : nLeft,nY: nTop});
				} else {
					this._removeOveredDroppableElement(el);
				}
			}
		}
	},

	/**
	 * min, max 값으로 base 값안에 check값이 있는지 판단.
	 */
	_checkOverArea : function(htBase, htCheck){

		if(htCheck.nMin < htBase.nMin){
			if(htCheck.nMax > htBase.nMin){
				return true;
			}
		}else{
			if(htCheck.nMin < htBase.nMax){
				return true;
			}
		}
		return false;
	},

	/**
	 * @description 커스텀 이벤트 move를 발생시킨다
	 */
	_fireMoveEvent : function(elDrop, htRect, htTouchInfo){
		var nRatioX = (htTouchInfo.nX - htRect.nLeft) / (htRect.nRight - htRect.nLeft);
		var nRatioY = (htTouchInfo.nY - htRect.nTop) / (htRect.nBottom - htRect.nTop);

		this.fireEvent('move',{
			elHandle : this._elHandle,
			elDrag : this._elDragging,
			elDrop : elDrop,
			nRatioX : nRatioX,
			nRatioY : nRatioY
		});
	},

	/**
	 * @description el을 드롭엘리먼트로 추가한다. 존재하지 않으면 'over' 커스텀 이벤트를 발생한다.
	 * @param {HTMLElement} el
	 */
	_addOveredDroppableElement : function(elDroppable) {
		if (this._waOveredDroppableElement.indexOf(elDroppable) == -1) {
			this._waOveredDroppableElement.push(elDroppable);
			this.fireEvent('over', {
				elHandle : this._elHandle,
				elDrag : this._elDragging,
				elDrop : elDroppable
			});
		}
	},

	/**
	 * @description el을 드롭엘리먼트에서 제거한다. 제거되면 'out' 커스텀 이벤트를 발생한다.
	 * @param {HTMLElement} el
	 */
	_removeOveredDroppableElement : function(elDroppable) {
		var nIndex = this._waOveredDroppableElement.indexOf(elDroppable);
		if (nIndex != -1) {
			this._waOveredDroppableElement.splice(nIndex, 1);
			this.fireEvent('out', {
				elHandle : this._elHandle,
				elDrag : this._elDragging,
				elDrop : elDroppable
			});
		}
	},

	/**
	 * @description 현재 드롭엘리먼트를 삭제하고 drop 커스텀 이벤트를 발생한다.
	 */
	_clearOveredDroppableElement : function(){
		for (var elDroppable; (elDroppable = this._waOveredDroppableElement.$value()[0]); ) {
			this._waOveredDroppableElement.splice(0, 1);

			this.fireEvent('drop', {
				elHandle : this._elHandle,
				elDrag : this._elDragging,
				elDrop : elDroppable
			});
		}
	},

	/**
	 * Drag되고 있는 채, 마우스가 올라간 엘리먼트의 리스트를 구함
	 * @return {Array} 겹쳐진 엘리먼트
	 */
	getOveredLists : function() {
		return this._waOveredDroppableElement ? this._waOveredDroppableElement.$value() : [];
	},

	/**
	 * @description MobileCommentJindo.m.DropArea 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this._attachEvent();

		if(this.option('oDragInstance')){
			var oDrag = this.option('oDragInstance');
			var self = this;

			oDrag.attach({
				'handleDown' : function(oCustomEvent){
					//console.log('drop HandleDown');
					self._elHandle = oCustomEvent.elHandle;
					self._elDragging = oCustomEvent.elDrag;
					self._waOveredDroppableElement.empty();

					self.fireEvent(oCustomEvent.sType, oCustomEvent);
				},
				'dragStart' : function(oCustomEvent){
					//self._reCalculate();
					if(!self.fireEvent(oCustomEvent.sType, oCustomEvent)){
						oCustomEvent.stop();
					}else{
						self._reCalculate();
						//self._htEvent["touchMove"].attach(document, self._sEvent);
					}
				},
				'beforeDrag' : function(oCustomEvent){
					self.fireEvent(oCustomEvent.sType, oCustomEvent);
				},
				'drag' : function(oCustomEvent){
					self._elDragging = oCustomEvent.elDrag;
					var wel = MobileCommentJindo.$Element(oCustomEvent.elDrag);

					var nTop =self.option('bUseTouchPoint')?  oCustomEvent.nTouchY	: oCustomEvent.nY;
					var nLeft = self.option('bUseTouchPoint')? oCustomEvent.nTouchX: oCustomEvent.nX;
					var nRight = nLeft+wel.width();
					var nBottom = nTop +wel.height();

					self._isDropMove(nLeft, nTop, nRight, nBottom );

					self.fireEvent(oCustomEvent.sType, oCustomEvent);
				},

				'dragEnd': function(oCustomEvent){
					//self._htEvent["touchMove"].detach(document, self._sEvent);

					var oParam = {};
					oParam.aElDrop = self.getOveredLists().concat();

					for(var p in oCustomEvent){
						oParam[p] = oCustomEvent[p];
					}

					self._clearOveredDroppableElement();

					self.fireEvent(oCustomEvent.sType, oParam);

				},
				'handleUp' : function(oCustomEvent){

					self.fireEvent('handleUp',{
						elHandle : self._elHandle,
						elDrag : self._elDragging
					});
					//console.log('handleUp');
					self._elHandle = null;
					self._elDragging = null;
				}
			});
		}
	},

	/**
	 * @description MobileCommentJindo.m.DropArea 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
		if(this.option('oDragInstance')){
			var oDrag = this.option('oDragInstance');
			oDrag.detachAll();
		}
	},

	/**
	 * @description MobileCommentJindo.m.DropArea 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};

		/* Touch 이벤트용 */
		//this._htEvent["touchMove"] = MobileCommentJindo.$Fn(this._onTouchMove, this);
	},

	/**
	 * @description MobileCommentJindo.m.DropArea 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		//this._htEvent["touchMove"].detach(this._htWElement.base, this._sEvent);
		this._htEvent = null;
	},

	/**
	 * @description  MobileCommentJindo.m.DropArea 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this.deactivate();

		for(var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		this._htWElement = null;

	}

}).extend(MobileCommentJindo.UIComponent);


/**
* @(#)MobileCommentJindo.m.Flicking.js 2011. 8. 29.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author "oyang2"
* @since 2011. 8. 29.
* @description
* @modify
* 2011-11-30
* bUsePreserve3dForAndorid 옵션추가 (corescroll에 추가된 옵션)
* <1.1.0 릴리즈, 코드수정>
*  - getTotalContents()메소드 추가
*  - getPrevElement() 메소드 추가
*  - getNextElement() 메소드 추가
*/

MobileCommentJindo.m.Flicking = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.Flicking.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
	 * @requires MobileCommentJindo.m.CoreScroll
	 * @example
var oFlicking = new MobileCommentJindo.m.Flicking('layer1', {
		bHorizontal : true,  //가로 플리킹 여부
		sClassPrefix : 'flick-',
		nDefaultIndex : 0, //로드시에 화면에 보일 view 화면 인덱스
		nDuration : 200,//flicking 타임
		bAutoResize : true, //
		nFlickThreshold : 40, //페이지 단위로 옮길때 최소 move 거리
		bActivateOnload : true
	})
     */
	$init : function(sId,htUserOption) {
		this.option({
			bHorizontal : true,
			sClassPrefix : 'flick-',
			bActivateOnload : true,
			nDefaultIndex: 0,
			bAutoResize : true,
			nFlickThreshold : 40,
			nDuration : 200,
			bUsePreserve3dForAndorid : false
		});

		this.option(htUserOption || {});
		this._setWrapperElement(sId);

		this._initVar();
		this._setSize();
		this._initScroll();
		this._updateSizeInfo();

		if(this.option("bActivateOnload")) {
			this.activate();
			this.moveTo(this.option('nDefaultIndex'), 0);
		}
	},

	_initScroll : function(){
		this._oCore = new MobileCommentJindo.m.CoreScroll(this._htWElement.base.$value(),{
			 bUseHScroll : this.option('bHorizontal'),
			 bUseVScroll : !this.option('bHorizontal'),
			 bUseMomentum : false,
			 bUsePreserve3dForAndorid : this.option('bUsePreserve3dForAndorid'),
			 bActivateOnload : false
		});

		this._oCore.attach({
			'beforeScroll' : MobileCommentJindo.$Fn(this._onBeforeScrollEnd, this).bind(),
			'afterScroll' : MobileCommentJindo.$Fn(this._onScrollEnd, this).bind()
		});
	},

	/**
	 * @description MobileCommentJindo.m.Flicking 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar: function() {
		this.bHorizontal = (this.option('bHorizontal'))? true : false;
		this.nCurrentIndex = this.option('nDefaultIndex');
		this.nNextIndex = this.nCurrentIndex;
		this.bResizeing = false;
	},

	/**
	 * @description MobileCommentJindo.m.Flicking 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement: function(el) {
		this._htWElement = {};
		el = MobileCommentJindo.$(el);
		var sClass = '.'+ this.option('sClassPrefix');

		this._htWElement.base = MobileCommentJindo.$Element(el);
		this._htWElement.wrapper = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle(sClass+'container',el));
		var aContents = MobileCommentJindo.$$(sClass+"ct", el);

		this._htWElement.aContent = MobileCommentJindo.$A(aContents).forEach(function(value,index, array){
			array[index] = MobileCommentJindo.$Element(value);
		}).$value();

	},


	_setSize : function(){
		if(!this.option('bAutoResize')) return;

		var nLen = this._htWElement.aContent.length;

		if(this.bHorizontal){
			var nW = this._htWElement.base.width();
			this._htWElement.wrapper.width(nW *nLen);
			MobileCommentJindo.$A(this._htWElement.aContent).forEach(function(value){
				value.width(nW);
			});

		}else{
			var nH = this._htWElement.aContent[0].height();
			this._htWElement.wrapper.height(nH*nLen);
		}

	},

	_updateSizeInfo : function(){
		var sLen = this.bHorizontal? 'width' : 'height';

		this._htPosition = [];

		var nPos = 0;

		for(var i=0,nLen = this._htWElement.aContent.length; i<nLen;i++){
			if(i != 0){
				nPos += this._htWElement.aContent[i-1][sLen]()*-1;
			}
			this._htPosition.push(nPos);
		}
	},

	_onBeforeScrollEnd :function(oCustomEvt){
		var nOrignalTime = oCustomEvt.nTime;

		var htPos = this._getSnap(oCustomEvt.nLeft, oCustomEvt.nTop, oCustomEvt.nDistanceX, oCustomEvt.nDistanceY,oCustomEvt.nMomentumX,oCustomEvt.nMomentumY);

		oCustomEvt.nNextLeft = htPos.nX;
		oCustomEvt.nNextTop = htPos.nY;
		oCustomEvt.nTime = htPos.nTime;

		this.nNextIndex = htPos.nIndex;

	},

	_onScrollEnd : function(){
		if(!this.bResizeing && (this.nNextIndex != this.nCurrentIndex)){
			this._setContentIndex(this.nNextIndex);

			this.fireEvent('afterFlicking',{
				nContentsIndex : this.getContentIndex()
			});
		}
		if(this.bResizeing){
			this.bResizeing = false;
		}
	},

	_getSnap : function(nX, nY, nDisX, nDisY,nMomX, nMomY){
		var nPosX = nPosY = nNewPos = 0;
		var nIndex = this._htWElement.aContent.length-1;

		var nCurrent = this.bHorizontal? nX : nY;
		var nDis = this.bHorizontal? nDisX : nDisY;
		var nMom = this.bHorizontal? nMomX : nMomY;

		for(var i=0,nLen = this._htPosition.length; i<nLen; i++){
			if(nCurrent >= (this._htPosition[i])){
				nIndex = i;
				break;
			}
		}

		if (nIndex == this.nCurrentIndex && nIndex > 0 && nDis > 0) nIndex--;

		if((Math.abs(nDis) <=  this.option('nFlickThreshold')) ){
			if(!(!MobileCommentJindo.m.getDeviceInfo().android && nMom != 0)){
				nIndex = this.nCurrentIndex;
			}
		}

		nNewPos = this._htPosition[nIndex];

		var nSize = Math.abs(this._htPosition[nIndex] -  this._htPosition[this.nCurrentIndex]);
		var nGap = nSize? Math.abs((nNewPos - nCurrent)/nSize) : 0;


		var nTime = ( !MobileCommentJindo.m.getDeviceInfo().android && (nMom != 0))? Math.round(this.option('nDuration')*nGap*0.5) : this.option('nDuration');
		nTime = Math.min(nTime, this.option('nDuration'));

		return {
			nX : this.bHorizontal? nNewPos : nPosX,
			nY : this.bHorizontal? nPosY : nNewPos,
			nTime : Math.round(nTime),
			nIndex : nIndex
		}
	},

	_getPosition :function(nIndex){
		var nPosX = nPosY = 0;

		if(typeof nIndex == 'undefined'){
			nIndex = this.nCurrentIndex;
		}

		nIndex = Math.max(0,nIndex);
		nIndex = Math.min(this._htPosition.length-1, nIndex);

		return {
			nX : this.bHorizontal? this._htPosition[nIndex]: nPosX,
			nY : this.bHorizontal? nPosY : this._htPosition[nIndex]
		}
	},


	_setContentIndex : function(nIndex){
		this.nCurrentIndex = nIndex;
	},

	/**
	 * @description 현재 플리킹화면에 보이는 컨텐츠의 인덱스를 리턴한다
	 * @return {Number}
	 */
	getContentIndex : function(){
		return this.nCurrentIndex;
	},

	/**
	 * @description 현재 플리킹화면에 보이는 컨텐츠의 래핑된 엘리먼트를 리턴한다.
	 * @return {MobileCommentJindo.$Element}
	 */
	getContentElement: function(){
		return this._htWElement.aContent[this.getContentIndex()];
	},

	/**
	 * @description 전체 플리킹의 컨텐츠 개수를 리턴한다.
	 * @return {Number}
	 */
	getTotalContents : function(){
		return this._htWElement.aContent.length;
	},
	/**
	 * @description 현재 컨텐츠의 이전 컨텐츠의 인덱스를 리턴한다
	 * @return {Number}
	 */
	getPrevIndex : function(){
		return Math.max(this.nCurrentIndex-1,0);
	},

	/**
	 * 현재 컨텐츠의 이전 컨텐츠의 래핑된 엘리먼트를 리턴한다. 이전 컨텐츠가 없는 경우 null을 리턴한다
	 * @return {MobileCommentJindo.$Element || null}
	 */
	getPrevElement : function(){
		if(this.nCurrentIndex-1 < 0){
			return null;
		}else{
			return this._htWElement.aContent[this.nCurrentIndex-1];
		}
	},

	/**
	 * 현재 컨텐츠의 이후 컨텐츠의 인덱스를 리턴한다
	 * @return {Number}
	 */
	getNextIndex : function(){
		return Math.min(this.nCurrentIndex+1, this._htWElement.aContent.length-1);
	},

	/**
	 * 현재 컨텐츠의 이후 컨텐츠의 래핑된 엘리먼트를 리턴한다. 이후 컨텐츠가 없는 경우 null을 리턴한다
	 * @return {MobileCommentJindo.$Element||null}
	 */
	getNextElement : function(){
		if(this.nCurrentIndex+1 > this._htWElement.aContent.length-1){
			return null;
		}else{
			return this._htWElement.aContent[this.nCurrentIndex+1];
		}
	},

	/**
	 * n번째 컨텐츠로 현재 플리킹화면을 이동한다.
	 * @param{Number} n
	 * @param{Number} 플리킹되는 duration 시간. 설정하지 않으면 옵션의 nDuration 값으로 설정한다
	 */
	moveTo : function(nIndex, nTime){
		if(nIndex < 0 || nIndex > this._htWElement.aContent.length-1){
			return;
		}

		if(typeof nTime == 'undefined'){
			nTime = this.option('nDuration');
		}

		var htPos = this._getPosition(nIndex);
		this.nNextIndex = nIndex;
		var htCurPos = this._oCore.getCurrentPos();

		if((htPos.nY !== htCurPos.nTop) || (htPos.nX !== htCurPos.nLeft)){
			this._oCore.scrollTo(htPos.nX, htPos.nY, nTime);
		}else{
			this._onScrollEnd();
		}
	},

	/**
	 * 이전화면으로 플리킹 화면을 이동한다.
	 * @param {Number} 플리킹되는 duration 시간. 설정하지 않으면 옵션의 nDuration 값으로 설정한다
	 */
	movePrev : function(nTime){
		this.moveTo(this.getPrevIndex(), nTime);
	},

	/**
	 * 이후화면으로 플리킹 화면을 이동한다.
	 * @param {Number} 플리킹되는 duration 시간. 설정하지 않으면 옵션의 nDuration 값으로 설정한다
	 */
	moveNext : function(nTime){
		this.moveTo(this.getNextIndex(), nTime);
	},

	/**
	 * 현재 애니메이션중인지 리턴한다
	 * @param {Boolean}
	 */
	isAnimating : function(){
		return this._oCore.isMoving();
	},


	_onResize : function(evt){
		var self = this;
		this._setSize();
		this._updateSizeInfo();
		this._oCore.refresh(true);


		self.bResizeing = true;
		self.moveTo(self.nCurrentIndex, 0);
	},

	/**
	 * @description MobileCommentJindo.m.Flicking 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this._oCore.activate();
		this._attachEvent();
	},

	/**
	 * @description MobileCommentJindo.m.Flicking 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._oCore.deactivate();
		this._detachEvent();
	},

	/**
	 * @description MobileCommentJindo.m.Flicking 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};
		// resize 이벤트  처리
		this._htEvent["rotate"] = MobileCommentJindo.$Fn(this._onResize, this).bind();
		MobileCommentJindo.m.bindRotate(this._htEvent["rotate"]);
	},

	/**
	 * @description MobileCommentJindo.m.Flicking 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		for(p in this._htEvent) {
			var htTargetEvent = this._htEvent[p];
			if (htTargetEvent.ref) {
				htTargetEvent.ref.detach(htTargetEvent.el, p);
			}
		}
		MobileCommentJindo.m.unbindRotate(this._htEvent["rotate"]);
		this._htEvent = null;
	},

	/**
	 * @description  MobileCommentJindo.m.Flicking 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this.deactivate();
		this._oCore.destroy();
		delete this._oCore;

		for(var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		this._htWElement = null;
		this.bHorizontal = null;
		this.nCurrentIndex = null;
		this._htPosition = null;
	}
}).extend(MobileCommentJindo.UIComponent);

/**
* @(#)MobileCommentJindo.m.FloatingLayer.js 2011. 7. 19.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sculove
* @since 2011. 7. 19.
* @description
*
* <2차 Release이후, 코드 수정사항>
* 1. 옵션 변경
*      bAutoResize 옵션 삭제
*      nFadeInDuration : 200 -> 0으로 변경
*     nFadeOutDuration : 2000 -> 0으로 변경
* 2. 메소드 변경
*       reSize -> resize
* 3. z-Index 문제 수정
*
* <3차 Release이후, 코드 수정사항>
* 1. ScrollEnd 적용 => 스크롤 관련 버그 제거
*
* <1.0.0 이후 수정사항>
* 1. Android 3.x, 4.x 대응
*  : 안드로이드 3.0 이하일 경우에만 하이라이트 문제 처리 (단, fixed에서의 슬라이드 적용은 안됨 )
* 2. 기능 변경 - 하이라이트 무시
* 3. active/deactive 시 관련 컴포넌트 생성/소멸
*
*/
MobileCommentJindo.m.FloatingLayer = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.FloatingLayer.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {HTMLElement} el 대상 엘리먼트 (필수)
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
	 * @requires MobileCommentJindo.m.LayerPosition
	 * @requires MobileCommentJindo.m.ScrollEnd
	 * @requires MobileCommentJindo.m.SlideEffect
	 * @requires MobileCommentJindo.m.FadeEffect
     */
	$init : function(el,htUserOption) {
		this.option({
			 bActivateOnload : true,
			 sPosition : "bottom",
			 sDirection : "up",
			 nSlideDuration : 500,
			 sSlideTimingFunction : "ease-in-out",
			 nFadeInDuration : 0,
			 sFadeInTimingFunction : "ease-in-out",
			 nFadeOutDuration : 0,
			 sFadeOutTimingFunction : "ease-in-out",
			 nTimeout : -1
		});
		this.option(htUserOption || {});
		this._initVar();
		this._setWrapperElement(el);
		if(this.option("bActivateOnload")) {
			this.activate();
		}
	},

	/**
	 * @description MobileCommentJindo.m.FloatingLayer 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar: function() {
		this._oFloatingEffect = null;
		this._oFadeinEffect = null;
		this._oLayerPosition = null;
		this._oScrollEnd = null;
		this._nTimeoutTimer = -1;

		this._isLayerOn = false;
		this._isMoving = false;	// 이동 여부
	},

	/**
	 * @description MobileCommentJindo.m.FloatingLayer 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement: function(el) {
		this._htWElement = {};
		this._htWElement["element"] = MobileCommentJindo.$Element(el);
		this._htWElement["viewElement"] = MobileCommentJindo.$Element(this._createView());

		/**
		 * Android 3, 4인 경우, fixed를 사용할 때(slide/fade-in) 깜빡이는 버그가 있다.
		 * 이를 개선하기 위해, fade-in되는 엘리먼트의 base를 동일하게 처리하였다.
		 */
		if(MobileCommentJindo.m.getDeviceInfo().android && parseInt(MobileCommentJindo.m.getDeviceInfo().version,10) >= 3) {
			this._htWElement["targetElement"] = this._htWElement["viewElement"];
		} else {
			this._htWElement["targetElement"] = this._htWElement["element"];
		}
	},

	/**
	 * @description 사용하는 컴포넌트를 초기화한다.
	 */
	_initComponent : function() {
		var self = this,
			el = this._htWElement["element"].$value();

		// Layer Position 지정
		this._oLayerPosition = new MobileCommentJindo.m.LayerPosition(this._htWElement["viewElement"].$value(), {
			sPosition : this.option("sPosition"),
			bActivateOnload : false,
			bAutoReposition : true
		});

		// LayerEffect (Slide, Fadein 지정)
		this._oFloatingEffect = new MobileCommentJindo.m.LayerEffect(el);
		if(this.option("nFadeInDuration") !== 0) {
			this._oFadeinEffect = new MobileCommentJindo.m.LayerEffect(this._htWElement["targetElement"].$value(), {
					nDuration: this.option("nFadeInDuration")
				}).attach("afterEffect",function() {
					self._startHideTimer();
				});
		}

		// ScrollEnd 지정
		this._oScrollEnd = new MobileCommentJindo.m.ScrollEnd();
	},

	/**
	 * @description Layer 를 반환한다.
	 * @return {HTMLElement}
	 */
	getLayer : function() {
		return this._htWElement["element"].$value();
	},

	/**
	 * @description el의 width와 height가 동일한 div을 만듦
	 * @return {MobileCommentJindo.$Element} welView
	 */
	_createView : function () {
		var bVisible = this._htWElement["element"].visible(),
			welView = this._htWElement["element"].query("._floatingLayer_view_divtag_");
		if(!welView) {
			welView = MobileCommentJindo.$Element("<div class='_floatingLayer_view_divtag_'>");
			// elView.style.border = "1px solid red";
		} else {
			welView = MobileCommentJindo.$Element(welView);
		}

		// el의 width와 height 얻기
		if (!bVisible) {
			this._htWElement["element"].css({
				left : "-9999px"
			}).show();
		}
 		welView.css({
 			width : this._htWElement["element"].width() + "px",
 			height : this._htWElement["element"].height() + "px",
 			zIndex : 1000
 		});
		//elView.style[MobileCommentJindo.m.getCssPrefix() + "TransformStyle"] = "preserve-3d";
		if (!bVisible) {
			this._htWElement["element"].hide();
		}
		return welView;
	},

	/**
	 * @description View의 크기를 갱신한다.
	 */
	resize : function(nWidth, nHeight) {
		this._htWElement["viewElement"].css({
			width : nWidth + "px",
			height : nHeight + "px"
		});
		this._oLayerPosition.setPosition();
	},

	/**
	 * @description FloatingLayer를 보임
	 */
	show : function() {
		if (this._fireEvent("beforeShow")) {
			// 1. LayerPosition activate
			if(!this._oLayerPosition.isActivating()) {
				this._oLayerPosition.activate();
			}
			// 2. FloatingEffect 이벤트 show로 설정
			this._setFloatingEffect(true);
			// 3. Slide
			this._htWElement["element"].show();
			this._oFloatingEffect.slide({
				sDirection: this.option("sDirection"),
				nDuration: this.option("nSlideDuration"),
				sTransitionTimingFunction : this.option("sSlideTimingFunction"),
				elBaseLayer: this._htWElement["viewElement"].$value()
			});
		}
	},

	/**
	 * @description FloatingLayer를 숨김
	 */
	hide : function() {
		if (this._fireEvent("beforeHide")) {
			// 0. hide Timer 제거
			this._stopHideTimer();
			// 1. LayerPosition deactivate
			if(this._oLayerPosition.isActivating()) {
				this._oLayerPosition.deactivate();
			}
			// 2. Floating관련 이벤트 detach
			this._detachFloatingEvent();
			// 3. FloatingEffect 이벤트 hide로 설정
			this._setFloatingEffect(false);
			// 4. Fade out
			if(this.option("nFadeOutDuration") !== 0) {
				this._oFloatingEffect.fade({
					sDirection: "out",
					nDuration: this.option("nFadeOutDuration"),
					sTransitionTimingFunction : this.option("sFadeOutTimingFunction")
				});
			} else {
				this._htWElement["targetElement"].hide();
				this._fireEvent("hide");
			}
		}
	},

	/**
	 *  @description 사용자 이벤트 호출
	 */
	_fireEvent : function(sType) {
		return this.fireEvent(sType, {
			welLayer : this._htWElement["element"]
		});
	},

	/**
	 * @description nTimeout속성이 -1보다 클경우 타이머 지정
	 * 타이머 이후 사라짐.
	 */
	_startHideTimer : function() {
		if (this.option("nTimeout") > -1) {
			var self = this;
			this._stopHideTimer();
			this._nTimeoutTimer = setTimeout(function(){
				self.hide();
			}, this.option("nTimeout"));
		}
	},

	/**
	 * @description nTimeout의 타이머 중지
	 */
	_stopHideTimer : function() {
		clearTimeout(this._nTimeoutTimer);
		this._nTimeoutTimer = -1;
	},

	/**
	 * @description touch가 시작될 경우 (ios,안드로이드 일 경우 touchstart)
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onTouchStart : function(we) {
		this._initFloatingData();
		if (this._isLayer(we.element)) {
			this._isLayerOn = true;
			this._htWElement["targetElement"].show();
		} else {
			// 상위 레이어에서 부터 시작안함
			this._htWElement["targetElement"].hide();
		}
	},

	/**
	 * @description scrollEnd일 경우 처리
	 * ios는 touchEnd 시점이  scrollEnd
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onScrollEnd : function(we) {
		this._runFadeIn();
	},

	/**
	 * @description touchmove시
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onTouchMove : function(we) {
		// this._clearFixedBug();
		this._isMoving = true;
	},

	/**
	 * @description 포지션 변경없이 터치가 될경우
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onTouchEnd : function(we) {
		if(this._isLayerOn) {
			this._oLayerPosition.setPosition();
			return;
		} else if (!this._isMoving) {
			this._runFadeIn();
		}
	},

	/**
	 * @description fadein 실행하는 함수
	 */
	_runFadeIn : function() {
		// console.log("fadein");
		if (this._isLayerOn) {
			this._startHideTimer();
		} else {
			this._fadeIn();
		}
	},

	/**
	 * @description 포지션 지정 완료 후 fade-in
	 */
	_fadeIn : function() {
			this._oLayerPosition.setPosition();
			if(this._oFadeinEffect) {
				// 중복 fade-in 문제 제거 (fade-in 하기전에 모든 큐 내용 제거)
				this._oFadeinEffect.clearEffect(true);
				this._oFadeinEffect.fade({
					sDirection: "in",
					sTransitionTimingFunction : this.option("sFadeInTimingFunction")
				});
			} else {
				this._htWElement["targetElement"].show();
				this._startHideTimer();
			}
	},

	/**
	 * @description Layer인지 아닌지 확인 (Layer는 하위 자식도 포함)
	 * @param {Object} el
	 */
	_isLayer : function(el) {
		if(el && (el === this._htWElement["element"].$value() || this._htWElement["element"].isParentOf(el)) ) {
			return true;
		} else {
			return false;
		}
	},

	/**
	 * @description Floating 제어 처음일 경우
	 */
	_initFloatingData : function() {
		// Timer 모두 중지
		this._stopHideTimer();

		// Effect 중지
		/*
		if(this._oFadeinEffect) {
			if(this._oFadeinEffect.isPlaying()) {
				this._oFadeinEffect.stop(true);
			}
		}
		if(this._oFloatingEffect && this.option("nFadeOutDuration") !== 0) {
			if(this._oFloatingEffect.isPlaying()) {
				this._oFloatingEffect.stop(true);
			}
		}
		*/
		if(this._oFloatingEffect && this.option("nFadeOutDuration") !== 0) {
			this._oFloatingEffect.clearEffect(true);
		}
		if(this._oFadeinEffect){
			this._oFadeinEffect.clearEffect(true);
		}
		// 속성값 중지
		this._isMoving = false;
		this._isLayerOn = false;
	},

	/**
	 * @description MobileCommentJindo.m.FloatingLayer 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this._initComponent();
	},

	/**
	 * @description MobileCommentJindo.m.FloatingLayer 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
		if(this._oFadeinEffect) {
			this._oFadeinEffect.detachAll("afterEffect");
			this._oFadeinEffect.destroy();
		}
		this._oFloatingEffect.destroy();
		this._oScrollEnd.destroy();
		this._oLayerPosition.destroy();
		document.body.appendChild(this._htWElement["element"].$value());
		this._htWElement["viewElement"].leave();
	},

	/**
	 * @description Floating관련 이벤트를 바인드한다.
	 */
	_attachFloatingEvent : function() {
		this._htEvent = {};
		this._htEvent["event_touchstart"] = {
			el : document,
			ref : MobileCommentJindo.$Fn(this._onTouchStart, this).attach(document, "touchstart")
		};
		this._htEvent["event_touchmove"] = {
			el : document,
			ref : MobileCommentJindo.$Fn(this._onTouchMove, this).attach(document, "touchmove")
		};
		this._htEvent["event_touchend"] = {
			el : document,
			ref : MobileCommentJindo.$Fn(this._onTouchEnd, this).attach(document, "touchend")
		};

		this._oScrollEnd.attach("scrollEnd", MobileCommentJindo.$Fn(this._onScrollEnd,this).bind());
	},

	/**
	 * @description MobileCommentJindo.m.FloatingLayer 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		this._detachFloatingEvent();
	},

	/**
	 * @description FloatingEffect 처리 후 타입 show,hide 지정
	 * @param {Boolean} type
	 */
	_setFloatingEffect : function(isShow) {
		var self=this;
		this._oFloatingEffect.detachAll("afterEffect");
		this._oFloatingEffect.clearEffect(true);
		if(this._oFadeinEffect){
			this._oFadeinEffect.clearEffect(true);
		}
		if(isShow) {
			// show할때 이벤트 등록
			this._oFloatingEffect.attach("afterEffect", function(){
				// Floating관련 이벤트 attach
				self._attachFloatingEvent();
				self._startHideTimer();
				self._fireEvent("show");
			});
		} else {
			if(this.option("nFadeOutDuration") !== 0) {
				this._oFloatingEffect.attach("afterEffect", function() {
					self._fireEvent("hide");
				});
			}
		}
	},

	/**
	 * @description Floating관련 이벤트를 해제한다.
	 */
	_detachFloatingEvent : function() {
		for(var p in this._htEvent) {
			var ht = this._htEvent[p];
			if (ht.ref) {
				ht.ref.detach(ht.el, p.substring(p.lastIndexOf("_")+1));
			}
		}
		this._oScrollEnd.detachAll("scrollEnd");
		this._htEvent = null;
	},

	/**
	 * @description  MobileCommentJindo.m.FloatingLayer 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this.deactivate();
		for(var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		delete this._htWElement;
		this._initFloatingData();
	}
}).extend(MobileCommentJindo.UIComponent);
/**
* @(#)MobileCommentJindo.m.LayerManager.js 2011. 6. 30.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sculove
* @since 2011. 6. 30.
* @description
*/
MobileCommentJindo.m.LayerManager = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.LayerManager.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class 특정 엘리먼트와 지정한 엘리먼트 그룹에서 발생한 이벤트에 따라 레이어를 보여주고 숨겨주는 컴포넌트
	 * @param {HTMLElement | String} el 숨기고자하는 레이어 엘리먼트 (혹은 id)
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
	 * @requires MobileCommentJindo.m.Touch
     */
	$init : function(el,htUserOption) {
		var oDeviceInfo = MobileCommentJindo.m.getDeviceInfo();
		this.option({
			bActivateOnload : true
		});
		this.option(htUserOption || {});
		this._initVar();
		this._setWrapperElement(el);
		if(this.option("bActivateOnload")) {
			this.activate();
		}
	},

	/**
	 * @description 인스턴스 변수를 초기화한다.
	 */
	_initVar: function() {
		this._aLink = [];
		this._oTouch = null;
	},

	/**
	 * @description MobileCommentJindo.m.LayerManager 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement: function(el) {
		this._htWElement = {};
		this.setLayer(el);
	},

	/**
	 * @description MobileCommentJindo.m.LayerManager 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this._attachEvent();
	},

	/**
  	 * @description MobileCommentJindo.m.LayerManager 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
	},

	/**
	 * 보여주고 숨겨줄 레이어 객체를 설정한다.
	 * @return {this}
	 */
	setLayer : function(el) {
		el = (typeof el == "string" ? MobileCommentJindo.$(el) : el);
		this._htWElement["element"] = MobileCommentJindo.$Element(el);
		this._htWElement["element"].css("position", "absolute");
		return this;
	},

	/**
	 * Layer가 보여지고 있는지 여부를 가져온다.
	 * @return {Boolean}
	 */
	getVisible: function(){
		return this._htWElement["element"].visible();
	},

	/**
	 * 보여주고 숨겨줄 레이어 객체를 가져온다.
	 * @return {HTMLElement}
	 */
	getLayer : function() {
		return this._htWElement["element"].$value();
	},

	/**
	 * link된 엘리먼트 배열을 가져온다.
	 * @return {Array}
	 */
	getLinks : function() {
		return this._aLink;
	},

	/**
	 * 생성자의 옵션으로 지정한 이벤트가 발생해도 레이어를 닫지 않게 할 엘리먼트를 지정한다
	 * @param {vElement} vElement 이벤트를 무시할 엘리먼트 또는 엘리먼트의 ID (인자를 여러개 주어서 다수 지정 가능)
	 * @return {this} 인스턴스 자신
	 * @example
	 *	o.link(MobileCommentJindo.$("one"), "two", oEl);
	 */
	link: function(vElement){
		if (arguments.length > 1) {
			for (var i = 0, len = arguments.length; i < len; i++) {
				this.link(arguments[i]);
			}
			return this;
		}
		if (this._find(vElement) != -1) {
			return this;
		}
		this._aLink.push(vElement);
		return this;
	},

	/**
	 * 생성자의 옵션으로 지정한 이벤트가 발생해도 레이어를 닫지 않게 할 엘리먼트 지정한 것을 제거한다
	 * @param {vElement} vElement 이벤트가 무시된 엘리먼트 또는 엘리먼트의 ID (인자를 여러개 주어서 다수 지정 가능)
	 * @return {this} 인스턴스 자신
	 * @example
	 *	o.unlink(MobileCommentJindo.$("one"), "two", oEl);
	 */
	unlink: function(vElement){
		if (arguments.length > 1) {
			for (var i = 0, len = arguments.length; i < len; i++) {
				this.unlink(arguments[i]);
			}
			return this;
		}
		var nIndex = this._find(vElement);
		if (nIndex > -1) {
			this._aLink.splice(nIndex, 1);
		}
		return this;
	},

	/**
	 * el에 발생한 이벤트를 무시할것인지를 결정
	 * @param {Object} el
	 * @return {Boolean} 무시할 경우 true, 무시하지 않을 경우 false
	 */
	_check: function(el){
		var wel = MobileCommentJindo.$Element(el);
		for (var i = 0, elLink, welLink; (elLink = this._aLink[i]); i++) {
			welLink = MobileCommentJindo.$Element(elLink);
			if (welLink) {
				elLink = welLink.$value();
				if (elLink && (el == elLink || wel.isChildOf(elLink))) {
					return true;
				}
			}
		}
		return false;
	},

	/**
	 * Link에 el이 포함되었는지 여부 확인
	 * @param {Object} el
	 * @return {Number} 포함된 index 반환, 없을시 -1
	 */
	_find: function(el){
		for (var i = 0, elLink; (elLink = this._aLink[i]); i++) {
			if (elLink == el) {
				return i;
			}
		}
		return -1;
	},

	/**
	 * beforeShow 사용자 이벤트 호출
	 */
	_fireEventBeforeShow : function() {
		return this.fireEvent("beforeShow", {
			elLayer : this.getLayer(),
			aLinkedElement : this.getLinks()
		});
	},

	/**
	 * show 사용자 이벤트 호출
	 */
	_fireEventShow : function() {
		this.fireEvent("show", {
			elLayer : this.getLayer(),
			aLinkedElement : this.getLinks()
		});
	},

	/**
	 * beforeHide 사용자 이벤트 호출
	 */
	_fireEventBeforeHide : function(el) {
		return this.fireEvent("beforeHide", {
			elTarget : el,
			elLayer : this.getLayer(),
			aLinkedElement : this.getLinks()
		});
	},

	/**
	 * hide 사용자 이벤트 호출
	 */
	_fireEventHide : function(el) {
		this.fireEvent("hide", {
			elTarget : el,
			elLayer : this.getLayer(),
			aLinkedElement : this.getLinks()
		});
	},

	/**
	 * 레이어를 보여준다.
	 * @return {this}
	 */
	show : function() {
		if (!this.getVisible()) {
			if (this._fireEventBeforeShow()) {
				this._htWElement["element"].show();
				this._fireEventShow();
			}
		}
		return this;
	},

	/**
	 * 레이어를 숨긴다.
	 * @param {HTMLElement} el. 이벤트의 타겟을 받는 엘리먼트
	 * @return {this}
	 */
	hide : function(el) {
		if (this.getVisible()) {
			if (this._fireEventBeforeHide(el)) {
				this._htWElement["element"].hide();
				this._fireEventHide(el);
			}
		}
		return this;
	},

	/**
	 * 레이어를 보여주거나 숨기도록 요청한다
	 * @return {this} 인스턴스 자신
	 */
	toggle: function(){
		if (this.getVisible()) {
			this.hide();
		} else {
			this.show();
		}
		return this;
	},

	/**
	 * 레이어의 이벤트를 처리한다.
	 * @param {Object} we
	 */
	_onEvent : function(we){
		var el = we.element;
		if (this.getVisible()) {
			if (this._check(el)) { // hide()수행중이 아니고 links 객체들 안에서 발생한거면 무시
				this.fireEvent("ignore", {
					elTarget : el
				});
			} else { //이벤트에 의해 hide()
				this.hide(el);
				return true;
			}
			we.stop();
		}
	},

	/**
	 * @description MobileCommentJindo.m.LayerManager 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		var self = this;
		this._oTouch = new MobileCommentJindo.m.Touch(document).attach("touchEnd", function(we) {
			if(we.sMoveType === MobileCommentJindo.m.MOVETYPE[3]) {
				self._onEvent(we);
			}
		});
	},

	/**
	 * @description MobileCommentJindo.m.LayerManager 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		if(this._oTouch) {
			this._oTouch.detachAll("touchEnd");
		}
	},

	/**
	 * @description MobileCommentJindo.m.LayerManager 객체를 release 시킨다.
	 */
	destroy: function() {
		this.deactivate();

		for(var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		this._htWElement = null;
		delete this._aLink;
		delete this._oTouch;
	}
}).extend(MobileCommentJindo.UIComponent);
/**
* @(#)MobileCommentJindo.m.CoreScroll.js 2011. 8. 18.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sculove
* @since 2011. 8. 18.
* @description
*/
MobileCommentJindo.m.Loading = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.Loading.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {Varient} el 기준이 되는 엘리먼트. null일 경우, 전체화면을 대상으로 로딩이 생성된다.
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
     */
	$init : function(el, htUserOption) {
		this.option({
			 bActivateOnload : true,
			 nWidth : 31,
			 nHeight : 31,
			 sDefaultForeground : "black",
			 sDefaultBackground : "transparent",
			 sLoadingText : "로딩중입니다",
			 bUseFoggy : el ? false : true,
			 sFoggyColor : "gray",
			 nFoggyOpacity : 0.3
		});
		this.option(htUserOption || {});
		this._setWrapperElement(el);
		if(this.option("bActivateOnload")) {
			this.activate();
		}
	},

	$static : {
		DELAY : ["0","-.9167s","-.833s","-.75s","-.667s","-.5833s","-.5s","-.41667s","-.333s","-.25s","-.1667s","-.0833s"],
		ANIMATION_STYLE : "_loading_animation_sytle_",
		CONTAINER_CLASS : "_loading_container_class_"
	},

	/**
	 * @description MobileCommentJindo.m.Loading 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
 	 * @param {Varient} el 엘리먼트를 가리키는 문자열이나, HTML엘리먼트
	 */
	_setWrapperElement: function(el) {
		this._htWElement = {};
		this._htWElement["base"] = MobileCommentJindo.$Element(MobileCommentJindo.$(el) ? MobileCommentJindo.$(el) : document.body);
		this._createLoading();
	},

	/**
	 * @description 로딩 생성
	 */
	_createLoading : function() {
		/**
		 *   container - foggy
		 *	                     - loadingbox - loading
		 *                                              - text
		*/
		this._createLoadingStyle();
		// Container 생성
		this._htWElement["container"] = MobileCommentJindo.$Element("<div style='zIndex: 1000'>")
				.addClass(MobileCommentJindo.m.Loading.CONTAINER_CLASS);
		// foggy 생성
		if(this.option("bUseFoggy")) {
			this._createFoggy().appendTo(this._htWElement["container"]);
		}
		// loadingbox 생성
		this._createLoadingElement();
		this._htWElement["loadingbox"] = MobileCommentJindo.$Element("<div>").css({
				"zIndex" : 1000,
				"position" : "absolute"
			}).append(this._htWElement["loading"]);
		// text 생성
		if(this.option("sLoadingText")) {
			this._createLoadingText().appendTo(this._htWElement["loadingbox"]);
		}
		this._htWElement["loadingbox"].appendTo(this._htWElement["container"]);
	},

	/**
	 * @description Foggy Layer 생성
	 */
	_createFoggy : function() {
		return this._htWElement["foggy"] = MobileCommentJindo.$Element("<div>").css({
				position : "absolute",
				padding : "0px",
				margin : "0px",
				border : "0px",
				backgroundColor : this.option("sFoggyColor"),
				opacity : this.option("nFoggyOpacity"),
				width : "100%",
				height : "100%",
				left : "0px",
				top : "0px",
				zIndex : 1000
		});
	},

	/**
	 * @description 위치를 지정한다.
	 */
	_setPosition : function() {
		var nWidth = this._htWElement["loadingbox"].width(),
			nHeight = this._htWElement["loadingbox"].height(),
			htScrollPosition;
		if(this._isBody()) {
			htScrollPosition = MobileCommentJindo.$Document().scrollPosition();
			this._htWElement["container"].css({
				"left" : htScrollPosition.left + "px",
				"top" : htScrollPosition.top + "px",
			});
			this._htWElement["container"].css({
				width : window.innerWidth + "px",
				height : window.innerHeight + "px"
			});
		} else {
			if(this._htWElement["container"].width() < nWidth) {
				this._htWElement["container"].width(nWidth);
			}
			if(this._htWElement["container"].height() < nHeight) {
				this._htWElement["container"].height(nHeight);
			}
		}
       this._htWElement["loadingbox"].css({
				"top" : "50%",
				"left" : "50%",
				"margin-left" : -parseInt(nWidth/2,10) + "px",
				"margin-top" : -parseInt(nHeight/2,10) + "px"
		});
	},

	_isBody : function() {
		return this._htWElement["base"].$value() === document.body;
	},

	/**
	 * @description Loading를 보여준다.
	 */
	show : function() {
		if(this.fireEvent("beforeShow")) {
			var aSpan = this._htWElement["loading"].queryAll("span"),
				sCssPrefix = MobileCommentJindo.m.getCssPrefix();
			for(var i=0; i<aSpan.length; i++) {
				MobileCommentJindo.$Element(aSpan[i]).css(sCssPrefix + "Animation", "loadingfade 1s linear " + MobileCommentJindo.m.Loading.DELAY[i] + " infinite");
			}
			this._attachEvent();
			this._htWElement["container"].show();
			this._setPosition();
			this.fireEvent("show");
		}
	},

	/**
	 * @description Loading를 감춘다.
	 */
	hide : function() {
		if(this.fireEvent("beforeHide")) {
			var aSpan = this._htWElement["loading"].queryAll("span"),
				sCssPrefix = MobileCommentJindo.m.getCssPrefix();
			for(var i=0; i<aSpan.length; i++) {
				MobileCommentJindo.$Element(aSpan[i]).css(sCssPrefix + "Animation", "");
			}
			this._detachEvent();
			this._htWElement["container"].hide();
			this.fireEvent("hide");
		}
	},

	/**
	 * @description 스크롤 방지를 위한 것
	 * @param {MobileCommentJindo.$Event} 진도 이벤트
	 */
	_onPrevent : function(we) {
		we.stop(MobileCommentJindo.$Event.CANCEL_ALL);
		return false;
	},

	/**
	 * @description 모바일 기기 방향 전환시 조절
	 * @param {MobileCommentJindo.$Event} 진도 이벤트
	 */
	_onRotate : function(we) {
		if(this._htWElement["container"].visible()) {
			/**
			 * ios인 경우, 가로에서 세로로 화면 회전시 마크업이 축소되어 있는 상태가 발생함.
			 * 이에 대한 처리를 해줌
			 */
			if(MobileCommentJindo.m.getDeviceInfo().andorid) {
				this._setPosition();
			} else {
				this._htWElement["container"].hide();
				var self=this;
				setTimeout(function(){
					self._htWElement["container"].show();
					self._setPosition();
				},0);
			}
		}
	},

	/**
	 * @description 이벤트 bind
	 */
	_attachEvent : function() {
		this._htEvent["rotate"] = MobileCommentJindo.$Fn(this._onRotate, this).bind();
		this._htEvent["prevent"] = MobileCommentJindo.$Fn(this._onPrevent, this)
			.attach(this._htWElement["container"],"touchstart")
			.attach(this._htWElement["container"],"touchmove");
		if(this._isBody()) {
			this._htEvent["prevent"].attach(document.body,"touchstart");
		}
		MobileCommentJindo.m.bindRotate(this._htEvent["rotate"]);
	},

	/**
	 * @description 이벤트 unbind
	 */
	_detachEvent : function() {
		if(this._htEvent["prevent"]) {
			this._htEvent["prevent"].detach(this._htWElement["container"], "touchmove")
				.detach(this._htWElement["container"],"touchstart");
			if(this._isBody()) {
				this._htEvent["prevent"].detach(document.body, "touchstart");
			}
		}
		MobileCommentJindo.m.unbindRotate(this._htEvent["rotate"]);
	},

	/**
	 * @description animation-keyframe을 사용하기 위한 설정
	 */
	_createLoadingStyle : function() {
		if(!MobileCommentJindo.$(MobileCommentJindo.m.Loading.ANIMATION_STYLE)) {
			var elStyle = MobileCommentJindo.$("<style id='" + MobileCommentJindo.m.Loading.ANIMATION_STYLE + "' type='text/css'></style>");
			document.getElementsByTagName("head")[0].appendChild(elStyle);
			elStyle.sheet.insertRule("@-webkit-keyframes loadingfade{from{opacity:1}to{opacity:0}}",0);
		}
	},

	/**
	 * @description Loading  구성요소 설정
	 */
	_createLoadingElement : function() {
			var sCssPrefix = MobileCommentJindo.m.getCssPrefix(),
				aHtml = [];
			for(var i=0; i<12; i++) {
				aHtml.push("<span style='display:block;position:absolute;top:40%;left:48%;width:11%;height:24%;border-radius:6px;background:");
				aHtml.push(this.option("sDefaultForeground"));
				aHtml.push("; opacity:0; -");
				aHtml.push(sCssPrefix);
				aHtml.push("-transform:rotate(");
				aHtml.push(i * 30);
				aHtml.push("deg) translate(0,-140%);'></span>");
			}
			this._htWElement["loading"] = MobileCommentJindo.$Element("<div>").css({
				"position" : "relative",
				"margin" : "0 auto"
			}).html(aHtml.join(""));
	},

	/**
	 * @description 지정한 옵션값을 갱신한다.
	 */
	refresh : function() {
		this._htWElement["loading"].css({
			"width" : this.option("nWidth") + "px",
			"height" : this.option("nHeight") + "px",
			"background" : this.option("sDefaultBackground")
		});
		if(this._htWElement["text"]) {
			this._htWElement["text"].html(this.option("sLoadingText"));
		}
	},

	/**
	 * @description 텍스트 모듈을 만듦
	 */
	_createLoadingText : function() {
		return this._htWElement["text"] = MobileCommentJindo.$Element("<div>").css({
			"margin" : "2px 0 0 0",
			"bottom" : 0,
			"width" : "100%",
			"text-align" : "center"
		});
	},

	/**
	 * @description MobileCommentJindo.m.Loading 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this._htEvent = {};
		this._htWElement["container"].appendTo(this._htWElement["base"]);
		if(this._isBody()) {
			this._htWElement["container"].css({
				"position" : "absolute",
				"top" : 0,
				"left" : 0,
				"width" : "100%",
				"height" : "100%"
			}).hide();
		} else {
			this._htWElement["container"].css({
				"position" : "relative"
			}).hide();
		}
		this.refresh();
	},

	/**
	 * @description MobileCommentJindo.m.Loading 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
		this._htWElement["container"].leave();
	},

	/**
	 * @description  MobileCommentJindo.m.Loading 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this.deactivate();
		for(var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		this._htWElement = null;
	}
}).extend(MobileCommentJindo.UIComponent);
/**
* @(#)MobileCommentJindo.m.MoreContentButton.js 2011. 7. 20.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author "oyang2"
* @since 2011. 7. 20.
* @description
*/

MobileCommentJindo.m.MoreContentButton = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.MoreContentButton.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {HTMLElement|String} sId 더보기 컴포넌트 기준 엘리먼트 아이디 혹은 엘리먼트
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.m.CorePagination
     */
	$init : function(el, htUserOption) {
		this.option({
			sClassPrefix : 'more_',
			nTotalItem : 10, //실제 아이템 개수
			nShowMaxItem : 10, //최대 더보기 하여 보여줄 개수
			nItemPerPage : 10,
			nPage : 1,
			bActivateOnload : true,
			htAjax : {}
		});

		this.option(htUserOption || {});
		this.option('nItem', this.option('nShowMaxItem'));

		this._initVar();
		this._setWrapperElement(el);

		if(this.option("bActivateOnload")) {
			this.activate();
			this._nCurrentPage = this.option('nPage');
		}
	},

	/**
	 * @description MobileCommentJindo.m.MoreContentButton 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar: function() {
		//this._nCurrentPage = this.option('nPage');
		var _htDefalutAjax = {
			sApi : null,
			htAjaxOption : {
				type: 'xhr'
			},
			htQuery : {},
			sStart : 'start',
			sDisplay : 'display'
		};

		var htAjax = this.option('htAjax');

		if(!htAjax){
			this.option('htAjax', _htDefalutAjax);
			return;
		}

		for(var p in _htDefalutAjax){
			if(typeof htAjax[p] == 'undefined'){
				htAjax[p] = _htDefalutAjax[p];
			}
		}

		//ajax option
		for(var p in _htDefalutAjax.htAjaxOption){
			if(typeof htAjax.htAjaxOption[p] == 'undefined'){
				htAjax.htAjaxOption[p] = _htDefalutAjax.htAjaxOption[p];
			}
		}

		//query string option
		for(var p in _htDefalutAjax.htQuery){
			if(typeof htAjax.htQuery[p]== 'undefined'){
				htAjax.htQuery[p] = _htDefalutAjax.htQuery[p];
			}
		}

		if(!!htAjax.sApi){
			//htAjax.htAjaxOption.onload = this._onAjaxResponse;
			this.oAjax = new MobileCommentJindo.$Ajax(htAjax.sApi, htAjax.htAjaxOption);
		}
	},

	/**
	 * @description MobileCommentJindo.m.MoreContentButton 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement: function(el) {
		this._htWElement = {};
		el = MobileCommentJindo.$(el);

		var sClass = '.'+ this.option('sClassPrefix');
		this._htWElement.elBase = MobileCommentJindo.$Element(el);

		this._htWElement.elMoreButton = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle(sClass+'button',el));
		this._htWElement.elTop = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle(sClass+'top',el));
		this._htWElement.elLoading = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle(sClass+'loading',el));
		this._htWElement.elMoreCnt = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle(sClass+'moreCnt', el)); //
		this._htWElement.elTotal = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle(sClass+'total',el));
		this._htWElement.elCurrent = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle(sClass+'current', el));
		this._htWElement.elLast = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle(sClass+'last', el));
		if(!!this._htWElement.elLast){
			this._htWElement.elLastTotal = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle(sClass+'total', this._htWElement.elLast.$value()));
			this._htWElement.elLastCurrent = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle(sClass+'current', this._htWElement.elLast.$value()));
		}
	},

	_onClickMore : function(oEvent){
		oEvent.stop(MobileCommentJindo.$Event.CANCEL_DEFAULT);
		if(this.hasNextPage()){
			this.more();
		}
	},

	_onClickTop : function(oEvent){
		oEvent.stop(MobileCommentJindo.$Event.CANCEL_DEFAULT);

		this.fireEvent('goTop',{
			element : oEvent.element
		});
	},


	more : function(bFireEvent){
		if (typeof bFireEvent == "undefined") {
			bFireEvent = true;
		}

		var nPage = this._nCurrentPage +1;

		var nBeforePage = this.getCurrentPage();
		if(bFireEvent){
			if(!this.fireEvent('beforeMore',{
				nPage : nPage,
				nCurrentPage : nBeforePage
			})){
				return;
			}
		}

		this.showLoadingImg();

		if(!!this.option('htAjax').sApi){
			this._callAjax(nPage,true, bFireEvent);
		}else{
			this._move(nPage);
			var htIndex = this.getPageItemIndex(nPage);

			if(bFireEvent){
				this.fireEvent('more',{
					nPage : nPage,
					nStartIndex : htIndex.nStart,
					nEndIndex : htIndex.nEnd
				});
			}

			this.updateInfo();
		}
	},

	/**
	 * nPage 페이지로 이동한다.
	 * @param {Number} nPage
	 * @param {Boolean} 커스텀 이벤트 발생 여부
	 * @description
	 */
	movePageTo : function(nPage, bFireEvent){
		if (typeof bFireEvent == "undefined") {
			bFireEvent = true;
		}

		var nBeforePage = this.getCurrentPage();
		if(bFireEvent){
			if(!this.fireEvent('beforeMovePage',{
				nPage : nPage,
				nCurrentPage : nBeforePage
			})){
				return;
			}
		}

		this.showLoadingImg();

		if(!!this.option('htAjax').sApi){
			this._callAjax(nPage, false ,bFireEvent);
		}else{
			this._move(nPage);
			var htIndex = this.getPageItemIndex(nPage);

			if(bFireEvent){
				this.fireEvent('movePage',{
					nPage : nPage,
					nBeforePage : nBeforePage,
					nStartIndex : 0,
					nEndIndex : htIndex.nEnd
				});
			}
			this.updateInfo();
		}
	},

	_move : function(nPage){
		var n = this._convertToAvailPage(nPage);
		if(n != this._nCurrentPage){
			this._nCurrentPage = n;
		}

	},

	/**
	 * @description 더보기 영역을 현재 페이지에 맞게 정보들을 설정한다.
	 */
	updateInfo : function(){
		var nPage = this.getCurrentPage();

		var htIndex = this.getPageItemIndex(nPage);

		this.hideLoadingImg();

		if(nPage >= this.getTotalPages() ){
			this._htWElement.elBase.addClass('u_pg_end');
			this._htWElement.elMoreButton.hide();
			this._htWElement.elLast.show('block');
		}else{
			this._htWElement.elBase.removeClass('u_pg_end');
			this._htWElement.elMoreButton.show('block');
			this._htWElement.elLast.hide();
		}

		if(!!this._htWElement.elCurrent){
			var sText = htIndex.nEnd+1;
			this._htWElement.elCurrent.text(this._setNumberFormat(sText));
		}

		if(typeof this._htWElement.elLastCurrent != 'undefined'){
			this._htWElement.elLastCurrent.text(this._setNumberFormat(htIndex.nEnd+1));
		}

		if(!!this._htWElement.elTotal){
			this._htWElement.elTotal.text(this._setNumberFormat(this.option('nTotalItem')));
		}
		if(typeof this._htWElement.elLastTotal != 'undefined'){
			this._htWElement.elLastTotal.text(this._setNumberFormat(this.option('nTotalItem')));
		}

		if(!!this._htWElement.elMoreCnt){
			var nCnt = Math.min(this.getItemPerPage(), this.getItemCount() - htIndex.nEnd-1);
			this._htWElement.elMoreCnt.text(this._setNumberFormat(nCnt));
		}

	},

	_callAjax : function(nPage, bMore ,bFireEvent){
		var self = this;
		this.oAjax.option('onload', null);

		this.oAjax.option('onload', function(res){
			self._onAjaxResponse(res, nPage, bMore, bFireEvent);
		});

		this.oAjax.request(this._getQueryString(nPage, bMore));
	},

	_onAjaxResponse : function(oResponse, nPage, bMore, bFireEvent){
		if(bFireEvent){
			this._move(nPage);
			var sEvent = bMore? 'more' : 'movePage';

			var htIndex = this.getPageItemIndex(nPage);

			this.fireEvent(sEvent,{
				oResponse : oResponse,
				nPage : nPage,
				nStartIndex : bMore? htIndex.nStart : 0,
				nEndIndex : htIndex.nEnd
			});
		}

		this.updateInfo();
	},

	_getQueryString : function(nPage, bMore){
		if(typeof bMore === 'undefined'){
			bMore = true;
		}
		var htQuery = this.option('htAjax').htQuery || {};

		var htIndex = this.getPageItemIndex(nPage);

		htQuery[this.option('htAjax').sStart] = bMore? htIndex.nStart : 0;
		htQuery[this.option('htAjax').sDisplay] = Math.min(this.getItemPerPage(), (this.getShowMaxItem() - htIndex.nStart));

		return htQuery;

	},

	_setNumberFormat: function(sText) {
		sText = sText.toString();
		var sReturn = "";
		var nDot = 0;
		var nLastPosition = sText.length;
		for (var i = nLastPosition; i >= 0; i--) {
			var sChar = sText.charAt(i);
			if (i > nLastPosition) {
				sReturn = sChar + sReturn;
				continue;
			}
			if (/[0-9]/.test(sChar)) {
				if (nDot >= 3) {
					sReturn = ',' + sReturn;
					nDot = 0;
				}
				nDot++;
				sReturn = sChar + sReturn;
			}
		}
		return sReturn;
	},

	/**
	 * @description 로딩이미지를 보여준다
	 */
	showLoadingImg : function(){
		if(!!this._htWElement.elLoading){
			this._htWElement.elLoading.show();
		}
	},

	/**
	 * @description 로딩이미지를 감춘다
	 */
	hideLoadingImg : function(){
		if(!!this._htWElement.elLoading){
			this._htWElement.elLoading.hide();
		}
	},

	/**
	 * @param {Number} nShowMaxItem 더보기할 아이템의 개수가 바뀌었을 경우 설정해준다.
	 * @description 1페이지로 더보기를 다시 그린다. 커스텀이벤트는 발생하지 않는다.
	 */
	reset : function(nShowMaxItem){
		if (typeof nShowMaxItem == "undefined") {
			nShowMaxItem = this.option('nShowMaxItem');
		}

		this.setShowMaxItem(nShowMaxItem);
		this.movePageTo(1, false);
	},
	/**
	 * @return {Number}
	 * @description 전체 아이템 개수를 구한다.
	 */
	getTotalItem : function(){
		return this.option('nTotalItem');
	},

	/**
	 * @param {Number} n
	 * @description 전체 아이템 개수를 n으로 설정한다.
	 */
	setTotalItem : function(n){
		this.option('nTotalItem', n);
	},

	/**
	 * @return {Number}
	 * @description  더보기 할 전체 아이템 개수를 구한다.
	 */
	getShowMaxItem : function(){
		return this.option('nShowMaxItem');
	},

	/**
	 * @param {Number} n
	 * @description 더보기할 전체 아이템 개수를 n으로 설정한다.
	 */
	setShowMaxItem : function(n){
		this.option('nShowMaxItem', n);
		this.option('nItem', n);
	},

	/**
	 * @description MobileCommentJindo.m.MoreContentButton 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this._attachEvent();
	},

	/**
	 * @description MobileCommentJindo.m.MoreContentButton 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
	},

	/**
	 * @description MobileCommentJindo.m.MoreContentButton 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};
		if(!!this._htWElement.elMoreButton){
			this._htEvent["click_More"] = {
				ref : MobileCommentJindo.$Fn(this._onClickMore, this).attach(this._htWElement.elMoreButton, 'click'),
				el : this._htWElement.elMoreButton.$value()
			};
		}
		if(!!this._htWElement.elTop){
			this._htEvent["click_Top"] = {
				ref : MobileCommentJindo.$Fn(this._onClickTop, this).attach(this._htWElement.elTop, 'click'),
				el : this._htWElement.elTop.$value()
			};
		}
	},

	/**
	 * @description MobileCommentJindo.m.MoreContentButton 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		for(var p in this._htEvent) {
			var htTargetEvent = this._htEvent[p];
			htTargetEvent.ref.detach(htTargetEvent.el, p.substring(0, p.indexOf("_")));
		}

		this._htEvent = null;
	},

	/**
	 * @description MobileCommentJindo.$Ajax Header 값을 설정한다.
	 * http://MobileCommentJindo.nhncorp.com/docs/jindo/archive/Jindo2-latest/ko/symbols/%24Ajax.html#header 참조
	 */
	header : function(vName, vValue) {
		if(this.oAjax) {
			return this.oAjax.header(vName, vValue);
		}
	},

	/**
	 * @description  MobileCommentJindo.m.MoreContentButton 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this._detachEvent();

		for(var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		this._htWElement = null;
	}
}).extend(MobileCommentJindo.m.CorePagination);
/**
* @(#)MobileCommentJindo.m.PageNavigation.js 2011. 7. 22.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author "oyang2"
* @since 2011. 7. 22.
* @description
*/

MobileCommentJindo.m.PageNavigation = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.PageNavigation.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.m.CorePagination
     */
	$init : function(el, htUserOption) {
		this.option({
			sClassPrefix : 'page_',
			nItem : 10, //아이템 개수
			nItemPerPage : 10,
			nPage : 1,
			bActivateOnload : true,
			sInfoTemplate : '{=PAGE} / {=TOTALPAGE}',
			htAjax : {}
		});
		this.option(htUserOption || {});
		this._initVar();
		this._setWrapperElement(el);

		if(this.option("bActivateOnload")) {
			this.activate();
			this._nCurrentPage = this.option('nPage');
		}
	},
	/**
	 * @description MobileCommentJindo.m.MoreContentButton 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar: function() {
		var _htDefalutAjax = {
			sApi : null,
			htAjaxOption : {
				type: 'xhr'
			},
			htQuery : {},
			sPage : 'page',
			sDisplay : 'display'
		};

		var htAjax = this.option('htAjax');

		if(!htAjax){
			this.option('htAjax', _htDefalutAjax);
			return;
		}

		for(var p in _htDefalutAjax){
			if(typeof htAjax[p] == 'undefined'){
				htAjax[p] = _htDefalutAjax[p];
			}
		}

			//ajax option
		for(var p in _htDefalutAjax.htAjaxOption){
			if(typeof htAjax.htAjaxOption[p] == 'undefined'){
				htAjax.htAjaxOption[p] = _htDefalutAjax.htAjaxOption[p];
			}
		}

		//query string option
		for(var p in _htDefalutAjax.htQuery){
			if(typeof htAjax.htQuery[p]== 'undefined'){
				htAjax.htQuery[p] = _htDefalutAjax.htQuery[p];
			}
		}

		if(!!htAjax.sApi){
			this.oAjax = new MobileCommentJindo.$Ajax(htAjax.sApi, htAjax.htAjaxOption);
		}

	},

	/**
	 * @description MobileCommentJindo.m.PageNavigation 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement: function(el) {
		this._htWElement = {};
		el = MobileCommentJindo.$(el);
		var sClass = '.'+this.option('sClassPrefix');

		this._htWElement.elBase = MobileCommentJindo.$Element(el);

		this._htWElement.elPrev = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle(sClass+'prev', el));
		this._htWElement.elNext = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle(sClass+'next', el));
		this._htWElement.elPrevOff = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle(sClass+'prev-off', el));
		this._htWElement.elNextOff = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle(sClass+'next-off', el));
		this._htWElement.elInfo = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle(sClass+'info', el));

	},

	_onClickPrev : function(oEvent){
		oEvent.stop();
		if(!this.hasPreviousPage()) {return;}

		var nPage = this.getCurrentPage();
		this.movePageTo(nPage-1);

	},

	_onClickNext : function(oEvent){
		oEvent.stop();
		if(!this.hasNextPage()) {return;}

		var nPage = this.getCurrentPage();
		this.movePageTo(nPage+1);
	},

	/**
	 * @description n 페이지로 이동합니다.
	 * @param {Number} n
	 * @param {Boolean} 커스텀 이벤트 발생 여부
	 */
	movePageTo : function(n, bFireEvent){
		if(typeof bFireEvent == 'undefined'){
			bFireEvent = true;
		}

		if(bFireEvent){
			if(!this._fireEventBefore(n)){ return;}
		}

		if(!!this.option('htAjax').sApi){
			this._callAjax(n, bFireEvent);
		}else{
			this._move(n);
			if(bFireEvent){
				this._fireEventEnd();
			}
			this.updateInfo();
			this.updateNavigation();
		}

	},

	_move : function(n){
		var nPage = this._convertToAvailPage(n);
		if(nPage != this._nCurrentPage){
			this._nCurrentPage = nPage;
		}
	},

	_callAjax : function(nPage, bFireEvent){

		var self = this;
		this.oAjax.option('onload', null);

		this.oAjax.option('onload', function(res){
			self._onAjaxResponse(res, nPage ,bFireEvent);
		});
		this.oAjax.request(this._getQueryString(nPage));

	},

	_fireEventBefore : function(nPage){
		return this.fireEvent('beforeMove', {
			nPage : nPage,
			nCurrentPage: this.getCurrentPage()
		});
	},

	_fireEventEnd : function(oResponse){
		if(typeof oResponse == 'undefined'){
			oResponse = null;
		}
		var nPage = this.getCurrentPage();
		var htIndex = this.getPageItemIndex(nPage);

		return this.fireEvent('move',{
			nPage : this.getCurrentPage(),
			nStartIndex : htIndex.nStart,
			nEndIndex : htIndex.nEnd,
			oResponse : oResponse
		});
	},

	_onAjaxResponse : function(oResponse, nPage, bFireEvent){
		this._move(nPage);

		if(bFireEvent){
			this._fireEventEnd(oResponse);
		}

		this.updateInfo();
		this.updateNavigation();
	},

	_getQueryString : function(n){
		var htQuery = this.option('htAjax').htQuery || {};
		var htIndex = this.getPageItemIndex(n);

		htQuery[this.option('htAjax').sPage] = n;
		htQuery[this.option('htAjax').sDisplay] = Math.min(this.getItemPerPage(), (this.getItemCount() - htIndex.nStart));

		return htQuery;
	},

	/**
	 * @description 현재페이지에 맞게 정보 영역을 업데이트 합니다.
	 */
	updateInfo : function(){
		if(!this._htWElement.elInfo){ return;}

		var nPage = this.getCurrentPage();
		var htIndex = this.getPageItemIndex(nPage);

		var sText = this.option('sInfoTemplate').replace(/\{=PAGE\}/,nPage).replace(/\{=TOTALPAGE\}/, this.getTotalPages())
		.replace(/\{=ITEMCOUT\}/, this.option('nItem')).replace(/\{=STARTINDEX\}/,htIndex.nStart+1).replace(/\{=ENDINDEX\}/,htIndex.nEnd+1);

		this._htWElement.elInfo.html(sText);
	},

	/**
	 * @description 현재페이지에 맞게 이전, 이후 링크 정보를 업데이트 합니다.
	 */
	updateNavigation : function(){
		var nPage = this.getCurrentPage();

		if(!!this._htWElement.elPrev) {this._htWElement.elPrev.hide();}
		if(!!this._htWElement.elNext) {this._htWElement.elNext.hide();}
		if(this._htWElement.elPrevOff) {this._htWElement.elPrevOff.hide();}
		if(this._htWElement.elNextOff) {this._htWElement.elNextOff.hide();}

		if(this.getTotalPages() == 1){
			return;
		}

		if(nPage == 1){
			if(!!this._htWElement.elPrevOff) {this._htWElement.elPrevOff.show('inline-block');}
			if(!!this._htWElement.elNext){this._htWElement.elNext.show('inline-block');}
		}else if (nPage == this.getTotalPages()){
			if(!!this._htWElement.elNextOff){this._htWElement.elNextOff.show('inline-block');}
			if(!!this._htWElement.elPrev){this._htWElement.elPrev.show('inline-block');}
		}else{
			if(!!this._htWElement.elPrev){this._htWElement.elPrev.show('inline-block');}
			if(!!this._htWElement.elNext){this._htWElement.elNext.show('inline-block');}
		}

	},

	/**
	 * @param {Number} nItem 아이템의 개수가 바뀌었을 경우 설정해준다.
	 * @description 1페이지로 더보기를 다시 그린다. 커스텀이벤트는 발생하지 않는다.
	 */
	reset : function(nItem){
		if (typeof nItem == "undefined") {
			nItem = this.option('nItem');
		}

		this.setItemCount(nItem);
		this.movePageTo(1, false);
	},

	/**
	 * @description MobileCommentJindo.m.PageNavigation 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this._attachEvent();
	},

	/**
	 * @description MobileCommentJindo.m.PageNavigation 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
	},

	/**
	 * @description MobileCommentJindo.m.PageNavigation 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};
		if(!!this._htWElement.elNext){
			this._htEvent["click_Next"] = {
				ref : MobileCommentJindo.$Fn(this._onClickNext, this).attach(this._htWElement.elNext, 'click'),
				el : this._htWElement.elNext.$value()
			};
		}
		if(!!this._htWElement.elPrev){
			this._htEvent["click_Prev"] = {
				ref : MobileCommentJindo.$Fn(this._onClickPrev, this).attach(this._htWElement.elPrev, 'click'),
				el : this._htWElement.elPrev.$value()
			};
		}

	},

	/**
	 * @description MobileCommentJindo.m.PageNavigation 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		for(var p in this._htEvent) {
			var htTargetEvent = this._htEvent[p];
			htTargetEvent.ref.detach(htTargetEvent.el, p.substring(0, p.indexOf("_")));
		}
		this._htEvent = null;
	},

	/**
	 * @description  MobileCommentJindo.m.PageNavigation 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this.deactivate();

		for(var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		this._htWElement = null;
	}
}).extend(MobileCommentJindo.m.CorePagination);
/**
* @(#)MobileCommentJindo.m.PreventClickEvent.js 2012. 2. 6.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sculove
* @since 2012. 2. 6
* @description
*/
MobileCommentJindo.m.PreventClickEvent = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.PreventClickEvent.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
     */
	$init : function(el, htUserOption) {
		this.option({
			 bActivateOnload : true,
			 sClassPrefix : "evt-"
		});
		this.option(htUserOption || {});
		this._setWrapperElement(el);
		if(this.option("bActivateOnload")) {
			this.activate();
		}
	},

	/**
	 * @description MobileCommentJindo.m.PreventClickEvent 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement: function(el) {
		this._htWElement = {};
		this._htWElement["target"] = MobileCommentJindo.$Element(el);
	},

	/**
	 * @description MobileCommentJindo.m.PreventClickEvent 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function(){
		this._detachEvents();
	},

	/**
	 * @description MobileCommentJindo.m.PreventClickEvent 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function(){
		this._attachEvents();
	},

	/**
	 * @description MobileCommentJindo.m.PreventClickEvent 사용하는 이벤트 attach 한다
	 */
	_attachEvents : function(){
		this._htEvent ={};
		this._htEvent["prevent"] = MobileCommentJindo.$Fn(this._onPrevent, this).attach(this._htWElement["target"], "touchstart");
	},


	/**
	 * @description MobileCommentJindo.m.PreventClickEvent 사용하는 이벤트 detach 한다
	 */
	_detachEvents : function(){
		this._htEvent["prevent"].detach(this._htWElement["target"], "touchstart");
		this._htEvent["prevent"] = null;
	},

	/**
	 * @description 이벤트 방지 모듈
	 */
	_onPrevent : function(we) {
		var wel = MobileCommentJindo.$Element(MobileCommentJindo.m.getNodeElement(we.element));
		if(!wel.hasClass(this.option("sClassPrefix") + "except")) {
			we.stop(MobileCommentJindo.$Event.CANCEL_ALL);
			this.fireEvent("prevent", {
				wel : wel
			});
			return false;
		} else {
			this.fireEvent("pass", {
				wel : wel
			});
		}
	},

	/**
	 * @description  MobileCommentJindo.m.PreventClickEvent 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this.deactivate();
		for(var p in this._htWElement) {
			console.log(p);
			this._htWElement[p] = null;
		}
		this._htWElement = null;
		this._htEvent = null;
	}
}).extend(MobileCommentJindo.UIComponent);

/**
* @(#)MobileCommentJindo.m.RadioButton.js 2011. 9. 19.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sshyun
* @since 2011. 9. 19.
* @description
*/
MobileCommentJindo.m.RadioButton = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.RadioButton.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {Varient} el Checkbox Layout Wrapper
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.m.CheckRadioCore
	 */
	$init : function(el, htUserOption) {
		this.option({
			sClassPrefix	: "frb-",
			sType			: "v",
			bActivateOnload : true,
			sUncheckBgColor : "transparent"
		});
		this.option(htUserOption || {});
		this._initVar();
		this._setWrapperElement(el, this.option("sClassPrefix"));
		this._initRadioLoad();
		if(this.option("bActivateOnload")) {
			this.activate();
		}
	},

	/**
	 * @description MobileCommentJindo.m.RadioButton 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar : function() {
		this.$super._initVar("radio", "radiobtn");
		this._nPreSelectIdx = -1;
	},
	/**
	 * @description 초기 radio button 체크 여부 확인.
	 */
	_initRadioLoad : function(){
		var aRadioBtnList = this._aWElFormList;
		for ( var i = 0; i < aRadioBtnList.length; i++) {
			if(aRadioBtnList[i].$value().checked){
				this._setChecked(i);
				break;
			}
		}
	},

	_afterCheck : function(welElement, bClickOverForm){
		var nIdx = -1;
		nIdx = this._htWElement["container"].indexOf(welElement);
		this._setChecked(nIdx);
	},

	/**
	 * @description CheckBox/RadioButton 에서 Click 이벤트 처리.
	 * @param {Object} we 이벤트 객체.
	 */
	_onFormClick : function(we){
		var sClassName = this._sUnitClass;
		var welElement = MobileCommentJindo.$Element(we.element);
		welElement = welElement.parent(function(v){
			return v.hasClass(sClassName);
		})[0];
		var sChecked = welElement.attr("data-cb-checked");
		we.element.checked = (sChecked && sChecked == "on") ? true : false;
		nIdx = this._htWElement["container"].indexOf(welElement);
		if(we.element.checked){
			if(this._nPreSelectIdx != nIdx){
				this._onCheck(we);
			}
		}
	},

	/**
	 * @description 체크여부 설정 처리.
	 * @param {Number} nIdx 체크할 RadioButton index
	 */
	_setChecked : function(nIdx){
		var elCurrentRadioBtn = this._aWElFormList[nIdx].$value();
		var welCurrentRadioUnit = this._aWElUnitList[nIdx];
		if(elCurrentRadioBtn.disabled){
			return false;
		}
		var sBgColor = this.option("sCheckBgColor");
		var elPreRadioUnit = null;
		var elPreRadioBtn = null;
		// 이전 index RadioButton 선택 해제
		if(this._nPreSelectIdx > -1){
			sBgColor = (sBgColor) ? this.option("sUncheckBgColor") : null;
			elPreRadioUnit = this._aWElUnitList[this._nPreSelectIdx].$value();
			elPreRadioBtn = this._aWElFormList[this._nPreSelectIdx].$value();
			this._aWElUnitList[this._nPreSelectIdx].removeClass(this._sOnClass);
			elPreRadioBtn.checked = false;
			if(sBgColor){
				this._aWElUnitList[this._nPreSelectIdx].css("backgroundColor", sBgColor + " !important");
			}
		}

		welCurrentRadioUnit.addClass(this._sOnClass);
		welCurrentRadioUnit.attr("data-cb-checked","on");
		elCurrentRadioBtn.checked = true;
		sBgColor = this.option("sCheckBgColor");
		if(sBgColor){
			welCurrentRadioUnit.css("backgroundColor", sBgColor + " !important");
		}
		this._nPreSelectIdx = nIdx;

		this.fireEvent("checked", {
			elPreRadioButtonUnit : elPreRadioUnit,
			elPreRadioButton : elPreRadioBtn,
			elRadioButtonUnit : welCurrentRadioUnit.$value(),
			elRadioButton : elCurrentRadioBtn
		});
	},
	/**
	 * @description check 된 항목값을 반환한다.
	 * @return {String} 체크된 RadioButton value 값.
	 * @example
	 *  var sValue = oRadioButton.getCheckedValue();
	 *  alert(sValue);
	 */
	getCheckedValue : function(){
		var sValue = "";
		if(this._nPreSelectIdx > -1){
			if(!this._aWElFormList[this._nPreSelectIdx].$value().disabled){
				sValue = this._aWElFormList[this._nPreSelectIdx].$value().value;
			}
		}
		return sValue;
	},
	/**
	 * @description 입력한 RadioButton 엘리먼트를 선택 / 선택해제 시킨다.
	 * @param {Variant} vElement 체크를 설정할 checkbox Element.
	 * RadioButton input 엘리먼트 또는 RadioButton Unit 엘리먼트  엘리먼트가 입력 될수 있다.
	 * @example
	 * * // 선택시
	 * oRadioButton.setCheckedButton(MobileCommentJindo.$("unit1"));
	 *
	 */
	setCheckedButton : function(vElement){
		var aIdx = this._getFormIdx(vElement);
		if(aIdx.length > 0)	{this._setChecked(aIdx[0]);}
	},
	/**
	 * @description RadioButton 를 활성화 시킨다.
	 * @param {Variant} vElement 활성화 할 RadioButton Element.
	 * RadioButton input 엘리먼트 배열 또는 RadioButton Unit 엘리먼트 배열 또는 단일 엘리먼트가 입력 될수 있고,
	 * 입력값이 없을시 모든 체크박스 엘리먼트가 기준이 된다.
	 * @example
	 * // 배열 활성화
	 * oRadioButton.enable([MobileCommentJindo.$("unit1"),MobileCommentJindo.$("unit2")]);
	 * // 단일 활성화
	 * oRadioButton.enable(MobileCommentJindo.$("unit1"));
	 * // 전체 활성화
	 * oRadioButton.enable();
	 *
	 */
	enable : function(vElement){
		var htElForm = this._useSettingForm(vElement, true);

		this.fireEvent("enable", {
			aRadioButtonList: htElForm.aFormList,
			aRadioButtonUnitList: htElForm.aUnitList
		});
	},
	/**
	 * @description RadioButton 를 비활성화 시킨다.
	 * @param {Variant} vElement 비활성화 할 RadioButton Element.
	 * RadioButton input 엘리먼트 배열 또는 RadioButton Unit 엘리먼트 배열 또는 단일 엘리먼트가 입력 될수 있고,
	 * 입력값이 없을시 모든 체크박스 엘리먼트가 기준이 된다.
	 * @example
	 * // 배열 비활성화
	 * oRadioButton.disable([MobileCommentJindo.$("unit1"),MobileCommentJindo.$("unit2")]);
	 * // 단일 비활성화
	 * oRadioButton.disable(MobileCommentJindo.$("unit1"));
	 * // 전체 비활성화
	 * oRadioButton.disable();
	 */
	disable : function(vElement){
		var htElForm = this._useSettingForm(vElement, false);

		this.fireEvent("disable", {
			aRadioButtonList: htElForm.aFormList,
			aRadioButtonUnitList: htElForm.aUnitList
		});
	},
	/**
	 * @description index 번호로 RadioButton Element 를 반환한다.
	 * @param {Number} nIdx 가져올 index 번호.
	 * @return {Object} RadioButton Element 객체 {elRadioButton : 대상 엘리먼트, elRadioButtonUnit : 대상 엘리먼트} 으로 구성된 객체를 반환
	 * @example
	 *
	 *  // 0번째 RadioButton 가져오기.
	 *  var oRadioButton = oRadioButton.getElementByIndex(0);
	 *  oRadioButton.elRadioButtonUnit; // RadioButton Unit Element 객체
	 *  oRadioButton.elRadioButton; // RadioButton Element 객체
	 */
	getElementByIndex : function(nIdx){
		return {
			elRadioButton: this._aWElFormList[nIdx].$value(),
			elRadioButtonUnit: this._aWElUnitList[nIdx].$value()
		};
	},
	/**
	 * @description  MobileCommentJindo.m.RadioButton 에서 사용하는 모든 객체를 release 시킨다.
	 * @example
	 * oRadioButton.destroy();
	 */
	destroy : function() {
		this.$super.destroy();
	}
}).extend(MobileCommentJindo.m.CheckRadioCore);
/**
* @(#)MobileCommentJindo.m.Scroll.js 2011. 9. 7.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sculove
* @since 2011. 9. 7.
* @description
*
* <2차 Release이후, 코드 수정사항>
* http://dev.naver.com/news/detail.php?news_id=732
*
* <V1.0.0 이후 수정사항>
* http://devcode.nhncorp.com/news/detail.php?news_id=325
*
* <v1.1.0 이후 수정사항>
*
*/
MobileCommentJindo.m.Scroll = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.Scroll.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {String|HTMLElement} el Scroll할 Element (필수)
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
	 * @requires MobileCommentJindo.m.CoreScroll
     */
	$init : function(el,htUserOption) {
		this.option({
			bActivateOnload : true,
			bUseScrollbar : true,
			bUseFixedScrollbar : false,
			bUsePullDown : false,
			bUsePullUp : false,
			sClassPrefix : "scroll_",
			bUseVScroll : true,
			bUseHScroll : false,
			bUseBounce : true,
			fnPullDownIdle : null,
			fnPullDownBeforeUpdate : null,
			fnPullDownUpdating : null,
			fnPullUpIdle : null,
			fnPullUpBeforeUpdate : null,
			fnPullUpUpdating : null,
			bAutoResize : false
		});
		this.option(htUserOption || {});
		this._initVar();
		this._setWrapperElement(el);
		this._InitPullUpdateFunc();

		if(this.option("bActivateOnload")) {
			this.activate();
		}
	},

	/**
	 * @description MobileCommentJindo.m.Scroll 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar: function() {
		this._oCore = null;
		this._isPullDown = false;
		this._isPullUp = false;
		this._isUpdating = false;
		this._nOrgMaxScrollTop = null;
		this._nPropHScroll = 0;
		this._nPropVScroll = 0;
	},

	/**
	 * @description MobileCommentJindo.m.Scroll 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement: function(el) {
		this._htWElement = {};
		this._htWElement["wrapper"] = MobileCommentJindo.$Element(el);

		var elTemp = this._htWElement["wrapper"].query("." + this.option("sClassPrefix") + "pullDown");
		this._htWElement["pullDown"] = elTemp ? MobileCommentJindo.$Element(elTemp) : null;
		elTemp = this._htWElement["wrapper"].query("." + this.option("sClassPrefix") + "pullUp");
		this._htWElement["pullUp"] = elTemp ? MobileCommentJindo.$Element(elTemp) : null;
	},

	/**
	 * @description pull down/up 관련 함수 옵션이 설정되지 않았을 경우 초기화한다.
	 */
	_InitPullUpdateFunc : function() {
		if(this.option("bUsePullDown") === true) {
			if(!this.option("fnPullDownIdle")) {
				this.option("fnPullDownIdle", function(wel) {
					wel.html("업데이트하시려면 아래로 내려주세요");
				});
			}
			if(!this.option("fnPullDownBeforeUpdate")) {
				this.option("fnPullDownBeforeUpdate", function(wel) {
					wel.html("업데이트 합니다");
				});
			}
			if(!this.option("fnPullDownUpdating")) {
				this.option("fnPullDownUpdating", function(wel) {
					wel.html("업데이트 중입니다...");
				});
			}
		}
		if(this.option("bUsePullUp") === true) {
			if(!this.option("fnPullUpIdle")) {
				this.option("fnPullUpIdle", function(wel) {
					wel.html("더 보시려면 위로 올려주세요");
				});
			}
			if(!this.option("fnPullUpBeforeUpdate")) {
				this.option("fnPullUpBeforeUpdate", function(wel) {
					wel.html("로드 합니다");
				});
			}
			if(!this.option("fnPullUpUpdating")) {
				this.option("fnPullUpUpdating", function(wel) {
					wel.html("로드 중...");
				});
			}
		}
	},

	/**
	 * @description MobileCommentJindo.m.Scroll 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		if(this._oCore) {
			this._oCore.activate();
		}
		this.refresh();
		this._attachEvent();
	},

	/**
	 * @description pullDown 사용여부를 지정할수 있습니다.
	 *
	 * @param {Boolean} bUse
	 */
	setUsePullDown : function(bUse) {
		this.option("bUsePullDown", bUse);
		this._refreshPullStatus();
	},

	/**
	 * @description pullUp 사용여부를 지정할 수 있습니다.
	 * @param {Boolean} bUse
	 */
	setUsePullUp : function(bUse) {
		this.option("bUsePullUp", bUse);
		this._refreshPullStatus();
	},

	/**
	 * @description width값을 설정하거나, 반환한다.
	 * @param {Number} nValue
	 */
	width : function(nValue) {
		if(nValue) {
			this.option("nWidth", nValue);
			this.refresh();
		} else {
			if(this.option("nWidth")) {
				return parseInt(this.option("nWidth"),10);
			} else {
				return this._htWElement["wrapper"].width();
			}
		}
	},

	/**
	 * @description height값을 설정하거나, 반환한다.
	 * @param {Number} nValue
	 */
	height : function(nValue) {
		if(nValue) {
			this.option("nHeight", nValue);
			this.refresh();
		} else {
			if(this.option("nHeight")) {
				return parseInt(this.option("nHeight"),10);
			} else {
				return this._htWElement["wrapper"].height();
			}
		}
	},

	/**
	 * @description pull Down/up 관련 상태을 초기화합니다.
	 */
	_refreshPullStatus : function() {
		this._isUpdating = false;
		this._nOrgMaxScrollTop = null;
		this._isPullDown = this.option("bUsePullDown") && this.option("bUseVScroll") && !this.option("bUseHScroll") && this.option("bUseBounce") && (this._htWElement["pullDown"] !== null);
		this._isPullUp = this.option("bUsePullUp") && this.option("bUseVScroll") && !this.option("bUseHScroll") && this.option("bUseBounce") && (this._htWElement["pullUp"] !== null);
		if (this._isPullDown && this.option("fnPullDownIdle")) {
			this._htWElement["pullDown"]._isReady_ = false;
			this.option("fnPullDownIdle")(this._htWElement["pullDown"]);
		}
		if (this._isPullUp && this.option("fnPullUpIdle")) {
			this._htWElement["pullUp"]._isReady_ = false;
			this.option("fnPullUpIdle")(this._htWElement["pullUp"]);
		}
	},

	/**
	 * @description Scroll영역의 내용이 변경될 경우, refresh를 호출하여 변경된 내용의 값을 갱신한다.<br/>
	 * refresh는 wrapper 엘리먼트가 보일경우 정상적으로 동작한다!
	 *
	 */
	refresh : function() {
		if(!this.isActivating()) {
			return;
		}
		this._refreshPullStatus();

		if (this._oCore) {
			this._oCore.option({
				nOffsetTop : this._isPullDown ? this._htWElement["pullDown"].height() : 0,
				nOffsetBottom : this._isPullUp ? this._htWElement["pullUp"].height() : 0,
				nWidth : this.option("nWidth"),
				nHeight : this.option("nHeight")
			});
			this._oCore.refresh();
		} else {
			var htOption = this.option();
			htOption.bActivateOnload = true;
			htOption.nOffsetTop =  this._isPullDown ? this._htWElement["pullDown"].height() : 0;
			htOption.nOffsetBottom =  this._isPullUp ? this._htWElement["pullUp"].height() : 0;
			this._oCore = new MobileCommentJindo.m.CoreScroll(this._htWElement["wrapper"], htOption);
		}
		// 스크롤바 refresh (없을시 자동 생성)
		if(this.option("bUseScrollbar")) {
			this._refreshScroll("V");
			this._refreshScroll("H");
		}
	},

	/**
	 * @description left, top 기준으로 스크롤을 이동한다.
	 * 스크롤을 해당 위치(nLeft, nTop)로 이동한다.<br/>
	 * 최상위의 위치는 0,0 이다. -값이 입력될 경우는 '절대값'으로 판단한다.<br/>
	 * 스크롤의 내용을 아래로 내리거나, 오른쪽으로 이동하려면 + 값을 주어야 한다.<br/>
	 *
	 * @example
	 * oScroll.scrollTo(0,100); //목록이 아래로 100px 내려간다.
	 * oScroll.scrollTo(0,-100); //목록이 아래로 100px 내려간다. (절대값이 100이므로)
	 * @param {Number} nLeft 0~양수 만 입력 가능하다. (-가 입력된 경우는 절대값으로 계산된다)
	 * @param {Number} nTop 0~양수 만 입력 가능하다. (-가 입력된 경우는 절대값으로 계산된다)
	 * @param {Number} nDuration 기본값은 0ms이다.
	 */
	scrollTo : function(nLeft, nTop, nDuration) {
		nDuration = nDuration || 0;
		nLeft = -Math.abs(nLeft);
		nTop = -Math.abs(nTop);
		nTop += this.getTop();
		this._oCore.scrollTo( (nLeft >= this.getLeft() ? this.getLeft() : (nLeft <= this.getRight() ? this.getRight() : nLeft) ),
			(nTop >= this.getTop() ? this.getTop() : (nTop <= this.getBottom() ? this.getBottom() : nTop) ),
			nDuration);
	},

	/**
	 * @description 오른쪽 위치 반환
	 * @return {Number}
	 */
	getRight : function() {
		return this._oCore.nMaxScrollLeft;
	},

	/**
	 * @description 왼쪽 위치 반환
	 * @return {Number}
	 */
	getLeft : function() {
		return 0;
	},

	/**
	 * @description 아래쪽 위치 반환
	 * @return {Number}
	 */
	getBottom : function() {
		return this._oCore.nMaxScrollTop;
	},

	/**
	 * @description 위쪽 위치 반환
	 * @return {Number}
	 */
	getTop : function() {
		return this._oCore.nMinScrollTop;
	},

	/**
	 * @description 현재 포지션을 반환함.
	 * @return {HashTable} nTop, nLeft의 값을 반환한다.
	 */
	getCurrentPos : function() {
		return this._oCore.getCurrentPos();
	},

	/**
	 * @description MobileCommentJindo.m.Scroll 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
		this._oCore.deactivate();
	},

	/**
	 * @description MobileCommentJindo.m.Scroll 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};
		this._oCore.attach({
			beforeTouchStart : MobileCommentJindo.$Fn(this._onBeforeTouchStart, this).bind(),
			touchStart : MobileCommentJindo.$Fn(this._onTouchStart, this).bind(),
			beforeTouchMove : MobileCommentJindo.$Fn(this._onBeforeTouchMove, this).bind(),
			touchMove: MobileCommentJindo.$Fn(this._onTouchMove, this).bind(),
			beforeTouchEnd : MobileCommentJindo.$Fn(this._onBeforeTouchEnd, this).bind(),
			touchEnd: MobileCommentJindo.$Fn(this._onTouchEnd, this).bind(),
			beforePosition : MobileCommentJindo.$Fn(this._onBeforePosition, this).bind(),
			position: MobileCommentJindo.$Fn(this._onPosition, this).bind(),
			setDuration : MobileCommentJindo.$Fn(this._onSetDuration, this).bind(),
			afterScroll : MobileCommentJindo.$Fn(this._onAfterScroll, this).bind()
		});
		if(this.option("bAutoResize")) {
			this._htEvent["rotate"] = MobileCommentJindo.$Fn(this._onRotate, this).bind();
			MobileCommentJindo.m.bindRotate(this._htEvent["rotate"]);
		}
	},

	/**
	 * @description 안드로이드 일 경우, 스크롤 이후 버튼이 클릭 안되는 이슈에 대한 대응
	 * @param {MobileCommentJindo.$Event} wel
	 */
	_fixedBugForAndroid : function(wel) {
		if(this._oCore.isAndroid) {
			var ele = wel.$value();
			var htOffset = MobileCommentJindo.m.getCssOffset(ele);
			var htIndicatorOffset=wel.offset();
			ele.style[this._oCore.sCssPrefix + "TransitionDuration"] = null;
            ele.style[this._oCore.sCssPrefix + "Transform"] = null;
			wel.offset(htOffset.top + htIndicatorOffset.top, htOffset.left + htIndicatorOffset.left);
		}
	},

	/**
	 * @description 디바이스 회전시, 처리
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onRotate : function(we) {
		this.refresh();
	},

	/**
	 * @description move시 duration을 지정한 후 이벤트. setDuration
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onSetDuration : function(we) {
		if (this.option("bUseScrollbar")) {
			if (we.bUseHScroll && this._htWElement["HscrollbarIndicator"]) {
				this._htWElement["HscrollbarIndicator"].css(this._oCore.sCssPrefix + "TransitionDuration", we.nDuration);
			}
			if (we.bUseVScroll && this._htWElement["VscrollbarIndicator"]) {
				this._htWElement["VscrollbarIndicator"].css(this._oCore.sCssPrefix + "TransitionDuration", we.nDuration);
			}
		}
	},

	/**
	 * @description beforeTouchStart 이벤트
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onBeforeTouchStart : function(we) {
		return this.fireEvent("beforeTouchStart",we);
	},

	/**
	 * @description touchStart 이벤트
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onTouchStart : function(we) {
		this.fireEvent("touchStart",we);
	},

	/**
	 * @description beforeTouchMove 이벤트
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onBeforeTouchMove : function(we) {
		return this.fireEvent("beforeTouchMove",we);
	},

	/**
	 * @description touchMove 이벤트
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onTouchMove : function(we) {
//		console.log("이동..." + we.nLeft + ", " + we.nTop + " max : " + we.nMaxScrollTop + " ,,, " + this._htWElement["pullDown"]._isReady_);
		if (this._isPullDown || this._isPullUp) {
			this._touchMoveForUpdate(we);
		}
		this.fireEvent("touchMove",we);
	},

	/**
	 * @description beforeTouchEnd 이벤트
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onBeforeTouchEnd : function(we) {
		return this.fireEvent("beforeTouchEnd",we);
	},

	/**
	 * @description TouchEnd 이벤트
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onTouchEnd : function(we) {
		if(this._isPullDown && this._htWElement["pullDown"]._isReady_) {
			this._pullUploading(this._htWElement["pullDown"], false);
		}
		if(this._isPullUp && this._htWElement["pullUp"]._isReady_) {
			this._pullUploading(this._htWElement["pullUp"], true);
		}
		this.fireEvent("touchEnd",we);
	},

	/**
	 * @description beforePosition 이벤트
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onBeforePosition : function(we) {
		return this.fireEvent("beforePosition",we);
	},

	/**
	 * @description 스크롤 포지션 설정 후 이벤트 position
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onPosition : function(we) {
		if(this.option("bUseScrollbar")) {
			this._setScrollBarPos("V", we.nTop);
			this._setScrollBarPos("H", we.nLeft);
		}
		this.fireEvent("position",we);
	},

	/**
	 * @description afterScroll시. 스크롤바 사라지는 기능
	 * @param {MobileCommentJindo.$Event} we
	 */
	_onAfterScroll : function(we) {
		if (this.option("bUseScrollbar") && !this.option("bUseFixedScrollbar") ) {
			this._hideScrollBar("H");
			this._hideScrollBar("V");
		}
		this.fireEvent("afterScroll",we);
	},

	/**
	 * @description scrollbar를 숨긴다
	 * @param {String} sDirect H,V 수평과 수직을 나타낸다.
	 */
	_hideScrollBar : function(sDirection) {
		var wel = this._htWElement[sDirection + "scrollbar"],
			bUseScroll = (sDirection === "H" ? this._oCore.bUseHScroll : this._oCore.bUseVScroll);
		if(bUseScroll && wel) {
			if(this._oCore.isAndroid) {
				this._fixedBugForAndroid(this._htWElement[sDirection + "scrollbarIndicator"]);
				wel.opacity(0);
			} else {
				wel.css(this._oCore.sCssPrefix + "TransitionDuration", "300ms").opacity(0);
			}
		}
	},

	/**
	 * @description pullDown 사용자 이벤트를 호출한다.
	 */
	_fireEventPullDown : function() {
		if(!this._htWElement) {
			return;
		}
		this.fireEvent("pullDown", {
			welElement : this._htWElement["pullDown"],
			oScroll : this
		});
	},

	/**
	 * @description pullUp 사용자 이벤트를 호출한다.
	 */
	_fireEventPullUp : function() {
		if(!this._htWElement) {
			return;
		}
		this.fireEvent("pullUp", {
			welElement : this._htWElement["pullUp"],
			oScroll : this
		});
	},

	/**
	 * @description Pull down/up시 upload하는 함수
	 * @param {MobileCommentJindo.$Element} wel
	 * @param {Boolean} isUp
	 */
	_pullUploading : function(wel, isUp) {
		var fn = isUp ? this.option("fnPullUpUpdating") : this.option("fnPullDownUpdating");
		var self = this;
		this._isUpdating = true;
		wel._isReady_ = false;
		if (fn) {
			setTimeout(function(){
				fn(wel);
				if (isUp) {
					self._fireEventPullUp();
				} else {
					self._fireEventPullDown();
				}
			}, 0);
		}
	},

	/**
	 * @description Update적용시 touchMove 기능 처리
	 * - notice => ready => pullDown/up 상태
	 *
	 * @param {Jindo.$Event} we
	 */
	_touchMoveForUpdate : function(we) {
		if (this._isUpdating) {
			return;
		}
		var nTopMargin = this._oCore.option("nOffsetTop");
		var nBottomMargin = this._oCore.option("nOffsetBottom");
		// nOrgMax값이 있을 경우
		we.nMaxScrollTop = this._nOrgMaxScrollTop ? this._nOrgMaxScrollTop : we.nMaxScrollTop;

		// 위에인 경우
		if (this._isPullDown) {
			if (this._htWElement["pullDown"]._isReady_) {
				if (nTopMargin > we.nTop) {
					this._htWElement["pullDown"]._isReady_ = false;
					if (this.option("fnPullDownIdle")) {
						this.option("fnPullDownIdle")(this._htWElement["pullDown"]);
						this._oCore.nMinScrollTop=-nTopMargin;
					}
				}
			} else {
				if (we.nTop > nTopMargin) {
					this._htWElement["pullDown"]._isReady_ = true;
					if (this.option("fnPullDownBeforeUpdate")) {
						this.option("fnPullDownBeforeUpdate")(this._htWElement["pullDown"]);
						this._oCore.nMinScrollTop=0;
					}
				}
			}

		}

		// 아래인 경우
		if (this._isPullUp) {
			if (this._htWElement["pullUp"]._isReady_) {
				if (we.nTop >= (we.nMaxScrollTop - nBottomMargin)) {
					this._htWElement["pullUp"]._isReady_ = false;
					if (this.option("fnPullUpIdle")) {
						this.option("fnPullUpIdle")(this._htWElement["pullUp"]);
						this._oCore.nMaxScrollTop=we.nMaxScrollTop;
					}
				}
			} else {
				if (we.nTop < (we.nMaxScrollTop - nBottomMargin)) {
					this._htWElement["pullUp"]._isReady_ = true;
					if (this.option("fnPullUpBeforeUpdate")) {
						this.option("fnPullUpBeforeUpdate")(this._htWElement["pullUp"]);
						this._nOrgMaxScrollTop = we.nMaxScrollTop;
						this._oCore.nMaxScrollTop=we.nMaxScrollTop - nBottomMargin;
					}
				}
			}
		}
	},

	/**
	 * @description 동작 여부를 반환
	 * @return {Boolean}  동작 여부
	 */
	isMoving : function() {
		return this._oCore.isMoving();
	},

	/**
	 * @description MobileCommentJindo.m.Scroll 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		this._oCore.detachAll();
		if(this.option("bAutoResize")) {
			MobileCommentJindo.m.unbindRotate(this._htEvent["rotate"]);
		}
		this._htEvent = null;
	},

	/**
	 * @description 스크롤바를 생성한다.
	 * @param {String} sDirection 수평, 수직 방향
	 */
	_createScroll : function(sDirection) {
		if( !(sDirection === "H" ? this._oCore.bUseHScroll : this._oCore.bUseVScroll) ) {
			return;
		}
		var welScrollbar = this._htWElement[sDirection + "scrollbar"],
			welScrollbarIndicator = this._htWElement[sDirection + "scrollbarIndicator"],
			welWrapper = this._htWElement["wrapper"];

		// 기존에 존재하면 삭제
		if(welScrollbar) {
			welWrapper.remove(welScrollbar);
			this._htWElement[sDirection + "scrollbar"] = this._htWElement[sDirection + "scrollbarIndicator"] = null;
		}

		// scrollbar $Element 생성
		welScrollbar = this._createScrollbar(sDirection);
		welScrollbarIndicator = this._createScrollbarIndicator(sDirection);
		this._htWElement[sDirection + "scrollbar"]= welScrollbar;
		this._htWElement[sDirection + "scrollbarIndicator"] = welScrollbarIndicator;
		welScrollbar.append(welScrollbarIndicator);
		welWrapper.append(welScrollbar);

		// scrollbar 갱신
		this._refreshScroll(sDirection);
	},

	/**
	 * @description 스크롤 바의 상태를 갱신한다.
	 * @param {String} sDirection 수평, 수직 방향
	 */
	_refreshScroll : function(sDirection) {
		// scrollbar indicator 사이즈 계산
		if( !(sDirection === "H" ? this._oCore.bUseHScroll : this._oCore.bUseVScroll) ) {
			return;
		}
		// 스크롤바가 존재하지 않을 경우 새로 생성함
		if(!this._htWElement[sDirection + "scrollbar"]) {
			this._createScroll(sDirection);
		}

		var welScrollbar = this._htWElement[sDirection + "scrollbar"],
			welScrollbarIndicator = this._htWElement[sDirection + "scrollbarIndicator"],
			nSize = 0;

		if(sDirection === "H" ) {
			welScrollbar.width(this._oCore.nWrapperW);
			nSize = Math.max(Math.round(Math.pow(this._oCore.nWrapperW,2) / this._oCore.nScrollW), 8);
			this._nPropHScroll = (welScrollbar.width() - nSize) / this._oCore.nMaxScrollLeft;
			welScrollbarIndicator.width(nSize);
		} else {
			welScrollbar.height(this._oCore.nWrapperH);
			nSize = Math.max(Math.round(Math.pow(this._oCore.nWrapperH,2) / this._oCore.nScrollH), 8);
			this._nPropVScroll = (welScrollbar.height() - nSize) / this._oCore.nMaxScrollTop;
			welScrollbarIndicator.height(nSize);
		}
	},

	/**
	 * @description 스크롤바 Wrapper를 생성한다
	 * @param {String} sDirection
	 */
	_createScrollbar : function(sDirection) {
	 	var welScrollbar = MobileCommentJindo.$Element("<div>");
		welScrollbar.css({
			"position" : "absolute",
			"zIndex" : 100,
			"bottom" : (sDirection === "H" ? "1px" : (this._oCore.bUseHScroll ? '7' : '2') + "px"),
			"right" : (sDirection === "H" ? (this._oCore.bUseVScroll ? '7' : '2') + "px" : "1px"),
			"pointerEvents" : "none",
			"overflow" : "hidden"});
		if(!this.option("bUseFixedScrollbar")) {
			welScrollbar.css(this._oCore.sCssPrefix + "TransitionProperty", "opacity")
				.css(this._oCore.sCssPrefix + "TransitionDuration", "0")
				.opacity(0);
		}
		if (sDirection === "H") {
			welScrollbar.css({
				height: "7px",
				left: "2px"
			});
		} else {
			welScrollbar.css({
				width: "7px",
				top: "2px"
			});
		}
		return welScrollbar;
	},

	/**
	 * @description 스크롤바 Indicator를 생성한다.
	 * @param {String} sDirection
	 */
	_createScrollbarIndicator : function(sDirection) {
		// scrollbar Indivator 생성
		var welScrollbarIndicator = MobileCommentJindo.$Element("<div>");
		welScrollbarIndicator.css({
			"position" : "absolute",
			"zIndex" : 100,
			"border": "1px solid rgba(255,255,255,0.9)",
			"borderRadius" : "3px",
			"pointerEvents" : "none",
			"left" : 0,
			"top" : 0,
			"background-color" :"rgba(0,0,0,0.5)"})
			.css(this._oCore.sCssPrefix + "BackgroundClip", "padding-box")
			.css(this._oCore.sCssPrefix + "BoxSizing", "border-box")
			.css(this._oCore.sCssPrefix + "BorderRadius", "3px")
			.css(this._oCore.sCssPrefix + "TransitionProperty", "-webkit-transform")
			.css(this._oCore.sCssPrefix + "Transform", "translate" + this._oCore.sTransOpen + "0,0" + this._oCore.sTransEnd);
		if(this._oCore.option("bUseTransition")) {
			welScrollbarIndicator.css(this._oCore.sCssPrefix + "TransitionTimingFunction", "cubic-bezier(0.33,0.66,0.66,1)");
		}

		if(sDirection === "H") {
			welScrollbarIndicator.css("height" , "100%");
		} else {
			welScrollbarIndicator.css("width", "100%");
		}
		return 	welScrollbarIndicator;
	},

	/**
	 * @description 스크롤바위 위치를 변경
	 * @param {String} sDirection
	 * @param {Number} nPos
	 */
	_setScrollBarPos: function (sDirection, nPos) {
		// 스크롤이 필요 없는 상황인 경우는 return
		var bUseScroll = (sDirection === "H" ? this._oCore.bUseHScroll : this._oCore.bUseVScroll);
		if(!bUseScroll) {
			return;
		}
		var welIndicator = this._htWElement[sDirection + "scrollbarIndicator"],
			welScrollbar = this._htWElement[sDirection + "scrollbar"];
		nPos = this["_nProp" + sDirection + 'Scroll'] * nPos;

		if (welIndicator) {
			if (this._oCore.isAndroid) {
				var nBufferPos = parseInt( ( sDirection === "H" ? welIndicator.css("left") : welIndicator.css("top") ), 10);
				nPos -= isNaN(nBufferPos) ? 0 : nBufferPos;
			}
			welIndicator.css(this._oCore.sCssPrefix + "Transform", "translate" + this._oCore.sTranOpen + (sDirection === "H" ? nPos + "px,0" : "0," + nPos + "px") + this._oCore.sTranEnd);
		}
		if (!this.option("bUseFixedScrollbar") && welScrollbar) {
			welScrollbar.css(this._oCore.sCssPrefix + "TransitionDuration", 0).opacity(1);
		}
	},

	/**
	 * @description  MobileCommentJindo.m.Scroll 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this.deactivate();
		for(var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		this._oCore.destroy();
		delete this._oCore;
		this._htWElement = null;
	}
}).extend(MobileCommentJindo.UIComponent);

/**
* @(#)MobileCommentJindo.m.Slider.js 2011. 9. 5.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author "oyang2"
* @since 2011. 9. 5.
* @description
*/


MobileCommentJindo.m.Slider = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.Slider.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {String | HTMLElement} 기준 엘리먼트
	 * @param {HashTable} htOption 초기화 옵션 설정을 위한 객체
	 * @extends MobileCommentJindo.UIComponent
	 * @requires MobileCommentJindo.m.Touch
	 * @example
var oSlider = new MobileCommentJindo.m.Slider('slider1', {
		sClassPrefix : 'slider-', //클래스명 접두어
		bVertical : false, //슬라이더 세로 여부
		nMinValue : 0, //슬라이더 최소값
		nMaxValue : 100, //슬라이더 최대값
		nDefaultValue : 0 , //초기 로드 thumb 값
		bActivateOnload : true // 활성화여부
	}).attach({
		'beforeChange' : function(oCustomEvt){

		},
		'change' : function(oCustomEvt){

		}
	})
     */
	$init : function(sId, htUserOption) {
		this.option({
			 sClassPrefix : 'slider-',
			 bVertical : false,
			 nMinValue : 0,
			 nMaxValue : 100,
			 nDefaultValue : 0,
			 bActivateOnload : true
		});
		this.option(htUserOption || {});

		this._setWrapperElement(sId);
		this._initVar();

		if(this.option("bActivateOnload")) {
			this.activate();
			this.setValue(this.option('nDefaultValue'));
		}
	},

	/**
	 * @description MobileCommentJindo.m.Slider 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar: function() {
		var nMove = this.option('bVertical')? 0: 6;
		this._oTouch = new MobileCommentJindo.m.Touch(this._htWElement.track.$value(),{
			nMoveGap: nMove,
			bActivateOnload: false
		});
		//
		this._oTouch.attach({
			'touchMove' : MobileCommentJindo.$Fn(this._onMove, this).bind(),
			'touchEnd' : MobileCommentJindo.$Fn(this._onMove, this).bind(),
			'touchStart' : MobileCommentJindo.$Fn(this._onStart, this).bind()
		});

		this._htSwap ={
			left : this.option('bVertical')? 'top' : 'left',
			width :  this.option('bVertical')? 'height' : 'width',
			nX :  this.option('bVertical')? 'nY' : 'nX'
		};

		//size 조정
		var nSize = this._htWElement.thumb[this._htSwap.width]()/2;
		this._htWElement.thumb.css('margin-'+this._htSwap.left, nSize*-1);
	},

	/**
	 * @description MobileCommentJindo.m.Slider 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement: function(el) {
		this._htWElement = {};
		var el = MobileCommentJindo.$(el);
		var sClass = '.' + this.option('sClassPrefix');

		this._htWElement.track = MobileCommentJindo.$Element(el);
		var elThumb = MobileCommentJindo.$$.getSingle(sClass+'thumb', el);
		this._htWElement.thumb = elThumb? MobileCommentJindo.$Element(elThumb) : null;
		var elRang = MobileCommentJindo.$$.getSingle(sClass+'range', el);
		this._htWElement.range = elRang? MobileCommentJindo.$Element(elRang) : null;
	},

	_onStart : function(oCustomEvt){
		//하이라이팅 막아버리기
		oCustomEvt.oEvent.stop(MobileCommentJindo.$Event.CANCEL_DEFAULT);
	},

	_onMove : function(oCustomEvt){
		if(oCustomEvt.sType == 'touchMove'){
			oCustomEvt.oEvent.stop(MobileCommentJindo.$Event.CANCEL_DEFAULT);
		}

		var nCurrent = oCustomEvt[this._htSwap.nX] - this._htWElement.track.offset()[this._htSwap.left] - (this._htWElement.thumb[this._htSwap.width]()/2);
		var nPos = this._getAdjustedPos(nCurrent);

		this._move(nPos);
	},

	_move : function(nPos, bFireEvent){
		if(typeof bFireEvent == 'undefined'){
			bFireEvent = true;
		}

		var nValue = this.getValue(nPos);
		var nAdjustPos = Math.round(nPos);
		var nAdjustValue = this.getValue(nAdjustPos);

		var htOption = {
			nValue : nValue,
			nPosition : nPos,
			nAdjustValue : nAdjustValue,
			nAdjustPosition : nAdjustPos
		};

		if(bFireEvent && !this._fireBeforeEvent(htOption)){
			return;
		}

		if(htOption.nAdjustValue != nAdjustValue){
			htOption.nAdjustPosition = this._getPositionFromValue(htOption.nAdjustValue);
		}

		this._moveThumb(htOption.nAdjustPosition);

		if(bFireEvent){
			this._fireChangeEvent(htOption);
		}

		if(this._htWElement.range){
			this._htWElement.range.css(this._htSwap.width, htOption.nAdjustPosition+'%');
		}
	},

	_fireBeforeEvent : function(htOption){
		return this.fireEvent('beforeChange',htOption);
	},

	_fireChangeEvent : function(htOption){
		this.fireEvent('change', htOption);
	},

	_moveThumb : function(n){
		if(n > 100 || n < 0){ return;}

		this._htWElement.thumb.css('webkitTransitionDuration', '0ms');
		this._htWElement.thumb.css('webkitTransitionProperty',this._htSwap.left);
		this._htWElement.thumb.css(this._htSwap.left ,n+"%");
	},

	_getTrackInfo : function(){
		var nTrackSize = this.option('bVertical')? this._htWElement.track.height() : this._htWElement.track.width();
		var nThumbSize = this.option('bVertical')? this._htWElement.thumb.height() : this._htWElement.thumb.width();

		var nMaxPos =  nTrackSize-(nThumbSize/2);

		return {
			maxPos : nMaxPos,
			max :  this.option('nMaxValue')*1,
			min :  this.option('nMinValue')*1
		};

	},

	/**
	 * 옵션을 설정한 nMinValue, nMaxValue에 대한 상대값으로 해당 Thumb의 위치값을 얻어온다
	 * @return {Value}
	 */
	getValue : function(nPos) {
		if(typeof nPos == 'undefined'){
			nPos = this.getPosition();
		}

		var oInfo = this._getTrackInfo();

		var nValue = oInfo.min + ((oInfo.max- oInfo.min)* (nPos/100));

		return nValue;
	},


	/**
	 * 옵션을 설정한 nMinValue, nMaxValue에 대한 상대값으로 해당 Thumb의 위치값을 설정한다
	 * @param {Value} Thumb의 value 값
	 * @param {Boolean} 커스텀 이벤트 발생여부
	 */
	setValue : function(nValue, bFireEvent){
		nValue = nValue *1;
		var nPos = this._getPositionFromValue(nValue);

		if(typeof bFireEvent == 'undefined'){
			bFireEvent = true;
		}

		this._move(nPos, bFireEvent);
	},

	_getAdjustedPos : function(nDistance){
		var htInfo = this._getTrackInfo();

		var nPecent = (nDistance* 100)/htInfo.maxPos;

		nPecent = Math.max(0, nPecent);
		nPecent = Math.min(nPecent,100);

		return nPecent;
	},

	/**
	 * 현재 Thumb의 위치값을(퍼센트) 리턴한다.
	 * @return Number
	 */
	getPosition : function() {
		var sPos = this._htWElement.thumb.css(this._htSwap.left);

		return (sPos == "auto") ? 0 : parseInt(sPos, 10);
	},

	/**
	 * Thumb의 위치값을 퍼센트로 설정한다
	 * @param{Number} Thumb의 위치 퍼센트 값
	 * @param {Boolean} 커스텀 이벤트 발생여부
	 */
	setPosition : function(nPos, bFireEvent){
		if(typeof bFireEvent == 'undefined'){
			bFireEvent = true;
		}

		this._move(nPos, bFireEvent);
	},

	_getPositionFromValue : function(nValue){
		var htInfo = this._getTrackInfo();

		var nPecent = ((nValue- htInfo.min)* 100) /(htInfo.max-htInfo.min);
		nPecent = isNaN(nPecent)? 100 : nPecent;
		nPecent = Math.max(0, nPecent);
		nPecent = Math.min(100, nPecent);

		return nPecent;
	},


	_onClick : function(evt){
		evt.stop();
	},

	/**
	 * @description MobileCommentJindo.m.Slider 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};
		// thumb click event 처리
//		this._htEvent["click"] = {
//			ref : MobileCommentJindo.$Fn(this._onClick, this).attach(this._htWElement.thumb, "click"),
//			el	: this._htWElement.thumb
//		};

	},

	/**
	 * @description 특정 이벤트를 해제한다.
	 * @param {String} sEventKey 이벤트 키
	 */
	_detachEvent : function(sEventKey) {
		if(sEventKey) {
			var htTargetEvent = this._htEvent[sEventKey];
			htTargetEvent.ref.detach(htTargetEvent.el, sEventKey);
		}
	},

	/**
	 * @description MobileCommentJindo.m.Slider 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this._attachEvent();
		this._oTouch.activate();
	},

	/**
	 * @description MobileCommentJindo.m.Slider 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
		this._oTouch.deactivate();
	},

	/**
	 * @description  MobileCommentJindo.m.Slider 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this.deactivate();

		for(var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		this._htWElement = null;

		for(var p in this._htSwap) {
			this._htSwap[p] = null;
		}
		this._htSwap = null;

		this._oTouch.detachAll();
	}
}).extend(MobileCommentJindo.UIComponent);
/**
* @(#)MobileCommentJindo.m.SlideTab.js 2011. 7. 14.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sculove
* @since 2011. 7. 14.
* @description
*
* <Release 1.0.0 이후>
* 1. 탭 외부를 선택시 하이라이트 제거
*
*/
MobileCommentJindo.m.SlideTab = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.SlideTab.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {String|HTMLElement} el SlideTab할 Element (필수)
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
	 * @requires MobileCommentJindo.m.SlideEffect
     */
	$init : function(el,htUserOption) {
		this.option({
			 bActivateOnload : true,
			 nDefaultIndex : 0,
			 sClassPrefix : "tc-",
			 nSlideDuration : 200,
			 sTimingFunction : "ease-in-out",
			 nCountPerVeiw : 3
		});
		this.option(htUserOption || {});
		this._initVar();
		this._setWrapperElement(el);
		this._initData();
		if(this.option("bActivateOnload")) {
			this.activate();
		}
		this.select(this.option("nDefaultIndex"));
	},

	/**
	 * @description MobileCommentJindo.m.SlideTab 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar: function() {
		this._nCurrentPage = 1;
		this._nCurrentIndex = -1;
		this._nTotalPage = 1;
		this._nPageWidth = 0;
		this._aTab = [];
		this._aPanel = [];
		this._aDummyTab = [];
		this._oEffect = null;
		this._isNext = null;
	},

	/**
	 * 현재 Tab의 인덱스를 반환한다.
	 * @return {Number} 현재 tab의 index를 반환함 (index는 0부터)
	 */
	getCurrentIndex : function() {
		return this._nCurrentIndex;
	},

	/**
	 * 현재 Tab의 페이지를 반환한다.
	 * @return {Number} 현재 tab의 현재 페이지를 반환함 (page수는 1부터)
	 */
	getCurrentPage : function() {
		return this._nCurrentPage;
	},

	/**
	 * 현재 Tab의 총 페이지수를 반환
	 * @return {Number} 현재 Tab의 총 페이지수를 반환. (초기값 1)
	 */
	getTotalPage : function() {
		return this._nTotalPage;
	},

	/**
	 * 현재 Tab을 반환
	 * @param {Number} nIdx 옵션 (index는 0부터)
	 * @return {HTMLElement, Array} index가 있을 경우, index에 해당하는 TAB HTMLElement반환
	 * 								index가 없을 경우, TAB HTMLElement 배열을 반환
	 * @example
	 *  var aTab = oComponent.getTab();
	 *  var elTab = oComponent.getTab(2);
	 */
	getTab : function(nIdx) {
		if(nIdx !== null && this._aTab.length > nIdx) {
			return this._aTab[nIdx];
		} else {
			return this._aTab;
		}
	},

	/**
	 * 현재 Panel을 반환
	 * @param {Number} nIdx 옵션 (index는 0부터)
	 * @return {HTMLElement, Array} index가 있을 경우, index에 해당하는 Panel HTMLElement반환
	 * 								index가 없을 경우, Panel HTMLElement 배열을 반환
	 * @example
	 *  var aPanel = oComponent.getPanel();
	 *  var elPanel = oComponent.getPanel(2);
	 */
	getPanel : function(nIdx) {
		if(nIdx !== null && this._aPanel.length > nIdx) {
			return this._aPanel[nIdx];
		} else {
			return this._aPanel;
		}
	},

	/**
	 * @description MobileCommentJindo.m.SlideTab 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement: function(el) {
		var sPrefix = this.option('sClassPrefix'),
			elTmp = null;

		el = (typeof el == "string" ? MobileCommentJindo.$(el) : el);
		if(!el) {
			return;
		}
		this._htWElement = {};
		this._htWElement["baseElement"] = MobileCommentJindo.$Element(el);
		elTemp = MobileCommentJindo.$$.getSingle('.' + sPrefix + 'tabview', el);
		this._htWElement["tab_view"] = elTemp ? MobileCommentJindo.$Element(elTemp) : null;
		elTemp = MobileCommentJindo.$$.getSingle('.' + sPrefix + 'tab-cont', el);
		this._htWElement["tab_container"] = elTemp ? MobileCommentJindo.$Element(elTemp) : null;
		// 탭 외부를 선택시 하이라이트 되는 문제
		if(this._htWElement["tab_container"]) {
			this._htWElement["tab_container"].css('-' + MobileCommentJindo.m.getCssPrefix() + '-tap-highlight-color', 'rgba(0,0,0,0)');
		}
		elTemp = MobileCommentJindo.$$.getSingle('.' + sPrefix + 'panel-cont', el);
		this._htWElement["panel_container"] = elTemp ? MobileCommentJindo.$Element(elTemp) : null;
		elTemp = MobileCommentJindo.$$.getSingle('.' + sPrefix + 'prev', el);
		this._htWElement["prev"] = elTemp ? MobileCommentJindo.$Element(elTemp) : null;
		elTemp = MobileCommentJindo.$$.getSingle('.' + sPrefix + 'next', el);
		this._htWElement["next"] = elTemp ? MobileCommentJindo.$Element(elTemp) : null;
		this._htWElement["baseElement"].css("position","relative");
		this._htWElement["tab_view"].css("overflow","hidden");
	},

	/**
	 * 초기 tab, panel 데이터 초기화
	 */
	_initData : function() {
		var nCountPreView = this.option("nCountPerVeiw"),
			el = null,
			nRemainPage;

		this._aTab = this._htWElement["tab_container"].queryAll('.' + this.option('sClassPrefix') + 'tab');
		this._aPanel = this._htWElement["panel_container"].queryAll('.' + this.option('sClassPrefix') + 'panel');
		for(var i=0, nLength=this._aTab.length; i < nLength; i++) {
			this._aTab[i] = MobileCommentJindo.$Element(this._aTab[i]);
			this._aPanel[i] = MobileCommentJindo.$Element(this._aPanel[i]);
		}

		// total Page 사이즈 결정
		this._nTotalPage = parseInt(this._aTab.length / nCountPreView, 10);
		nRemainPage = this._aTab.length % nCountPreView;
		if(nRemainPage > 0 ) {
			this._nTotalPage++;
		}
		// dummy tab 생성
		for(j=0, nLength=nCountPreView - nRemainPage; j< nLength; j++) {
			el = MobileCommentJindo.$("<li></li>");
			this._aDummyTab.push(MobileCommentJindo.$Element(el));
			this._htWElement["tab_container"].append(el);
		}

		// Effect 생성
		this._oEffect = new MobileCommentJindo.m.LayerEffect(this._htWElement["tab_container"].$value());
	},

	/**
	 * Tab을 View에 맞게 조절 및 Page 설정값 조정
	 */
	resize : function() {
		var nTabWidth, nPrePageWidth = this._nPageWidth;

		// tab 사이즈 결정
		this._nPageWidth = this._htWElement["tab_view"].width() - this._htWElement["prev"].width() - this._htWElement["next"].width();
		nTabWidth = this._nPageWidth / this.option("nCountPerVeiw");

		if(nPrePageWidth > this._nPageWidth) {	// 기존 사이즈 보다 작아지는 경우
			this._setTabWidth(nTabWidth);
			this._htWElement["tab_container"].width(this._nPageWidth * this._nTotalPage);
		} else {		// 기존 사이즈 보다 커지는 경우
			this._htWElement["tab_container"].width(this._nPageWidth * this._nTotalPage);
			this._setTabWidth(nTabWidth);
		}
		this._htWElement["tab_container"].css("left", (this._nCurrentPage-1) * -this._nPageWidth );
	},

	/**
	 * Tab의 width를 설정한다.
	 */
	_setTabWidth : function(nTabWidth) {
			for(var i in this._aTab) {
				this._aTab[i].width(nTabWidth);
			}
			for(i in this._aDummyTab) {
				this._aDummyTab[i].width(nTabWidth);
			}
	},

	/**
	 * BeforeSelect 사용자 이벤트 호출
	 */
	_fireEventBeforeSelect : function() {
		return this.fireEvent("beforeSelect", {
		 	nIndex : this._nCurrentIndex,
			elTab : this._aTab[this._nCurrentIndex],
		 	elPanel : this._aPanel[this._nCurrentIndex]
		});
	},


	/**
	 * Prev 사용자 이벤트 호출
	 */
	_fireEventSelect : function() {
		this.fireEvent("select", {
		 	nIndex : this._nCurrentIndex,
			elTab : this._aTab[this._nCurrentIndex],
		 	elPanel : this._aPanel[this._nCurrentIndex]
		});
	},

	/**
	 * beforePrev 사용자 이벤트 호출
	 */
	_fireEventBeforePrev : function() {
		return this.fireEvent("beforePrev", {
		 	nPage : this._nCurrentPage,
			nIndex : this._nCurrentIndex,
		 	nTotalPage : this._nTotalPage
		});
	},

	/**
	 * Prev 사용자 이벤트 호출
	 */
	_fireEventPrev : function() {
		this.fireEvent("prev", {
		 	nPage : this._nCurrentPage,
			nIndex : this._nCurrentIndex,
			nTotalPage : this._nTotalPage
		});
	},

	/**
	 * beforeNext 사용자 이벤트 호출
	 */
	_fireEventBeforeNext : function() {
		return this.fireEvent("beforeNext", {
			nPage : this._nCurrentPage,
			nIndex : this._nCurrentIndex,
			nTotalPage : this._nTotalPage
		});
	},

	/**
	 * Prev 사용자 이벤트 호출
	 */
	_fireEventNext : function() {
		this.fireEvent("next", {
		 	nPage : this._nCurrentPage,
			nIndex : this._nCurrentIndex,
		 	nTotalPage : this._nTotalPage
		});
	},

	/**
	 * index에 해당하는 패널 선택
	 * @param {Object} nIdx
	 */
	select : function(nIdx) {
		if(nIdx !== null && this._aTab.length > nIdx &&	(this._nCurrentIndex !== nIdx)) {
			if (this._fireEventBeforeSelect()) {
				var sSelect = this.option('sClassPrefix') + "selected";
				if(this._nCurrentIndex > -1){
					this._aTab[this._nCurrentIndex].removeClass(sSelect);
					this._aPanel[this._nCurrentIndex].removeClass(sSelect);
					this._aPanel[this._nCurrentIndex].hide();
				}
				this._aTab[nIdx].addClass(sSelect);
				this._aPanel[nIdx].addClass(sSelect);
				this._aPanel[nIdx].show();
				this._nCurrentIndex = nIdx;

				this._fireEventSelect();
			}
		}
	},

	/**
	 * @description MobileCommentJindo.m.SlideTab 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this.resize();
		this._attachEvent();
	},

	/**
	 * @description MobileCommentJindo.m.SlideTab 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
	},

	/**
	 * @description MobileCommentJindo.m.SlideTab 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};
		this._htEvent["prev_click"] = {
			ref: MobileCommentJindo.$Fn(this._onPrev, this).attach(this._htWElement["prev"], "click"),
			el: this._htWElement["prev"]
		};
		this._htEvent["next_click"] = {
			ref : MobileCommentJindo.$Fn(this._onNext, this).attach( this._htWElement["next"], "click"),
			el : this._htWElement["next"]
		};
		this._htEvent["tabSelect_click"] = {
			ref : MobileCommentJindo.$Fn(this._onSelect, this).attach( this._htWElement["tab_container"], "click"),
			el : this._htWElement["tab_container"]
		};
		this._oEffect.attach("afterEffect", MobileCommentJindo.$Fn(this._onEndEffect, this).bind());
	},

	/**
	 * 효가가 완료되었을 경우, 현재 페이지값을 변경하고, 현재 페이지의 첫번째 tab을 선택
	 */
	_onEndEffect : function() {
		if(this._isNext) {
			this._nCurrentPage++;
			this._fireEventNext();
		} else {
			this._nCurrentPage--;
			this._fireEventPrev();
		}
		this._isNext = null;
		this.select((this._nCurrentPage-1) * this.option("nCountPerVeiw"));
	},

	/**
	 * @description MobileCommentJindo.m.SlideTab 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		for(var p in this._htEvent) {
			var ht = this._htEvent[p];
			ht.ref.detach(ht.el, p.substring(p.lastIndexOf("_")));
		}
		this._htEvent = null;
	},

	/**
	 * 이번 버튼이 눌러졌을 경우 이벤트 처리
	 * @param {Object} we
	 */
	_onPrev : function(we) {
		if ((this._nCurrentPage > 1) && !this._oEffect.isPlaying()) {
			if (this._fireEventBeforePrev()) {
				this._oEffect.slide({
					sDirection: "right",
					nDuration: this.option("nSlideDuration"),
					sTransitionTimingFunction : this.option("sTimingFunction"),
					nSize: this._nPageWidth
				});
				this._isNext = false;
			}
		}
	},

	/**
	 * 이후 버튼이 눌러졌을 경우 이벤트 처리
	 * @param {Object} we
	 */
	_onNext : function(we) {
//		console.log(this._nCurrentPage, this._nTotalPage);
		if ((this._nCurrentPage < this._nTotalPage) && !this._oEffect.isPlaying()) {
			if (this._fireEventBeforeNext()) {
				this._oEffect.slide({
					sDirection: "left",
					nDuration: this.option("nSlideDuration"),
					sTransitionTimingFunction : this.option("sTimingFunction"),
					nSize: this._nPageWidth
				});
				this._isNext = true;
			}
		}
	},

	/**
	 * 탭을 선택했을 시, 이벤트 처리
	 * @param {Object} we
	 */
	_onSelect : function(we) {
		if(we.element) {
			we.stop();
			var welElement = MobileCommentJindo.$Element(we.element);
			var sClassName = this.option('sClassPrefix') + 'tab';
			if(this._htWElement["tab_container"].isParentOf(welElement) &&
				!welElement.hasClass(sClassName)){
				welElement = welElement.parent(function(v){
					return v.hasClass(sClassName);
				})[0];
			}
			var nIdx = this._htWElement["tab_container"].indexOf(welElement);
			if(nIdx > -1) {
				this.select(nIdx);
			}
		}
	},

	/**
	 * @description  MobileCommentJindo.m.SlideTab 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this.deactivate();

		for(var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		this._htWElement = null;

		for(p in this._aTab) {
			this._aTab[p] = null;
		}
		this._aTab = null;

		for(p in this._aDummyTab) {
			this._aDummyTab[p] = null;
		}
		this._aDummyTab = null;

		for(p in this._aPanel) {
			this._aPanel[p] = null;
		}
		this._aPanel = null;

		this._nCurrentPage = 1;
		this._nCurrentIndex = 0;
		this._nTotalPage = 1;
		this._nPageWidth = 0;
		this._oEffect.destroy();
		delete this._oEffect;
	}
}).extend(MobileCommentJindo.UIComponent);
/**
* @(#)MobileCommentJindo.m.Tab.js 2011. 8. 25.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sshyun
* @since 2011. 8. 25.
* @description
*/
MobileCommentJindo.m.Tab = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.Tab.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {Varient} el Tab Layout Wrapper
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
	 */
	$init : function(el, htUserOption) {
		this.option({
			sClassPrefix 		: "tc-",
			nDefaultIndex	: 0,
			bActivateOnload 	: true
		});
		this.option(htUserOption || {});
		this._initVar();
		this._setWrapperElement(el);
		this._initData();
		if(this.option("bActivateOnload")) {
			this.activate();
		}
		this.select(this.option("nDefaultIndex"));
	},

	/**
	 * @description MobileCommentJindo.m.Tab 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar : function() {
		this._nCurrentIndex = -1;
		this._aTab = [];
		this._aPanel = [];
		this._isNext = null;
	},

	/**
	 * @description MobileCommentJindo.m.Tab 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement : function(el) {
		this._htWElement = {};
		var sPrefix = this.option('sClassPrefix');
		el = (typeof el == "string" ? MobileCommentJindo.$(el) : el);

		this._htWElement["tab_container"] = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle('.' + sPrefix + 'tab-cont', el));
		this._htWElement["panel_container"] = MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle('.' + sPrefix + 'panel-cont', el));
	},

	/**
	 * 초기 tab, panel 데이터 초기화
	 */
	_initData : function() {
		this._aTab = this._htWElement["tab_container"].queryAll('.' + this.option('sClassPrefix') + 'tab');
		this._aPanel = this._htWElement["panel_container"].queryAll('.' + this.option('sClassPrefix') + 'panel');
		for(var i=0, nLength=this._aTab.length; i < nLength; i++) {
			this._aTab[i] = MobileCommentJindo.$Element(this._aTab[i]);
			this._aPanel[i] = MobileCommentJindo.$Element(this._aPanel[i]);
		}
	},

	/**
	 * @todo
	 */

	/**
	 * @description MobileCommentJindo.m.Tab 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this._attachEvent();
	},
	/**
	 * @description MobileCommentJindo.m.Tab 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
	},
	/**
	 * @description MobileCommentJindo.m.Tab 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};
		this._htEvent["tab_click"] = {
				el  : this._htWElement["tab_container"],
				ref : MobileCommentJindo.$Fn(this._onSelect, this).attach( this._htWElement["tab_container"], "click")
		};
	},
	/**
	 * @description MobileCommentJindo.m.Tab 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		for(var p in this._htEvent) {
			var ht = this._htEvent[p];
			ht.ref.detach(ht.el, p.substring(p.lastIndexOf("_")+1));
		}
		this._htEvent = null;
	},
	/**
	 * 현재 Tab의 인덱스를 반환한다.
	 * @return {Number} 현재 tab의 index를 반환함 (index는 0부터)
	 */
	getCurrentIndex : function() {
		return this._nCurrentIndex;
	},
	/**
	 * 현재 Tab의 페이지를 반환한다.
	 * @return {Number} 현재 tab의 현재 페이지를 반환함 (page수는 1부터)
	 */
	getCurrentPage : function() {
		return (this._nCurrentIndex + 1);
	},
	/**
	 * 현재 Tab을 반환
	 * @param {Number} nIdx 옵션 (index는 0부터)
	 * @return {HTMLElement, Array} index가 있을 경우, index에 해당하는 TAB HTMLElement반환
	 * 								index가 없을 경우, TAB HTMLElement 배열을 반환
	 * @example
	 *  var aTab = oComponent.getTab();
	 *  var elTab = oComponent.getTab(2);
	 */
	getTab : function(nIdx) {
		if(nIdx !== null && this._aTab.length > nIdx) {
			return this._aTab[nIdx];
		} else {
			return this._aTab;
		}
	},

	/**
	 * 현재 Panel을 반환
	 * @param {Number} nIdx 옵션 (index는 0부터)
	 * @return {HTMLElement, Array} index가 있을 경우, index에 해당하는 Panel HTMLElement반환
	 * 								index가 없을 경우, Panel HTMLElement 배열을 반환
	 * @example
	 *  var aPanel = oComponent.getPanel();
	 *  var elPanel = oComponent.getPanel(2);
	 */
	getPanel : function(nIdx) {
		if(nIdx !== null && this._aPanel.length > nIdx) {
			return this._aPanel[nIdx];
		} else {
			return this._aPanel;
		}
	},

	/**
	 * 탭을 선택했을 시, 이벤트 처리
	 * @param {Object} we
	 */
	_onSelect : function(we) {
		if(we.element) {
			we.stop();
			var welElement = MobileCommentJindo.$Element(we.element);
			var sClassName = this.option('sClassPrefix') + 'tab';
			if(this._htWElement["tab_container"].isParentOf(welElement) &&
				!welElement.hasClass(sClassName)){
				welElement = welElement.parent(function(v){
					return v.hasClass(sClassName);
				})[0];
			}
			var nIdx = this._htWElement["tab_container"].indexOf(welElement);
			if(nIdx > -1) {
				this.select(nIdx);
			}
		}
	},

	/**
	 * index에 해당하는 패널 선택
	 * @param {Object} nIdx
	 */
	select : function(nIdx) {
		if(nIdx !== null && this._aTab.length > nIdx &&
				(this._nCurrentIndex != nIdx)) {
			if (this._fireEventBeforeSelect()) {
				var sSelect = this.option('sClassPrefix') + "selected";
				if(this._nCurrentIndex > -1){
					this._aTab[this._nCurrentIndex].removeClass(sSelect);
					this._aPanel[this._nCurrentIndex].removeClass(sSelect);
				}
				this._aTab[nIdx].addClass(sSelect);
				this._aPanel[nIdx].addClass(sSelect);
				this._nCurrentIndex = nIdx;

				this._fireEventSelect();
			}
		}
	},

	/**
	 * BeforeSelect 사용자 이벤트 호출
	 */
	_fireEventBeforeSelect : function() {
		return this.fireEvent("beforeSelect", {
		 	nIndex : this._nCurrentIndex,
			elTab : this._aTab[this._nCurrentIndex],
		 	elPanel : this._aPanel[this._nCurrentIndex]
		});
	},


	/**
	 * Prev 사용자 이벤트 호출
	 */
	_fireEventSelect : function() {
		this.fireEvent("select", {
		 	nIndex : this._nCurrentIndex,
			elTab : this._aTab[this._nCurrentIndex],
		 	elPanel : this._aPanel[this._nCurrentIndex]
		});
	},

	/**
	 * @description  MobileCommentJindo.m.Tab 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy : function() {
		this.deactivate();
		this._detachEvent();

		for ( var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		this._htWElement = null;
	}
}).extend(MobileCommentJindo.UIComponent);
/**
* @(#)MobileCommentJindo.m.TextArea.js 2011. 9. 21.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sshyun
* @since 2011. 9. 21.
* @description
*/
MobileCommentJindo.m.TextArea = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.TextArea.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {Varient} el textarea 엘리먼트 또는 ID
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
	 */
	$init : function(el, htUserOption) {
		this.option({
			sClassPrefix	: "fta-",
			bActivateOnload : true,
			bUseRadius 		: false,
			sRadiusSize		: "0.5em",
			nExpandHeight	: 30,
			nMaxHeight		: -1
		});
		this.option(htUserOption || {});
		this._initVar();
		this._setWrapperElement(el);
		// 코너 곡선 여부 추가.
		if(this.option("bUseRadius")){
			this._applyRadiusStyle(this.option("sRadiusSize"));
		}
		if(this.option("bActivateOnload")) {
			this.activate();
		}
	},

	/**
	 * @description MobileCommentJindo.m.TextArea 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar : function() {
		this._nTimer = -1;
		this._bTouchTextArea = false;
		this._touchMoved = false;
	},

	/**
	 * @description MobileCommentJindo.m.TextArea 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 * @param {Varient} el textarea 엘리먼트 또는 ID
	 */
	_setWrapperElement : function(el) {
		this._htWElement = {};
		var sPrefix = this.option('sClassPrefix');
		el = (typeof el == "string" ? MobileCommentJindo.$(el) : el);
		this._htWElement["textarea"] = MobileCommentJindo.$Element(el);
	},
	/**
	 * @description 테두리 라운드 효과 설정.
	 * @param {String} sRadius 곡선 Radius 값.
	 */
	_applyRadiusStyle : function(sRadius){
		var sCssName = MobileCommentJindo.m.getCssPrefix() + "BorderRadius";
		var oCssProperty = {
			sCssName : sRadius,
			"borderRadius" : sRadius
		};
		this._htWElement["textarea"].css(oCssProperty);
		oCssFirstProperty = null;
	},

	/**
	 * @description MobileCommentJindo.m.TextArea 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this._attachEvent();
	},
	/**
	 * @description MobileCommentJindo.m.TextArea 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
		clearInterval(this._nTimer);
		this._nTimer = -1;
	},
	/**
	 * @description MobileCommentJindo.m.TextArea 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};
		var elTextArea = this._htWElement["textarea"].$value();
		this._htEvent["textarea_focus"] = {
			el  : elTextArea,
			ref : MobileCommentJindo.$Fn(this._onFocus, this).attach( elTextArea, "focus")
		};
		this._htEvent["textarea_blur"] = {
			el  : elTextArea,
			ref : MobileCommentJindo.$Fn(this._onBlur, this).attach( elTextArea, "blur")
		};

	},

	/**
	 * @description MobileCommentJindo.m.TextArea 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		for(var p in this._htEvent) {
			var ht = this._htEvent[p];
			ht.ref.detach(ht.el, p.substring(p.lastIndexOf("_")+1));
		}
		this._htEvent = null;
	},
	/**
	 * @description TextArea 에 Focus 이벤트 처리.
	 * @param {Object} we 이벤트 객체.
	 */
	_onFocus : function(we){
		if(this._nTimer > -1){
			return;
		}
		this._htWElement["textarea"].addClass(this.option('sClassPrefix') + "textarea-focus");
		this._nTimer = setInterval(MobileCommentJindo.$Fn(this._checkHeightAndExpand, this).bind(), 10);

		this.fireEvent("focus",{
			elTextArea : this._htWElement["textarea"].$value()
		});
	},
	/**
	 * @description TextArea 에 Blur 이벤트 처리.
	 * @param {Object} we 이벤트 객체.
	 */
	_onBlur : function(we){
		if (this._nTimer == -1) {
			return;
		}

		clearInterval(this._nTimer);
		this._nTimer = -1;
		this._htWElement["textarea"].removeClass(this.option('sClassPrefix') + "textarea-focus");
		this.fireEvent("blur",{
			elTextArea : this._htWElement["textarea"].$value()
		});
	},
	/**
	 * @description 텍스트 영역의 높이가 적으면, 확장한다.
	 */
	_checkHeightAndExpand : function() {
		if (this._hasEnoughHeight() === false) {
			this._expandHeight();
		}
	},

	/**
	 * @description 입력 상자의 크기가 현재 까지 입력된 글의 내용을 스크롤 없이 보여주기 충분한지를 체크한다.
	 * @private
	 */
	_hasEnoughHeight : function() {
		var elTextArea = this._htWElement["textarea"].$value();
		// 입력된 글영역의 높이(A) 측정
		// A 가 입력창 높이(B)를 초과하는지 체크
		if (elTextArea.scrollHeight > elTextArea.clientHeight) {
			return false;
		}
		return true;
	},
	/**
	 * @description 입력 상자의 높이를 늘인다.
	 * @private
	 */
	_expandHeight : function() {
		var elTextArea = this._htWElement["textarea"].$value();
		var nMaxHeight = this.option("nMaxHeight");
		var nExpandHeight = this.option("nExpandHeight");
		var nNewHeight = elTextArea.scrollHeight + nExpandHeight;

		if (nMaxHeight > 0 && nNewHeight >= nMaxHeight){
			elTextArea.style.height = nMaxHeight + "px";
		} else {
			elTextArea.style.height = elTextArea.scrollHeight + nExpandHeight + "px";
			this.fireEvent("expand",{
				elTextArea : this._htWElement["textarea"].$value()
			});
		}

	},
	/**
	 * @description TextArea 값을 반환.
	 * @return {String} TextArea value 값
	 * @example
	 *
	 * var sValue = oTextArea.getValue();
	 */
	getValue : function(){
		return this._htWElement["textarea"].$value().value;
	},
	/**
	 * @description TextArea 값을 입력.
	 * @param {String} sValue TextArea value 값
	 * @example
	 *
	 * var sValue = "test";
	 * oTextArea.getValue(sValue);
	 */
	setValue : function(sValue){
		this._htWElement["textarea"].$value().value = sValue;
		this._checkHeightAndExpand();
	},
	/**
	 * @description TextArea 값을 지움.
	 * @example
	 *
	 * oTextArea.deleteValue();
	 */
	deleteValue : function(){
		this._htWElement["textarea"].$value().value = "";
	},
	/**
	 * @description TextArea 활성화.
	 * @example
	 *
	 * oTextArea.enable();
	 */
	enable : function(){
		var elTextArea = this._htWElement["textarea"].$value();
		elTextArea.disabled = false;
		this._htWElement["textarea"].removeClass(this.option("sClassPrefix") + "textarea-disable");

		this.fireEvent("enable",{
			elTextArea : elTextArea
		});
	},
	/**
	 * @description TextArea 비활성화.
	 * @example
	 *
	 * oTextArea.enable();
	 */
	disable : function(){
		var elTextArea = this._htWElement["textarea"].$value();
		elTextArea.disabled = true;
		this._htWElement["textarea"].addClass(this.option("sClassPrefix") + "textarea-disable");
		this.fireEvent("disable",{
			elTextArea : elTextArea
		});
	},
	/**
	 * @description Textarea height 증가 크기값 설정
	 * @param {Number} nExpandHeight 증가 크기값
	 * @example
	 *
	 * oTextArea.setExpandHeight(50);
	 */
	setExpandHeight : function(nExpandHeight){
		this.option("nExpandHeight", nExpandHeight);
	},
	/**
	 * @description Textarea height 증가 크기값 반환
	 * @return {Number} 증가 크기값
	 * @example
	 *
	 * var nExpandHeight = oTextArea.getExpandHeight();
	 */
	getExpandHeight : function(){
		return this.option("nExpandHeight");
	},
	/**
	 * @description Textarea height 최대 크기값 설정
	 * @param {Number} nMaxHeight 최대 크기값
	 * @example
	 *
	 * oTextArea.setMaxHeight(200);
	 */
	setMaxHeight : function(nMaxHeight){
		this.option("nMaxHeight", nMaxHeight);
		var elTextArea = this._htWElement["textarea"].$value();
		if (nMaxHeight > 0 && elTextArea.scrollHeight >= nMaxHeight){
			elTextArea.style.height = nMaxHeight + "px";
		} else if (nMaxHeight > 0 && elTextArea.scrollHeight < nMaxHeight){
			elTextArea.style.height = elTextArea.scrollHeight + "px";
		}
	},
	/**
	 * @description Textarea height 최대 크기값 반환
	 * @return {Number} 최대 크기값
	 * @example
	 *
	 * var nMaxHeight = oTextArea.getMaxHeight();
	 */
	getMaxHeight : function(){
		return this.option("nMaxHeight");
	},
	/**
	 * @description  MobileCommentJindo.m.TextArea 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy : function() {
		this.deactivate();

		if (this._oTimer) {
			clearInterval(this._oTimer);
			this._oTimer = null;
		}

		for ( var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		this._htWElement = null;


		this._bTouchTextArea = null;
		this._touchMoved = null;
	}
}).extend(MobileCommentJindo.UIComponent);
/**
* @(#)MobileCommentJindo.m.ToggleSlider.js 2011. 9. 8.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author "oyang2"
* @since 2011. 9. 8.
* @description
*/

MobileCommentJindo.m.ToggleSlider = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.ToggleSlider.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
     */
	$init : function(sId, htUserOption) {
		this.option({
			sClassPrefix : 'tslider-',
			bUseDrag : true,
			bActivateOnload : true,
			nOnPosition : 50,
			nOffPosition: 0,
			bStatus : true
		});

		this.option(htUserOption || {});

		this._setWrapperElement(sId);
		this._initVar();

		if(this.option("bActivateOnload")) {
			this.activate();
			if(this.option('bStatus')){
				this.bStatusOn = false;
				this.on();
			}else{
				this.bStatusOn = true;
				this.off();
			}
		}
	},

	/**
	 * @description MobileCommentJindo.m.ToggleSlider 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar: function() {
		if(this._htWElement.track){
			this._oTouch = new MobileCommentJindo.m.Touch(this._htWElement.track.$value(),{
				nSlopeThreshold : 1,
				nMoveGap: 2,
				bActivateOnload: false
			});

			this._oTouch.attach({
				'touchMove' : MobileCommentJindo.$Fn(this._onMove, this).bind(),
				'touchEnd' : MobileCommentJindo.$Fn(this._onEnd, this).bind(),
				'touchStart' : MobileCommentJindo.$Fn(this._onStart, this).bind()
			});
		}else{
			this._oTouch = null;
		}

		this.bMove = false;
		//this.bStatusOn = this.option('bStatusOn');
		this.htInfo = {
			nMax : Math.max(this.option('nOnPosition'), this.option('nOffPosition')),
			nMin : Math.min(this.option('nOnPosition'), this.option('nOffPosition')),
			nGap  : Math.round(Math.abs((this.option('nOnPosition')-this.option('nOffPosition'))/2))
		};

	},

	/**
	 * @description MobileCommentJindo.m.ToggleSlider 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement: function(el) {
		this._htWElement = {};
		var el = MobileCommentJindo.$(el);

		var sClass = '.' + this.option('sClassPrefix');

		this._htWElement.base = MobileCommentJindo.$Element(el);

		var aRadio = el? MobileCommentJindo.$$('[name='+this.option('sClassPrefix')+'radio]', el): null;
		this._htWElement.aRadio = MobileCommentJindo.$A(aRadio).forEach(function(value, index,array){
			array[index] = MobileCommentJindo.$Element(value);
		}).$value();

		this._htWElement.track = el? MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle(sClass+'track', el)) : null;
		this._htWElement.thumb = el? MobileCommentJindo.$Element(MobileCommentJindo.$$.getSingle(sClass+'thumb', el)) : null;
	},

	_onStart : function(oCustomEvt){
		//하이라이팅 막아버리기
		oCustomEvt.oEvent.stop(MobileCommentJindo.$Event.CANCEL_DEFAULT);
	},
	_onMove : function(oCustomEvt){
		if(!this.option('bUseDrag')){ return;}

		oCustomEvt.oEvent.stop(MobileCommentJindo.$Event.DEFAULT);

		this.bMove = true;

		var nDis = oCustomEvt.nDistanceX;

		var n = this._getAdjustedPos(nDis);
		this._moveThumb(n);

	},

	_onEnd : function(oCustomEvt){
		if(oCustomEvt.sMoveType == 'tap'){
			this.toggle();
		}else{
			if(this.bMove){
				var nCurrent = this.isOn()? this.option('nOnPosition') : this.option('nOffPosition');
				var nPos = this._getPosition();
				if( Math.abs(nCurrent- nPos) > this.htInfo.nGap ){
					this.toggle();
				}else{
					this._move(this.isOn(), false);
				}

			}else{
				this.toggle();
			}
		}

		this.bMove = false;
	},

	_move : function(bOn ,bFireEvent){
		if(typeof bFireEvent == 'undefined'){
			bFireEvent = true;
		}

		var nDis = this.option('nOffPosition');

		if(bFireEvent){
			if(!this.fireEvent('beforeChange',{
				bOn : this.isOn()
			})){
				return false;
			}
		}

		if(bOn) {nDis = this.option('nOnPosition');}

		this._moveThumb(nDis, 100);
		if(bFireEvent){
			this.fireEvent('change',{
				bOn : bOn
			});
		}

		this.bStatusOn = bOn;

		this._updateForm();
	},

	/**
	 * 현재 상태값을 토글한다
	 */
	toggle : function(){
		if(this.isOn()){
			this.off();
		}else{
			this.on();
		}
	},

	/**
	 * 현재 상태값을 on으로 바꾼다
	 */
	on : function(){
		if(!this.isOn()){
			this._move(true);
		}
	},

	/**
	 * 현재 상태값을 off로 바꾼다
	 */
	off : function(){
		if(this.isOn()){
			this._move(false);
		}
	},

	/**
	 * 현재 상태이 on 인지 리턴한다
	 * @return {Boolean} on인지 여부
	 */
	isOn : function(){
		return this.bStatusOn;
	},

	_updateForm : function(){
		if(!this._htWElement.aRadio){ return;}
		var value = this.isOn()? 'on' : 'off';

		for(var i=0,nLen = this._htWElement.aRadio.length;i<nLen; i++){
			var wel = this._htWElement.aRadio[i];
			if(wel.$value().value == value){
				wel.$value().checked = true;
			}else{
				wel.$value().checked = false;
			}
		}
	},

	_moveThumb : function(n, nTime){
		if(n > this.htInfo.nMax || n < this.htInfo.nMin ){ return;}

		if(typeof nTime == 'undefined'){
			nTime = 0;
		}
		if(this._htWElement.thumb){
			this._htWElement.thumb.css('webkitTransitionDuration', nTime+'ms');
			this._htWElement.thumb.css('webkitTransitionProperty','left');
			this._htWElement.thumb.css('left' ,n+"%");
		}
	},

	_getAdjustedPos : function(nDis){

		var nPecent = Math.round((nDis * 100) / this._htWElement.track.width());

		nPecent = nPecent + (this.isOn()? this.option('nOnPosition') : this.option('nOffPosition'));

		nPecent = Math.max(this.htInfo.nMin, nPecent);
		nPecent = Math.min(this.htInfo.nMax, nPecent);

		return nPecent;
	},

	_getPosition : function(){
		var sPos = this._htWElement.thumb.css('left');

		return (sPos == "auto") ? 0 : parseInt(sPos, 10);
	},

	_onClick : function(evt){
		evt.stop();
	},

	/**
	 * @description MobileCommentJindo.m.ToggleSlider 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};
		// thumb click event 처리
		this._htEvent["click"] = {
			ref : MobileCommentJindo.$Fn(this._onClick, this).attach(this._htWElement.thumb, "click"),
			el	: this._htWElement.thumb
		};

	},

	/**
	 * @description 특정 이벤트를 해제한다.
	 * @param {String} sEventKey 이벤트 키
	 */
	_detachEvent : function(sEventKey) {
		if(sEventKey) {
			var htTargetEvent = this._htEvent[sEventKey];
			htTargetEvent.ref.detach(htTargetEvent.el, sEventKey);
		}
	},

	/**
	 * @description MobileCommentJindo.m.ToggleSlider 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this._attachEvent();
		if(this._oTouch){
			this._oTouch.activate();
		}
	},

	/**
	 * @description MobileCommentJindo.m.ToggleSlider 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
		if(this._oTouch){
			this._oTouch.deactivate();
		}
	},

	/**
	 * @description  MobileCommentJindo.m.ToggleSlider 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy: function() {
		this.deactivate();

		for(var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		this._htWElement = null;

		this._oTouch.detachAll();
		this._oTouch = null;

		this.bMove = null;
		this.bStatusOn = null;

	}
}).extend(MobileCommentJindo.UIComponent);
/**
* @(#)MobileCommentJindo.m.ExpandEffect.js 2011. 12. 15.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author "oyang2"
* @since 2011. 12. 15.
* @description
*/

MobileCommentJindo.m.ExpandEffect = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.ExpandEffect.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @extends MobileCommentJindo.m.Effect
	 * @requires MobileCommentJindo.m.LayerEffect
	 */
	sEffectName : "expand",

	getCommand : function(el, htOption){
		var sDirection = htOption.sDirection? htOption.sDirection :'down';

		var sProperty = 'width';
		var nSize = this._htLayerInfo["nWidth"];

		if(sDirection == 'up' || sDirection == 'down'){
			sProperty = 'height';
			nSize = this._htLayerInfo["nHeight"];
		}

		var htStyle = htOption.htTo || {};
		htStyle[sProperty] = nSize+"px";

		if(sDirection == 'left'){
			htStyle["margin-left"] = this._htLayerInfo["nMarginLeft"]+"px";
		}

		if(sDirection == 'up'){
			htStyle["margin-top"] = this._htLayerInfo["nMarginTop"]+"px";
		}

		return {
			sTaskName : this.sEffectName+"-"+sDirection ,
			htStyle : htStyle,
			htTransform : {}
		};
	},

	getBeforeCommand : function(el, htOption){
		var sDirection = htOption.sDirection? htOption.sDirection :'down';

		var sProperty = 'width';

		if(sDirection == 'up' || sDirection == 'down'){
			sProperty = 'height';
		}

		var htBeforeStyle = htOption.htFrom || {};
		htBeforeStyle[sProperty] = "0";
		htBeforeStyle["overflow"] = "hidden";

		if(sDirection == 'left'){
			htBeforeStyle["margin-left"] = (this._htLayerInfo["nWidth"] + this._htLayerInfo["nMarginLeft"])+"px";
		}

		if(sDirection == 'up'){
			htBeforeStyle["margin-top"] = (this._htLayerInfo["nHeight"] +this._htLayerInfo["nMarginTop"]) +"px";
			//console.log(htBeforeStyle);
		}

		return {
			htStyle : htBeforeStyle ,
			htTransform : {}
		};
	}

}).extend(MobileCommentJindo.m.Effect);
/**
* @(#)MobileCommentJindo.m.TextInput.js 2011. 11. 23.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sculove
* @since 2011. 11. 23.
* @description
*
* <1.0.0 이후 변경사항>
* 1. 버그 수정
*  : validate 이후 값이 변경되어 input 값이 없을 경우, 삭제 버튼이 지워지지 않응 오류 수정
* 2. android 3.x, 4.x 대응
*  : android 3.x는 삭제후 소프트 키보드가 올라오지 않는 이슈 존재
*    android 3.x, 4.x 마크업 이슈 존재  (http://devcafe.nhncorp.com/mobilewebsource/549141)
*/
MobileCommentJindo.m.TextInput = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.TextInput.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @param {Varient} el Input Box 기준 엘리먼트
	 * @param {HashTable} htUserOption 추가 옵션 (생략가능)
	 * @extends MobileCommentJindo.UIComponent
	 */
	$init : function(el, htUserOption) {
		this.option({
			sClassPrefix	: "fit-",
			bUseValidate : false,
			bActivateOnload : true
		});
		this.option(htUserOption || {});
		this._initVar();
		this._setWrapperElement(el);
		this._init();

		if(this.option("bActivateOnload")) {
			this.activate();
		}
	},

	$static : {
		INDEX_ATTR : "data-index",
		VALIDATE_ATTR : "data-validate"
	},

	/**
	 * @description MobileCommentJindo.m.TextInput 에서 사용하는 모든 인스턴스 변수를 초기화한다.
	 */
	_initVar : function() {
		this._aTextInput = [];
		this._sPreValue = null;
		this._nWatcher = null;
		this._sClickEvent = (MobileCommentJindo.m.getDeviceInfo().iphone || MobileCommentJindo.m.getDeviceInfo().ipad || MobileCommentJindo.m.getDeviceInfo().android) ? "touchstart" : "mousedown";
		this._nFocusTimer = null;
		this._nBlurTimer = null;
	},

	/**
	 * @description MobileCommentJindo.m.TextInput 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
	 */
	_setWrapperElement : function(el) {
		this._htWElement = {};
		this._htWElement["baseElement"] = MobileCommentJindo.$Element(el);
	},

	/**
	 * @description
	 */
	_init : function() {
		var welUnit, welInput, welDel, sValidate, aBaseList, aValidate = [];
		aBaseList = this._htWElement["baseElement"].queryAll("." + this.option("sClassPrefix") + "textinput-unit");
		for(var i=0, nLength=aBaseList.length; i<nLength; i++) {
			 // Unit 지정
			 welUnit = MobileCommentJindo.$Element(aBaseList[i]);
			 welUnit.attr(MobileCommentJindo.m.TextInput.INDEX_ATTR, i).css("position" , "relative");
			 // Input 지정
			 welInput = MobileCommentJindo.$Element(welUnit.query("input"));
			 welInput.attr(MobileCommentJindo.m.TextInput.INDEX_ATTR, i);
			 // Del 지정
			 welDel = welUnit.query("." + this.option("sClassPrefix") + "clear-btn");
			 if(welDel) {
			 	welDel = MobileCommentJindo.$Element(welDel);
			 	welDel.attr(MobileCommentJindo.m.TextInput.INDEX_ATTR, i).css({
			 		"position" : "absolute",
			 		"zIndex" : 100,
			 		"cursor" : "pointer"	,
			 		"right" : "0px",
			 		"top" : "0px"
			 	}).hide();
			 }
			 this._aTextInput.push({
			 	welUnit : welUnit,
			 	welInput : welInput,
			 	welDel : welDel
			 });
		}
	},

	/**
	 * @description MobileCommentJindo.m.TextInput 에서 사용하는 모든 이벤트를 바인드한다.
	 */
	_attachEvent : function() {
		this._htEvent = {};
		this._htEvent["focus"] = MobileCommentJindo.$Fn(this._onFocus, this);
		this._htEvent["blur"] = MobileCommentJindo.$Fn(this._onBlur, this);
		this._htEvent["clear"] = MobileCommentJindo.$Fn(this._onClear, this);
		for(var i=0, nLength=this._aTextInput.length; i<nLength; i++) {
			this._attachUnitEvent(this._aTextInput[i]);
		}
	},

	/**
	 * @description input단위 이벤트 attach
	 */
	_attachUnitEvent : function(htUnit) {
		this._htEvent["focus"].attach(htUnit.welInput, "focus");
		this._htEvent["blur"].attach(htUnit.welInput, "blur");
		if(htUnit.welDel) {
			this._htEvent["clear"].attach(htUnit.welDel, this._sClickEvent);
		}
	},

	/**
	 * @description MobileCommentJindo.m.TextInput 에서 사용하는 모든 이벤트를 해제한다.
	 */
	_detachEvent : function() {
		for(var i=0, nLength=this._aTextInput.length; i<nLength; i++) {
			this._detachUnitEvent(this._aTextInput[i]);
		}
		for(var p in this._htEvent ) {
			this._htEvent[p] = null;
		}
		this._htEvent = null;
	},

	/**
	 * @description input단위 이벤트 detach
	 */
	_detachUnitEvent : function(htUnit) {
		this._htEvent["focus"].detach(htUnit.welInput, "focus");
		this._htEvent["blur"].detach(htUnit.welInput, "blur");
		if(htUnit.welDel) {
			this._htEvent["clear"].detach(htUnit.welDel, this._sClickEvent);
		}
	},

	/**
	 * @description 'X' 버튼 활성화 처리.
	 * @param {MobileCommentJindo.$Element} welInput input $Element 객체.
	 */
	_displayClearBtn : function(welInput){
		var nIdx = this.getIndex(welInput),
			welClearBtn = this._aTextInput[nIdx].welDel;

		// 버튼이 없다면 ...
		if(!welClearBtn) {
			return;
		}
		// 버튼 제어
		if(MobileCommentJindo.$S(welInput.$value().value).trim() != "") {
			if(!welClearBtn.visible() && this.fireEvent("beforeShowClearBtn", {
					nIndex : nIdx,
					welClearBtn : welClearBtn
				})) {
				welClearBtn.show();
				this.fireEvent("showClearBtn", {
					nIndex : nIdx,
					welClearBtn : welClearBtn
				});
			}
		} else {
			if(welClearBtn.visible() && this.fireEvent("beforeHideClearBtn", {
					nIndex : nIdx,
					welClearBtn : welClearBtn
				})) {
				welClearBtn.hide();
				this.fireEvent("hideClearBtn", {
					nIndex : nIdx,
					welClearBtn : welClearBtn
				});
			}
		}
	},

	/**
	 * @description validatie 한다
	 * @param {MobileCommentJindo.$Element} welInput input $Element 객체.
	 */
	_validate : function(welInput) {
		var sValidate = welInput.attr(MobileCommentJindo.m.TextInput.VALIDATE_ATTR);
		if(!sValidate) {
			return;
		}
		var sValue = welInput.$value().value,
			htResult = MobileCommentJindo.m.Validation.validate(sValidate, sValue),
			nIdx=this.getIndex(welInput);
		if(htResult) {
			// valid가 유효하지 않을 경우, 값을 수정함 (?)
			if(typeof htResult.sCorrectedValue !== "undefined" && htResult.sCorrectedValue !== null) {
				// if(MobileCommentJindo.m.getDeviceInfo().iphone || MobileCommentJindo.m.getDeviceInfo().ipad) {
					// // ios 버그....
					// if(welInput.$value().value.indexOf(htResult.sCorrectedValue) != -1) {
						// var sTmp = htResult.sCorrectedValue.substr(welInput.$value().value.length);
						// if(this._checkUnicode(sTmp)) {
							// htResult.sCorrectedValue += " ";
						// }
					// }
					// welInput.$value().value =  this._sPreValue = htResult.sCorrectedValue;
				// } else {
					welInput.$value().value =  this._sPreValue = htResult.sCorrectedValue;
			//	}
			}
			// console.log("Validation Result : " + htResult.bValid + ", sCorrectedValue : " + htResult.sCorrectedValue);
			this.fireEvent( (htResult.bValid ? "valid" : "invalid"), {
				htValidate : htResult,
				htTextInput : this._aTextInput[nIdx],
				nIndex : nIdx
			});
		}
	},

	/**
	 * @description TextInput Box  에서 Focus 이벤트 처리.
	 * android일 경우, fouce가 2번 타는 문제 발생함
	 *
	 * @param {MobileCommentJindo.$Event} we 이벤트 객체.
	 */
	_onFocus : function(we){
		var nIdx = this.getIndex(we.element);
		var self=this;
		if(MobileCommentJindo.m.getDeviceInfo().android) {
			clearTimeout(this._nFocusTimer);
			this._nFocusTimer = setTimeout(function() {
				self._processFocus(nIdx);
			},100);
		} else {
			self._processFocus(nIdx);
		}
	},

	/**
	 * @description Focus 이벤트 발생시 처리하는 모듈
	 * @param {Number} nIdx 감시할 Element의 idx
	 */
	_processFocus : function(nIdx) {
		var htTextInput = this._aTextInput[nIdx];
		var welTextInputUnit = htTextInput.welUnit;
		var sCssName = this.option("sClassPrefix") + "focus";
		if(!welTextInputUnit.hasClass(sCssName)) {
			welTextInputUnit.addClass(sCssName);
		}
		// 입력값 변경을 감시할 Watcher 실행
		this._runWatcher(htTextInput.welInput);
		// focus 사용자 이벤트 발생
		this.fireEvent("focus", {
			nIndex : nIdx,
			htTextInput : htTextInput
		});
	},

	/**
	 * @description TextInput Box  에서 Blur 이벤트 처리.
	 * @param {MobileCommentJindo.$Event} we 이벤트 객체.
	 */
	_onBlur : function(we){
		var nIdx = this.getIndex(we.element);
		var self=this;
		if(MobileCommentJindo.m.getDeviceInfo().android) {
			clearTimeout(this._nBlurTimer);
			this._nBlurTimer = setTimeout(function() {
				self._processBlur(nIdx);
			},100);
		} else {
			self._processBlur(nIdx);
		}
	},

	/**
	 * @description Blur 이벤트 발생시 처리하는 모듈
	 * @param {Number} nIdx 감시할 Element의 idx
	 */
	_processBlur : function(nIdx) {
		this._aTextInput[nIdx].welUnit.removeClass(this.option("sClassPrefix") + "focus");
		// 입력값 변경을 감시할 Watcher 중지
		this._stopWatcher();
		if(this.option("bUseValidate")) {
			var welInput = this._aTextInput[nIdx].welInput;
			this._validate(welInput);
			this._displayClearBtn(welInput);
		}
		this.fireEvent("blur", {
			nIndex : nIdx,
			htTextInput : this._aTextInput[nIdx]
		});
	},

	/**
	 * @description 'X' 버튼 이벤트 처리.
	 * @param {MobileCommentJindo.$Event} we 이벤트 객체.
	 */
	_onClear : function(we){
		//console.log("클리어...");
		var welBtn = MobileCommentJindo.$Element(we.element)
			nIndex = this.getIndex(welBtn),
			welInput = this._aTextInput[nIndex].welInput,
			htInfo = MobileCommentJindo.m.getDeviceInfo(),
			nVersion = parseInt(htInfo.version,10);
		welInput.$value().value = "";

		/**
		 * Android 3.x는 input값이 변경되는 경우, focus가 벗어나야 정상적으로 화면에 출력됨
		 * 따라서, 할당된 이벤트를 제거후, blur를 주고, focus를 준 후, 다시 이벤트를 할당하여, 정상적으로 동작하도록 수정함.
		 * 단, 삭제 후에 키패드가 사라지는 오류 발생
		 */
		if(htInfo.android && nVersion === 3) {
			this._detachUnitEvent(this._aTextInput[nIndex]);
			welInput.$value().blur();
			welInput.$value().focus();
			this._attachUnitEvent(this._aTextInput[nIndex]);
		} else {
			/**
			 * ios는 한글 자소 입력시 문제가 됨. "소" 입력후, 삭제버튼 클릭. 그 후 "ㅅ" 입력하면 "솟"으로 나옴
			 * 단, ios5이상은 처리 가능함.
			 */
			if(!htInfo.android && nVersion > 4) {
				welInput.$value().blur();
				welInput.$value().focus();
			}
		}
		this._displayClearBtn(welInput);
		this.fireEvent("clear", {
			nIndex : nIndex,
			htTextInput : this._aTextInput[nIndex]
		});
		/* TODO 에이.. 스크롤 확인.. 정말 Cancel_all해야만 하는가?*/
		we.stop(MobileCommentJindo.$Event.CANCEL_ALL);
		return false;
	},

	/**
	 * @description Watcher를 실행한다
	 * @param {MobileCommentJindo.$Element} welInput
	 */
	_runWatcher : function(welInput) {
		var self = this,
			sValue = null;
		this._stopWatcher();
		this._nWatcher = setInterval( function() {
			self._onChange(welInput);
		}, 100);
	},

	/**
	 * @description Watcher를 제거한다.
	 */
	_stopWatcher : function() {
		clearInterval(this._nWatcher);
		this._nWatcher = null;
		this._sPreValue = null;
	},

	/**
	 * @description TextInput Box  에서 입력값 변경시 처리.
	 * @param {MobileCommentJindo.$Element} welInput 모니터링할 input 객체
	 */
	_onChange : function(welInput){
		//console.log("값이 변경되었나?");
		var sValue = welInput.$value().value;
		if(this._sPreValue != sValue) {
			//console.log("값이 변경되었음...");
			this._sPreValue = sValue;
			this.fireEvent("change", {
				sPreValue : sValue,
				welInput : welInput,
				nIndex : this.getIndex(welInput)
			});
			this._displayClearBtn(welInput);
		} else {
			//console.log("값이 변화없음.");
			this._displayClearBtn(welInput);
		}
	},

	/**
	 * @description TextInput Unit 엘리먼트 배열을 반환
	 * @param {Variant} vElement index를 찾을 TextInput Unit Element.
	 * @return {Array} MobileCommentJindo.$Element의 배열
	 */
	_getTextInputList : function(vElement){
		var aTextInputUnit = [];
		if(vElement) {
			if(vElement instanceof Array) {
				for(var i=0, nLength = vElement.length; i<nLength; i++) {
					aTextInputUnit.push(MobileCommentJindo.$Element(vElement[i]));
				}
			} else {
				aTextInputUnit.push(MobileCommentJindo.$Element(vElement));
			}
		} else {
			for(var i=0, nLength = this._aTextInput.length; i<nLength; i++) {
				aTextInputUnit.push(this._aTextInput[i].welUnit);
			}
		}
		return aTextInputUnit;
	},

	/**
	 * @description 활성화 비활성화 OS별 설정.
	 * @param {Variant} vElement  활성화 / 비활성화 하는 TextInput Unit Element.
	 * @param {boolean} 활성화 / 비활성화 여부
	 * @return {[type]}
	 */
	 _useSettingUnit : function(vElement, bUse){
		var self = this;
		// Andorid인 경우 watcher가 돌고 있을 경우(즉, 포커스가 있는 경우), 포커스가 있는 input의 삭제버튼이 사라지지 않는 문제가 있었음
		this._stopWatcher();
		var aTextInputUnit = this._getTextInputList(vElement);
		if(MobileCommentJindo.m.getDeviceInfo().android) {
			setTimeout(function() {
				self._useSettingUnitCore(aTextInputUnit, bUse);
			},100);
		} else {
			self._useSettingUnitCore(aTextInputUnit, bUse);
		}
	},

	/**
	 * @description 활성화 비활성화 설정.
	 * @param {aTextInputUnit} aTextInputUnit  활성화 / 비활성화 하는 TextInput Unit Element.
	 * @param {boolean} 활성화 / 비활성화 여부
	 */
	_useSettingUnitCore : function(aTextInputUnit, bUse){
		for (var i = 0, nLength = aTextInputUnit.length ; i < nLength ; i++) {
			if(bUse) {
				this._enableElement(aTextInputUnit[i]);
			} else {
				this._disableElement(aTextInputUnit[i]);
			}
		}
		this.fireEvent( (bUse ? "enable" : "disable"),{
			aTextInputUnit: aTextInputUnit
		});
	},

	/**
	 * @description 활성화 처리.
	 * @param {MobileCommentJindo.$Element} 활성화 TextInput Unit
	 */
	_enableElement : function(welUnit){
		var nIdx = this.getIndex(welUnit),
			welInput = this._aTextInput[nIdx].welInput;
		this._detachUnitEvent(this._aTextInput[nIdx]);
		this._attachUnitEvent(this._aTextInput[nIdx]);
		welUnit.removeClass(this.option("sClassPrefix") + "disable");
		welInput.$value().disabled = false;
		this._displayClearBtn(welInput);
	},

	/**
	 * @description 비활성화 처리.
	 * @param {MobileCommentJindo.$Element} 활성화 TextInput Unit
	 */
	_disableElement : function(welUnit){
		var nIdx = this.getIndex(welUnit),
			welInput = this._aTextInput[nIdx].welInput,
			welDel = this._aTextInput[nIdx].welDel;
		this._detachUnitEvent(this._aTextInput[nIdx]);
		welUnit.addClass(this.option("sClassPrefix") + "disable");
		welInput.$value().disabled = true;
		if(welDel){
			welDel.hide();
		}
	},

	/**
	 * @description TextInput 을 활성화 시킨다.
	 * @param {Variant} vElement 활성화 할 TextInput Unit Element.
	 * TextInput Unit 엘리먼트 배열 또는 단일 TextInput Unit 엘리먼트가 입력 될수 있고,
	 * 입력값이 없을시 모든 TextInput Unit 엘리먼트가 기준이 된다.
	 * @example
	 * // 배열 활성화
	 * oTextInput.enable([MobileCommentJindo.$("unit1"),MobileCommentJindo.$("unit2")]);
	 * // 단일 활성화
	 * oTextInput.enable(MobileCommentJindo.$("unit1"));
	 * // 전체 활성화
	 * oTextInput.enable();
	 *
	 */
	enable : function(vElement){
		if(this.isActivating()) {
			this._useSettingUnit(vElement, true);
		}
	},

	/**
	 * @description TextInput 을 비활성화 시킨다.
	 * @param {Variant} vElement 비활성화 할 TextInput Unit Element.
	 * TextInput Unit 엘리먼트 배열 또는 단일 TextInput Unit 엘리먼트가 입력 될수 있고,
	 * 입력값이 없을시 모든 TextInput Unit 엘리먼트가 기준이 된다.
	 * @example
	 * // 배열 비활성화
	 * oTextInput.disable([MobileCommentJindo.$("unit1"),MobileCommentJindo.$("unit2")]);
	 * // 단일 비활성화
	 * oTextInput.disable(MobileCommentJindo.$("unit1"));
	 * // 전체 비활성화
	 * oTextInput.disable();
	 *
	 */
	disable : function(vElement){
		if(this.isActivating()) {
			this._useSettingUnit(vElement, false);
		}
	},

	/**
	 * @description index 번호로 TextInput Unit Element 를 반환한다.
	 * @param {Number} nIdx 가져올 index 번호.
	 * @return {MobileCommentJindo.$Element} TextInput Unit Element 객체
	 * @example
	 *
	 *  // 0번째 TextInput Unit Element 가져오기.
	 *  var welUnit = oTextInput.getElement(0);
	 */
	getElement : function(nIdx){
		if(nIdx < this._aTextInput.length && nIdx >= 0) {
			return this._aTextInput[nIdx].welUnit;
		}
	},

	/**
	 * @description index 번호로 TextInput Input Element 를 반환한다.
	 * @param {Number} nIdx 가져올 index 번호.
	 * @return {MobileCommentJindo.$Element} TextInput Input Element 객체
	 * @example
	 *
	 *  // 0번째 TextInput Input Element 가져오기.
	 *  var welInput = oTextInput.getInputElement(0);
	 */
	getInputElement : function(nIdx) {
		if(nIdx < this._aTextInput.length && nIdx >= 0) {
			return this._aTextInput[nIdx].welInput;
		}
	},

	/**
	 * @description index 번호로 TextInput Del Element 를 반환한다.
	 * @param {Number} nIdx 가져올 index 번호.
	 * @return {MobileCommentJindo.$Element} TextInput Del Element 객체
	 * @example
	 *
	 *  // 0번째 TextInput Del Element 가져오기.
	 *  var welDel = oTextInput.getDelElement(0);
	 */
	getDelElement : function(nIdx) {
		if(nIdx < this._aTextInput.length && nIdx >= 0) {
			return this._aTextInput[nIdx].welDel;
		}
	},

	/**
	 * @description index 번호를 반환한다.
	 * @param {MobileCommentJindo.$Element, Element, String} nIdx 가져올 엘리먼트
	 * @return {Number} TextInput Index
	 */
	getIndex : function(ele) {
		return parseInt(MobileCommentJindo.$Element(ele).attr(MobileCommentJindo.m.TextInput.INDEX_ATTR),10);
	},

	/**
	 * @description TextInput Unit 개수를 반환
	 * @return {Number}
	 */
	getLength : function() {
		return this._aTextInput.length;
	},

	/**
	 * @description MobileCommentJindo.m.Tab 컴포넌트를 활성화한다.
	 * activate 실행시 호출됨
	 */
	_onActivate : function() {
		this._attachEvent();
	},
	/**
	 * @description MobileCommentJindo.m.Tab 컴포넌트를 비활성화한다.
	 * deactivate 실행시 호출됨
	 */
	_onDeactivate : function() {
		this._detachEvent();
		this._stopWatcher();
	},
	/**
	 * @description  MobileCommentJindo.m.TextInput 에서 사용하는 모든 객체를 release 시킨다.
	 */
	destroy : function() {
		this.deactivate();
		for ( var p in this._htWElement) {
			this._htWElement[p] = null;
		}
		this._htWElement = null;
	}
}).extend(MobileCommentJindo.UIComponent);
/**
* @(#)MobileCommentJindo.m.Validation.js 2011. 11. 23.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sculove
* @since 2011. 11. 23.
* @description
*/
MobileCommentJindo.m.Validation = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.Validation.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 */
	$init : function() {},

	$static : {
		_htValidator : {},
		_htValidatorType : {
			"email" : "MobileCommentJindo.m.EmailValidator",
			"url" : "MobileCommentJindo.m.UrlValidator",
			"tel" : "MobileCommentJindo.m.TelValidator",
			"date" : "MobileCommentJindo.m.DateValidator",
			"number" : "MobileCommentJindo.m.NumberValidator",
			"currency" : "MobileCommentJindo.m.CurrencyValidator",
			"require" : "MobileCommentJindo.m.RequireValidator"
		},

		/**
		 * @description sType에 맞는 Validatior를 생성한다.
		 */
		_createValidator : function(sType) {
			if(MobileCommentJindo.m.Validation._htValidatorType[sType] && !MobileCommentJindo.m.Validation._htValidator[sType]) {
				//console.log("객체 생성 : new " + MobileCommentJindo.m.Validation._htValidatorType[sType] + "()");
				MobileCommentJindo.m.Validation._htValidator[sType] = eval("new " + MobileCommentJindo.m.Validation._htValidatorType[sType] + "()");
			}
		},

		/**
		 * @static
		 * @description sType의 Validatior를 추가 또는 갱신한다.
		 * @param {String} sType validatior 타입
		 * @param {String} sClassName validatior 클래스명
		 */
		add : function(sType, sClassName) {
			MobileCommentJindo.m.Validation._htValidatorType[sType] = sClassName;
		},

		/**
		 * @static
		 * @description sType의 Validatior 를 삭제한다.
		 * @param {String} sType validatior 타입
		 */
		remove : function(sType) {
			delete MobileCommentJindo.m.Validation._htValidatorType[sType];
		},

		/**
		 * @description validation문자열을 분석하여 HashTab로 결과를 반환한다
		 * parse 된 Validation Type은 자동으로 Validator를 생성한다.
		 * @param {String} sValidate validation문자열
		 * @return {HashTable} htValidateData key : value = "Validator타입" : sFormat""
		 */
		_parse : function(sValidate) {
			var aValidate = sValidate.split(";");
			var sType, sValue, htValidateData = {};
			for(var i=0, nLength = aValidate.length; i<nLength; i++) {
				var aTemp = aValidate[i].split(":");
				if(aTemp) {
					sType = aTemp[0];
					sValue = aTemp.length >1 ? aTemp[1] : null;
					htValidateData[sType] = htValidateData[sType] || sValue;
					// static으로 Validator들 생성하여 저장
					MobileCommentJindo.m.Validation._createValidator(sType);
				}
			}
			return htValidateData;
		},

		/**
		 *  @description sValidate에 대해 Validation 한다.
		 * @static
		 * @param {String} sValidate validation문법
		 * @param {String} sValue validate할 문장,내용
		 * @param {HashTable} {bValid : 성공여부, sCorrectedValue : 수정된 값, sPreValue : 이전 값, sType : validation type}
		 */
		validate : function(sValidate, sValue) {
			var htResult, htValidateData = MobileCommentJindo.m.Validation._parse(sValidate);

			/** require인 경우 예외처리*/
			if("require" in htValidateData) {
				htResult = MobileCommentJindo.m.Validation._htValidator["require"].validate(sValue);
				if(!htResult.bValid) {
					return {
						bValid : false,
						sType : "require",
						sPreValue : sValue
					};
				} else {
					delete htValidateData["require"];
				}
			}
			/* 값이 없는 경우 null */
			if(MobileCommentJindo.$S(sValue).trim() == "") {
				return null;
			}
			for(var sType in htValidateData) {
				htResult = MobileCommentJindo.m.Validation._htValidator[sType].validate(sValue, htValidateData[sType]);
				if(!htResult.bValid) {
					htResult.sType = sType;
					htResult.sPreValue = sValue;
					return htResult;
				}
			}
			htResult.bValid = true;
			htResult.sPreValue = sValue;
			return htResult;
		}
	}
});
/**
* @(#)MobileCommentJindo.m.CurrencyValidator.js 2011. 12. 14.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sculove
* @since 2011. 12. 14.
* @description
*/
MobileCommentJindo.m.CurrencyValidator = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.CurrencyValidator.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @extends MobileCommentJindo.m.Validator
	 * @requires MobileCommentJindo.m.NumberValidator
	 */
	rx :  /^[+-]?[^\s\t\v\d]+(\d{1,3},)?(\d{3},)*(\d)+(\.\d+)?$/,

	_getCorrectedValue : function(sValue, sFormat) {
		// 숫자 형식 필터링, 콤마적용
		sValue = this._applyComma(this._filterNumber(sValue));
		sFormat = sFormat || "\\";
		sValue = ( sValue.charAt(0) === "-" ?  "-" + sFormat + sValue.substring(1) : sFormat + sValue );
		return sValue;
	}

}).extend(MobileCommentJindo.m.NumberValidator);
/**
* @(#)MobileCommentJindo.m.DateValidator.js 2011. 11. 23.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sculove
* @since 2011. 11. 23.
* @description
*/
MobileCommentJindo.m.DateValidator = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.DateValidator.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @extends MobileCommentJindo.m.Validator
	 */

	_isValid : function(sValue, sFormat) {
		sFormat = sFormat || "yyyy-mm-dd";
		sValue = sValue.replace(/[\.-]/g,"");
		var sFormatData = sFormat.replace(/[\d\.-]/g,""),
			nYear = sValue.substr(sFormatData.indexOf("yyyy"),4) * 1,
			nMonth = sValue.substr(sFormatData.indexOf("mm"),2) * 1,
			nDay = sValue.substr(sFormatData.indexOf("dd"),2) * 1;
		//console.log("년도 : " + nYear + ":"+ nMonth + ":"+ nDay + "==" + sValue + "__" + sFormatData.length+ "__" + sValue.length);
		if((nMonth >= 1 && nMonth <= 12) && (nDay >= 1 && nDay <= 31) && (nYear >= 1000)) {
			return true;
		}
		return false;
	},

	_getCorrectedValue : function(sValue, sFormat) {
		sFormat = sFormat || "yyyy-mm-dd";
		var sFormatData = sFormat.replace(/[\d\.-]/g,"");

		// 불필요한 문자 제거
		sValue = sValue.replace(/[^\d]/g,"").substr(0,sFormatData.length);
		if(sValue.length >= (sFormatData.length-1) ) {
			sValue = this._getFormatted(sValue, sFormat);
		}
		return sValue;
	},

	/**
	 * @description 입력 문자열을 지정한 date 포맷 값으로 변경.
	 * @param {String} sFormat 포맷 형식.
	 * @param {String} sDateStr 포맷 변경 문자열.
	 */
	_getFormatted : function(sDateStr, sFormat){
		var sFormatData = sFormat.replace(/[\.-]/g,""),
			sYear = sDateStr.substr(sFormatData.indexOf("yyyy"),4),
			sMonth = sDateStr.substr(sFormatData.indexOf("mm"),2),
			sDay = sDateStr.substr(sFormatData.indexOf("dd"),2);
		return sFormat.replace(/(yyyy|mm|dd)/gi,
	        function($1){
	            switch ($1){
	                case 'yyyy': return sYear;
	                case 'mm': return sMonth;
	                case 'dd':   return sDay;
	            }
	        }
	    );
	}
}).extend(MobileCommentJindo.m.Validator);
/**
* @(#)MobileCommentJindo.m.EmailValidator.js 2011. 11. 23.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sculove
* @since 2011. 11. 23.
* @description
*/
MobileCommentJindo.m.EmailValidator = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.EmailValidator.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @extends MobileCommentJindo.m.Validator
	 */
	rx : /^(([\w-]+\.)+[\w-]+|([a-zA-Z]{1}|[\w-]{2,}))@((([0-1]?[0-9]{1,2}|25[0-5]|2[0-4][0-9])\.([0-1]?[0-9]{1,2}|25[0-5]|2[0-4][0-9])\.([0-1]?[0-9]{1,2}|25[0-5]|2[0-4][0-9])\.([0-1]?[0-9]{1,2}|25[0-5]|2[0-4][0-9])){1}|([a-zA-Z]+[\w-]+\.)+[a-zA-Z]{2,4})$/,

	/**
	 * @description 유효성 검증
	 * @param sValue 검증할 메일주소
	 */
	_isValid : function(sValue) {
		if(this.rx.test(sValue)) {
			return true;
		} else {
			return false;
		}
	},

 	/**
	 * @description 유효문자로 변경
	 * @param sValue 검증할 메일주소
	 */
	_getCorrectedValue : function(sValue){
		sValue = sValue.replace(/[^\w\.\@]/g,"").replace(/\.{2,}/g,".");
		var aEmail = sValue.split("@");
		if(aEmail.length > 2) {
			sValue = aEmail.shift() + "@" + aEmail.join("");
		}
		return sValue;
	}
}).extend(MobileCommentJindo.m.Validator);
/**
* @(#)MobileCommentJindo.m.RequireValidator.js 2011. 11. 23.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sculove
* @since 2011. 11. 23.
* @description
*/
MobileCommentJindo.m.RequireValidator = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.RequireValidator.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @extends MobileCommentJindo.m.Validator
	 */
	/**
	 * @description validate 한다.
	 * @return {HashTable}  {bValid, sPreValue, sType, sCorrectedValue}
	 */
	validate : function(sValue) {
		sValue = MobileCommentJindo.$S(sValue).trim();
		var htResult = {
			bValid : false,
			sCorrectedValue : null
		};
		htResult.bValid = sValue != "" ? true : false;
		return htResult;
	}
}).extend(MobileCommentJindo.m.Validator);
/**
* @(#)MobileCommentJindo.m.TelValidator.js 2011. 11. 23.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sculove
* @since 2011. 11. 23.
* @description
*/
MobileCommentJindo.m.TelValidator = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.TelValidator.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @extends MobileCommentJindo.m.Validator
	 */
	rx : /^(\d{2,3})(\d{3,4})(\d{4})$/,

	_isValid : function(sValue) {
		sValue = sValue.replace(/[^\d]/g, "");
		if(this.rx.test(sValue)) {
			var nLength = sValue.length,
				bResult = false;
			if(sValue.charAt(0) === "0") {
				// 02-123-4567
				// 01X-123-4567, 07X-123-4567, 지역번호-123-4567
				// 01X-1234-5678, 07X-1234-5678, 0505-123-4567, 지역번호-1234-5678
				if( (nLength === 9 && sValue.substring(0,2) === "02") || nLength === 10 || nLength === 11 ) {
					bResult = true;
				}
			}
			return bResult;
		} else {
			return false;
		}
	},

 	/**
	 * @description 유효문자로 변경
	 * @param sValue 검증할 메일주소
	 */
	_getCorrectedValue : function(sValue,sFormat){
		sValue = sValue.replace(/[^\d]/g, "");
		sValue = (sValue.length > 11 ? sValue.substr(0,11) : sValue);
		return this._applyFormat(sValue, sFormat);
	},

	/**
	 * @description 포맷을 적용함
	 */
	_applyFormat : function(sValue, sFormat) {
		sFormat = sFormat || "-";
		var nLength = sValue.length;
		if(sValue.charAt(0) === "0") {
			if(nLength === 9 && sValue.substring(0,2) === "02") {
				// 02-123-4567
				sValue = sValue.substr(0,2) + sFormat + sValue.substr(2,3) +  sFormat + sValue.substr(5,4);
			} else if(nLength === 10) {
				// 01X-123-4567, 07X-123-4567,  지역번호-123-4567
				sValue = sValue.substr(0,3) + sFormat + sValue.substr(3,3) +  sFormat + sValue.substr(6,4);
			} else if(nLength === 11) {
				// 01X-1234-5678, 07X-1234-5678, 0505-123-4567, 지역번호-1234-5678
				if(sValue.substr(0,4) === "0505") {
					sValue = sValue.substr(0,4) + sFormat + sValue.substr(4,3) +  sFormat + sValue.substr(7,4);
				} else {
					sValue = sValue.substr(0,3) + sFormat + sValue.substr(3,4) +  sFormat + sValue.substr(7,4);
				}
			}
		}
		return sValue;
	}
}).extend(MobileCommentJindo.m.Validator);
/**
* @(#)MobileCommentJindo.m.UrlValidator.js 2011. 11. 23.
*
* Copyright NHN Corp. All rights Reserved.
* NHN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*/
/**
* @author sculove
* @since 2011. 11. 23.
* @description
*/
MobileCommentJindo.m.UrlValidator = MobileCommentJindo.$Class({
	/** @lends MobileCommentJindo.m.UrlValidator.prototype */
	/**
	 * @description 초기화 함수
	 * @constructs
	 * @class
	 * @extends MobileCommentJindo.m.Validator
	 */
	rx : /(^(http:\/\/)|^(https:\/\/)|(^[A-Za-z0-9\.-]+))+([A-Za-z0-9\.-])*(\.[A-Za-z]{2,}(\/([A-Za-z0-9\.-])*)*)$/,

	/**
	 * @description 유효성 검증
	 * @param sValue 검증할 메일주소
	 */
	_isValid : function(sValue, sFormat) {
		if(this.rx.test(sValue)) {
			return true;
		} else {
			return false;
		}
	},

 	/**
	 * @description 유효문자로 변경
	 * @param sValue 검증할 메일주소
	 */
	_getCorrectedValue : function(sValue){
		return sValue.replace(/[^A-Za-z0-9-\?&\.\:\/]/g,"").replace(/\.{2,}/g,"").replace(/\?{2,}/g,"").replace(/&{2,}/g,"").replace(/\:{3,}/g,"");
	}
}).extend(MobileCommentJindo.m.Validator);
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
* @(#)nhn.comment.mobile.revision.js 2012. 04. 26
*/
(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';
})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
* @(#)nhn.comment.mobile.util.js 2012. 03. 19
*/
(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/**
	 * @description 댓글에서 사용하는 유틸리티성 함수들
	 */
	Comment.Util = {
		/**
		 * @description 문자열을 trim 하여 반환한다.
		 * @param {String}	sStr	문자
		 * @return {String}
		 */
		trim : function(sStr) {
			var re = /^\s+|\s+$/g;
			return sStr.replace(re, '');
		},

		/**
		 * @description 날짜스트링을 포맷에 맞게 변경하여 반환한다.
		 * @param {String}	sDate	날짜스트링
		 * @param {String}	sDateFormat 날짜포맷
		 * @return {String}
		 */
		dateFormat : function(sDate, sDateFormat) {
			var aDatetime = sDate.split(/\+/);
			aDatetime = aDatetime[0].split(/T/);
			if (aDatetime.length > 1) {
				var ymd = aDatetime[0].split(/-/);
				var his = aDatetime[1].split(/:/);
				var year = ymd[0];
				var month = ymd[1];
				var dayOfMonth = ymd[2];

				var time = his[0];
				var minute = his[1];
				var second = his[2].split(/\./);
				var milli = second[1];
				second = second[0];

				year = Number(year);
				month = Number(month) - 1;
				var day = Number(dayOfMonth);
				time = Number(time);
				minute = Number(minute);
				second = Number(second);

				var oDate = J.$Date(year, month, day, time, minute, second, milli);
				return oDate.format(sDateFormat);
			} else {
				return aDatetime[0];
			}
		},

		setNumberFormat: function(sText) {
			sText = sText.toString();
			var sReturn = "";
			var nDot = 0;
			var nLastPosition = sText.length;
			for (var i = nLastPosition; i >= 0; i--) {
				var sChar = sText.charAt(i);
				if (i > nLastPosition) {
					sReturn = sChar + sReturn;
					continue;
				}
				if (/[0-9]/.test(sChar)) {
					if (nDot >= 3) {
						sReturn = ',' + sReturn;
						nDot = 0;
					}
					nDot++;
					sReturn = sChar + sReturn;
				}
			}
			return sReturn;
		},
		
		/**
		 * @description 텍스트에 멀티라인허용유무에 따라 변경하여 반환한다.
		 * @param	{String}	sText	텍스트
		 * @param	{Boolean}	bEnableMultiLine	멀티라인 허용유무
		 * @param	{String}
		 */
		multiLine: function(sText, bEnableMultiLine){
			sText = sText.split(/\r/).join('');
			if (bEnableMultiLine) {
				sText = sText.split(/\n/).join('<br/>');
			}
			else {
				sText = sText.split(/\n/).join(' ');
			}
			return sText;
		},

		/**
		 * @description 맨위로 올라가기 (주소창 숨기는 효과)
		 */
		scrollTop : function() {
			window.scrollTo(0, 1);
		},

		/**
		 * @description 게시중단댓글인지의 불리언 값을 반환한다.
		 * @param	{Number}	nStatus	상태코드
		 * @return	{Boolean}
		 */
		isInterruptedComment : function(nStatus) {
			return nStatus >= 7 && nStatus <= 9;
		},

		/**
		 * @description 캐리지리턴 문자열를 제외한 두 텍스트가 같은지에 대한 불리언 값을 반환한다.
		 * @param	{String}	sParamText1	비교대상문자
		 * @param	{String}	sParamText2 비교대상문자
		 * @return {String}
		 */
		compareTextWithoutRetuneChar : function(sParamText1, sParamText2){
			var sText1 = sParamText1;
			var sText2 = sParamText2;

			sText1 = sText1.replace(/\r/g, "");
			sText1 = sText1.replace(/\n/g, "");

			sText2 = sText2.replace(/\r/g, "");
			sText2 = sText2.replace(/\n/g, "");

			if(sText1 == sText2){
				return true;
			}

			return false;
		},

		/**
		 * @description 내용 Validation 처리
		 * @param	{String}	sContents	내용
		 * @param	{Number)	nMin	최소글자수
		 * @param	{Number}	sMax	최대글자수
		 * @param	{String}	sEmptyError	빈문자일때의 에러메시지
		 * @param	{String}	sMinError	최소글자수보다 적을때의 에러메시지
		 * @param	{String}	sMaxError	최대글자수보다 많을때의 에러메시지
		 * @return	{Boolean}
		 */
		validation: function(sContents, nMin, sMax, sEmptyError, sMinError, sMaxError){
			sContents = J.$S(sContents).trim().$value();

			if (sEmptyError && sContents.length === 0) {
				alert(sEmptyError);
				return false;
			}

			if (sMinError && sContents.length < nMin) {
				alert(J.$Template(sMinError).process({
					'min': escape(nMin.toString())
				}));
				return false;
			}

			if (sMaxError && sContents.length > sMax) {
				alert(J.$Template(sMaxError).process({
					'max': escape(sMax.toString())
				}));
				return false;
			}
			return true;
		},

		isFunctionalKey : function(nKeyCode) {
			if ( nKeyCode == null) {
				return false;
			}

			switch (nKeyCode) {
				case 8 : // backspace
				case 18 : // alt
				case 17 : // ctrl
				case 37 : // left
				case 38 : // up
				case 39 : // right
				case 40 : // down
				case 33 : // pageup
				case 34 : // pagedown
				case 46 : // delete
				case 16 : // shift
				case 35 : // end
				case 36 : // home
				case 45 : // insert
				case 20 : // capslock
				case 27 : // esc
					return true;
			}

			return false;
		},

		/**
		 * @description 페이지 이동
		 * @param	{String}	sUrl	url
		 * @param	{HashTable}	htParams	파라미터(key, value)
		 */
		movePage : function(sUrl, htParams) {
			sUrl = this.removeParamsInUrl(sUrl, htParams);
			var sQueryString = this.makeQueryString(htParams);

			if (sUrl.indexOf('?') > -1) {
				sUrl += '&' + sQueryString;
			} else {
				sUrl += '?' + sQueryString;
			}

			this.redirect(sUrl);
		},

		/**
		 * @description 페이지 리다이렉트
		 * @param	{String}	sUrl	url
		 */
		redirect : function(sUrl) {
			if (!sUrl) { return; }
			window.location.href = sUrl;
		},

		/**
		 * @description url 에서 파라미터를 제거한다.
		 * @param	{String}	sUrl	url
		 * @param	{HashTable}	htParams	제거할파라미터
		 * @param	{String}	url
		 */
		removeParamsInUrl : function(sUrl, htParams) {
			if (htParams) {
				for (var sParam in htParams) {
					sUrl =  sUrl.replace(new RegExp("\\b" + sParam + "=[^&#]*", "g"), "");
				}
				sUrl = sUrl.replace("&&", "&").replace("?&", "?").replace("&#", "#").replace(/(.*)[&?]$/, "$1");
			}

			return sUrl;
		},

		/**
		 * @description url 쿼리 스트링을 생성한다.
		 * @param	{HashTable}	htParams	파라미터
		 * @return	{String}	url쿼리스트링
		 */
		makeQueryString : function(htParams) {
			var aParam = [],
				sValue = '';

			if (htParams) {
				for (var sParam in htParams) {
					sValue = htParams[sParam];

					if (!sValue) { continue; }
					aParam.push(sParam + "=" + encodeURIComponent(htParams[sParam]));
				}
			}

			return aParam.join('&');
		},

		/**
		 * @description 이벤트 버블링으로 처리할 경우, 상위 엘리먼트에 하이라이트 되는 문제 회피 (안드로이드에서)
		 * - 진도 2.0.1 에는 $Element 에 들어가 있지만, 진도 1.5.3 에는 없는 기능으로 추가해줌
		 */
		preventTapHighlightForJindoNotSupported : function() {
			//탭 하이라이트 기능이 이미 있다면
			if (typeof J.$Element.prototype.preventTapHighlight === "function") {
				return;
			}(function () {
				if (J.$Agent().navigator().msafari) {
					var sClassName = 'no_tap_highlight' + new Date().getTime();
					var elStyleTag = document.createElement('style');
					var elHTML = document.getElementsByTagName('html')[0];

					elStyleTag.type = "text/css";

					elHTML.insertBefore(elStyleTag, elHTML.firstChild);
					var oSheet = elStyleTag.sheet || elStyleTag.styleSheet;

					oSheet.insertRule('.' + sClassName + ' { -webkit-tap-highlight-color: rgba(0,0,0,0); }', 0);
					oSheet.insertRule('.' + sClassName + ' * { -webkit-tap-highlight-color: rgba(0,0,0,.25); }', 0);

					J.$Element.prototype.preventTapHighlight = function(bFlag) {
						return this[bFlag ? 'addClass' : 'removeClass'](sClassName);
					};
				} else {
					J.$Element.prototype.preventTapHighlight = function(bFlag) { return this; };
				}
            })();
		},

		/**
		 * @description 진도 2.0.1에는 있으나 1.5.3에 없는 $A.set 선언
		 */
		arraySetJindoNotSupported : function() {
			if ( typeof J.$Element.prototype.set === "function") {
				return;
			}(function () {
				J.$A.prototype.set = function(nIndex,vValue){
					this._array[nIndex] = vValue;
					return this;
				};
			})();
		},

		popUp: function(url, name, width, height){
			var popup = window.open(url, name, 'width=' + width + ',height=' + height + ',status=no,left=0,top=0');
			if(popup) {
				popup.focus();
				return popup;
			}
		}
	};

})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};
nhn.comment.mobile.Util = nhn.comment.mobile.Util || {};

(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile,
		Util = nhn.comment.mobile.Util;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/**
	 * @fileOverview
	 * 엘리먼트에 추가 정보를 설정하고 값을 얻는 함수
	 */
	Util.DomData = {
		/**
		 * 엘리먼트에 클래스명과 추가정보를 설정하는 메서드
		 *
		 * - nhn.comment.mobile.Util.DomData.setClass(elDiv, 'hello', [ 1, 2, 3 ]) 이라고 사용하면
		 *   elDiv 의 클래스명은 'hello(1,2,3)' 가 된다.
		 *
		 * - 이 상태에서 nhn.comment.mobile.Util.DomData.set(elDiv, 'world', [ 'foo' ]) 이라고 사용하면
		 *   elDiv 의 클래스명은 'hello(1,2,3) world(foo)' 가 된다.
		 *
		 * - 이 상태에서 nhn.comment.mobile.Util.DomData.set(elDiv, 'naver') 이라고 사용하면
		 *   elDiv 의 클래스명은 'hello(1,2,3) world(foo) naver' 가 된다.
		 *
		 * @param {HTMLElement} elEl : 클래스명을 변경할 엘리먼트
		 * @param {String} sKey : 클래스명
		 * @param {Array} aVars : 클래스명에 추가적으로 넣을 값
		 *
		 * @return {HTMLElement} 클래스명이 변경된 엘리먼트
		 */
		set : function(elEl, sKey, aVars) {

			if (this.get(elEl, sKey)) {
				this.remove(elEl, sKey);
			}

			elEl.className += (elEl.className ? ' ' : '') + sKey + (aVars instanceof Array ? '(' + this._encode(aVars).join(',') + ')' : '');
			return elEl;

		},

		_encode : function(sStr) {

			if (!sStr) return sStr;

			if (sStr instanceof Array) {

				var aRet = [];
				for (var i = 0, nLen = sStr.length; i < nLen; i++) {
					aRet.push(arguments.callee(sStr[i]));
				}

				return aRet;

			}

			return String(sStr).replace(/(["',\(\)\\])/g, function(_, sChar) {

				switch (sChar) {
				case ',': sChar = '.'; break;
				case '(': sChar = '['; break;
				case ')': sChar = ']'; break;
				}

				return '\\' + sChar;

			});

		},

		/*
		 * nhn.comment.mobile.Util.DomData.set(document.body, 'foo', [ 'hello', 'wor,ld', '(kkk)' ]);
		 * nhn.comment.mobile.Util.DomData.get(document.body,'foo')
		 */

		_decode : function(sStr) {

			if (!sStr) return sStr;

			if (sStr instanceof Array) {

				var aRet = [];
				for (var i = 0, nLen = sStr.length; i < nLen; i++) {
					aRet.push(arguments.callee(sStr[i]));
				}

				return aRet;

			}

			return String(sStr).replace(/\\(["'\.\[\]\\])/g, function(_, sChar) {

				switch (sChar) {
				case '.': sChar = ','; break;
				case '[': sChar = '('; break;
				case ']': sChar = ')'; break;
				}

				return sChar;

			});

		},

		/**
		 * 엘리먼트에 지정된 클래스명의 추가정보를 얻어오는 메서드
		 *
		 * - elDiv 의 클래스명이 'hello(1,2,3)' 인 상태에서
		 *   nhn.comment.mobile.Util.DomData.get(elDiv, 'hello') 이라고 사용하면
		 *   반환되는 값은 [ '1', '2', '3' ] 이다.
		 *
		 * - elDiv 의 클래스명이 'hello(1,2,3) world' 인 상태에서
		 *   nhn.comment.mobile.Util.DomData.get(elDiv, 'world') 이라고 사용하면
		 *   반환되는 값은 [ ] 이다.
		 *
		 * - elDiv 의 클래스명이 'hello(1,2,3) world' 인 상태에서
		 *   nhn.comment.mobile.Util.DomData.get(elDiv, 'noexist') 이라고 사용하면
		 *   반환되는 값은 null 이다.
		 *
		 * @param {HTMLElement} elEl : 클래스명 정보를 얻어올 엘리먼트
		 * @param {String} sKey : 클래스명
		 *
		 * @return {Array} 해당 클래스명이 존재하지 않으면 null 이 리턴된다
		 */
		get : function(elEl, sKey) {
			var oRegExp = this._getRegExp(sKey);
			var elResult = this._checkElement(elEl, oRegExp);

			if (elResult) {
				return (this.last() || "").split(',');
			}

			return null;

		},

		/**
		 * 엘리먼트에 지정된 클래스명을 삭제하는 메서드
		 *
		 * - elDiv 의 클래스명이 'hello(1,2,3) world' 인 상태에서
		 *   nhn.comment.mobile.Util.DomData.remove(elDiv, 'hello') 이라고 사용하면
		 *   elDiv 의 클래스명은 'world' 가 된다.
		 *
		 * - elDiv 의 클래스명이 'hello(1,2,3) world' 인 상태에서
		 *   nhn.comment.mobile.Util.DomData.remove(elDiv, 'world') 이라고 사용하면
		 *   elDiv 의 클래스명은 'hello(1,2,3)' 가 된다.
		 *
		 * @param {HTMLElement} elEl : 클래스명을 삭제할 엘리먼트
		 * @param {String} sKey : 클래스명
		 *
		 * @return {HTMLElement} 클래스명이 삭제된 엘리먼트
		 */
		remove : function(elEl, sKey) {

			var oRegExp = this._getRegExp(sKey);
			elEl.className = elEl.className.replace(oRegExp, '$4').replace(/(^\s+|\s+$)/g, '');

			return elEl;

		},

		/**
		 * 마지막으로 얻은 클래스 내부의 값을 가지고 있던걸 반환
		 *
		 * @return {String} 값
		 */
		last : function() {
			return this._lastValue;
		},

		/**
		 * 자신을 포함하여 부모 엘리먼트로부터 특정한 클래스명이 존재하는지 탐색하여 그 엘리먼트를 반환한다
		 *
		 * @param {HTMLElement} elEl : 탐색을 시작할 엘리먼트
		 * @param {String} sKey : 클래스명
		 *
		 * @return {HTMLElement} 찾아낸 엘리먼트 (찾지 못했으면 null 반환)
		 */
		getParent : function(elEl, sKey, aVars) {

			var oRegExp = this._getRegExp(sKey, aVars);
			var elRet;

			var bHasClass = false;
			try { bHasClass = 'className' in elEl; } catch(e) {};

			for (; elEl && bHasClass; elEl = elEl.parentNode) {

				if (elRet = this._checkElement(elEl, oRegExp)) {
					return elRet;
				}

			}

			return null;

		},

		/**
		 * 자신을 제외하고 자식 엘리먼트로부터 특정한 클래스명이 존재하는지 탐색하여 그 엘리먼트를 반환한다
		 *
		 * @param {HTMLElement} elEl : 탐색을 시작할 엘리먼트
		 * @param {String} sKey : 클래스명
		 *
		 * @return {HTMLElement} 찾아낸 엘리먼트 (찾지 못했으면 null 반환)
		 */
		getChild : function(elEl, sKey, aVars) {

			if (elEl === document && typeof aVars === 'undefined') {

				this._gatherCollection();

				var elRet = this._oCollection[sKey];
				if (elRet && this._isInHTML(elRet)) {
					return elRet;
				}

				return J.$$.getSingle('div.' + sKey) || J.$$.getSingle('.' + sKey);

			}

			var oRegExp = this._getRegExp(sKey, aVars);

			var aChilds = elEl.getElementsByTagName('*');
			for (var i = 0, elChild; elChild = aChilds[i]; i++) {
				if (elRet = this._checkElement(elChild, oRegExp)) {
					return elRet;
				}
			}

			return null;

		},

		/**
		 * 자신을 제외하고 자식 엘리먼트로부터 특정한 클래스명이 존재하는지 탐색하여 그 모든 엘리먼트를 반환한다
		 *
		 * @param {HTMLElement} elEl : 탐색을 시작할 엘리먼트
		 * @param {String} sKey : 클래스명
		 *
		 * @return {Array} 찾아낸 엘리먼트
		 */
		getChildAll : function(elEl, sKey, aVars) {

			var aRet = [];
			var sTagName = '*';

			if (/^([a-z0-9]+)\./.test(sKey)) {
				sTagName = RegExp.$1;
				sKey = sKey.replace(/^([a-z0-9]+)\./, '');
			}

			var oRegExp = this._getRegExp(sKey, aVars);
			var elRet;

			var aChilds = elEl.getElementsByTagName(sTagName);
			for (var i = 0, elChild; elChild = aChilds[i]; i++) {
				if (elRet = this._checkElement(elChild, oRegExp)) {
					aRet.push(elRet);
				}
			}

			return aRet;

		},

		_getRegExp : function(sKey, aVars) {

			if (aVars) {
				var sEscapedKey = sKey + ('(' + this._encode(aVars).join(',') + ')').replace(/([\/\(\)\[\]\+\.\*\?\|\{\}\\])/g, '\\$1');
				return new RegExp('(^|\\s+)' + sEscapedKey + '(\\s+|$)', 'i');
			}

			return new RegExp('(^|\\s+)' + sKey + '(\\(([^\)]*)\\))?(\\s+|$)', 'i');
		},

		_checkElement : function(elEl, oRegExp) {

			if (oRegExp.test(elEl.className)) {
				this._lastValue = this._decode(RegExp.$3);
				return elEl;
			}

			return null;

		},

		_gatherCollection : function() {

			if (this._oCollection) {
				return;
			}

			var oCollection = {};

			var aEls = document.getElementsByTagName('*');
			var rReg = /(^|\b)_(\w+)(?=\(|\b|$)/g;

			for (var i = 0, elEl; elEl = aEls[i]; i++) {

				var aResult = elEl.className.match(rReg);
				if (aResult) {

					for (var j = 0, nLen = aResult.length; j < nLen; j++) {
						if (!oCollection[aResult[j]]) {
							oCollection[aResult[j]] = elEl;
						}
					}

				}

			}

			this._oCollection = oCollection;

		},

		_isInHTML : function(elEl) {

			do {

				if (elEl === document.body) {
					return true;
				}

			} while(elEl = elEl.parentNode);

			return false;

		}

	};
})();

nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};
nhn.comment.mobile.Util = nhn.comment.mobile.Util || {};

(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile,
		Util = nhn.comment.mobile.Util;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/*
	 * @class nhn.comment.mobile.Bubbler
	 * 버블링을 사용한 이벤트 바인딩을 구현하는 클래스
	 */
	Util.Bubbler = J.$Class( {

		/**
		 * @constructor
		 *
		 * @param {HTMLElement} elEl 어느 엘리먼트를 통해 이벤트를 잡아낼지 지정
		 */
		$init : function(elEl) {

			this._el = elEl;

			this._eventTypes = {};
			this._fpEventHandler = J.$Fn(this._eventHandler, this);

		},
		/**
		 * 이벤트 핸들러 등록
		 *
		 * @param {String} sEvent 이벤트 종류 및 클래스명
		 * @param {Function} fpHandler 이벤트 핸들러
		 */
		attach : function(sEvent, fpHandler) {

			// 객체 형태로 인자를 지정했을때는 루프를 돌아 모두 등록시킨다
			if (typeof sEvent == 'object') {

				var fp = arguments.callee;

				J.$H(sEvent).forEach( function(f, k) {
					fp.call(this, k, f);
				}, this);

				return this;
			}

			//모바일 사파리지원기능
			if (J.$Agent().navigator().msafari) {
				sEvent = sEvent.replace(/:mousedown$/, ':touchstart').replace(/:mousemove$/, ':touchmove').replace(/:mouseup$/, ':touchend');
			}


			// 이벤트명과 클래스명을 잘라냄
			var aParsed = sEvent.split(':');

			var sClassName = aParsed[0];
			var sType = aParsed[1].toLowerCase();
			var sNot = /^!/.test(sClassName) ? 'T' : 'F';

			sClassName = sClassName.replace(/^!/, '');

			// mouseenter 와 mouseleave 이벤트는 mouseover, mouseout 이벤트를 통해 구현해야 함
			var sRealType = sType;

			if (sRealType == 'mouseenter')
				sRealType = 'mouseover';
			else if (sRealType == 'mouseleave')
				sRealType = 'mouseout';

			// 이벤트 바인딩이 안되어 있으면
			if (!(sType in this._eventTypes)) {
				this._eventTypes[sType] = J.$H();
				this._fpEventHandler.attach(this._el, sRealType);
			}

			var whClassNames = this._eventTypes[sType];

			// 해당 클래스가 등록되어 있지 않으면
			if (!whClassNames.hasKey(sClassName)) {
				whClassNames.$(sClassName, { 'T' : J.$A(), 'F' : J.$A() });
			}

			// 핸들러 추가
			whClassNames.$(sClassName)[sNot].push(fpHandler);

			return this;

		},

		/**
		 * 이벤트 핸들러 등록 해제
		 *
		 * @param {String} sEvent 이벤트 종류 및 클래스명
		 * @param {Function} fpHandler 이벤트 핸들러
		 */
		detach : function(sEvent, fpHandler) {

			// 객체 형태로 인자를 지정했을때는 루프를 돌아 모두 등록 해제시킨다
			if (typeof sEvent == 'object') {
				var fp = arguments.callee;
				J.$H(sEvent).forEach( function(f, k) {
					fp.call(this, k, f);
				}, this);

				return this;
			}
			//모바일 사파리지원기능
			if (J.$Agent().navigator().msafari) {
				sEvent = sEvent.replace(/:mousedown$/, ':touchstart').replace(/:mousemove$/, ':touchmove').replace(/:mouseup$/, ':touchend');
			}

			// 이벤트명과 클래스명을 잘라냄
			var aParsed = sEvent.split(':');

			var sClassName = aParsed[0];
			var sType = aParsed[1].toLowerCase();
			var sNot = /^!/.test(sClassName) ? 'T' : 'F';

			sClassName = sClassName.replace(/^!/, '');

			var whClassNames = this._eventTypes[sType];
			var waHandlers = whClassNames.$(sClassName)[sNot];

			// 핸들러 목록에서 제거
			if (waHandlers) {

				var nIndexOf = waHandlers.indexOf(fpHandler);
				if (nIndexOf != -1)
					waHandlers.splice(nIndexOf, 1);

			}

		},

		/**
		 * 등록한 이벤트가 발생했을때 호출되는 메서드
		 *
		 * @param {$Event} oEvent 이벤트 객체
		 */
		_eventHandler : function(oEvent) {

			var sType = oEvent.type.toLowerCase();
			var sAltType = null;

			// mouseover, mouseout 이벤트인 경우 mouseenter, mouseleave 에 대한 처리를 해야함
			if (sType == 'mouseover')
				sAltType = 'mouseenter';
			else if (sType == 'mouseout')
				sAltType = 'mouseleave';

			if (sAltType) {
				this._launchEventHandlers(oEvent, this._eventTypes[sAltType], true);
			}

			this._launchEventHandlers(oEvent, this._eventTypes[sType]);

			oEvent = null;

		},

		_launchEventHandlers : function(oEvent, whClassNames, bAltType) {

			if (!whClassNames) {
				return;
			}

			var elSrc = oEvent.element;
			var elRelSrc = oEvent.relatedElement;

			// 해당 이벤트가 등록된 클래스를 루프돔
			whClassNames.forEach( function(oHandlers, sClassName) {

				var waHandlers = oHandlers['F'];
				var waNotHandlers = oHandlers['T'];

				// 이벤트가 발생한 엘리먼트가 해당 클래스명을 가졌는지 검사
				var elTar = Util.DomData.getParent(elSrc, sClassName);
				if (!elTar) {
					waNotHandlers.forEach( function(fpHandler) { fpHandler(oEvent); });
					J.$H.Continue();
				}

				// mouseenter, mouseleave 이벤트에 대한 판단을 해야하는 경우
				if (bAltType) {
					var elRelTar = Util.DomData.getParent(elRelSrc, sClassName);

					// 대상 안에서 mouseover, mouseout 이 발생한거면 무시
					if (elTar === elRelTar) {
						waNotHandlers.forEach( function(fpHandler) { fpHandler(oEvent); });
						J.$H.Continue();
					}
				}

				var aArgs = Util.DomData.get(elTar, sClassName);

				// 등록된 이벤트 핸들러 호출
				waHandlers.forEach( function(fpHandler) {
					fpHandler(oEvent, elTar, aArgs);
				});

				elTar = null;

			}, this);

		}

	});
})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
* @(#)nhn.comment.mobile.config.js 2012. 03. 19
*/

(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile,
		Util = nhn.comment.mobile.Util;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/**
	* @description 댓글 설정관련 클래스
	*/
	Comment.Config = J.$Class({
		/** @lends nhn.comment.mobile.Config.prototype */

		message : {},

		/**
		 * @description 초기화 함수
		 * @constructs
		 * @class
		 * @param {HashTable} htUserOption 옵션 (생략가능)
		 * @extends jindo.Component
		 */
		$init : function(htOptions) {
			this.instance = {};

			this._initDefaultConfig();
			this._initConvertOption();

			if (typeof htOptions == 'object') {
				this.option(htOptions);
			}

			//이벤트 버블링 사용할 경우 상위 엘리먼트에 하이라이트가 되는 경우가 있어
			//하이라이트 되는 것을 막기 위해 (진도 1.5.3 에 구현되지 않아 추가해줌)
			Util.preventTapHighlightForJindoNotSupported();

			// 진도 1.5.3에 구현되지 않은 $A.set() 선언(있으면 skip)
			Util.arraySetJindoNotSupported();
		},

		/**
		 * @description 디폴트 옵션을 설정한다.
		 */
		_initDefaultConfig : function() {
			this.option('servicePath', 'comments');
			this.option('isLogin', false);	//로그인 유무
			this.option('objectUrl', '' + document.location);
			this.option('certUrl', 'https://nid.naver.com/user/mobile_rncheck.nhn?todo=start');
			this.option('loginUrl', 'https://nid.naver.com/nidlogin.login?svctype=262144');
			this.option('browser', J.$Agent().navigator().getName());

			//proxy에 지정해준 json 연결주소.
			var serviceAddress = document.location.protocol + '//';
			serviceAddress += document.location.host + '/';
			serviceAddress += this.option('servicePath') + '/';
			this.option('serviceAddress', serviceAddress);

			this.option('categoryId', 'default');	// 카테고리를 지정하지 않은 경우, 작성되는 댓글의 기본 카테고리명
			this.option('viewCategoryId', undefined);	// 카테고리를 지정하지 않은 경우, 리스팅하는 댓글들의 카테고리명. undefined 인 경우, 모든 카테고리를 리스팅

			this.option('method', 'post');	//ajax call
			this.option('pageSize', 25);	//한 페이지에 보일 개수
			this.option('pageNo', 1);
			this.option('isRedirectAfterDelete', false);	//삭제 후에 redirect 여부

			this.option('formation', ['count', 'write', 'sort', 'bestList', 'list', 'listFooter', 'page']);	//UI 순서
			this.option('commands', []);	//동작버튼 - 삭제와 신고버튼은 comment 영역에 포함됨
			this.option('isHideWriteForm', false);	//글쓰기 폼 숨김처리
			this.option('maximumCommentLength', 500);	// 글 입력 최대 문자열 개수
			this.option('enableMultiLine', false);	//멀티 라인 입력 허용 유무
			this.option('useEscapeHtml',true);	//HTML표현식을 태그로써 동작하지 않게 할 지를 설정

			this.option('myNickName', '');	//내 게시물일일때 닉네임 변경
			this.option('dateFormat', 'Y-m-d H:i');	//코멘트 날짜 포맷

			this.option('urlList', {});		// URL list
			
			this.option('booleans', {});
			this.option('comment', []);
			this.option('convention', {});
			this.option('initialized', false);
			this.option('pagingParameterName', 'page');		// 공통댓글용 페이지 파라미터명(적용되는 서비스와 충돌시 이를 바꿔서 적용하도록 Guide)
			this.option('hidePageAreaIfOnlyOnePageExist', true);	// 첫페이지만 존재하는 경우 페이징 영역을 hide 시킬지 여부
			this.option('maxDepth', 2);

			var htDeviceInfo = J.m.getDeviceInfo();
			
			this.option('useMoreContent', false );
			if ( htDeviceInfo.iphone || htDeviceInfo.ipad) { // IOs 계열인지 여부
				this.option('useMoreContent', true );
			}

			this.option('errorHandlers', {});
			
			this.option('isBlackMode', false);
			this.option('listType', 'u_comment_v2'); // 리스트 타입 v1, v2 선택 ( v1 은 서비스 내 댓글 목록형 )
			this.option('writeLinkUrl', '#'); // 서비스 댓글 쓰기 URL 링크
			this.option('innerSvcListSize', '3'); //서비스 내 댓글 목록형 댓글 노출 갯수
			this.option('innerSvcListSort', 'newest'); //서비스 내 댓글 목록형 정렬 기준
			this.option('useInnerSvcShowReply', true); //요약목록의 일반댓글의 답글 표시여부
			this.option('isSimpleList', false); // 요약목록의 답글, 공감/비공감 영역 표시여부
			this.option('useRecommendArea', false); // 추천영역(베스트댓글) 사용여부
			this.option('replyPageSize', 10); // 답글리스트 목록수 설정
			this.option('useRecommendBtnLevel', 2); // 답글버튼 레벨(2인 경우 부모글에만 답글을 달 수 있다)
			this.option('listAsync', false); // 리스트 ajax 호출시 동기 비동기 설정 
			this.option('useFocus', true); // 리스트의 이전/다음 버튼 클릭시 focus여부 
			this.option('landingCommentNo', null); // null이 아닌경우 해당 댓글번호가 있는 곳으로 landing
			this.option({'elements' : {
				body : '#comment_module',
				focusTarget : 'comment_focus',
				countArea : '.__comment_info',
				count : '.__comment_count',
				writeboxRoot : '.__comment_writebox_root_area',
				writebox : '.__comment_writebox',
				textarea : 'textarea',
				writeButton : '.__comment_write_btn',
				list : '.__comment_list',
				paginate : '.__comment_page_area',
				pagemore : '.__comment_page_more',
				pagenavigation : '.__comment_page_navigation',
				commandArea : '.__comment_command',
				bestCommentList : '.__best_comment_list'
			}});

			this.option({'css' : {
				commentItem : '__comment_item',
				commendDel : '__comment_del_btn',
				commendReport : '__comment_report_btn',
				textarea : '__comment_textarea',
				writeButton : '__comment_write_btn',
				replyItem : '__reply_item',
				noList : '__comment_no_list',
				writePrompt : '__comment_write_prompt',
				replyButton : '__comment_reply_form_btn',
				replyItemBest : '__reply_item_best',
				replyButtonBest : '__comment_reply_form_btn_best',
				replyCloseButton : '__comment_reply_close_btn',
				replyList : '__comment_reply_List',
				replyCloseBtnArea : '__comment_reply_close_btn_area',
				userRecommendYn : '__comment_user_recommend_yn',
				replyListPaging : '__comment_reply_list_paging',
				replyPrevButton : '__comment_reply_prev_btn',
				replyNextButton : '__comment_reply_next_btn',
				replyPageInfo : '__comment_reply_page',
				parentCommentNo : '__parent_comment_no'
			}});

			this.option({'templates' : {
				countArea : '<div class="u_comment_top __comment_info"></div>',
				countSimple : 
					'<div class="u_section">' +
						'<h2 class="c_fnt">댓글 <span class="u_count __comment_count">{=count}</span></h2>' + 
						'<a class="u_btn_refresh c_line c_bak __comment_refresh_btn" href="#">새로고침</a>' + 
						'<a class="u_btn_write c_line c_bak c_fnt __comment_writebox_view" href="#">댓글쓰기</a>' +
					'</div>',					
				rootWriteBoxArea : '<div class="u_comment_writebox __comment_writebox_root_area"></div>',
				replyWriteBoxArea : '<div class="u_comment_writebox __reply_item{if isUserRecommend}_best{/if}({=commentNo})" style="display:none;"></div>',
				writeBox :
					'<form action="">'+
					'<fieldset class="u_comment_write __comment_writebox">'+
					'<legend class="u_hc">댓글입력</legend>'+
					'<div class="u_writebox c_line">'+
					'<span class="u_write_text"><textarea id="upload_txt" rows="3" cols="30" class="__comment_textarea({=commentNo}) __comment_user_recommend_yn({if isUserRecommend}Y{else}N{/if})"></textarea></span>'+
					'<span class="u_data __comment_write_prompt({=commentNo})">{=writePrompt}</span>'+
					'</div>'+
					'{=socialCommentArea}'+
					'<span class="u_btn_upload"><input type="submit" title="등록" value="등록" class="u_btn_w c_fnt __comment_write_btn"></span>'+
					'</fieldset>'+
					'{if isUserRecommend}'+
					'<a href="#" class="u_btn_more __comment_reply_close_btn_area({=commentNo})">'+
						'<span class="u_btn_wrap">'+							
						'<span class="u_btm_txt open">답글접기</span>'+
						'</span>'+
					'</a>'+
					'{/if}'+
					'</form>',
				
				replyWriterArea : '<span class="u_comment_reply_writer u_comment_reply_writer{=replyLevel} __reply_writer">{=myNickName}</span>',
				replyBox :
					'<div class="u_comment_write u_comment_reply_area u_comment_reply_area{=replyLevel} __reply_item({=commentNo})">' +
						'<form action="#" method="post">' +
						'<fieldset>' +
						'<legend class="u_hc">댓글입력</legend>' +
						'<div>' +
							'<label class="u_hc" for="upload_txt{=commentNo}">댓글</label>' +
							'<span class="u_comment_input">' +
								'<textarea id="upload_txt{=commentNo}" class="u_comment_upload __comment_textarea({=commentNo})" rows="5" cols="30"></textarea>' +
							'</span>' +
							'<input class="u_comment_reply_ulbtn __comment_write_btn" type="button" value="등록">' +
						'</div>' +
						'{=socialCommentArea}'+
						'<p class="u_comment_promt __comment_write_prompt({=commentNo})">{=writePrompt}</p>' +
						'</fieldset>' +
						'</form>' +
					'</div>',
				writePrompt : '<em>{=inputCommentLength}</em> / {=maximumCommentLength}',
				bestList : '<ul class="u_comment_lst __best_comment_list"></ul>',
				list : '<ul class="u_comment_lst __comment_list"></ul>',
				noList : '<div class="u_comment_none">' +
							'<p>댓글이 없습니다.<br>첫번째 댓글을 남겨주세요.</p>' +							
						'</div>',

				comment :
					'<li class="u_comment_depth{if isUserRecommend} best{/if} __comment_item({=commentNo}) {if replyLevel > 1}u_comment_depth{=replyLevel}{/if}">' +
						'{if replyLevel > 1}<span class="u_depth">└</span>{/if}' +
						'<div class="u_comment_info">' +
						'<em class="u_name">{=writerNickName} <span class="u_id">({=writerId})</span></em> {=registeredDate}'+
						'{if !isMine} <span class="u_bar">|</span> <a href="#" class="u_report __comment_report_btn">신고</a></div>{/if}'+
						'{if isMine}<a href="#" class="u_btn_del __comment_del_btn __parent_comment_no({=parentCommentNo})">댓글삭제</a></div>{/if}' + 
						'<p class="u_comment_text u_comment_txt{=replyLevel}">{if isUserRecommend}<span class="u_recomm">공감댓글</span> {/if}{=contents}</p>'+
						'<div class="u_comment_reply __comment_reply">' +
						
						'<div class="u_comment_btns">'+
						'{if maxDepth > replyLevel}'+
							'{if isUserRecommend}' +
								'<a href="#" class="u_btn c_fnt c_line bt_arw close __comment_reply_form_btn_best({=commentNo})" ><span>답글</span> <b>{if replyCount != null}{=replyCount}{else}0{/if}</b></a>'+
							'{else}'+
								'<a href="#" class="u_btn c_fnt c_line __comment_reply_form_btn({=commentNo})" >답글</a>'+
							'{/if}' +
						'{/if}'+
						'{=socialCommentArea}'+
						'{=recommendDiscommendArea}'+
						'</div>'+
						'<ul class="u_comment_reply_list __comment_reply_List({=commentNo})" style="display:none;"></ul>'+
						'<div class="u_comment_reply_list_paging __comment_reply_list_paging({=commentNo})" style="display:none;">'+
						'<a href="#" class="u_rpg_pre __comment_reply_prev_btn" title="이전">이전 답글</a>'+
						'<a href="#" class="u_rpg_next __comment_reply_next_btn" title="다음">다음 답글</a>'+
						'</div>'+
						'</div>'+
					'</li>',
				deleteComment :					
					'<li class="u_comment_depth __comment_item({=commentNo}) {if replyLevel > 1}u_comment_depth{=replyLevel}{/if}">' +
						'{if replyLevel > 1}<span class="u_depth">└</span>{/if}' +
						'<div class="u_comment_del">{if replyLevel > 1}답글{/if}{if replyLevel < 2}댓글{/if}이 삭제되었습니다.'+
						'</div>' +
					'</li>',
                   
				blockComment :					
					'<li class="u_comment_depth __comment_item({=commentNo}) {if replyLevel > 1}u_comment_depth{=replyLevel}{/if}">' +
						'{if replyLevel > 1}<span class="u_depth">└</span>{/if}' +
						'<div class="u_comment_del">'+
						'{if status == 7 }'+
						'본 게시물은 저작권법 제103조에 의거하여 저작권자의 요청으로 임시 게시중단 되었습니다.'+
						'{elseif status == 8 || status == 9}'+
						'본 게시물은 정보통신망이용촉진및정보보호등에 관한 법률 제44조의2를 준수하기 위해 다른 이용자의 요청으로 임시 게시중단 되었습니다.'+
						'{/if}'+
						'</div>' +
					'</li>',
				emptyComment :
					'<li class="u_comment_lst u_empty_comment_lst __comment_item(empty)" style="display:none;">' +
						'<div>' +
							'<p class="u_comment_txt u_emtpy_comment_txt" style="word-break:break-all;line-break: all;word-wrap:break-word;">' +
							'. . .'+
							'</p>' +
						'</div>' +
					'</li>',
				reportForm :
					'<form id="commentReportForm" method="GET" target="_parent">' +
					'<input type="hidden" name="itemSvcCd" id="itemSvcCd" value="CBM"/>' +
					'<input type="hidden" name="itemType" id="itemType" value="CMNT"/>' +
					'<input type="hidden" name="itemVirtualSvcCd" id="itemVirtualSvcCd" value=""/>' +
					'<input type="hidden" name="itemId" id="itemId" value=""/>' +
					'<input type="hidden" name="itemTitle" id="itemTitle" value=""/>' +
					'<input type="hidden" name="itemCateId" id="itemCateId" class="itemCateId0" value=""/>' +
					'<input type="hidden" name="itemCateName" id="itemCateName" class="itemCateName0" value=""/>' +
					'<input type="hidden" name="itemCateLevel" id="itemCateLevel" class="itemCateLevel0" value=""/>' +
					'<input type="hidden" name="itemWriterId" id="itemWriterId" value=""/>' +
					'<input type="hidden" name="itemEncyptWriterId" id="itemEncyptWriterId" value=""/>' +
					'<input type="hidden" name="itemWriterNick" id="itemWriterNick"/>' +
					'<input type="hidden" name="itemDt" id="itemDt" value=""/>' +
					'<input type="hidden" name="m" id="m" value="rprtMobileFrm"/>' +
					'<input type="hidden" name="retUrl" id="retUrl" value=""/>' +
					'<input type="submit" style="display:none;"/>' +
					'</form>',
				pageArea :
					'<div class="__comment_page_area"></div>' ,
				pageMore :
				    '<div class="u_pg __comment_page_more">' +
				    	'<a href="#" class="u_pg_btn __comment_more_button">'+
				    		'<span class="u_pg_wrap">'+
				    			'<span class="u_pg_area">'+
				    				'<span class="u_pg_lod __comment_more_loading" style="display:none;">'+
				    					'<span class="u_pg_lodic">로딩중..</span>'+
				    				'</span>'+
				    				'<span class="u_pg_txt">'+
				    				'<span><span class="__comment_more_moreCnt"></span>개 더보기</span><br/>'+
				    					'<span class="u_pg_cnt"><span class="__comment_more_current"></span> / <span class="u_pg_total __comment_more_total"></span></span>' +
				    				'</span>' +
				    			'</span>' +
				    		'</span>' +
				    	'</a>' +
				    	'<span class="u_pg_btn __comment_more_last" style="display:none;">' +
				    		'<span class="u_pg_wrap">' +
				    			'<span class="u_pg_area">' +
				    				'<span class="u_pg_txt">'+
				    					'<span class="u_pg_cnt"><span class="__comment_more_current"></span> / <span class="u_pg_total __comment_more_total"></span></span>'+
				    				'</span>'+
				    			'</span>'+
				    		'</span>'+
				    	'</span>'+
				    	'<a href="#" class="u_pg_top __comment_more_top">맨위로</a>'+
				    '</div>',
				pageNavigation :
					'<div class="u_pg2 __comment_page_navigation">' +
					 	'<a href="#" class="u_pg2_btn u_pg2_prev __comment_page_prev"><span class="">이전</span></a>' +
					 	'<span class="u_pg2_btn u_pg2_prev __comment_page_prev-off"><span class="">이전</span></span>' +
					 	'<em class="u_pg2_pg __comment_page_info">1-10 <span class="u_pg2_total">/ </span></em>' +
					 	'<a href="#" class="u_pg2_btn u_pg2_next __comment_page_next"><span class="">다음</span></a>' +
					 	'<span class="u_pg2_btn u_pg2_next  __comment_page_next-off"><span class="">다음</span></span>' +
					 '</div>',
				pageInfoTemplate :
					'{=STARTINDEX}-{=ENDINDEX}<span class="u_pg2_total"> / {=ITEMCOUT}</span>',
				replyPageInfo : '<span class="u_comment_reply_page __comment_reply_page"><em><span>현재페이지 </span>{=curPage}<span>페이지</span></em> / <span>전체페이지 </span>{=totalPage}<span>페이지</span></span>'
			}});
		},

		/**
		 * @description 옵션을 사용하기 편하게 변경해 준다.
		 */
		_initConvertOption : function() {
			//boolean 값으로 바꿔줄값
			var booleans = this.option('booleans');
			booleans.isMine = true;
			booleans.isAdmin = true;
			booleans.isReply = true;
			booleans.isDeleted = true;
			booleans.isVisible = true;
			booleans.isAuthor = true;
			booleans.isAuthorComment = true;
			booleans.isUserRecommend = true;
			booleans.isAuthorRecommend = true;
			booleans.isRecommendArea = true;
			booleans.isMobile = true;

			//json으로 전송되어온 변수중 사용할 변수는 여기에 추가시킨다.
			var comment = this.option('comment');
			comment.push('parentCommentNo');
			comment.push('commentNo');
			comment.push('writerNickName');
			comment.push('writerId');
			comment.push('writerIp');
			comment.push('maskedWriterId');
			comment.push('isMine');
			comment.push('isAdmin');
			comment.push('contents');
			comment.push('registeredDate');
			comment.push('modifiedDate');
			comment.push('replyLevel');
			comment.push('isReply');
			comment.push('isDeleted');
			comment.push('isVisible');
			comment.push('writerProfileUrl');
			comment.push('writerProfileType');
			comment.push('isMe2DayPosted');
			comment.push('upCount');
			comment.push('downCount');
			comment.push('isUserRecommend');
			comment.push('isAuthorRecommend');
			comment.push('isRecommendArea');
			comment.push('isAuthor');
			comment.push('isAuthorComment');
			comment.push('replyCount');
			comment.push('objectScore');
			comment.push('status');
			comment.push('isMobile');
			comment.push('personacon');
			comment.push('categoryId');
			comment.push('ticket');

			var convention = this.option('convention');
			convention = {
				parentCommentNo : 'parent_comment_no',
				commentNo : 'comment_no',
				groupNo : 'group_no',
				writerNickName : 'writer_nickname',
				writerId : 'writer_id',
				encodedWriterId : 'enc_writer_id',
				maskedWriterId : 'masked_writer_id',
				writerIp : 'writer_ip',
				registeredDate : 'registered_ymdt',
				modifiedDate : 'modified_ymdt',
				replyLevel : 'reply_level',
				typeCode : 'comment_type_code',
				isMine : 'is_mine',
				isAdmin : 'is_admin',
				isReply : 'is_reply',
				isDeleted : 'deleted_yn',
				isVisible : 'visible_yn',
				isMe2DayPosted : 'is_me2day_posted',
				ticket : 'ticket',
				objectId : 'object_id',
				objectUrl : 'object_url',
				replyCount : 'reply_count',
				writerProfileUrl : 'writer_profile_url',
				writerProfileType : 'writer_profile_type',
				upCount : 'up_count',
				downCount : 'down_count',
				isUserRecommend : 'user_recommend_yn',
				isAuthorRecommend : 'author_recommend_yn',
				isRecommendArea : 'is_recommend_area',
				isAuthor : 'is_author',
				isAuthorComment : 'is_author_comment',
				objectScore : 'object_score',
				status : 'status',
				isMobile : 'mobile_yn',
				personacon : 'personacon',
				categoryId : 'category_id'
			};

			this.option('convention', convention);
		},

		/**
		 * @description 엘리먼트 접근자를 반환하거나 옵션에 저장한다.
		 * @param	{Object}	oName		엘리먼트접근이름
		 * @param	{String}	sElement	엘리먼트접근값(클래스명,타입,아이디)
		 * @return	{String|Object|null}
		 */
		element : function(oName, sElement) {
			var htElements = this.option('elements');

			if (typeof htElements == 'undefined' || htElements === null) {
				htElements = {};
				this.option('elements', htElements);
			}

			if (typeof oName == 'object') {
				for(var sKey in oName) {
					htElements[sKey] = oName[sKey];
				}
			} else if (typeof oName == 'string') {
				if (typeof sElement == 'string') {
					htElements[oName] = sElement;
				} else {
					return htElements[oName];
				}
			} else {
				return null;
			}
		},

		/**
		 * @description 템플릿을 반환하거나 옵션에 저장한다.
		 * @param	{Object}	oName		템플릿접근이름
		 * @param	{String}	sElement	템플릿
		 * @return	{jindo.$Template|Object|null}
		 */
		template : function(oName, sTemplate) {
			var htTemplates = this.option('templates');

			if (typeof htTemplates == 'undefined' || htTemplates === null) {
				htTemplates = {};
				this.option('templates', htTemplates);
			}

			if (typeof oName == 'object') {
				for(var sKey in oName) {
					htTemplates[sKey] = oName[sKey];
				}
			} else if (typeof oName == 'string') {
				if (typeof sTemplate == 'string') {
					htTemplates[oName] = sTemplate;
				} else {
					return J.$Template(htTemplates[oName]);
				}
			} else {
				return null;
			}
		},

		/**
		 * @description 클래스를 반환하거나 옵션에 저장한다.
		 * @param	{Object}	oName		클래스접근이름
		 * @param	{String}	sStyle		클래스명
		 * @return	{String|Object|null}
		 */
		css : function(oName, sStyle) {
			var htStyles = this.option('css');

			if (typeof htStyles == 'undefined' || htStyles === null) {
				htStyles = {};
				this.option('css', htStyles);
			}

			if (typeof oName == 'object') {
				for(var sKey in oName) {
					htStyles[sKey] = oName[sKey];
				}
			} else if (typeof oName == 'string') {
				if (typeof sStyle == 'string') {
					htStyles[oName] = sStyle;
				} else {
					return htStyles[oName];
				}
			} else {
				return null;
			}
		},

		/**
		 * @description 메시지를 재정의 한다.
		 * @param	{String}	sName		메시지명
		 * @param	{String}	sMessage	메시지내용
		 */
		message : function(oName, sMessage) {
			var htMessage = this.message;

			if (typeof oName == 'object') {
				for(var sKey in oName) {
					htMessage[sKey] = oName[sKey];
				}
			} else if (typeof oName == 'string') {
				if (typeof sMessage == 'string') {
					htMessage[oName] = sMessage;
				}
			}
		},
		
		/**
		 * @description 서버에서 설정 값을 가져와서 config에 세팅한다.
		 */
		setTicketConfig : function() {
			var htParams = {
				ticket : this.option('ticket')
			};
			
			this.instance.ajax.call({
				operation : 'ticketConfig',
				onSuccess : J.$Fn(function(oResponse) {
					this.option('social', oResponse.social);
				}, this).bind(),
				param : htParams
			});
		},
		
		getUrlList : function() {
			var whtUrlList = J.$H(this.option('urlList'));
	    	if (whtUrlList.length() == 0) {
	    		this.instance.ajax.call({
	    			operation : 'urlList',
	    			onSuccess : J.$Fn(function(oResponse) {
	    				this.option('urlList', oResponse.url_list);
	    			}, this).bind(),
	    			param : {}
	    		});
	    	}
	    	
	    	return this.option('urlList');
		}
	}).extend(J.Component);


	Comment.Config.prototype.message.UNAVAILABLE_OPERATION = '요청한 동작을 수행할 수 없습니다.';
	Comment.Config.prototype.message.ALREADY_REPORT = '이미 신고된 글입니다.';
	Comment.Config.prototype.message.REPORT_COMPLETE = "신고 완료 처리 되었습니다.";
	Comment.Config.prototype.message.NOT_LOGIN = '로그인이 필요한 서비스 입니다.\n로그인 하시겠습니까?';
	Comment.Config.prototype.message.EXCEED_MAX_LENGTH = '최대 {=max}자까지 입력할 수 있습니다.';
	Comment.Config.prototype.message.NO_CONTENTS = '내용을 입력해주세요.';
	Comment.Config.prototype.message.DELETE_CONFIRM = '정말 삭제하시겠습니까?';
	Comment.Config.prototype.message.CREATE_ERROR_PWORD_BLOCK = '작성하신 내용에 금칙어가 포함되어 있습니다. [{=pwords}]';
	Comment.Config.prototype.message.CREATE_ERROR_PWORD_ABUSING = '작성하신 내용에 사용이 제한된 문구가 포함되어 일시적으로 등록이 제한됩니다.';
	Comment.Config.prototype.message.DEFAULT_TEXT = '주제와 무관한 댓글, 악플은 삭제될 수 있습니다.';
	Comment.Config.prototype.message.NOT_AUTHENTICATED = '정보통신망법에 따라 게시판에 글 작성 시 실명확인이 필요합니다.\n실명확인을 하시겠습니까?';

	nhn.comment.config = new Comment.Config();

})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};


/**
* @(#)nhn.comment.mobile.ajax.js 2012. 03. 19
*/
(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/**
	 * @description 댓글에서 ajax 호출과 응답 처리 클래스
	 */
	Comment.Ajax = J.$Class({
		/** @lends nhn.comment.mobile.Ajax.prototype */

		message : {},

		_htDefaultErrors : {},
		error : {
			create : {}
		},

		/**
		 * @description 초기화 함수
		 * @constructs
		 * @class
		 * @extends jindo.Component
		 */
		$init : function() {
			this.option('handlers', {});
			this.option('list', 'list_comment.nhn');
			this.option('moreList', 'list_next_comment.nhn');
			this.option('create', 'set_comment.nhn');
			this.option('delete', 'delete_comment.nhn');
			this.option('isReport', 'isreported_comment.nhn');
			this.option('report', 'report_comment.nhn');
			this.option('isLogin', 'is_logged_in.nhn');
			this.option('vote', 'vote_comment.nhn');
			this.option('checkAuth', 'is_authenticated_name.nhn');
			this.option('snsAuthStatus', 'get_sns_auth_status.nhn');	// SNS 연동 인증 상태 조회 API
			this.option('ticketConfig', 'get_ticket_config.nhn');		// 티켓 설정 조회 API
			this.option('urlList', 'get_url_list.nhn');	// URL list 조회 API
			this.option('replyList', 'list_reply_comment.nhn'); // reply list 조회 API

			this.indexInstance = Comment.Ajax.getInstance().length - 1;
			this.config = Comment.Config.getInstance()[this.indexInstance];
		},

		/**
		 * errorHandler 초기화.
		 */
		initErrorHandler : function() {
			//댓글 등록시 로그인상태가 아니면 아래 Error Code(403101) 리턴, 실명 미인증시면 Error Code(301) 리턴
			// 기본 errorHandler
			this.setErrorHandlers({
				'403101' : J.$Fn(this._handleNotLoginError, this).bind(),
				'301' : J.$Fn(this._handleNotAuthError, this).bind()
			});

			// 사용자가 customizing한 handler가 있을 경우, 해당 handler 등록
			this.setErrorHandlers(this.config.option('errorHandlers'));
		},

		/**
		 * @description 파라미터를 반환한다.
		 * @return	{HashTable}	파라미터
		 */
		getCommonParams : function() {
			var htParams = {};

			htParams.ticket = this.config.option('ticket');
			htParams.object_id = this.config.option('objectId');
			htParams._ts = (new Date().getTime());

			//lkey는 보안키. config에 use_secure_key 가 true라면 lkey가 없으면 결과값을 반환하지 않는다.
			if (typeof this.config.option('lkey') != 'undefined') {
				htParams.lkey = this.config.option('lkey');
			}

			if (typeof this.config.option('viewCategoryId') != 'undefined') {
				htParams.view_category_id = this.config.option('viewCategoryId');
			}

			if (typeof this.config.option('categoryId') != 'undefined') {
				htParams.category_id = this.config.option('categoryId');
			}

			return htParams;
		},

		/**
		 * @description 리스트용 파라미터를 반환한다.
		 * @return	{HashTable}	파라미터
		 */
		getListParams : function() {
			var htParams = this.getCommonParams();
			htParams.page_size = this.config.option('pageSize');
			return htParams;
		},

		/**
		 * @description 처리동작에 맞는 ajax 호출 url 을 반환한다.
		 * @return	{String}	url
		 */
		getUrl : function(sOperation) {
			var sUrl = this.config.option('serviceAddress') + this.option(sOperation);
			return sUrl;
		},

		/**
		 * @description ajax 를 호출한다.
		 * @param	{HashTable}	url & 파라미터
		 */
		call : function(htOptions) {
			var handler = this.option('handlers');
			delete handler[htOptions.operation];
			handler[htOptions.operation] = htOptions.onSuccess;

			var sUrl = this.getUrl(htOptions.operation);
			var req = J.$Ajax(sUrl, {
				method : this.config.option('method') || 'post',
				async : htOptions.async ? htOptions.async : false,
				onload : J.$Fn(this._onSuccess, this).bind(htOptions.operation, htOptions.param),
				onerror : J.$Fn(this._onError, this).bind(htOptions.errorMessage)
			});
			req.request(htOptions.param);
		},

		callSync : function(operation, param) {
			var sUrl = this.getUrl(operation);
			var context = { success:undefined, response:undefined };
			var req = J.$Ajax(sUrl, {
				method : this.config.option('method') || 'post',
				async : false,
				onload : J.$Fn(this._onSuccessSync, this).bind(context),
				onerror : J.$Fn(this._onErrorSync, this).bind(context)
			});
			req.request(param);
			// 연결 성공여부
			if(context.success) {
				// 응답의 에러코드 확인
				var errorCode = this._errorHandler(context.response, this.error[operation]);
				if(errorCode == 0) {
					// 성공적인 응답인 경우, json 응답결과의 객체를 반환한다.
					return context.response;
				}
			}
		},

		_onSuccessSync : function(context, response) {
			context.success = true;
			context.response = response.json();
		},

		_onErrorSync : function(context, response) {
			context.success = false;
		},

		/**
		 * @description 응답 성공시 callback 함수를 호출한다.
		 */
		_onSuccess : function(sType, htParams, oResult) {
			var oMessage = oResult.json();

			if (this._errorHandler(oMessage, this.error[sType]) === 0) {
				var fn = this.option('handlers')[sType];
				fn(oMessage, htParams);
			}
		},

		/**
		 * @description 응답 에러시 에러코드에 맞는 메시지를 alert 으로 출력한다.
		 */
		_onError : function(oMessage, oResult) {
			if(typeof oMessage != 'undefined'){
				alert(oMessage);
			}
		},

		/**
		 * @description 응답은 성공했으나, 에러코드가 반환될 경우, 해당하는 에러 메시지를 alert 으로 출력한다.
		 */
		_errorHandler : function(message, errorhandler) {
			if (!message.error) {
				return -1;
			}

			var error = message.error;

			if ( !error.no || error.no == '0') {
				return Number(error.no);
			}

			if (error.no == '-1') {
				alert(this.config.message.UNAVAILABLE_OPERATION);
				return Number(error.no);
			}

			if (errorhandler && errorhandler[error.no]) {
				var fnTemp = J.$Fn(errorhandler[error.no], this).bind();
				fnTemp(message);
			} else {
				if (this._htDefaultErrors && this._htDefaultErrors[error.no]) {
					this._htDefaultErrors[error.no](message, this);
				} else {
					alert(error.message);
				}
			}

			return Number(error.no);
		},

		/**
		 * AJax결과에 대한 error handler 등록
		 */
		setErrorHandlers : function(htHandlers) {
			if ( typeof htHandlers != 'object') {
				return;
			}

			for ( var sKey in htHandlers) {
				this._htDefaultErrors[sKey] = htHandlers[sKey];
			}
		},

		//댓글 등록시 로그인상태가 아니면 아래 Error Code(403101) 리턴, 실명 미인증시면 Error Code(301) 리턴
		//재 로그인이 필요하므로 기존 로그인 여부 플래그 false 지정후 로그인필요 컨펌 노출
		_handleNotLoginError : function(oResult, oThis) {
			oThis.config.option('isLogin', false);
			oThis.config.instance.auth.redirectLogin();
		},

		_handleNotAuthError : function(oResult, oThis) {
			oThis.config.option('isAuth', false);
			oThis.config.instance.auth.redirectAuth();
		}

	}).extend(J.Component);

	nhn.comment.ajax = new Comment.Ajax();
})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
* @(#)nhn.comment.mobile.commentItem.js 2012. 03. 19
*/
(function() {

	var J = window.nhn.comment.mobile.jindo || jindo,
	    Comment = nhn.comment.mobile,
	    Util = Comment.Util;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/**
	 * @description 댓글 아이템을 생성하는 클래스 (listArea Class 에서 댓글 개수만큼 commentItem 인스턴스를 생성해서 dom 에 append 하는 구조임)
	 */
	Comment.CommentItem = J.$Class({
		/** @lends nhn.comment.mobile.CommentItem.prototype */

		/**
		 * @description 초기화 함수
		 * @constructs
		 * @class
		 * @param	{HashTable}	htOptions	댓글생성시필요한 옵션들
		 * @extends jindo.Component
		 */
		$init : function(htOptions) {
			this.indexInstance = htOptions.indexInstance;
			this.config = Comment.Config.getInstance()[this.indexInstance];

			var _values = this.config.option('comment');
			var _convention = this.config.option('convention');
			var _booleans = this.config.option('booleans');

			//옵션에 저장되어있는 키값으로,
			//받아온 htOption에 대입시켜 값을 옵션에 넣는다.
			for ( var i =0 ; i < _values.length ; i++){
				var key = _convention[_values[i]];

				if (typeof key == 'undefined') {
					key = _values[i];
				}

				var value = htOptions[key];

				if (_booleans[_values[i]]) {
					value = (value == 'Y');
				}
				if (key == 'reply_count') {
					value = Util.setNumberFormat(value == null ? 0 : value);
					
				}
				this.option(_values[i], value);
			}

			this.option('maxDepth', this.config.option('maxDepth'));

			// 설정객체를 통째로 넣는다
			this.option('config', this.config);
		},

		/**
		 * @description 댓글을 생성한다.
		 * @param	{jindo.$Element}	welParent	부모엘리먼트
		 */
		createItem : function(welParent, nPreSiblingCommentNo) {
			var sTplComment = null;

			if (this.option('isDeleted')) {
				sTplComment = this.config.template('deleteComment');
			} else {
				//삭제된것은 아니지만 게시중단댓글일 경우는 삭제는 가능하지만 댓글 내용은 게시중단에 알맞게 보여준다.
				if(Util.isInterruptedComment(this.option('status'))){
					sTplComment = this.config.template('blockComment');
				} else {
					sTplComment = this.config.template('comment');
				}
			}

			// 소셜댓글
			this.option('socialCommentArea', this._createSocialCommentAreaHtml());
			
			// 추천비추천
			this.option('recommendDiscommendArea', this._createRecommendDiscommendAreaHtml());
			
			var sComment = sTplComment.process(this.option());
			var welComment = J.$Element(sComment);

			// 이전 commentNo가 0이면 가장 앞에 추가
			if ( nPreSiblingCommentNo == 0) {
				var welCommentBody = this.config.instance.core.getBody();
				var welBestList = J.$Element(welCommentBody.query(this.config.element('bestCommentList')));
				if (welBestList == null || welBestList.query('.first') == null) {
					var welCommentList = J.$Element(welCommentBody.query(this.config.element('list')));
					if(!!welCommentList.query('.first')){
						welCommentList.query('.first').removeClass('first');
					}
					welComment.addClass('first');
				} else {
					welComment.addClass('best');
				}
				welParent.prepend(welComment);
			} else  {
				var welPreSiblingLi = J.$Element(this.config.instance.listarea.getElCommentLiTag(nPreSiblingCommentNo));
				welPreSiblingLi.after(welComment);
			}

			this._populateCommand(welComment);
			this._createReplyWriteBox(welComment);
		},
		
		/**
		 * @description 베스트댓글을 생성한다.
		 * @param	{jindo.$Element}	welParent	부모엘리먼트
		 */
		createBestItem : function(welParent, nPreSiblingCommentNo, isReply) {
			var sTplComment = null;

			if (this.option('isDeleted')) {
				sTplComment = this.config.template('deleteComment');
			} else {
				//삭제된것은 아니지만 게시중단댓글일 경우는 삭제는 가능하지만 댓글 내용은 게시중단에 알맞게 보여준다.
				if(Util.isInterruptedComment(this.option('status'))){
					sTplComment = this.config.template('blockComment');
				} else {
					sTplComment = this.config.template('comment');
				}
			}

			// 소셜댓글
			this.option('socialCommentArea', this._createSocialCommentAreaHtml());
			
			// 추천비추천
			this.option('recommendDiscommendArea', this._createRecommendDiscommendAreaHtml());
			
			var sComment = sTplComment.process(this.option());
			var welComment = J.$Element(sComment);

			// 이전 commentNo가 0이면 가장 앞에 추가
			if ( nPreSiblingCommentNo == 0) {
				if(!isReply) {
					welComment.addClass('first');
				}
				welParent.prepend(welComment);
				if(isReply){
					welComment.attr('tabindex', '-1');
					welComment.$value().focus();
					// focus영역표시를 없애기 위해 다시 blur시킨다
					welComment.$value().blur();
					welComment.attr('tabindex', null);
				}
			} else  {
				var welPreSiblingLi = J.$Element(this.config.instance.bestlistarea.getElCommentLiTag(nPreSiblingCommentNo));
				welPreSiblingLi.after(welComment);
			}

			this._populateCommand(welComment);
			this._createReplyWriteBox(welComment);
		},
		
		/**
		 * @description 소셜댓글 영역 HTML 생성
		 * @returns {String} 소셜댓글 영역 HTML
		 */
		_createSocialCommentAreaHtml : function() {
			// 소셜댓글 인스턴스가 있는지 체크
			if (!Comment.SocialCommentArea || !this.config.option('isLogin')) {
				return '';
			}
			
			// 있으면 소셜댓글 영역 HTML 가져와서 반환
			this.config.instance.socialCommentArea = Comment.SocialCommentArea.getInstance()[this.indexInstance];
			return this.config.instance.socialCommentArea.createListAreaHtml(this.option());
		},
		
		/**
		 * @description 추천비추천 영역 HTML 생성
		 * @returns {String} 추천비추천 영역 HTML
		 */
		_createRecommendDiscommendAreaHtml : function() {
			// 추천비추천 인스턴스가 있는지 체크
			if (!Comment.RecommendDiscommendArea) {
				return '';
			}
			
			// 있으면 추천비추천 영역 HTML 가져와서 반환
			this.config.instance.recommendDiscommendArea = Comment.RecommendDiscommendArea.getInstance()[this.indexInstance];
			
			var sHtml = '<div class="u_comment_recomm __comment_recomm">' + this.config.instance.recommendDiscommendArea.createListAreaHtml(this.option()) + '</div>';
			return sHtml;
		},

		/**
		 * Command영역 생성
		 */
		_populateCommand : function(welComment) {
			if ( welComment == null) return;
			var welCommandArea = J.$Element(welComment.query(this.config.element('commandArea')));

			if ( welCommandArea == null ) return;
			var sCommandText = this._createCommand();

			if ( sCommandText == null) return;
			welCommandArea.appendHTML(sCommandText);
		},

		/**
		 * 답글 영역 생성
		 */
		_createReplyWriteBox : function(welComment) {
			this.option('isLogin', this.config.option('isLogin'));
			this.option('maximumCommentLength', this.config.option('maximumCommentLength'));

			this.config.instance.writearea.createReplyArea(welComment, this.option());
		},

		/**
		 * @description 댓글을 상태에 맞는 코맨드를 생성한다.
		 */
		_createCommand : function() {
			var aCommands = this.config.option('commands');
			var sOperation = '',
				sText = '',
				aCommandText = [];

			for ( var i = 0; i < aCommands.length; i++) {
				sText = '';
				sOperation = aCommands[i];

				//만약 삭제된 댓글이라면 커맨드를 만들지 않는다.
				if(this.option('isDeleted')){
					continue;
				}

				//만약 게시중단된 댓글이라면 삭제명령만 통과시킨다.
				if (Util.isInterruptedComment(this.option('status')) && !(sOperation === 'delete')) {
					continue;
				}

				// deleteCommand, reportCommand 존재.
				sText = this.config.template(sOperation + 'Command').process(this.option());

				//만약 권한등의 이유로 표시 안되는 명령이 있다면, 다음 명령으로 넘어간다.
				if(sText == "") {
					continue;
				}
				aCommandText.push(sText);
			}

			return aCommandText.join('');
		},

		getCommentNo : function() {
			return this.option('commentNo');
		},

		getReplyLevel : function() {
			return this.option('replyLevel');
		},

		getRegisteredDate : function() {
			return this.option('registeredDate');
		},

		isDeleted : function() {
			return this.option('isDeleted') == true;
		}
	}).extend(J.Component);
})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
* @(#)nhn.comment.mobile.command.js 2012. 03. 19
*/

(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile,
		Util = nhn.comment.mobile.Util;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/**
	 * @description 댓글 리스트에서의 명령어 처리(삭제 등)
	 */
	Comment.Command = J.$Class({
		/** @lends nhn.comment.mobile.Command.prototype */

		/**
		 * @description 초기화 함수
		 * @constructs
		 * @class
		 * @extends jindo.Component
		 */
		$init : function() {
			this.indexInstance = Comment.Command.getInstance().length - 1;
			this.config = Comment.Config.getInstance()[this.indexInstance];
		},

		/**
		 * 댓글을 삭제한다.
		 * @param	{jindo.$Event}	oEvent	이벤트객체
		 * @param	{HTMLElement}	elItem	엘리먼트
		 */
		deleteComment : function(oEvent, elItem) {
			oEvent.stop();

			var deleteConfirmMessage = this.config.message.DELETE_CONFIRM;

			if(!confirm(deleteConfirmMessage)){
				return false;
			}

			var htParams = this.config.instance.ajax.getListParams();
			htParams.comment_no = this.getCommentNo(elItem);
			htParams.page_no = this.config.instance.pagearea.getPageNo();
			htParams.best_yn = J.$Element(elItem).attr('best_yn');
			htParams.sort = this.config.option('currentSortOption');
			
			this.config.instance.ajax.call( {
				operation : 'delete',
				onSuccess : J.$Fn(this._onDeleteComment, this).bind(),
				param : htParams
			});
		},

		/**
		 * 댓글을 삭제한다.
		 * @param	{jindo.$Event}	oEvent	이벤트객체
		 * @param	{HTMLElement}	elItem	엘리먼트
		 */
		deleteBestReplyComment : function(oEvent, elItem) {
			oEvent.stop();
			var parentCommentNo = Util.DomData.get(elItem, this.config.css('parentCommentNo'))[0];
			if(parentCommentNo == 0 || parentCommentNo == null) {
				J.$Element(elItem).attr('best_yn','Y');
				this.deleteComment(oEvent, elItem);
				return;
			}
			var deleteConfirmMessage = this.config.message.DELETE_CONFIRM;

			if(!confirm(deleteConfirmMessage)){
				return false;
			}

			var htParams = this.config.instance.ajax.getListParams();
			htParams.comment_no = this.getCommentNo(elItem);
			htParams.page_no = this.config.instance.pagearea.getPageNo();
			htParams.parent_comment_no = parentCommentNo;
			
			this.config.instance.ajax.call( {
				operation : 'delete',
				onSuccess : J.$Fn(this._onDeleteBestReplyComment, this).bind(),
				param : htParams
			});
		},
		
		//덧글 신고
		reportComment : function(oEvent, elItem) {
			oEvent.stop();

			var params = {};
			params.ticket = this.config.option('ticket');
			params.object_id = this.config.option('objectId');
			params.comment_no = this.getCommentNo(elItem);

			//해당 신고가 이미 접수된것인지 알아본다.
			var response = this.config.instance.ajax.callSync('isReport', params);
			if(response) {
				if (response.reported_yn === 0) {
					// 공통신고팝업으로 redirect 하는 페이지의 URL과 파라미터를 생성한다.
					var url = document.location.protocol + '//' + document.location.host + '/' + 'comments' + '/' + 'get_report_information.nhn';
					if (params.ticket == '' || params.commentNo == '-1') {
						alert(commonMessage.openFail);
					}
					J.$Ajax(url, {
						async: false,
						onload: this.redirectCommonReport
					}).request({
						comment_no: params.comment_no,
						ticket: params.ticket,
						object_id: params.object_id,
						is_mobile: params.is_mobile,
						retUrl: params.retUrl
					});
				} else {
					// 이미 신고된 경우 중복신고 alert 창을 띄운다.
					alert(this.config.message.ALREADY_REPORT);
				}
			}
		},
		// 공통 덧글 신고 창으로 이동
		redirectCommonReport : function(result) {
			var message = result.json();
			var categoryList = message.category;

			var report = J.$Form('commentReportForm');
			report.$value().action = message.srp_url;
			report.value('itemVirtualSvcCd', message.virtual_service_code);
			report.value('itemId', message.content_id);
			report.value('itemTitle', message.contents);

			var categoryId = "";
			var categoryIds = new Array();
			var categoryNames = new Array();
			var categoryLevels = new Array();
			for(var index in categoryList){
				var category = categoryList[index];
				if(categoryId.length > 0){
					categoryId += ";";
				}
				categoryId += category.category_id;
				categoryIds.push(categoryId);
				categoryNames.push(category.category_name);
				categoryLevels.push(category.category_level);
			}
			report.value('itemCateId', categoryIds);
			report.value('itemCateName', categoryNames);
			report.value('itemCateLevel', categoryLevels);

			report.value('itemWriterId', message.masked_writer_id);
			report.value('itemEncyptWriterId', unescape(message.writer_id));
			report.value('itemWriterNick', message.writer_nickname);
			report.value('itemDt', message.registered_ymdt);
			report.value('retUrl', encodeURIComponent(window.location.href));

			report.submit();
		},
		
		/**
		 * 댓글의 번호를 반환한다.
		 * @param	{HTMLElement}	elItem	엘리먼트
		 * @return	{String}	댓글번호
		 */
		getCommentNo : function(elItem) {
			var sItemClass = this.config.css('commentItem');
			var elParent = Util.DomData.getParent(elItem, sItemClass);
			Util.DomData.get(elParent, sItemClass);

			return Util.DomData.last();
		},

		/**
		 * 댓글 삭제 후 처리
		 */
		_onDeleteComment : function(oResponse, htParams) {
			this.config.instance.sortListArea.resetArea();
			if (this.config.option('useMoreContent') && !this.config.option('isRedirectAfterDelete') && htParams.best_yn != "Y") {
				this.config.instance.listarea.deleteCommentForIos(htParams.comment_no);
			} else if ( !this.config.option('isRedirectAfterDelete')) {
				this.config.instance.listarea.refreshWithTheResult(oResponse);
			} else {
				var htParam = {};
				htParam[this.config.option('pagingParameterName') ] = this.config.option('pageNo');
				Util.movePage(this.config.option('objectUrl') , htParam);
			}
			
			var oResult = {};
			oResult.commentNo = htParams.comment_no;
			oResult.totalCount = this.config.instance.pagearea.getTotalCount();
			
			this._processAfterDelete(oResult);
		},
		

		/**
		 * 댓글 삭제 후 처리
		 */
		_onDeleteBestReplyComment : function(oResponse, htParams) {
			this.config.instance.bestlistarea.callReplyList(htParams.parent_comment_no, 1);
		},

		_processAfterDelete : function(oResult) {
			this.config.fireEvent('afterDelete', {
				'result': oResult
			});
		},

		toggleReplyForm : function(oEvent, elItem) {
			oEvent.stop();

			var sCommentNo = this.getCommentNo(elItem);
			
			var welReplyForm = J.$Element(Util.DomData.getChild(this.config.instance.listarea.getAreaElement().$value(), this.config.css('replyItem'), [sCommentNo ]));

			if ( !this.config.instance.listarea.toggleTargetAreaDependsOnLoginAndAuth(welReplyForm) ) {
				return;
			}
			this.config.instance.listarea.toogleReplyBtn(J.$Element(elItem));
		},
		
		/**
		 * 베스트답글 버튼 처리
		 */
		toggleReplyFormBest : function(oEvent, elItem) {
			oEvent.stop();
			var sCommentNo = this.getCommentNo(elItem);

			this.config.instance.bestlistarea.toogleReplyBtnBest(sCommentNo);
		},

		/**
		 * 베스트답글 버튼 처리 하단
		 */
		toggleReplyFormBestBottom : function(oEvent, elItem) {
			oEvent.stop();
			var sCommentNo = this.getCommentNo(elItem);
			this.config.instance.bestlistarea.toogleReplyBtnBest(sCommentNo);
			var welBtn = this.config.instance.bestlistarea._getAreaChildElement('replyButtonBest', sCommentNo);
			welBtn.$value().focus();
		}
	}).extend(J.Component);

	nhn.comment.command = new Comment.Command();
})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
* @(#)nhn.comment.mobile.countArea.js 2012. 03. 19
*/
(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile,
		Util = nhn.comment.mobile.Util;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/**
	 * @description 카운트영역을 처리하는 클래스
	 */
	Comment.CountArea = J.$Class({
		/** @lends nhn.comment.mobile.CountArea.prototype */

		/**
		 * @description 초기화 함수
		 * @constructs
		 * @class
		 * @extends jindo.Component
		 */
		$init : function() {
			this._welArea = null;

			this.indexInstance = Comment.CountArea.getInstance().length - 1;
			this.config = Comment.Config.getInstance()[this.indexInstance];
		},

		/**
		 * @description 카운트영역을 생성한다.
		 * @return {jindo.$Element}
		 */
		createArea : function() {
			this._welArea = J.$Element(this.config.template('countArea').process());
			return this._welArea;
		},

		/**
		 * @description 영역 생성 후..
		 */
		afterCreateArea : function() {
			this.update(0);
			this._createBubbler();
		},

		/**
		 * @description 카운트영역을 반환한다.
		 * @return {jindo.$Element}
		 */
		getAreaElement : function() {
			return this._welArea;
		},

		/**
		 * @description 카운트영역을 업데이트한다.
		 */
		update : function(nTotalCount) {
			var elCount = null;

			this.getAreaElement().empty();

			elCount = this.config.template('countSimple').process({count : nTotalCount});
			this.getAreaElement().append(elCount);
		},

		/**
		 * @description 이벤트를 할당한다.
		 */
		_createBubbler : function() {
			this._oBubbler = new Util.Bubbler(this.getAreaElement().$value()).attach({
				'__comment_writebox_view:click' : J.$Fn(this._onClickWriteboxView, this).bind(),
				'__comment_refresh_btn:click' : J.$Fn(this._onClickRefreshButton, this).bind()
				
			});

			this.getAreaElement().preventTapHighlight(true);
		},

		/**
		 * @description 글쓰기 페이지 이동 버튼
		 * @param	{jindo.$Event}	oEvent	이벤트객체
		 */
		_onClickWriteboxView : function(oEvent) {
			oEvent.stop();
			
			top.location = this.config.option('writeLinkUrl');
		},
		_onClickRefreshButton : function(oEvent) {
			oEvent.stop();
			
			this.config.instance.listarea.refresh();
		}
	}).extend(J.Component);

	nhn.comment.countarea = new Comment.CountArea();
})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
* @(#)nhn.comment.mobile.writeArea.js 2012. 03. 19
*/
(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile,
		Util = Comment.Util;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/**
	 * @description 글쓰기 영역을  처리하는 클래스
	 */
	Comment.WriteArea = J.$Class({
		/** @lends nhn.comment.mobile.WriteArea.prototype */

		/**
		 * @description 초기화 함수
		 * @constructs
		 * @class
		 * @extends jindo.Component
		 */
		$init : function() {
			this._whtWriteArea = J.$H({});

			this._welArea = null;
			this._welTextarea = null;

			this.indexInstance = Comment.WriteArea.getInstance().length - 1;
			this.config = Comment.Config.getInstance()[this.indexInstance];
		},

		/**
		 * @description 글쓰기 영역을 생성한다.
		 * @return {jindo.$Element}
		 */
		createArea : function() {
			this._welArea = J.$Element(this.config.template('rootWriteBoxArea').process());
			return this._welArea;
		},

		/**
		 * @description 영역 생성 후..
		 */
		afterCreateArea : function() {
			this._createWriteBox();
			this._createBubbler(this._welArea, this._welTextarea);
		},

		/**
		 * 답글 영역 생성
		 */
		createReplyArea : function(welComment, htOptions) {
			if ( welComment == null || htOptions == null ) {
				return;
			}
			
			var welReply = welComment.query('.__comment_reply');
			
			if ( welReply == null ) {
				return;
			}

			var sReplyWriteArea = this.config.template('replyWriteBoxArea').process(htOptions);
			var welReplyWriteArea = J.$Element(sReplyWriteArea);

			// 답글 작성자 영역
			//var sReplyWriterArea = this._createReplyWriterAreaHtml(htOptions.replyLevel);
			//welReplyWriteArea.append(J.$Element(sReplyWriterArea));

			// 답글쓰기창 영역
			htOptions.writePrompt = this._createWritePromptHtml(0);
			htOptions.socialCommentArea = this._createSocialCommentAreaHtml(false);
			var sWriteBox = this.config.template('writeBox').process(htOptions);
			welReplyWriteArea.append(J.$Element(sWriteBox));
			welReply.append(welReplyWriteArea);

			// 기본문구 적용
			var welTargetTextarea = J.$Element(Util.DomData.getChild(welReplyWriteArea.$value(), this.config.css('textarea')));
			welTargetTextarea.text(this.config.message.DEFAULT_TEXT);

			// 이벤트 설정
			this._createBubbler(welReplyWriteArea, welTargetTextarea);
		},

		/**
		 * 답글 작성자 영역 생성
		 */
		_createReplyWriterAreaHtml : function(sReplyLevel) {
			var htParam = {};
			htParam.replyLevel = sReplyLevel;
			htParam.myNickName = this.config.option('myNickName');
			return this.config.template('replyWriterArea').process(htParam);
		},

		/**
		 * 댓글, 답글 쓰기창 입력 문자 카운트 영역 생성
		 */
		_createWritePromptHtml : function(sLength) {
			return this.config.template('writePrompt').process({
				"maximumCommentLength" : this.config.option('maximumCommentLength'),
				"inputCommentLength" : sLength
			});
		},

		/**
		 * 해당 comment에 대한 댓글, 답글 쓰기창 입력 문자 카운트 업데이트
		 */
		_updatePromptArea : function(sTargetCommentNo, bestYn, sLength) {
			var elTargetPrompt = null;
			if(bestYn == "Y") {
				elTargetPrompt = Util.DomData.getChild(this.config.instance.bestlistarea.getAreaElement().$value(), this.config.css('writePrompt'), [sTargetCommentNo]);
			} else {
				elTargetPrompt = Util.DomData.getChild(this.config.instance.core.getBody().$value(), this.config.css('writePrompt'), [sTargetCommentNo]);
			}
			
			if ( elTargetPrompt == null) {
				return;
			}

			var sWritePrompt = this._createWritePromptHtml(sLength);

			J.$Element(elTargetPrompt).html(sWritePrompt);
		},

		/**
		 * @description 글쓰기영역을 반환한다.
		 * @return {jindo.$Element}
		 */
		getAreaElement : function() {
			return this._welArea;
		},

		/**
		 * @description 글쓰기영역을 보여준다.
		 */
		show : function() {
			this._welArea.show();
		},

		/**
		 * @description 글쓰기 창에 포커스
		 */
		focus : function(sTargetCommentNo, bestYn) {
			this._getTargetTextarea(sTargetCommentNo, bestYn).$value().focus();
		},

		/**
		 * @description 글쓰기 창에 포커스아웃
		 */
		blur : function(sTargetCommentNo, bestYn) {
			this._getTargetTextarea(sTargetCommentNo, bestYn).$value().blur();
		},

		/**
		 * @description 소셜댓글 영역 HTML 생성
		 * @param bRoot {Boolean} 최상위 댓글 여부(댓글:true, 답글:false)
		 * @returns {String} 소셜댓글 영역 HTML
		 */
		_createSocialCommentAreaHtml : function(bRoot) {
			// 소셜댓글 인스턴스가 있는지 체크
			if (!Comment.SocialCommentArea ) {
				return '';
			}
			
			// 있으면 소셜댓글 영역 HTML 가져와서 반환
			this.config.instance.socialCommentArea = Comment.SocialCommentArea.getInstance()[this.indexInstance];
			
			return this.config.instance.socialCommentArea.createWriteBoxAreaHtml(bRoot);
		},

		/**
		 * @description 소셜댓글 이벤트 바인딩 호출
		 * @param elTargetArea {Element} 이벤트 바인딩할 영역
		 */
		_createSocialCommentBubbler : function(elTargetArea) {
			// 소셜댓글 인스턴스가 없으면 패스
			if (!Comment.SocialCommentArea ) {
				return;
			}
			
			// 소셜댓글에 이벤트 바인딩
			this.config.instance.socialCommentArea = Comment.SocialCommentArea.getInstance()[this.indexInstance];
			if (this.config.instance.socialCommentArea) {
				this.config.instance.socialCommentArea.createWriteBoxBubbler(elTargetArea.query(this.config.element('socialCommentWriteBoxArea')));
			}
		},
		
		/**
		 * @description 소셜댓글 체크박스 파라미터 처리
		 * @param welForm {WrappingElement} 글쓰기 폼
		 * @param oParam {HashTable} 파라미터 해시 테이블
		 * @returns {HashTable} oParam 받은 파라미터 다시 반환
		 */
		_getSocialCommentParams : function(welForm, oParam) {
			// 소셜댓글 인스턴스가 없으면 패스
			if (!Comment.SocialCommentArea ) {
				return oParam;
			}
			
			// 소셜댓글에 이벤트 바인딩
			this.config.instance.socialCommentArea = Comment.SocialCommentArea.getInstance()[this.indexInstance];
			if (this.config.instance.socialCommentArea) {
				return this.config.instance.socialCommentArea.getParams(welForm, oParam);
			}
			
			return oParam;
		},
		
		/**
		 * @description 글쓰기 폼을 생성한다.
		 */
		_createWriteBox : function() {
			var sWritePrompt = this._createWritePromptHtml(0);
			var sSocialComment = this._createSocialCommentAreaHtml(true);
			var sWriteBox = this.config.template('writeBox').process({
				"isLogin" : this.config.option('isLogin'),
				"writePrompt" : sWritePrompt,
				"socialCommentArea" : sSocialComment,
				"commentNo" : 0
			});
			var welWriteBox = J.$Element(sWriteBox);
			this._welArea.append(welWriteBox);

			this._welTextarea = J.$Element(welWriteBox.query(this.config.element('textarea')));
			this._welTextarea.text(this.config.message.DEFAULT_TEXT);

			if (this.config.option('isHideWriteForm')) {
				this._welArea.hide();
			} else {
				this._welArea.show();
			}
		},

		/**
		 * @description 이벤트를 바인딩한다.
		 */
		_createBubbler : function(welTargetWriteArea, welTargetTextArea) {
			this._oBubbler = new Util.Bubbler(welTargetWriteArea.$value()).attach({
				'__comment_textarea:keydown' : J.$Fn(this._onKeyDownWriteBox, this).bind(),
				'__comment_write_btn:click' : J.$Fn(this._onClickWriteBtn, this).bind(),
				'__comment_textarea:click' : J.$Fn(this._onClickWriteBox, this).bind()				
			});

			J.$Fn(this._onBlurWriteBox, this).attach(welTargetTextArea.$value(), 'blur');
			J.$Fn(this._onFocusWriteBox, this).attach(welTargetTextArea.$value(), 'focus');

			welTargetWriteArea.preventTapHighlight(true);
			
			this._createSocialCommentBubbler(welTargetWriteArea);	// 소셜댓글 이벤트 바인딩
		},

		/**
		 * bind된 function release
		 */
		releaseBubbler : function(sCommentNo) {
			var elTargetTextArea = Util.DomData.getChild(this.config.instance.listarea.getAreaElement().$value(), this.config.css('textarea'), [sCommentNo]);
			
			if ( elTargetTextArea == null ) { // n차 댓글이 없는 경우는 return
				return;
			}

			J.$Fn(this._onBlurWriteBox, this).detach(elTargetTextArea, 'blur');
			J.$Fn(this._onFocusWriteBox, this).detach(elTargetTextArea, 'focus');
		},

		/**
		 * @description 포커스 이벤트 발생시
		 * @param	{jindo.$Event} oEvent 이벤트 객체
		 */
		_onFocusWriteBox : function(oEvent) {		
			
			this._afterFocus(oEvent);
		},

		/**
		 * @description 포커스 이벤트 발생시
		 * 				//크롬, 모바일 브라우저에서 confirm 창에서 취소를 눌러도
		 * 				textarea 에 focus 가 가서 무한루프가 돌아서 blur 로 회피함
		 * @param	{jindo.$Event} oEvent 이벤트 객체
		 */
		_afterFocus : function(oEvent) {
			// for cross-browsing
			var welTextarea = J.$Element(oEvent.$value().target);
			if ( welTextarea == null) {
				welTextarea = J.$Element(oEvent.element);
			}

			this._hideDefaultText(welTextarea);
		},

		/**
		 * @description 포커스 이벤트 발생시
		 * @param	{jindo.$Event} oEvent 이벤트 객체
		 */
		_onBlurWriteBox : function(oEvent) {
			// for cross-browsing
			var welTextarea = J.$Element(oEvent.$value().target);
			if ( welTextarea == null) {
				welTextarea = J.$Element(oEvent.element);
			}

			this._showDefaultText(welTextarea);
		},

		/**
		 * @description 키다운이벤트 발생시
		 * @param	{jindo.$Event} oEvent 이벤트 객체
		 */
		_onKeyDownWriteBox : function(oEvent) {
			// 기기 별로 textarea에 값을 입력후 이벤트 발생하기도 하고, 입력전에 발생하기도 하여
			// 약간의 delay설정(모두 입력후 발생하도록)
			if (!this.config.instance.auth.redirectLogin()) {
				return;
			}
			
			setTimeout(J.$Fn(this._doAfterKeyDownEvent, this).bind(oEvent), 10);
		},
		
		/**
		 * @description 클릭이벤트 발생시
		 * @param	{jindo.$Event} oEvent 이벤트 객체
		 */
		_onClickWriteBox : function(oEvent) {
			if (!this.config.instance.auth.redirectLogin()) {
				var sTargetCommentNo = Util.DomData.get(oEvent.element, this.config.css('textarea'))[0];
				var bestYn = Util.DomData.get(oEvent.element, this.config.css('userRecommendYn'))[0];
				this.blur(sTargetCommentNo, bestYn);
				return;	
			}
		},

		_doAfterKeyDownEvent : function(oEvent) {
			// for cross-browsing
			var elTarget = oEvent.$value().target;
			if ( elTarget == null) {
				elTarget = oEvent.element;
			}

			var sTargetCommentNo = Util.DomData.get(elTarget, this.config.css('textarea'))[0];
			var bestYn = Util.DomData.get(elTarget, this.config.css('userRecommendYn'))[0];
			if ( Util.isFunctionalKey(oEvent.key().keyCode) ) {
				var welTextArea = this._getTargetTextarea(sTargetCommentNo, bestYn);
				this._whtWriteArea.$(sTargetCommentNo, welTextArea.text());
				this._updatePromptArea(sTargetCommentNo, bestYn, J.$S(welTextArea.text()).trim().$value().length);

				return;
			}

			this._detectOverMaxLength(sTargetCommentNo, bestYn);
		},

		/**
		 * @description 글쓰기 버튼 클릭시
		 * @param	{jindo.$Event} oEvent 이벤트 객체
		 */
		_onClickWriteBtn : function(oEvent) {
			oEvent.stop();

			if (!this.config.instance.auth.redirectLogin()) {
				return;
			}
			if (!this.config.instance.auth.redirectAuth()) {
				return;
			}

			var welForm = J.$Element(oEvent.element).parent(function(v){  
	            return v.tag == 'form';
	        })[0];
			var elTextArea = Util.DomData.getChild(welForm.$value(), this.config.css('textarea'));

			var welTextarea = J.$Element(elTextArea);

			var sTargetCommentNo = Util.DomData.get(elTextArea, this.config.css('textarea'))[0];
			var sText = Util.trim(welTextarea.text());

			if (sText == this.config.message.DEFAULT_TEXT) {
				sText = '';
			}

			var bestYn = Util.DomData.get(elTextArea, this.config.css('userRecommendYn'))[0];
			if(!Util.validation(
					sText,
					1,
					this.config.option('maximumCommentLength'),
					this.config.message.NO_CONTENTS,
					false,
					this.config.message.EXCEED_MAX_LENGTH)){
				this.focus(sTargetCommentNo, bestYn);
				return;
			}

			//덧글이 입력되지 않았으면 에러
			if (sText.length === 0 || Util.compareTextWithoutRetuneChar(sText,this.config.message.DEFAULT_TEXT)) {
				alert(this.config.message.NO_CONTENTS);
				this.focus(sTargetCommentNo, bestYn);
				return;
			}

			//Fixed By qpitlove 글을 작성하기전에 외부에서 추가 파라미터를 설정할수 있도록 oParam 추가함
			var oParam = {};
			oParam.parent_comment_no = sTargetCommentNo;
			// 베스트 댓글의 답글인 경우 저장후 답글리스트 영역만 재정의 되기위한 flag로 사용
			oParam.user_recommend_yn = bestYn;
			oParam = this._getSocialCommentParams(welForm, oParam);	// 소셜댓글 파라미터 처리

			this._requestWrite(sText, oParam);
		},

		/**
		 * @description 글쓰기를 요청한다.
		 * @param	{String} sText 입력글
		 * @param	{Object} oParam 파라미터로 전달될 추가 파라미터
		 */
		_requestWrite : function(sText, oParam) {
			var htParams = this.config.instance.ajax.getCommonParams();
			htParams.page_size = this.config.option('pageSize');
			htParams.object_url = this.config.option('objectUrl');
			htParams.contents = sText;
			htParams.mobile_yn = 'Y';

			for(var prop in oParam){
				htParams[prop] = oParam[prop];
			}

			if ( !this._processBeforeWrite(htParams) ) {
				return;
			}

			this.config.instance.ajax.call( {
				operation : 'create',
				onSuccess : J.$Fn((htParams.user_recommend_yn == "Y" ? this._onWriteBestReply : this._onWrite), this).bind(),
				errorMessage : this.config.message.UNAVAILABLE_OPERATION,
				param : htParams
			});
		},

		/**
		 * @description 글쓰기를 완료하면 페이지 새로고침을 한다.
		 */
		_onWrite : function(oResponse, htParams) {
			this.config.option('currentSortOption','newest');
			this.config.instance.sortListArea.resetArea();
			this._initTargetWriteArea(htParams.parent_comment_no);

			if ( !this._processAfterWrite(this._extractCreatedCommentFromResponse(oResponse)) ) {
				return;
			}

			if (this.config.option('useMoreContent') ) {
				this._writeForIos(oResponse, htParams);
				return;
			}

			this._writeForAndroid(oResponse, htParams);
		},

		/**
		 * 베스트댓글의 답글저장후 처리
		 */
		_onWriteBestReply : function(oResponse, htParams) {
			this._initTargetWriteAreaBestReply(htParams.parent_comment_no);
			this.config.instance.bestlistarea.callReplyList(htParams.parent_comment_no, 0);
		},

		/**
		 * 글 등록후 해당 영역 초기화
		 */
		_initTargetWriteArea : function(sCommentNo) {
			// 글 등록후 답글창 숨기기
			this._hideTargetReplyForm(sCommentNo);

			// 글 등록후 기본문구로 대체함
			this._getTargetTextarea(sCommentNo, "N").text(this.config.message.DEFAULT_TEXT);

			// 입력 길이 초기화
			this._updatePromptArea(sCommentNo, "N", 0);
		},

		/**
		 * 배스트댓글의 답글 등록후 해당 영역 초기화
		 */
		_initTargetWriteAreaBestReply : function(sCommentNo) {
			// 글 등록후 답글창 숨기기
			//this._hideTargetReplyForm(sCommentNo);

			// 글 등록후 기본문구로 대체함
			this._getTargetTextarea(sCommentNo, "Y").text(this.config.message.DEFAULT_TEXT);

			// 입력 길이 초기화
			this._updatePromptArea(sCommentNo, "Y", 0);
		},

		
		/**
		 * 안드로이드 및 일반 브라우저에서 쓰기 완료후 동작
		 */
		_writeForAndroid : function(oResponse, htParams) {
			this.config.instance.listarea.refreshWithTheResult(oResponse);
		},

		/**
		 * 글작성 전 전처리
		 */
		_processBeforeWrite : function(htParam) {
			return this.config.fireEvent('beforeWrite', {
				'oParam' : htParam
			});
		},

		/**
		 * 글작성후 후처리(리스트 그리기 전)
		 */
		_processAfterWrite : function(htResultComment) {
			return this.config.fireEvent('afterWrite', {
				'oResultComment': htResultComment
			});
		},

		/**
		 * IOs 글쓰기
		 */
		_writeForIos : function(oResponse, htParams) {
			var oRawCreatedComment = this._extractCreatedCommentFromResponse(oResponse);

			oRawCreatedComment = this.config.instance.listarea.preProcessForRawComment(oRawCreatedComment, oResponse.author_yn);
			var oComment = new Comment.CommentItem(oRawCreatedComment);

			var nPreSiblingCommentNo = this.config.instance.commentListModel.findPreSiblingCommentNoOfCreatedComment(oRawCreatedComment.parent_comment_no, oRawCreatedComment.reply_level);
			
			/*
			 * 답글인 경우 기존 답글의 수에따라 자신이 쓴 글이 여러페이지 후에 나올 수도 있다.
			 * 안드로이드는 페이지 이동이므로 상관 없지만 IOs는 더보기가 여러번 호출 되어야 할 수도 있으므로
			 * 현재 페이지에 자신이 쓴 글이 없다면 자신의 글을 추가하지 않는다.
			 */ 
			if( nPreSiblingCommentNo != 'empty'){
				oComment.createItem(this.config.instance.listarea.getAreaElement(), nPreSiblingCommentNo);
				this.config.instance.commentListModel.addComment(oComment, nPreSiblingCommentNo);
			}
			// empty 태그 보여주기
			this.config.instance.listarea.showOrHideEmptyLiTag();

			// Nolist 영역 감추기
			this.config.instance.listarea.showOrHideNoListLiTag();

			// 페이지 및 카운트 영역 update
			this.config.instance.pagearea.update(oResponse.page_no, this.config.instance.pagearea.getTotalCount()+1);
			this.config.instance.countarea.update(this.config.instance.pagearea.getTotalCount());
						
			//답글 버튼 전환
			var welReplyButton = J.$Element(Util.DomData.getChild(this.config.instance.listarea.getAreaElement().$value(), this.config.css('replyButton'), [oRawCreatedComment.parent_comment_no]));
			this.config.instance.listarea.toogleReplyBtn(welReplyButton);
			
		},

		/**
		 * 답글창 숨기기
		 */
		_hideTargetReplyForm : function(sParentCommentNo) {
			if ( sParentCommentNo == null || sParentCommentNo == 0) {
				return;
			}

			var elTargetTextArea = Util.DomData.getChild(this.config.instance.listarea.getAreaElement().$value(), this.config.css('replyItem'), [sParentCommentNo]);

			if ( elTargetTextArea == null) {
				return;
			}

			J.$Element(elTargetTextArea).hide();
			
		},

		/**
		 * Response에서 생성된 comment만 추출
		 */
		_extractCreatedCommentFromResponse : function(oResponse) {
			if ( oResponse  == null || oResponse.comment_list == null || oResponse.create_result == null|| oResponse.create_result.comment_no == null) {
				return null;
			}

			var aCommentList = oResponse.comment_list;
			for (var nIndex in aCommentList ) {
				if ( aCommentList[nIndex].comment_no == oResponse.create_result.comment_no) {
					return aCommentList[nIndex];
				}
			}

			return null;
		},

		/**
		 * @description 입력된 글자가 허용된 글자를 넘는지 체크한다.
		 */
		_detectOverMaxLength : function(sTargetCommentNo, bestYn) {
			var wel = this._getTargetTextarea(sTargetCommentNo, bestYn);

			var sText = wel.text();

			var sResult = Util.validation(
					sText,
					1,
					this.config.option('maximumCommentLength'),
					false,
					false,
					this.config.message.EXCEED_MAX_LENGTH);

			if ( sResult) {
				this._whtWriteArea.$(sTargetCommentNo, sText);
				this._updatePromptArea(sTargetCommentNo, bestYn, sText.trim().length);
				return;
			}

			//결과값이 올바르지 않으면 전의 값을 삽입하고, 올바르면 이전값을 저장해놓는다.
			var sPrevText = this._whtWriteArea.$(sTargetCommentNo);
			wel.text(sPrevText == null ? '' : sPrevText);
		},

		_getTargetTextarea : function(sTargetCommentNo, bestYn) {
			if ( sTargetCommentNo == 0 ) {
				return this._welTextarea;
			}
			
			if (bestYn == "Y") {
				return J.$Element(Util.DomData.getChild(this.config.instance.bestlistarea.getAreaElement().$value(), this.config.css('textarea'), [sTargetCommentNo]));
			} else {
				return J.$Element(Util.DomData.getChild(this.config.instance.listarea.getAreaElement().$value(), this.config.css('textarea'), [sTargetCommentNo]));
			}
		},

		/**
		 * @description 디폴트 문자열을 보여준다.
		 */
		_showDefaultText : function(welTextarea) {
			var sText = welTextarea.text();

			if (Util.trim(sText) == '') {
				welTextarea.text(this.config.message.DEFAULT_TEXT);
			}
		},

		/**
		 * @description 디폴트 문자열을 숨겨준다.
		 */
		_hideDefaultText : function(welTextarea) {
			var sText = welTextarea.text();

			if (Util.compareTextWithoutRetuneChar(sText, this.config.message.DEFAULT_TEXT)) {
				welTextarea.text('');
			}
		}
	}).extend(J.Component);

	nhn.comment.writearea = new Comment.WriteArea();
})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
* @(#)nhn.comment.mobile.BestListArea.js 2012. 03. 19
*/
(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile,
		Util = nhn.comment.mobile.Util;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/**
	 * @description 베스트목록영역을 처리하는 클래스
	 */
	Comment.BestListArea = J.$Class({
		/** @lends nhn.comment.mobile.BestListArea.prototype */

		/**
		 * @description 초기화 함수
		 * @constructs
		 * @class
		 * @extends jindo.Component
		 */
		$init : function() {
			this._welArea = null;

			this.indexInstance = Comment.BestListArea.getInstance().length - 1;
			this.config = Comment.Config.getInstance()[this.indexInstance];
			this._oResult = null;
		},

		/**
		 * @description 목록영역을 생성한다.
		 * @return {jindo.$Element}
		 */
		createArea : function() {
			//var sNoListLiTag = this.config.template('noList').process();
			//var sEmptyComment = this.config.template('emptyComment').process();
			this._welArea = J.$Element(this.config.template('bestList').process());
			if(this.config.option('useSortList') != true && this.config.option('useRecommendArea') == true) {
				this._welArea.attr('id',this.config.element('focusTarget'));
			}
			return this._welArea;
		},

		/**
		 * @description 영역 생성 후..
		 */
		afterCreateArea : function() {
			this._createBubbler();
		},

		/**
		 * @description 목록영역을 반환한다.
		 * @return {jindo.$Element}
		 */
		getAreaElement : function() {
			return this._welArea;
		},

		/**
		 * @description 이벤트를 바인딩한다.
		 */
		_createBubbler : function() {
			this._oBubbler = new Util.Bubbler(this.getAreaElement().$value()).attach({
				'__comment_del_btn:click' : J.$Fn(this.config.instance.command.deleteBestReplyComment, this.config.instance.command).bind(),
				'__comment_report_btn:click' : J.$Fn(this.config.instance.command.reportComment, this.config.instance.command).bind(),
				'__comment_reply_form_btn_best:click' : J.$Fn(this.config.instance.command.toggleReplyFormBest, this.config.instance.command).bind(),
				'__comment_reply_close_btn_area:click' : J.$Fn(this.config.instance.command.toggleReplyFormBestBottom, this.config.instance.command).bind(),
				'__comment_reply_prev_btn:click' : J.$Fn(this.movePrevReplyList, this).bind(),
				'__comment_reply_next_btn:click' : J.$Fn(this.moveNextReplyList, this).bind()
			});

			this.getAreaElement().preventTapHighlight(true);
			
			this._createRecommendDiscommendBubbler(this.getAreaElement());	// 추천비추천 이벤트 바인딩
		},

		/**
		 * @description 베스트 목록 영역을 다 지운다.
		 */
		empty : function() {
			this.getAreaElement().empty();
		},

		/**
		 * @description 목록을 보여준다.
		 * @param	{Object}	oResult				결과
		 */
		showBestList : function(oResult) {
			
			if ( oResult == null || oResult.comment_list == null || oResult.total_count == null || oResult.page_no == null) {
				return;
			}

			// list에 추가전 마지막 commentNo 기억
			//var sLastCommentNo = this.config.instance.commentListModel.getBaseLastCommentNo();
			this._addBestComment(oResult.recommended_list, oResult.author_yn);
			this._oResult = oResult;
		},

		/**
		 * @description 베스트 댓글리스트 추가 
		 */
		_addBestComment : function(htCommentList, sAuthorYn) {
			if ( htCommentList == null) {
				return;
			}

			var oRawComment = null,	oComment = null;
			var nLastCommentNo = 0;
			for ( var nIndex = 0 ; nIndex < htCommentList.length ; nIndex++) {
				oRawComment = this.preProcessForRawComment(htCommentList[nIndex], sAuthorYn);
				oComment = new Comment.CommentItem(oRawComment);
				oComment.createBestItem(this.getAreaElement(), nLastCommentNo, false);
				nLastCommentNo = htCommentList[nIndex].comment_no;
			}
		},

		/**
		 * 해당 sCommentNo에 해당하는 comment element를 반환.
		 */
		getElCommentLiTag : function(sCommentNo) {
			if ( sCommentNo == null) {
				return null;
			}

			return Util.DomData.getChild(this.getAreaElement().$value(), this.config.css('commentItem'), [sCommentNo]);
		},

		/**
		 * @description	댓글 아이템 전처리
		 * @param	{HashTable}	htComment	댓글 아이템
		 */
		preProcessForRawComment : function(htComment, sAuthorYn) {
			if ( htComment.done_preprocessing) {
				return htComment;
			}

			htComment.registered_ymdt = Comment.Util.dateFormat(htComment.registered_ymdt, this.config.option('dateFormat'));
			htComment.modified_ymdt = Comment.Util.dateFormat(htComment.modified_ymdt, this.config.option('dateFormat'));

			if (this.config.option('useEscapeHtml')){
				// remove <!-- Not Allowed Tag Filtered -->
				htComment.contents = htComment.contents.replace('<!-- Not Allowed Tag Filtered -->', '');
				// unescape & escape HTML
				htComment.contents = J.$S(htComment.contents).unescapeHTML().escapeHTML().$value();
			}

			htComment.contents = Comment.Util.multiLine(htComment.contents, this.config.option('enableMultiLine'));
			htComment.indexInstance = this.indexInstance;
			htComment.is_author = sAuthorYn;
			htComment.done_preprocessing = true;

			return htComment;
		},

		/**
		 * @description 특정 답글의 요소를 가져온다.
		 * @param css옵션에 정의된 class
		 * @param 댓글번호
		 */
		_getAreaChildElement : function (cssOption, sCommentNo) {
			return J.$Element(Util.DomData.getChild(this.getAreaElement().$value(), this.config.css(cssOption), [sCommentNo]));
		},
		
		 /**
		 * @description 베스트 댓글에 대한 답글버튼 처리
		 * @param 답글번호
		 */
		toogleReplyBtnBest : function(sCommentNo) {	
			var welBtn = this._getAreaChildElement('replyButtonBest', sCommentNo);
			var replyList = this._getAreaChildElement('replyList', sCommentNo);

			if ( welBtn == null || replyList == null) {
				return;
			}
			
			welBtn.toggleClass('open');
			welBtn.toggleClass('close');
			
			if (welBtn.hasClass('open')) {
				this.callReplyList(sCommentNo, 1);
			} else {
				var welReplyForm = J.$Element(Util.DomData.getChild(this.getAreaElement().$value(), this.config.css('replyItemBest'), [sCommentNo ]));
				welReplyForm.hide();
				welBtn.query('span').text('답글');
				welBtn.query('b').text(Util.setNumberFormat(welBtn.attr('replyCount')));
				replyList.hide();
				this._getAreaChildElement('replyListPaging', sCommentNo).hide(); // 페이징
			}
		},
		
		/**
		 * @description 서버API 에 답글리스트 목록을 요청한다.
		 * @param	{String}	sCommentNo	부모답글번호
		 * @param	{Number}	pageNo	페이지번호
		 */
		callReplyList : function(sCommentNo, pageNo){
			var htParams = this.config.instance.ajax.getListParams();

			htParams.page_size = this.config.option('replyPageSize');
			htParams.parent_comment_no = sCommentNo;
			if(pageNo > 0){
				htParams.page_no = pageNo;
			}
			
			this.config.instance.ajax.call( {
				operation : 'replyList',
				onSuccess : J.$Fn(this.displayReplyList, this).bind(),
				param : htParams
			});
		},
		
		/**
		 * @description 답글리스트 호출후 callback
		 */
		displayReplyList : function(oResult){
			if ( oResult == null || oResult.reply_lists[0] == null) {
				return;
			}

			var sParentCommentNo = oResult.reply_lists[0].parent_comment_no;
			var replyList = oResult.reply_lists[0].reply_list;
			if ( replyList == null ) {
				return;
			}
			this._openReplyListBest(sParentCommentNo, oResult.reply_lists[0].reply_count);
			this._getAreaChildElement('replyList', sParentCommentNo).empty();
			this._addReplyCommentToBest(sParentCommentNo, replyList, oResult.author_yn);

			this.displayReplyListPaging(oResult.reply_lists[0]); // 페이징

		},

		/**
		 * @description 베스트 댓글의 답글리스트 추가
		 * @param {String} 부모의 답글번호
		 * @param {HashTableList} 답글리스트
		 * @param {String} 권한여부
		 */
		_addReplyCommentToBest : function(sParentCommentNo, htCommentList, sAuthorYn) {
			if ( htCommentList == null) {
				return;
			}

			var oRawComment = null,	oComment = null;
			var nLastCommentNo = 0;
			for ( var nIndex = 0 ; nIndex < htCommentList.length ; nIndex++) {
				oRawComment = this.preProcessForRawComment(htCommentList[nIndex], sAuthorYn);
				oComment = new Comment.CommentItem(oRawComment);

				 var replyList = J.$Element(Util.DomData.getChild(this.getAreaElement().$value(), this.config.css('replyList'), [sParentCommentNo]));

				oComment.createBestItem(replyList, nLastCommentNo, true);
				nLastCommentNo = htCommentList[nIndex].comment_no;
			}
		},

		 /**
		 * @description 베스트 댓글에 대한 답글 open시 답글리스트 호출후 처리
		 * @param 답글번호
		 * @param 답글수
		 */
		_openReplyListBest : function(sCommentNo, sCount) {
			var welBtn = this._getAreaChildElement('replyButtonBest', sCommentNo);
			if ( welBtn == null ) {
				return;
			}
			
			var replyList = this._getAreaChildElement('replyList', sCommentNo);
			if ( replyList == null ) {
				return;
			}			

			var welReplyForm = J.$Element(Util.DomData.getChild(this.getAreaElement().$value(), this.config.css('replyItemBest'), [sCommentNo ]));
			welReplyForm.show('block');
			welBtn.attr('replyCount', sCount);
			if( sCount == 0 ) {
				replyList.hide();
				welBtn.query('span').text('답글취소');
				welBtn.query('b').text('');
				this._getAreaChildElement('replyCloseBtnArea', sCommentNo).hide();
				this._getAreaChildElement('replyListPaging', sCommentNo).hide(); // 페이징
			} else {
				replyList.show("block");
				welBtn.query('span').text('답글');
				welBtn.query('b').text(Util.setNumberFormat(sCount));
				this._getAreaChildElement('replyCloseBtnArea', sCommentNo).show("block");
				this._getAreaChildElement('replyListPaging', sCommentNo).show("block"); // 페이징
			}
		},

		 /**
		 * @description 답글리스트에대한 페이징 영역 표시한다
		 */
		displayReplyListPaging : function(oReplyInfo) {
			var sCommentNo = oReplyInfo.parent_comment_no;
			var sPageNo = oReplyInfo.page_no;
			
			var pagingArea = this._getAreaChildElement('replyListPaging', sCommentNo);

			var welPrevBtn = J.$Element(Util.DomData.getChild(pagingArea.$value(), this.config.css('replyPrevButton')));

			welPrevBtn.attr('parent_comment_no', sCommentNo);
			welPrevBtn.attr('page_no', sPageNo);
			if( oReplyInfo.is_have_prev_page == "Y" ) {
				welPrevBtn.removeClass('u_rpg_dim');
				welPrevBtn.attr('href','#');
			} else {
				welPrevBtn.addClass('u_rpg_dim');
				welPrevBtn.attr('href',null);
			}

			var welPageInfo = J.$Element(Util.DomData.getChild(pagingArea.$value(), this.config.css('replyPageInfo')));
			if ( welPageInfo != null) {
				pagingArea.remove(welPageInfo);
			}
			
			var totalPage = Math.ceil(Number(oReplyInfo.reply_count)/Number(oReplyInfo.page_size));
			welPageInfo = J.$Element(this.config.template('replyPageInfo').process({curPage : sPageNo, totalPage : totalPage}));
			
			welPrevBtn.after(welPageInfo);

			var welNextBtn = J.$Element(Util.DomData.getChild(pagingArea.$value(), this.config.css('replyNextButton')));

			welNextBtn.attr('parent_comment_no', sCommentNo);
			welNextBtn.attr('page_no', sPageNo);
			welNextBtn.attr('total_page', totalPage);
			if( oReplyInfo.is_have_next_page == 'Y' ) {
				welNextBtn.removeClass('u_rpg_dim');
				welNextBtn.attr('href','#');
			} else {
				welNextBtn.addClass('u_rpg_dim');
				welNextBtn.attr('href',null);
			}
		},
		
		 /**
		 * @description 답글리스트의 이전페이지 이동
		 */
		movePrevReplyList : function(oEvent) {
			oEvent.stop();
			if( Number(J.$Element(oEvent.element).attr('page_no')) == 1) {
				return;
			}
			this.callReplyList(J.$Element(oEvent.element).attr('parent_comment_no'), Number(J.$Element(oEvent.element).attr('page_no')) - 1);
		},
		
		 /**
		 * @description 답글리스트의 다음페이지 이동
		 */
		moveNextReplyList : function(oEvent) {
			if( J.$Element(oEvent.element).attr('page_no') == J.$Element(oEvent.element).attr('total_page')) {
				return;
			}
			oEvent.stop();
			this.callReplyList(J.$Element(oEvent.element).attr('parent_comment_no'), Number(J.$Element(oEvent.element).attr('page_no')) + 1);
		},
		
		/**
		 * @description 추천비추천 이벤트 바인딩 호출
		 * @param elTargetArea {Element} 이벤트 바인딩할 영역
		 */
		_createRecommendDiscommendBubbler : function(elTargetArea) {
			
			// 추천비추천 인스턴스가 없으면 패스
			if (!Comment.RecommendDiscommendArea ) {
				return;
			}
			
			// 추천비추천 버튼에 이벤트 바인딩
			this.config.instance.recommendDiscommendArea = Comment.RecommendDiscommendArea.getInstance()[this.indexInstance];
			if (this.config.instance.recommendDiscommendArea) {
				this.config.instance.recommendDiscommendArea.createListBubbler(elTargetArea);
			}
		}
		
	}).extend(J.Component);

	nhn.comment.bestlistarea = new Comment.BestListArea();

})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
* @(#)nhn.comment.mobile.listArea.js 2012. 03. 19
*/
(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile,
		Util = nhn.comment.mobile.Util;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/**
	 * @description 목록영역을 처리하는 클래스
	 */
	Comment.ListArea = J.$Class({
		/** @lends nhn.comment.mobile.ListArea.prototype */

		/**
		 * @description 초기화 함수
		 * @constructs
		 * @class
		 * @extends jindo.Component
		 */
		$init : function() {
			this._welArea = null;

			this.indexInstance = Comment.ListArea.getInstance().length - 1;
			this.config = Comment.Config.getInstance()[this.indexInstance];
			this._oResult = null;
		},

		/**
		 * @description 목록영역을 생성한다.
		 * @return {jindo.$Element}
		 */
		createArea : function() {
			//var sNoListLiTag = this.config.template('noList').process();
			//var sEmptyComment = this.config.template('emptyComment').process();
			this._welArea = J.$Element(this.config.template('list').process());
			if( !(this.config.option('useSortList') == true || this.config.option('useRecommendArea') == true) ) {
				this._welArea.attr('id',this.config.element('focusTarget'));
			}
			return this._welArea;
		},
		
		
		createEmptyArea : function() {
			this._welNoListArea = J.$Element(this.config.template('noList').process());

			return this._welNoListArea;
		},

		/**
		 * @description 영역 생성 후..
		 */
		afterCreateArea : function() {
			this._createBubbler();
		},

		/**
		 * @description 목록영역을 반환한다.
		 * @return {jindo.$Element}
		 */
		getAreaElement : function() {
			return this._welArea;
		},

		/**
		 * @description 이벤트를 바인딩한다.
		 */
		_createBubbler : function() {
			this._oBubbler = new Util.Bubbler(this.getAreaElement().$value()).attach({
				'__comment_del_btn:click' : J.$Fn(this.config.instance.command.deleteComment, this.config.instance.command).bind(),
				'__comment_report_btn:click' : J.$Fn(this.config.instance.command.reportComment, this.config.instance.command).bind(),
				'__comment_reply_form_btn:click' : J.$Fn(this.config.instance.command.toggleReplyForm, this.config.instance.command).bind()
			});

			this.getAreaElement().preventTapHighlight(true);
			
			this._createRecommendDiscommendBubbler(this.getAreaElement());	// 추천비추천 이벤트 바인딩
		},

		/**
		 * @description 서버API 에 목록을 요청한다.
		 * - pc 용 공통댓글과 동일하게 했는데, 페이지만 필요할 경우 인자를 빼면됨
		 * @param	{String}	sType	타입
		 * @param	{Number}	nNo		넘버
		 */
		requestList : function(sType, nNo, async) {
			var htParams = this.config.instance.ajax.getListParams();

			//page.no가 오면 page로 이동한다.
			if (sType == 'page') {
				htParams.page_no = nNo;
			}
			
			if ( this.config.option('currentSortOption') ) {
				htParams.sort = this.config.option('currentSortOption');
			}

			if ( this.config.option('listType') == 'u_comment_v1') { // 리스트 1 타입의 경우 ( 서비스 내 삽입 ) 특수 처리
				// summary형식이라도 답글도 보여줄 수 있도록 수정
				if( this.config.option('useInnerSvcShowReply') == false){
					htParams.depth = 1;
				}
				htParams.page_size = this.config.option('innerSvcListSize');
				htParams.sort = this.config.option('innerSvcListSort');
			}

			// landing page기능 추가
			if (this.config.option('landingCommentNo') != null) {
				htParams.comment_no = this.config.option('landingCommentNo');
				htParams.up_to_date_yn = "Y";
				this.config.option('landingCommentNo',null);
			}
			
			var listAsync = false;
			if (typeof async == 'boolean'){
				listAsync = async;
			} else {
				if (typeof this.config.option('listAsync') == 'boolean'){
					listAsync = this.config.option('listAsync');	
				}
			}

			this.config.instance.ajax.call({
				operation : 'list',
				async : listAsync,
				onSuccess : J.$Fn(this.showList, this).bind(),
				param : htParams
			});
		},

		/**
		 * @description 목록 영역을 다 지운다. (필요 없는 듯)
		 */
		empty : function() {
			this.getAreaElement().empty();
			this.config.instance.commentListModel.reset();
			this.config.instance.pagearea.reset();
			
		},

		/**
		 * @description 페이지 새로고침한다.
		 */
		refresh : function(async) {
			this.empty();
			this.requestList('page', 1, async);
			this.config.instance.sortListArea.resetArea();
		},

		/**
		 * 새로 고침 없이, 특정 액션후 해당 액션 결과 result를 이용해 페이지를 다시 구성
		 */
		refreshWithTheResult : function(oResult) {
			this.empty();
			this.showList(oResult);
		},

		/**
		 * @description 목록을 보여준다.
		 * @param	{Object}	oResult				결과
		 */
		showList : function(oResult) {
			if ( oResult == null || oResult.comment_list == null || oResult.total_count == null || oResult.page_no == null) {
				return;
			}

			this._processBeforeShowList(oResult);

			// BEST댓글 사용시에만
			if(this.config.option('useRecommendArea')){
				//IOS에서 moreList를 호출한 경우는 베스트를 초기화하지 않는다. 
				if(!(this.config.option('useMoreContent') && oResult.more_yn == "Y")) {
					this.config.instance.bestlistarea.empty();
				}

				//android의 1페이지 혹은 IOS의 첫 페이지에서만 베스트를 보여준다.
				if(oResult.page_no == 1 && oResult.more_yn != "Y") {
					this.config.instance.bestlistarea.showBestList(oResult);
				}
			}
			
			// list에 추가전 마지막 commentNo 기억
			var sLastCommentNo = this.config.instance.commentListModel.getBaseLastCommentNo();

			this._addCommentToBaseAndRemoveBottom(oResult);
			this.showOrHideEmptyLiTag();
			this.showOrHideNoListLiTag();

			if ( this.config.option('useRecommendArea') == true && this.config.option('listType') == 'u_comment_v1') {
				var listCount = oResult.comment_list.length + oResult.recommended_list.length;
				
				if( listCount > 0) {
					this._welNoListArea.hide();
					this._welArea.show();
				}
			}

			//페이지네이션 영역(삭제가 가능한지 여부 파악시 마지막페이지인지 여부가 필요)
			// 더보기시 데이터가 넘어오지 않는 경우(페이지 접근시에는 다음 페이지 데이터가 있었으나, 동시간에 다른 브라우저에서 삭제하여 더보기시 값이 없는 케이스 고려)
			if ( this.config.option('useMoreContent') && (oResult.comment_list == null || oResult.comment_list.length < this.config.option('pageSize'))) {
				this.config.instance.pagearea.makeLastPage();
			}

			/**
			 * 기존 보여지는 영역의 마지막 comment에 대해서 삭제가 가능하면 삭제 진행.
			 *
			 *  comment List에서 마지막 페이지가 아닌 경우, 마지막 comment삭제시 다음 페이지에서
			 * 해당 페이지의 답글이 있을 가능성이 있어, 삭제된 댓글로 노출!!
			 *
			 * 이후 더보기시 해당 댓글 삭제(view에서 제거)가 가능하면 삭제 진행작업.
			 */
			this._removeAndReturnTheCount(sLastCommentNo);

			//페이지네이션 영역(위 commentProcess에서 보여지는 count값 변경 가능성 존재)
			this.config.instance.pagearea.update(oResult.page_no, oResult.total_count, true);

			//카운트업데이트
			this.config.instance.countarea.update(this.config.instance.pagearea.getTotalCount());
			
			//list v1 에서 사용하는 하단 Count 영역 업데이트
			this.config.instance.listFooterArea.update(this.config.instance.pagearea.getTotalCount());

			this._processAfterShowList(oResult);
			this._oResult = oResult;
		},

		/**
		 * BaseCommentList에 추가 및 IOS인 경우, BottomCommentList에 있는 경우 삭제
		 */
		_addCommentToBaseAndRemoveBottom : function(oResult) {
			var htCommentList = oResult.comment_list;
			var sAuthorYn = oResult.author_yn;
			
			if ( htCommentList == null) {
				return;
			}

			var oRawComment = null,	oComment = null;
			
			if ( this.config.option('useRecommendArea') == true && this.config.option('listType') == 'u_comment_v1') {
				var moreCount = Number(this.config.option('innerSvcListSize')) - oResult.recommended_list.length;
				var moreCountTemp = 0;
				for ( var nIndex = 0 ; nIndex < htCommentList.length ; nIndex++) {
					if( moreCount <= moreCountTemp){
						break;
					}
					if ( this._notExistBestComment(htCommentList[nIndex].comment_no, htCommentList[nIndex].parent_comment_no, oResult.recommended_list) ) {
						oRawComment = this.preProcessForRawComment(htCommentList[nIndex], sAuthorYn);
						oComment = new Comment.CommentItem(oRawComment);
						this._removeBottomCommentWhenListing(oComment.getCommentNo());

						var nLastCommentNo = this.config.instance.commentListModel.getBaseLastCommentNo();
						oComment.createItem(this.getAreaElement(), nLastCommentNo);
						this.config.instance.commentListModel.addComment(oComment);
						moreCountTemp++;
					}
				}
			} else {
				for ( var nIndex = 0 ; nIndex < htCommentList.length ; nIndex++) {				
					oRawComment = this.preProcessForRawComment(htCommentList[nIndex], sAuthorYn);
					oComment = new Comment.CommentItem(oRawComment);
					this._removeBottomCommentWhenListing(oComment.getCommentNo());

					var nLastCommentNo = this.config.instance.commentListModel.getBaseLastCommentNo();
					oComment.createItem(this.getAreaElement(), nLastCommentNo);
					this.config.instance.commentListModel.addComment(oComment);
				}				
			}

		},

		/**
		 * 해당 댓글이 베스트댓글 리스트에 존재하는지 여부
		 */		
		_notExistBestComment : function (sCommentNo, sParentCommentNo, sRecommendedList) {
			var rtrnVal = true;
			for (var idx in sRecommendedList) {
				if (sCommentNo == sRecommendedList[idx].comment_no || sParentCommentNo == sRecommendedList[idx].comment_no) {
					rtrnVal = false;
					break;
				}
			}
			return rtrnVal;
		},
		
		/**
		 * 더보기시 추가로 작성된 영역(하단 ... 이후)에 해당 comment가 있으면 삭제.
		 */
		_removeBottomCommentWhenListing : function(sCommentNo) {
			if ( !this.config.option('useMoreContent') || !this.config.instance.commentListModel.isExistInBottomCommentList(sCommentNo)) {
				return;
			}

			this.config.instance.commentListModel.removeComment(sCommentNo);
			this._removeElCommentLiTag(sCommentNo);
		},

		/**
		 * 해당 sCommentNo에 해당하는 comment element를 반환.
		 */
		getElCommentLiTag : function(sCommentNo) {
			if ( sCommentNo == null) {
				return null;
			}

			return Util.DomData.getChild(this.getAreaElement().$value(), this.config.css('commentItem'), [sCommentNo]);
		},

		/**
		 * 해당 sCommentNo에 해당하는 comment element를 삭제.
		 */
		_removeElCommentLiTag : function(sCommentNo) {
			this.config.instance.writearea.releaseBubbler(sCommentNo);

			var elItem = this.getElCommentLiTag(sCommentNo);
			this.getAreaElement().remove(elItem);
		},

		/**
		 * 목록 가져오기 전처리
		 */
		_processBeforeShowList : function(oResult) {
			//custom화를 위하여(ex:롤링) list전에 함수를 호출
			this.config.fireEvent('beforeList', {
				'result': oResult
			});
		},

		/**
		 * 목록 가져온후 후처리
		 */
		_processAfterShowList : function(oResult) {
			//custom화를 위하여(ex:롤링) list후에 함수를 호출
			this.config.fireEvent('afterList', {
				'result': oResult
			});
		},

		/**
		 * bottomComment 개수에 따라 emptyLi 태그 노출 결정
		 */
		showOrHideEmptyLiTag : function() {
//			if ( !this.config.option('useMoreContent') ) {
//				return;
//			}
//
//			var elEmptyLiTag = this.getElCommentLiTag('empty');
//
//			if ( elEmptyLiTag == null) {
//				return;
//			}
//
//			var welEmptyLiTag = J.$Element(elEmptyLiTag);
//
//			if ( this.config.instance.commentListModel.isEmptyBottomComment()) {
//				welEmptyLiTag.hide();
//				return;
//			}
//
//			welEmptyLiTag.show();
		},

		/**
		 * BaseComment 개수에 따라 No List 영역을 보여주거나 감추기
		 */
		showOrHideNoListLiTag : function() {

			if ( this.config.instance.commentListModel.isEmptyBaseComment()) {
				this._welNoListArea.show();
				this._welArea.hide();
				return;
			}

			this._welNoListArea.hide();
			this._welArea.show();
			
		},

		/**
		 * @description	IOS 일 경우, 삭제한 댓글만 dom 에서 제거해주는 처리
		 * @param	{Number}	nCommentNo	댓글 번호
		 */
		deleteCommentForIos : function(nCommentNo) {
			if (nCommentNo == null) return;

			// 해당 comment에 isDeleted Mark
			this.config.instance.commentListModel.markTargetCommentDeleted(nCommentNo);

			// 삭제(view에서 제거) 불가하면 삭제된 댓글로 노출
			if (!this.config.instance.commentListModel.canRemoveTargetComment(nCommentNo) ) {
				this._makeDeletedComment(nCommentNo);

				return;
			}

			// 실제 삭제(view에서 제거)가 가능하면 삭제.
			var nRemovedCommentCount = this._removeAndReturnTheCount(nCommentNo);
			this.showOrHideEmptyLiTag();
			this.showOrHideNoListLiTag();

			this.config.instance.pagearea.update(this.config.instance.pagearea.getPageNo(), this.config.instance.pagearea.getTotalCount() - nRemovedCommentCount);
			this.config.instance.countarea.update(this.config.instance.pagearea.getTotalCount());
		},

		/**
		 * 삭제된 comment로 상태 및 view 변경
		 */
		_makeDeletedComment : function(nCommentNo) {
			var oDeletedCommentInfo = this.config.instance.commentListModel.getCommentInfoFromBaseAndBottom(nCommentNo);

			if ( oDeletedCommentInfo == null) {
				return;
			}

			var oRawDeletedComment = this._preProcessForDeleteComment(oDeletedCommentInfo);
			var oDeletedComment = new Comment.CommentItem(oRawDeletedComment);

			var elItem = this.getElCommentLiTag(nCommentNo);
			if (elItem  == null) return;

			// 기존 comment는 삭제하고, '삭제된 댓글'을 신규 생성
			J.$Element(elItem).hide();
			oDeletedComment.createItem(this.getAreaElement(), nCommentNo);

			this.getAreaElement().remove(elItem);
		},

		/**
		 * 삭제된 comment에 대한 기본 정보 생성.
		 */
		_preProcessForDeleteComment : function(oDeletedCommentInfo) {
			var oRawDeletedComment = {};
			oRawDeletedComment.indexInstance = this.indexInstance;
			oRawDeletedComment.writer_id = '********';
			oRawDeletedComment.writer_nickname = '';
			oRawDeletedComment.comment_no = oDeletedCommentInfo.commentNo;
			oRawDeletedComment.registered_ymdt = oDeletedCommentInfo.registeredDate;
			oRawDeletedComment.reply_level = oDeletedCommentInfo.replyLevel;
			oRawDeletedComment.deleted_yn = 'Y';

			return oRawDeletedComment;
		},

		/**
		 * 특정 comment가 삭제가 가능하면 삭제, 이후 이전 comment도 삭제가 가능한지 체크하여
		 * 연속적으로 삭제.
		 */
		_removeAndReturnTheCount : function(nCommentNo) {
			var nCount = 0;

			if ( !this.config.option('useMoreContent') ) {
				return nCount;
			}

			while ( this.config.instance.commentListModel.canRemoveTargetComment(nCommentNo)) {
				var htPreSiblingComment = this.config.instance.commentListModel.getPreSiblingCommentInfo(nCommentNo);
				this.config.instance.commentListModel.removeComment(nCommentNo);

				this._removeElCommentLiTag(nCommentNo);
				nCount++;

				if ( htPreSiblingComment == null ) {
					break;
				}

				nCommentNo = htPreSiblingComment.commentNo;
			}

			return nCount;
		},

		/**
		 * @description	댓글 아이템 전처리
		 * @param	{HashTable}	htComment	댓글 아이템
		 */
		preProcessForRawComment : function(htComment, sAuthorYn) {
			if ( htComment.done_preprocessing) {
				return htComment;
			}

			htComment.registered_ymdt = Comment.Util.dateFormat(htComment.registered_ymdt, this.config.option('dateFormat'));
			htComment.modified_ymdt = Comment.Util.dateFormat(htComment.modified_ymdt, this.config.option('dateFormat'));

			if (this.config.option('useEscapeHtml')){
				// remove <!-- Not Allowed Tag Filtered -->
				htComment.contents = htComment.contents.replace('<!-- Not Allowed Tag Filtered -->', '');
				// unescape & escape HTML
				htComment.contents = J.$S(htComment.contents).unescapeHTML().escapeHTML().$value();
			}

			htComment.contents = Comment.Util.multiLine(htComment.contents, this.config.option('enableMultiLine'));
			htComment.indexInstance = this.indexInstance;
			htComment.is_author = sAuthorYn;
			htComment.done_preprocessing = true;

			return htComment;
		},

		/**
		 * 로그인 및 실명인증 권한에 따른 쓰기창 toggle 처리
		 */
		toggleTargetAreaDependsOnLoginAndAuth : function(welTarget) {
			if ( welTarget == null) {
				return false;
			}

			if (!this.config.instance.auth.redirectLogin()) {
				return false;
			}

			if (!this.config.instance.auth.redirectAuth()) {
				return false;
			}

			welTarget.toggle();
			
			return true;
		},
		
		toogleReplyBtn : function(welBtn) {	
			if ( welBtn == null ) {
				return;
			}
			var text = welBtn.text();
			
			if ( text == '답글') {
				welBtn.text('답글취소');
			} else {
				welBtn.text('답글');
			}			
		},
		
		/**
		 * @description 추천비추천 이벤트 바인딩 호출
		 * @param elTargetArea {Element} 이벤트 바인딩할 영역
		 */
		_createRecommendDiscommendBubbler : function(elTargetArea) {
			
			// 추천비추천 인스턴스가 없으면 패스
			if (!Comment.RecommendDiscommendArea ) {
				return;
			}
			
			// 추천비추천 버튼에 이벤트 바인딩
			this.config.instance.recommendDiscommendArea = Comment.RecommendDiscommendArea.getInstance()[this.indexInstance];
			if (this.config.instance.recommendDiscommendArea) {
				this.config.instance.recommendDiscommendArea.createListBubbler(elTargetArea);
			}
		},
		
		setFocusList : function () {
			if( this.config.option('useFocus') == true) {
				window.scrollTo(0, J.$Element(this.config.element('focusTarget')).offset().top);
			}
		}
		
	}).extend(J.Component);

	nhn.comment.listarea = new Comment.ListArea();

})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
* @(#)nhn.comment.mobile.commonPageArea.js 2012. 04. 27
*/
(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile,
		Util = Comment.Util;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/**
	 * @description 공통(아이폰, 안드로이드) 페이지 영역을 처리하는 클래스
	 */
	Comment.CommonPageArea = J.$Class({
		$init : function() {
			this._welArea = null;
			this._nPageNo = 1;
			this._nTotalCount = 0;

			this.indexInstance = Comment.PageArea.getInstance().length - 1;
			this.config = Comment.Config.getInstance()[this.indexInstance];
		},

		/**
		 * @description 목록영역을 반환한다.
		 * @return {jindo.$Element}
		 */
		getAreaElement : function() {
			return this._welArea;
		},

		/**
		 * @description 페이지영역을 보여준다.
		 */
		show : function() {
			this._welArea.show();
		},

		/**
		 * @description 페이지영역을 숨겨준다.
		 */
		hide : function() {
			this._welArea.hide();
		},

		/**
		 * @description 서비스로부터 전달된 flag 및 전체 페이지 개수에 따라서
		 * 페이지 영역을 숨길지 여부
		 */
		isNeedToHidePageArea : function(nTotalCount) {
			// 서비스에서 초기 controller옵셜 설정시 전달
			if ( !this.config.option('hidePageAreaIfOnlyOnePageExist')) {
				return false;
			}

			if ( this.config.option('pageSize') < nTotalCount  ) {
				return false;
			}

			return true;
		},

		setPageNo : function(nPageNo) {
			if ( nPageNo == null) {
				return;
			}

			this._nPageNo = nPageNo;
		},

		getPageNo : function() {
			return this._nPageNo;
		},

		setTotalCount : function(nTotalCount) {
			this._nTotalCount = nTotalCount;
		},

		getTotalCount : function() {
			return this._nTotalCount;
		}
	}).extend(J.Component);
})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
* @(#)nhn.comment.mobile.pageArea.js 2012. 03. 19
*/
(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile,
		Util = Comment.Util;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/**
	 * @description 페이지 영역을 처리하는 클래스
	 */
	Comment.PageArea = J.$Class({
		/** @lends nhn.comment.mobile.PageArea.prototype */

		/**
		 * @description 초기화 함수
		 * @constructs
		 * @class
		 * @extends nhn.comment.mobile.CommonPageArea
		 * @require	jindo.m.PageNavigation
		 */
		$init : function() {
			this._oPageNavigation = null;
		},

		/**
		 * @description 페이지영역을 생성한다.
		 * @return {jindo.$Element}
		 */
		createArea : function() {
			this._welArea = J.$Element(this.config.template('pageArea').process());
			return this._welArea;
		},

		/**
		 * @description 영역 생성 후..
		 */
		afterCreateArea : function() {
			this._wel = J.$Element(this.config.template('pageNavigation').process());
			this._welArea.append(this._wel);
			this._initComponent();
			this.hide();
		},

		/**
		 * @description 페이지영역의 정보를 업데이트 해준다.
		 * @param	{Object}	oResult
		 */
		update : function(nPageNo, nTotalCount, bNeedInfoUpdate) {
			this.setPageNo(nPageNo);
			this.setTotalCount(nTotalCount);

			// Jindo Mobile component의 버그로 전체 카운트가 0인 경우, page 연산에 오류가 있어, 1로 전달.
			this._oPageNavigation.reset((nTotalCount == 0 ? 1 : nTotalCount ));
//			this._oPageNavigation.reset(nTotalCount);
			this._oPageNavigation.movePageTo(nPageNo, false);

			this._oPageNavigation.updateInfo();

			if ( this.isNeedToHidePageArea(nTotalCount)) {
				this.hide();
				return;
			}

			this.show();
		},

		/**
		 * @description 페이지네비게이션 컴포넌트를 생성한다.
		 */
		_initComponent : function() {
			var self = this;

			this._oPageNavigation = new J.m.PageNavigation(this._wel.$value(), {
				sClassPrefix : '__comment_page_',
				nItemPerPage : this.config.option('pageSize'),
				sInfoTemplate : this.config.template('pageInfoTemplate')._str
			}).attach({
				'beforeMove' : function(oCustomEvt) {
					oCustomEvt.stop();
					self.hide();
					self.config.instance.listarea.empty();
					self.config.instance.listarea.requestList('page', oCustomEvt.nPage, false);
					self.config.instance.listarea.setFocusList();
				}
			});
		},

		isLastPage : function() {
			return (this.config.option('pageSize') * this._nPageNo ) >= this._nTotalCount;
		},
		
		reset : function() {
			
		}
	}).extend(Comment.CommonPageArea);

	nhn.comment.pagearea = new Comment.PageArea();
})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
* @(#)nhn.comment.mobile.currentCountChangeableMoreContentButton.js 2012. 04. 13
*/
(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile,
		Util = Comment.Util;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/**
	 * @description 더보기 버튼을 처리하는 클래스(
	 */
	Comment.CurrentCountChangeableMoreContentButton = J.$Class({
		/** @lends nhn.comment.mobile.CurrentCountChangeableMoreContentButton.prototype */

		/**
		 * 현재 페이지
		 */
		_nCurrentPage : 1,

		$init : function(config, el, htUserOption) {
			this.config = config;
			// jindo.m.CorePagination init - start
			this.option({
				nItem : 10,
				nItemPerPage : 10,
				nPage : 1,
				bActivateOnload : true
			});
			this.option(htUserOption || {});
			this._nCurrentPage = this.option('nPage');
			// jindo.m.CorePagination init - end

			// jindo.m.MoreContentButton init - start
			this.option({
				sClassPrefix : 'more_',
				nTotalItem : 10, //실제 아이템 개수
				nShowMaxItem : 10, //최대 더보기 하여 보여줄 개수
				nItemPerPage : 10,
				nPage : 1,
				bActivateOnload : true,
				htAjax : {}
			});

			this.option(htUserOption || {});
			this.option('nItem', this.option('nShowMaxItem'));

			this._initVar();
			this._setWrapperElement(el);

			if(this.option("bActivateOnload")) {
				this.activate();
				this._nCurrentPage = this.option('nPage');
			}
			// jindo.m.MoreContentButton init - end

			this._nBaseCommentCount = 0;
			this._bLastPage = false;
		},

		// jindo.m.CorePagination function 시작
		getItemCount : function(){
			return this.option('nItem');
		},

		getItemPerPage : function(){
			return this.option('nItemPerPage');
		},

		/**
		 * 현재 페이지를 리턴한다.
		 * @return {Number} 현재 페이지
		 */
		getCurrentPage : function(){
			return this._nCurrentPage;
		},

		/**
		 * 전체 아이템 개수를 설정한다.
		 * @param {Number} n 아이템 개수
		 */
		setItemCount : function(n){
			this.option('nItem', n);
		},

		/**
		 * 한페이지당 아이템 개수를 설정한다
		 * @param {Number} n 한 페이지당 아이템 개수
		 */
		setItemPerPage : function(n){
			this.option('nItemPerPage',n);
		},

		/**
		 * 현재 페이지의 다음 페이지로 이동한다.
		 */
		nextPageTo : function(){
			var nPage = this._nCurrentPage +1;
			this.movePageTo(nPage);
		},

		/**
		 * 현재 페이지의 다음 페이지로 이동한다.
		 */
		previousPageTo : function(){
			var nPage = this._nCurrentPage-1;
			this.movePageTo(nPage);
		},

		/**
		 * 전체 페이지 수를 리턴한다.
		 * @return {Number}
		 */
		getTotalPages : function(){
			var nTotal = this.option('nItem'),
				nCount = this.option('nItemPerPage');

			if(!nCount){
				return null;
			}

			return Math.ceil(nTotal/nCount);
		},

		/**
		 * 이전 페이지가 있는지 리턴한다.
		 * @return {Boolean}
		 */
		hasPreviousPage : function(){
			return (this.getCurrentPage() > 1);
		},

		/**
		 * n 페이지의 아이템들의 start, end 인덱스를 리턴한다.
		 * @param {Number} n
		 * @return {HashTable}
		 * @example
	var htIndex = oCorePagination.getPageIntemIndex(2);
	htIndex.nStart //2페이지의 아이템의 시작 인덱스
	htIndex.nEnd //2페이지의 아이템의 끝 인덱스
		 */
		getPageItemIndex : function(nPage){
			nPage = this._convertToAvailPage(nPage);

			var nTotal = this.option('nItem'),
				nCount = this.option('nItemPerPage'),
				start, end;

			if(!nPage || !nCount){
				return null;
			}

			start = (nPage-1) * nCount;
			end = Math.min(start+ nCount, nTotal)-1;

			return {
				nStart :  start,
				nEnd : end
			};
		},

		/**
		 * n번째 아이템이 몇번째 페이지인지 구한다.
		 * @param {Number} n
		 * @return {Number}
		 */
		getPageOfItem : function(n){
			return Math.ceil(n / this.getItemPerPage());
		},

		_convertToAvailPage : function(nPage){
			var nLastPage = this.getTotalPages();

			nPage = Math.max(nPage, 1);
			nPage = Math.min(nPage, nLastPage);

			return nPage;
		},

		// jindo.m.CorePagination function 끝


		// jindo.m.MoreContentButton function 시작
		/**
		 * @description jindo.m.MoreContentButton 에서 사용하는 모든 인스턴스 변수를 초기화한다.
		 */
		_initVar: function() {
			//this._nCurrentPage = this.option('nPage');
			var _htDefalutAjax = {
				sApi : null,
				htAjaxOption : {
					type: 'xhr'
				},
				htQuery : {},
				sStart : 'start',
				sDisplay : 'display'
			};

			var htAjax = this.option('htAjax');

			if(!htAjax){
				this.option('htAjax', _htDefalutAjax);
				return;
			}

			for(var p in _htDefalutAjax){
				if(typeof htAjax[p] == 'undefined'){
					htAjax[p] = _htDefalutAjax[p];
				}
			}

			//ajax option
			for(var p in _htDefalutAjax.htAjaxOption){
				if(typeof htAjax.htAjaxOption[p] == 'undefined'){
					htAjax.htAjaxOption[p] = _htDefalutAjax.htAjaxOption[p];
				}
			}

			//query string option
			for(var p in _htDefalutAjax.htQuery){
				if(typeof htAjax.htQuery[p]== 'undefined'){
					htAjax.htQuery[p] = _htDefalutAjax.htQuery[p];
				}
			}

			if(!!htAjax.sApi){
				//htAjax.htAjaxOption.onload = this._onAjaxResponse;
				this.oAjax = new J.$Ajax(htAjax.sApi, htAjax.htAjaxOption);
			}
		},

		/**
		 * @description jindo.m.MoreContentButton 에서 사용하는 모든 엘리먼트의 참조를 가져온다.
		 */
		_setWrapperElement: function(el) {
			this._htWElement = {};
			el = J.$(el);

			var sClass = '.'+ this.option('sClassPrefix');
			this._htWElement.elBase = J.$Element(el);

			this._htWElement.elMoreButton = J.$Element(J.$$.getSingle(sClass+'button',el));
			this._htWElement.elTop = J.$Element(J.$$.getSingle(sClass+'top',el));
			this._htWElement.elLoading = J.$Element(J.$$.getSingle(sClass+'loading',el));
			this._htWElement.elMoreCnt = J.$Element(J.$$.getSingle(sClass+'moreCnt', el)); //
			this._htWElement.elTotal = J.$Element(J.$$.getSingle(sClass+'total',el));
			this._htWElement.elCurrent = J.$Element(J.$$.getSingle(sClass+'current', el));
			this._htWElement.elLast = J.$Element(J.$$.getSingle(sClass+'last', el));
			if(!!this._htWElement.elLast){
				this._htWElement.elLastTotal = J.$Element(J.$$.getSingle(sClass+'total', this._htWElement.elLast.$value()));
				this._htWElement.elLastCurrent = J.$Element(J.$$.getSingle(sClass+'current', this._htWElement.elLast.$value()));
			}
		},

		_onClickMore : function(oEvent){
			oEvent.stop(J.$Event.CANCEL_DEFAULT);
			if(this.hasNextPage()){
				this.more();
			}
		},

		_onClickTop : function(oEvent){
			oEvent.stop(J.$Event.CANCEL_DEFAULT);

			this.fireEvent('goTop',{
				element : oEvent.element
			});
		},

		more : function(bFireEvent){
			if (typeof bFireEvent == "undefined") {
				bFireEvent = true;
			}

			var nPage = this._nCurrentPage +1;

			var nBeforePage = this.getCurrentPage();
			if(bFireEvent){
				if(!this.fireEvent('beforeMore',{
					nPage : nPage,
					nCurrentPage : nBeforePage
				})){
					return;
				}
			}

			this.showLoadingImg();

			if(!!this.option('htAjax').sApi){
				this._callAjax(nPage,true, bFireEvent);
			}else{
				this._move(nPage);
				var htIndex = this.getPageItemIndex(nPage);

				if(bFireEvent){
					this.fireEvent('more',{
						nPage : nPage,
						nStartIndex : htIndex.nStart,
						nEndIndex : htIndex.nEnd
					});
				}

				this.updateInfo();
			}
		},

		/**
		 * nPage 페이지로 이동한다.
		 * @param {Number} nPage
		 * @param {Boolean} 커스텀 이벤트 발생 여부
		 * @description
		 */
		movePageTo : function(nPage, bFireEvent){
			if (typeof bFireEvent == "undefined") {
				bFireEvent = true;
			}

			var nBeforePage = this.getCurrentPage();
			if(bFireEvent){
				if(!this.fireEvent('beforeMovePage',{
					nPage : nPage,
					nCurrentPage : nBeforePage
				})){
					return;
				}
			}

			this.showLoadingImg();

			if(!!this.option('htAjax').sApi){
				this._callAjax(nPage, false ,bFireEvent);
			}else{
				this._move(nPage);
				var htIndex = this.getPageItemIndex(nPage);

				if(bFireEvent){
					this.fireEvent('movePage',{
						nPage : nPage,
						nBeforePage : nBeforePage,
						nStartIndex : 0,
						nEndIndex : htIndex.nEnd
					});
				}
				this.updateInfo();
			}
		},

		_move : function(nPage){
			var n = this._convertToAvailPage(nPage);
			if(n != this._nCurrentPage){
				this._nCurrentPage = n;
			}
		},

		_callAjax : function(nPage, bMore ,bFireEvent){
			var self = this;
			this.oAjax.option('onload', null);

			this.oAjax.option('onload', function(res){
				self._onAjaxResponse(res, nPage, bMore, bFireEvent);
			});
			
			var htQuery = this._getQueryString(nPage, bMore);
			
			if (htQuery.sort != 'best' && htQuery.comment_no != "0") {
				this.oAjax.request(htQuery);
			}
		},

		_onAjaxResponse : function(oResponse, nPage, bMore, bFireEvent){
			if(bFireEvent){
				this._move(nPage);
				var sEvent = bMore? 'more' : 'movePage';

				var htIndex = this.getPageItemIndex(nPage);

				this.fireEvent(sEvent,{
					oResponse : oResponse,
					nPage : nPage,
					nStartIndex : bMore? htIndex.nStart : 0,
					nEndIndex : htIndex.nEnd
				});
			}

			this.updateInfo();
		},

		/**
		 * @return {Number}
		 * @description  더보기 할 전체 아이템 개수를 구한다.
		 */
		getShowMaxItem : function(){
			return this.option('nShowMaxItem');
		},

		_setNumberFormat: function(sText) {
			sText = sText.toString();
			var sReturn = "";
			var nDot = 0;
			var nLastPosition = sText.length;
			for (var i = nLastPosition; i >= 0; i--) {
				var sChar = sText.charAt(i);
				if (i > nLastPosition) {
					sReturn = sChar + sReturn;
					continue;
				}
				if (/[0-9]/.test(sChar)) {
					if (nDot >= 3) {
						sReturn = ',' + sReturn;
						nDot = 0;
					}
					nDot++;
					sReturn = sChar + sReturn;
				}
			}
			return sReturn;
		},

		/**
		 * @description 로딩이미지를 보여준다
		 */
		showLoadingImg : function(){
			if(!!this._htWElement.elLoading){
				this._htWElement.elLoading.show();
			}
		},

		/**
		 * @description 로딩이미지를 감춘다
		 */
		hideLoadingImg : function(){
			if(!!this._htWElement.elLoading){
				this._htWElement.elLoading.hide();
			}
		},

		/**
		 * @param {Number} nShowMaxItem 더보기할 아이템의 개수가 바뀌었을 경우 설정해준다.
		 * @description 1페이지로 더보기를 다시 그린다. 커스텀이벤트는 발생하지 않는다.
		 */
		reset : function(nShowMaxItem){
			if (typeof nShowMaxItem == "undefined") {
				nShowMaxItem = this.option('nShowMaxItem');
			}

			this.setShowMaxItem(nShowMaxItem);
			this.movePageTo(1, false);
			
			this._bLastPage = false;
		},

		/**
		 * @return {Number}
		 * @description 전체 아이템 개수를 구한다.
		 */
		getTotalItem : function(){
			return this.option('nTotalItem');
		},

		/**
		 * @param {Number} n
		 * @description 전체 아이템 개수를 n으로 설정한다.
		 */
		setTotalItem : function(n){
			this.option('nTotalItem', n);
		},

		/**
		 * @param {Number} n
		 * @description 더보기할 전체 아이템 개수를 n으로 설정한다.
		 */
		setShowMaxItem : function(n){
			this.option('nShowMaxItem', n);
			this.option('nItem', n);
		},

		/**
		 * @description jindo.m.MoreContentButton 컴포넌트를 활성화한다.
		 * activate 실행시 호출됨
		 */
		_onActivate : function() {
			this._attachEvent();
		},

		/**
		 * @description jindo.m.MoreContentButton 컴포넌트를 비활성화한다.
		 * deactivate 실행시 호출됨
		 */
		_onDeactivate : function() {
			this._detachEvent();
		},

		/**
		 * @description jindo.m.MoreContentButton 에서 사용하는 모든 이벤트를 바인드한다.
		 */
		_attachEvent : function() {
			this._htEvent = {};
			if(!!this._htWElement.elMoreButton){
				this._htEvent["click_More"] = {
					ref : J.$Fn(this._onClickMore, this).attach(this._htWElement.elMoreButton, 'click'),
					el : this._htWElement.elMoreButton.$value()
				};
			}
			if(!!this._htWElement.elTop){
				this._htEvent["click_Top"] = {
					ref : J.$Fn(this._onClickTop, this).attach(this._htWElement.elTop, 'click'),
					el : this._htWElement.elTop.$value()
				};
			}
		},

		/**
		 * @description jindo.m.MoreContentButton 에서 사용하는 모든 이벤트를 해제한다.
		 */
		_detachEvent : function() {
			for(var p in this._htEvent) {
				var htTargetEvent = this._htEvent[p];
				htTargetEvent.ref.detach(htTargetEvent.el, p.substring(0, p.indexOf("_")));
			}

			this._htEvent = null;
		},

		/**
		 * @description jindo.$Ajax Header 값을 설정한다.
		 * http://jindo.nhncorp.com/docs/jindo/archive/Jindo2-latest/ko/symbols/%24Ajax.html#header 참조
		 */
		header : function(vName, vValue) {
			if(this.oAjax) {
				return this.oAjax.header(vName, vValue);
			}
		},

		/**
		 * @description  jindo.m.MoreContentButton 에서 사용하는 모든 객체를 release 시킨다.
		 */
		destroy: function() {
			this._detachEvent();

			for(var p in this._htWElement) {
				this._htWElement[p] = null;
			}
			this._htWElement = null;
		},
		// jindo.m.MoreContentButton function 끝


/**
 * 윗 부분은 기존 jindo_mobile_component를 그대로 가져온 부분(extend하여 사용하는데 각 서비스의 jindo mobile component가 업데이트 되거나 커스터마이징된 경우 js오류 발생가능성이 있어,
 * 위에 두고 필요한 부분만 아래에서 수정하여 컨트롤하도록 함.
 */

		/**
		 * 기존 jindo MoreContentButton의 기능중 ajax 호출하는 queryString가져오는 부분 override
		 */
		_getQueryString : function(nPage, bMore){
			if(typeof bMore === 'undefined'){
				bMore = true;
			}
			var htQuery = this.option('htAjax').htQuery || {};

			htQuery[this.option('htAjax').sDisplay] = this.getItemPerPage();
			htQuery['sort'] = this.config.option('currentSortOption');
			return htQuery;
		},

		/**
		 * @description 더보기 영역을 현재 페이지에 맞게 정보들을 설정한다.
		 */
		updateInfo : function(){
			// 더보기시 값이 없는 경우 setLastPage로 설정
			if( this._bLastPage || this._nBaseCommentCount >= this.option('nTotalItem')){
				this._bLastPage = true;
				this.setTotalItem(this._nBaseCommentCount );
			}else{
				this._bLastPage = false;
			}
		},

		/**
		 * 페이지 네비게이션뷰 갱신
		 */
		updateView : function() {
			this.hideLoadingImg();

			if( this._bLastPage ){
				this._htWElement.elBase.addClass('u_pg_end');
				if(!!this._htWElement.elMoreButton){
					this._htWElement.elMoreButton.hide();
				}
				if(!!this._htWElement.elLast){
					this._htWElement.elLast.show('block');
				}
			}else{
				this._htWElement.elBase.removeClass('u_pg_end');
				if(!!this._htWElement.elMoreButton){
					this._htWElement.elMoreButton.show('block');
				}
				if(!!this._htWElement.elLast){
					this._htWElement.elLast.hide();
				}
			}

			if(!!this._htWElement.elCurrent){
				this._htWElement.elCurrent.text(this._nBaseCommentCount);
			}

			if(typeof this._htWElement.elLastCurrent != 'undefined'){
				this._htWElement.elLastCurrent.text(this._setNumberFormat(this._nBaseCommentCount));
			}

			if(!!this._htWElement.elTotal){
				this._htWElement.elTotal.text(this._setNumberFormat(this.option('nTotalItem')));
			}
			if(typeof this._htWElement.elLastTotal != 'undefined'){
				this._htWElement.elLastTotal.text(this._setNumberFormat(this.option('nTotalItem')));
			}

			if(!!this._htWElement.elMoreCnt){
				var nMoreCount = Math.min(this.getItemPerPage(), this.option('nTotalItem') - this._nBaseCommentCount);
				this._htWElement.elMoreCnt.text(this._setNumberFormat(nMoreCount));
			}
		},

		/**
		 * 마지막 페이지 인지 여부.
		 */
		isLastPage : function() {
			return this._bLastPage;
		},

		makeLastPage : function() {
			this._bLastPage = true;
		},

		/**
		 * 기존 jindo MoreContentButton의 기능들중 다음페이지 존재여부 판단하는 로직 override
		 * 아래 method는 반드시 존재해야함.
		 */
		hasNextPage : function(){
			return this._nBaseCommentCount < this.option('nTotalItem');
		},

		setBaseCommentCount : function(nCount) {
			this._nBaseCommentCount = nCount;
		}

	}).extend(J.UIComponent);
})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
* @(#)nhn.comment.mobile.moreContentArea.js 2012. 03. 19
*/
(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile,
		Util = Comment.Util;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/**
	 * @description 더보기 영역을 처리하는 클래스
	 */
	Comment.MoreContentArea = J.$Class({
		/** @lends nhn.comment.mobile.MoreContentArea.prototype */

		/**
		 * @description 초기화 함수
		 * @constructs
		 * @class
		 * @extends nhn.comment.mobile.CommonPageArea
		 * @require	jindo.m.MoreContentButton
		 */
		$init : function() {
			this._wel = null;
			this._oMoreContent = null;
			this._bInitComponent = false;
		},

		/**
		 * @description 더보기 영역을 생성한다.
		 * @return {jindo.$Element}
		 */
		createArea : function() {
			this._welArea = J.$Element(this.config.template('pageArea').process());
			return this._welArea;
		},

		/**
		 * @description 영역 생성 후..
		 */
		afterCreateArea : function() {
			this._wel= J.$Element(this.config.template('pageMore').process());
			this._welArea.append(this._wel);
			this._initComponent();

			this.hide();
		},

		/**
		 * @description 더보기영역을 위한 정보를 업데이트 해준다.
		 */
		update : function(nPageNo, nTotalCount, bNeedInfoUpdate) {
			this.setPageNo(nPageNo);

			var htParams = this.config.instance.ajax.getListParams();
			htParams['comment_no'] = this.config.instance.commentListModel.getBaseLastCommentNo();

			this._oMoreContent.option('htAjax').htQuery = htParams;
			this._oMoreContent.setTotalItem(nTotalCount);
			this._oMoreContent.setShowMaxItem(nTotalCount);
			this._oMoreContent.setItemCount(nTotalCount);
			this._oMoreContent.setBaseCommentCount(this.config.instance.commentListModel.getBaseCommentCount());

			// 리스트를 가져오는 경우만 update
			if ( bNeedInfoUpdate) {
				this._oMoreContent.updateInfo();
			}

			this._oMoreContent.updateView();

			if ( this.isNeedToHidePageArea(nTotalCount) ) {
				this.hide();
				return;
			}

			this.show();
		},

		/**
		 * 전체 카운트 가져오기
		 */
		getTotalCount : function() {
			if ( this._oMoreContent.getTotalItem() == null) {
				return 0;
			}

			return this._oMoreContent.getTotalItem();
		},

		/**
		 * @description	더보기 컴포넌트를 생성한다.
		 */
		_initComponent : function() {
			var self = this;
			var htPatams = this.config.instance.ajax.getListParams();

			this._oMoreContent = new Comment.CurrentCountChangeableMoreContentButton(this.config, this._wel.$value(),{
				sClassPrefix : '__comment_more_',
	            nItemPerPage : this.config.option('pageSize'), 		//페이지당 더보기 할 건수
	            htAjax : {
	                sApi : this.config.instance.ajax.getUrl('moreList'), //ajax 호출 api
	                sDisplay : 'page_size',
	                htQuery : htPatams
	            },
	            nTotalItem : 1,
	            nShowMaxItem :1

	        }).attach({
	        	'goTop' : function() {
	        		Util.scrollTop();
	        	},
	        	'more' : function(oCustomEvent) {
	        		self._afterMore(oCustomEvent.oResponse);
	        	}
	        });
		},

		/**
		 * @description	더보기 이후, 목록 데이타를 보여준다.
		 */
		_afterMore : function(oResponse) {
			oResponse = oResponse.json();
			oResponse.more_yn = "Y";
			this.config.instance.listarea.showList(oResponse);
		},

		/**
		 * 페이지 영역을 숨길필요가 있는지 여부
		 */
		isNeedToHidePageArea : function(nTotalCount) {
			// 서비스에서 초기 controller옵셜 설정시 전달
			if ( !this.config.option('hidePageAreaIfOnlyOnePageExist')) {
				return false;
			}

			if ( !this._isFirstPageWasLastPage()  ) {
				return false;
			}

			return true;
		},

		/**
		 * 최초 로딩시 마지막 페이지 였는지 여부
		 */
		_isFirstPageWasLastPage : function() {
			if ( this._bFirstPageWasLastPage != null) {
				return this._bFirstPageWasLastPage;
			}

			this._bFirstPageWasLastPage = this.isLastPage();

			return this._bFirstPageWasLastPage;
		},

		/**
		 * 마지막 페이지 인지 여부
		 */
		isLastPage : function() {
			return this._oMoreContent.isLastPage();
		},

		/**
		 * 마지막 페이지로 만들기(더보기시 페이지 열때에는 있었던 다음페이지
		 * 댓글이 다른 사용자에 의해 삭제된 경우, 더이상 컨텐츠가 없기 때문에 이를 위한 설정)
		 */
		makeLastPage : function() {
			this._oMoreContent.makeLastPage();
		},
		
		reset : function() {
			this._oMoreContent.reset();
		}
	}).extend(Comment.CommonPageArea);

	nhn.comment.morecontentarea = new Comment.MoreContentArea();
})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
* @(#)nhn.comment.mobile.auth.js 2012. 03. 19
*/
(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/**
	 * @description 인증처리 클래스
	 */
	Comment.Auth = J.$Class({
		/** @lends nhn.comment.mobile.Auth.prototype */

		/**
		 * @description 초기화 함수
		 * @constructs
		 * @class
		 * @extends jindo.Component
		 */
		$init : function() {
			this.indexInstance = Comment.Auth.getInstance().length - 1;
			this.config = Comment.Config.getInstance()[this.indexInstance];
		},

		/**
		 * @description 로그인여부를 체크한다.
		 */
		checkLogin : function() {
			var htParams = {};
			htParams.ticket = this.config.option('ticket');

			this.config.instance.ajax.call( {
				operation : 'isLogin',
				async : false,
				onSuccess : J.$Fn(this._onCheckLogin, this).bind(),
				param : htParams
			});
		},

		/**
		 * @description 로그인 페이지로 리다이렉트
		 */
		redirectLogin : function() {
			if (this._isLoginNow()) {
				return true;
			}

			if (confirm(this.config.message.NOT_LOGIN)) {
				var loginUrl = this.config.option('loginUrl') || 'https://nid.naver.com/nidlogin.login';

				top.location = loginUrl + '&url=' + encodeURIComponent(this.config.option('objectUrl'));
			}

			return false;
		},

		/**
		 * 현재 로그인 상태인지 여부 체크..
		 *
		 * 브라우저 다른 탭에서 로그인했을 가능성이 있어, 로그아웃상태인 경우에는 한번더 로그인했는지 여부를
		 * 서버에 질의.
		 */
		_isLoginNow : function() {
			if (this.config.option("isLogin")) {
				return true;
			}

			this.checkLogin();

			return this.config.option("isLogin");
		},

		/**
		 * @description 비실명 인증 여부를 체크한다.
		 */
		checkAuth : function() {
			if (this.config.option('isAuth') !== undefined) {
				return;
			}
			var htParams = {};
			htParams.ticket = this.config.option('ticket');

			this.config.instance.ajax.call({
				operation : 'checkAuth',
				async : false,
				onSuccess : J.$Fn(this._onCheckAuth, this).bind(),
				param : htParams
			});
		},

		/**
		 * @description 비실명 인증 페이지로 리다이렉트
		 */
		redirectAuth : function() {
			if (this.config.option("isAuth")) {
				return true;
			}

			if (confirm(this.config.message.NOT_AUTHENTICATED)) {
				var certUrl = this.config.option('certUrl') || 'https://nid.naver.com/user/mobile_rncheck.nhn?todo=start';
				var rurl = this.config.option('certRurl') || this.config.option('objectUrl');
				var surl = this.config.option('certSurl') || this.config.option('objectUrl');
				var svc = this.config.option('certSvc') || "";

				top.location = certUrl + '&rurl=' + encodeURIComponent(rurl) + '&surl=' + encodeURIComponent(surl) + '&svc=' + svc;
			} else {
				this.checkAuth();
			}

			return false;
		},

		/**
		 * @description 비실명 체크 후, 값을 저장해 놓는다.
		 * @param	{Object}	oResult	결과값
		 */
		_onCheckAuth : function(oResult) {
			this.config.option('isAuth', oResult.is_authenticated_name == 'Y');
		},

		/**
		 * @description 로그인체크 후, 값을 저장해 놓는다.
		 * @param	{Object}	oResult	결과값
		 */
		_onCheckLogin : function(oResult) {
			if(oResult.is_logged_in == 'Y'){
				this.config.option('isLogin', true);
			}
		}
	}).extend(J.Component);

	nhn.comment.auth = new Comment.Auth();
})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
* @(#)nhn.comment.mobile.core.js 2012. 03. 19
*/

(function() {
	document.domain = 'naver.com';

	var J = window.nhn.comment.mobile.jindo || jindo,
	    Comment = nhn.comment.mobile;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/**
	* @description 댓글 모듈 (초기화처리)
	*/
	Comment.Core = J.$Class({
		/** @lends nhn.comment.mobile.Core.prototype */

		/**
		 * @description 초기화 함수
		 * @constructs
		 * @class
		 * @extends jindo.Component
		 */
		$init : function() {
			this.indexInstance = Comment.Core.getInstance().length - 1;
			this.config = Comment.Config.getInstance()[this.indexInstance];
			this._welBody = null;
		},

		/**
		 * @description 댓글을 초기화한다.
		 */
		initialize : function() {
			this._saveInstanceInConfig();
			this._doAfterInstanceCreated();
			this._createArea();

			this.option('initialized', true);
			this.config.fireEvent('initialized');
		},

		/**
		 * 해당 댓글 메인body에 해당하는 태그 리턴
		 */
		getBody : function() {
			return this._welBody;
		},

		/**
		 * instance 생성후에 수행되어야 하는 job 수행.
		 */
		_doAfterInstanceCreated : function() {
			this.config.instance.ajax.initErrorHandler();
			
			// 서버에 설정된 값을 가져와서 세팅
			this.config.setTicketConfig();
			this.config.getUrlList();
		},

		/**
		 * @description 필요한 인스턴스를 생성하여 저장한다.
		 */
		_saveInstanceInConfig :function(){
			var htDeviceInfo = J.m.getDeviceInfo();

			this.config.instance.core = Comment.Core.getInstance()[this.indexInstance];
			this.config.instance.ajax = Comment.Ajax.getInstance()[this.indexInstance];
			this.config.instance.command = Comment.Command.getInstance()[this.indexInstance];
			this.config.instance.countarea = Comment.CountArea.getInstance()[this.indexInstance];
			this.config.instance.writearea = Comment.WriteArea.getInstance()[this.indexInstance];
			this.config.instance.bestlistarea = Comment.BestListArea.getInstance()[this.indexInstance];
			this.config.instance.listarea = Comment.ListArea.getInstance()[this.indexInstance];
			this.config.instance.auth = Comment.Auth.getInstance()[this.indexInstance];
			this.config.instance.commentListModel = Comment.CommentListModel.getInstance()[this.indexInstance];
			this.config.instance.sortListArea = Comment.SortListArea.getInstance()[this.indexInstance];
			this.config.instance.listFooterArea = Comment.ListFooterArea.getInstance()[this.indexInstance];

			if (this.config.option('useMoreContent')) {
				this.config.instance.pagearea = Comment.MoreContentArea.getInstance()[this.indexInstance];
			} else {
				this.config.instance.pagearea = Comment.PageArea.getInstance()[this.indexInstance];
			}
		},

		/**
		 * @description 사용자가 정의한 포맷 순서에 맞게 영역을 생성한다.
		 */
		_createArea : function() {
			var isHasList = false;
			this._welBody = J.$Element(J.$$.getSingle(this.config.element('body')));
			
			this._welBody.addClass(this.config.option('listType'));
			
			if ( this.config.option('isBlackMode') ) {
				this._welBody.addClass('c_black');		
			}

			if ( this.config.option('listType') == 'u_comment_v1' && this.config.option('isSimpleList') ) {
				this._welBody.addClass('u_comment_hc');
			}
			
			var aFormation = this.config.option('formation');
			var sFormation;

			var htAreaElement = {
				count : this.config.instance.countarea,
				bestList : this.config.instance.bestlistarea,
				list : this.config.instance.listarea,
				page : this.config.instance.pagearea,
				write : this.config.instance.writearea,
				listFooter : this.config.instance.listFooterArea,
				sort : this.config.instance.sortListArea,
			};

			for ( var i = 0, nLen = aFormation.length; i < nLen; i++) {
				sFormation = aFormation[i];

				if (sFormation == 'list') {
					isHasList = true;					
					this._welBody.append(this.config.instance.listarea.createEmptyArea()); // Empty Div 영역도 List 상단에 만들어 둔다.
				}

				this._welBody.append(htAreaElement[sFormation].createArea());
				htAreaElement[sFormation].afterCreateArea();
				
			}

			//댓글 리스팅
			if (isHasList) {
				this.config.instance.listarea.requestList('page', this.config.option('pageNo'), false);
			}

			this._welBody.append(J.$Element(this.config.template('reportForm').process()));
		}
	}).extend(J.Component);

	nhn.comment.core = new Comment.Core();
})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
* @(#)nhn.comment.mobile.controller.js 2012. 03. 19
*/
(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/**
	* @description 댓글 모듈 생성 컨트롤러
	* 댓글의 옵션 설정과 모듈 생성은 Controller 를 통해서만 하도록 한다.
	*/
	Comment.Controller = J.$Class({
		/** @lends nhn.comment.mobile.Controller.prototype */

		_sTarget : null,
		_htOptions : null,
		_htTemplates : null,
		_htMessage : null,

		/**
		 * @description 초기화 함수
		 * @constructs
		 * @class
		 * @extends jindo.Component
		 */
		$init : function() {
			this._htTemplates = {};
			this._htMessage = {};
			this._htOptions = {};
		},

		/**
		 * @description 댓글 코어을 생성한다.
		 * @param	{String}	sTarget	타겟엘리먼트접근자 (필수)
		 * @param	{String}	sTicket	티켓아이디 (필수)
		 * @param	{String}	sObjectId	오브젝트아이디 (필수)
		 * @param	{String}	sCategoryId	카데고리아이디 (생략가능)
		 */
		create : function(sTarget, sTicket, sObjectId, sCategoryId) {
			if(!sTarget || !(J.$$.getSingle(sTarget))) {
				throw TypeError('Invalid target element selector argument.');
			}
			if(!sTicket) {
				throw TypeError('Invalid ticket argument.');
			}
			if(!sObjectId) {
				throw TypeError('Invalid objectId argument.');
			}

			// 가장 최근에 생성된 댓글 코어 인스턴스 선택
			var oInstances = Comment.Core.getInstance();
			var oCore = oInstances[oInstances.length - 1];

			if (oCore.initialized) {
				var oConfIns = new Comment.Config();
				var oAuthIns = new Comment.Auth();
				var oAjaxIns = new Comment.Ajax();
				var oCoreIns = new Comment.Core();
				var oCountAreaIns = new Comment.CountArea();
				var oWriteAreaIns = new Comment.WriteArea();
				var oBestListAreaIns = new Comment.BestListArea();
				var oListAreaIns = new Comment.ListArea();
				var oPageAreaIns = new Comment.PageArea();
				var oMoreContentAreaIns = new Comment.MoreContentArea();
				var oCommandIns = new Comment.Command();
				var oCommentListModelIns = new Comment.CommentListModel();
				if (Comment.SocialCommentArea) {
					var oSocialCommentArea = new Comment.SocialCommentArea();
				}
				if (Comment.RecommendDiscommendArea) {
					var oRecommendDiscommendArea = new Comment.RecommendDiscommendArea();
				}
				var oSortListArea = new Comment.SortListArea();
				var oListFooterArea = new Comment.ListFooterArea();

				// 새로운 인스턴스들을 생성하고 최신의 core 인스턴스를 얻어온다.
				oCore = oInstances[oInstances.length - 1];
			}

			//설정 재적용
			this.resetConfig(oCore);

			// 댓글 ticket, objectId, categoryId 설정
			oCore.config.option('ticket', sTicket);
			oCore.config.option('objectId', sObjectId);
			if(sCategoryId) {
				oCore.config.option('categoryId', sCategoryId);
				oCore.config.option('viewCategoryId', sCategoryId);
			}

			// 댓글이 표시될 영역 설정
			oCore.config.element('body',sTarget);
			oCore.initialized = true;

			// 댓글 인스턴스 반환
			return oCore;
		},

		/**
		 * @description 댓글 코어를 초기화한다.
		 */
		initialize : function(oCore) {
			// 댓글 초기화
			oCore.initialize();
		},

		/**
		 * @description 커스텀 이벤트 핸들러를 등록한다.
		 * @param	{HashTable}	htEventHandler	이벤트핸들러
		 */
		addEventHandler : function(oCore, htEventHandler) {
			if (oCore && oCore.initialized) {
				oCore.config.attach(htEventHandler);
			}
		},

		/**
		 * @description 옵션을 설정한다.
		 * @param	{Object}	oOption	옵션명 혹은 오브젝트
		 * @param	{Object}	oValue	값
		 */
		setOptions : function(oOption, oValue)
		{
			if (typeof oOption == 'object') {
				for (var sKey in oOption) {
					this._htOptions[sKey] = oOption[sKey];
				}
			} else if (typeof oOption == 'string' && oValue) {
				this._htOptions[oOption] = oValue;
			}
		},


		/**
		 * @description 옵션을 설정한다.
		 * @param	{Object}	oOption	옵션명 혹은 오브젝트
		 * @param	{Object}	oValue	값
		 */
		setTemplates : function(oTemplate, oValue) {
			if (typeof oTemplate == 'object') {
				for (var sKey in oTemplate) {
					this._htTemplates[sKey] = oTemplate[sKey];
				}
			} else if (typeof oTemplate == 'string' && oValue) {
				this._htTemplates[oTemplate] = oValue;
			}
		},


		/**
		 * @description 옵션을 설정한다.
		 * @param	{Object}	oOption	옵션명 혹은 오브젝트
		 * @param	{String}	sValue	값
		 */
		setMessages : function(oMessage, sValue) {
			if (typeof oMessage == 'object') {
				for (var sKey in oMessage) {
					this._htMessage[sKey] = oMessage[sKey];
				}
			} else if (typeof oMessage == 'string' && sValue) {
				this._htMessage[oMessage] = sValue;
			}
		},

		/**
		 * @description	인스턴스들에 변경된 설정과 템플릿을 적용한다.
		 * oCoreInstance 를 넘기지 않은 경우, 모든 인스턴스에 설정을 갱신한다.
		 *
		 * @param	{nhn.comment.mobile.Core}	oCoreInstance	코어인스턴스
		 */
		resetConfig : function(oCore) {
			var aInstances;
			if(oCore && oCore.name == 'nhn.comment.mobile.Core') {
				aInstances = [oCore];
			} else {
				aInstances = Comment.Core.getInstance();
			}

			for(var i = 0; i < aInstances.length; i++) {
				var oInstance = aInstances[i];
				// 사용자 설정 적용
				oInstance.config.option(this._htOptions);

				// 사용자 템플릿 적용
				oInstance.config.template(this._htTemplates);

				// 사용자 메시지 적용
				oInstance.config.message(this._htMessage);
			}
		}
	}).extend(J.Component);
})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
* @(#)nhn.comment.mobile.commentListModel.js 2012. 04. 27
*/
(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile,
		Util = nhn.comment.mobile.Util;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';

	/**
	 * @description 댓글 관련 model
	 */
	Comment.CommentListModel = J.$Class({
		/** @lends nhn.comment.mobile.commentListModel.prototype */

		/**
		 * @description 초기화 함수
		 * @constructs
		 * @class
		 * @extends jindo.Component
		 */
		$init : function() {
			this.reset();
			this.indexInstance = Comment.CommentListModel.getInstance().length - 1;
			this.config = Comment.Config.getInstance()[this.indexInstance];
		},

		/**
		 * 타겟 리스트에서 해당 commentNo를 갖는 comment의 index 반환
		 */
		_getCommentIndex : function(waCommentList, sCommentNo) {
			var nIndex = null;

			if ( waCommentList == null || sCommentNo == null) {
				return null;
			}

			waCommentList.forEach(
				function(oEach, index, array) {
					if ( oEach.commentNo == sCommentNo) {
						nIndex = index;
						J.$A.Break();
					}
				}
			)

			return nIndex;
		},

		/**
		 * commentNo에 해당하는 comment 삭제 marking
		 */
		markTargetCommentDeleted : function(sCommentNo) {
			var waTargetCommentList = this._findTargetCommentList(sCommentNo);
			var nIndex = this._getCommentIndex(waTargetCommentList, sCommentNo);
			var htCommentInfo = waTargetCommentList.get(nIndex);

			htCommentInfo.isDeleted = true;
			waTargetCommentList.set(nIndex, htCommentInfo);
		},

		/**
		 * 해당 commentNo가 있는 commentList 가져오기
		 */
		_findTargetCommentList : function(sCommentNo) {
			if (this._isExistInBaseCommentList(sCommentNo)) {
				return this._waBaseCommentList;
			}

			return this._waBottomCommentList;
		},

		/**
		 * 기본적인 commentInfo 생성
		 */
		_generateCommentInfo : function(oComment) {
			var htCommentInfo = {};
			htCommentInfo.commentNo = oComment.getCommentNo();
			htCommentInfo.replyLevel = oComment.getReplyLevel();
			htCommentInfo.registeredDate = oComment.getRegisteredDate();
			htCommentInfo.isDeleted = oComment.isDeleted();

			return htCommentInfo;
		},

		/**
		 * Baselist에 추가할수 있는지 여부
		 */
		_isPossibleToAddBaseCommentList : function(nParentCommentNo) {
			// 1레벨 댓글이면 가능
			if ( nParentCommentNo == 0) {
				return true;
			}

			// 마지막 페이지면 가능
			if ( this.config.instance.pagearea.isLastPage() ) {
				return true;
			}

			// 부모comment가 baselist에 있고, 부모 comment이후 comment들이 모두 부모의 자손들이 아니면 가능
			if ( this._isExistInBaseCommentList(nParentCommentNo) && !this._isHighReplyLevelOnlyExistAfterComment(nParentCommentNo)) {
				return true;
			}

			return false;
		},

		/**
		 * 해당 comment 이후의 comment들이 모두 해당 comment의 자손들인지 여부
		 */
		_isHighReplyLevelOnlyExistAfterComment : function(sCommentNo) {
			var htCommentInfo = this._getBaseCommentInfo(sCommentNo);

			var waSlicedListAfterTargetComment = this._getSlicedListAfterCommentNo(this._waBaseCommentList, sCommentNo);

			if ( waSlicedListAfterTargetComment == null) {
				return true;
			}

			var bOnlyHighLevelCommentExist = true;

			waSlicedListAfterTargetComment.forEach(
				function(oEach, index, array) {
					if ( oEach.replyLevel <= htCommentInfo.replyLevel ) {
						bOnlyHighLevelCommentExist = false;
						J.$A.Break();
					}
				}
			);

			return bOnlyHighLevelCommentExist;
		},

		/**
		 * 특정 commentNo 이후의 comment리스트들을 반환
		 */
		_getSlicedListAfterCommentNo : function(waCommentList, sCommentNo) {
			var nIndex = this._getCommentIndex(waCommentList, sCommentNo);

			if ( nIndex == null) {
				return null;
			}

			return waCommentList.slice(nIndex + 1, waCommentList.length());
		},

		/**
		 * 생성된 comment가 위치할 바로앞 형제 node의 commentNo를 반환
		 */
		findPreSiblingCommentNoOfCreatedComment : function(nParentCommentNo, nReplyLevel) {
			var waTargetCommentList = this._waBaseCommentList;
			var sPreSiblingCommentNo = 0;

			if ( !this._isPossibleToAddBaseCommentList(nParentCommentNo)) {
				waTargetCommentList = this._waBottomCommentList;

				if ( this._isExistInBaseCommentList(nParentCommentNo) ) {
					nParentCommentNo = 'empty';
				}
			}

			var nIndex = this._getCommentIndex(waTargetCommentList, nParentCommentNo);

			if ( nIndex == null) {
				return 0;
			}

			var htParentCommentInfo = this.getCommentInfoFromBaseAndBottom(nParentCommentNo);
			var waSlicedListAfterTargetComment = this._getSlicedListAfterCommentNo(waTargetCommentList, nParentCommentNo);
			var sPreSiblingCommentNo = nParentCommentNo;

			// replyLevel이 같거나 크면 저장.
			waSlicedListAfterTargetComment.forEach(
				function(oEach, index, array) {
					if ( oEach.replyLevel < nReplyLevel ) {
						J.$A.Break();
					}

					sPreSiblingCommentNo = oEach.commentNo;
				}
			);

			return sPreSiblingCommentNo;
		},

		/**
		 * BottomComment가 비어있는지 여부
		 */
		isEmptyBottomComment : function() {
			if ( this._waBottomCommentList.length() == 1) {
				return true;
			}

			return false;
		},

		/**
		 * BaseComment가 비어있는지 여부
		 */
		isEmptyBaseComment : function() {
			if ( this._waBaseCommentList.length() > 0) {
				return false;
			}

			return true;
		},

		/**
		 * nPreSiblingCommentNo 뒤에 oComment 추가
		 */
		addComment : function(oComment, nPreSiblingCommentNo) {
			if ( oComment == null) {
				return;
			}

			var htCommentInfo = this._generateCommentInfo(oComment);

			// 이전 commentNo가 없으면 제일 뒤에 추가
			if ( nPreSiblingCommentNo == null) {
				this._waBaseCommentList.push(htCommentInfo);
				return;
			}

			// 이전 commentNo가 0이면 가장앞에 추가(1단계 레벨임)
			if ( nPreSiblingCommentNo == 0 ) {
				this._waBaseCommentList.unshift(htCommentInfo);
				return;
			}

			this._createListWithCommentInserted(htCommentInfo, nPreSiblingCommentNo);
		},

		/**
		 * 알맞은 list를 찾아서, 해당 commentInfo를 nPreSiblingCommentNo 뒤에 추가
		 */
		_createListWithCommentInserted : function(htCommentInfo, nPreSiblingCommentNo) {
			var waTargetCommentList = this._findTargetCommentList(nPreSiblingCommentNo);
			var nPreSiblingCommentIndex = this._getCommentIndex(waTargetCommentList, nPreSiblingCommentNo) + 1;

			var waNewCommentList = J.$A([]);
			waNewCommentList = waTargetCommentList.slice(0, nPreSiblingCommentIndex);
			waNewCommentList.push(htCommentInfo);

			waTargetCommentList.slice(nPreSiblingCommentIndex, waTargetCommentList.length()).forEach(
				function(oEach, index, array) {
					waNewCommentList.push(oEach);
				}
			);

			if (this._isExistInBaseCommentList(nPreSiblingCommentNo)) {
				this._waBaseCommentList = waNewCommentList;
				return;
			}

			this._waBottomCommentList = waNewCommentList;
		},

		/**
		 * baseList의 마지막 comment인지 여부
		 */
		_isLastBaseCommentNo : function(sCommentNo) {
			return this.getBaseLastCommentNo() == sCommentNo;
		},

		/**
		 * baseList의 마지막 comment fetch
		 */
		_getBaseLastComment : function() {
			if ( this._waBaseCommentList.length() == 0) {
				return null;
			}

			return this._waBaseCommentList.get(this._waBaseCommentList.length()-1);
		},

		/**
		 * baseList의 마지막 commentNo fetch
		 */
		getBaseLastCommentNo : function() {
			var htLastComment = this._getBaseLastComment();

			if ( htLastComment == null) {
				return 0;
			}

			return htLastComment.commentNo;
		},

		/**
		 * commentNo에 해당하는 comment 삭제
		 */
		removeComment : function(sCommentNo) {
			if ( sCommentNo == null) {
				return;
			}

			var nIndex = null;

			this._waBaseCommentList = this._getListWithoutTargetComment(this._waBaseCommentList, sCommentNo);
			this._waBottomCommentList = this._getListWithoutTargetComment(this._waBottomCommentList, sCommentNo);
		},

		/**
		 * 특정 list에서 targetComment 제외후 리턴
		 */
		_getListWithoutTargetComment : function(waCommentList, sCommentNo) {
			return waCommentList.filter(
				function(oEach, index, array) {
					if ( oEach.commentNo == sCommentNo) {
						return false;
					}

					return true;
				}
			);
		},

		/**
		 * 기본 정보 reset
		 */
		reset : function() {
			this._waBaseCommentList = J.$A([]);
			this._waBottomCommentList = J.$A([]);

			var htComment = {};
			htComment.commentNo = 'empty';
			htComment.replyLevel = 1;
			htComment.isDeleted = false;

			this._waBottomCommentList.push(htComment);
		},

		/**
		 * BaseList에서 sCommentNo에 해당하는 commentInfo 반환
		 */
		_getBaseCommentInfo : function(sCommentNo) {
			var oComment = null;

			var nIndex = this._getCommentIndex(this._waBaseCommentList, sCommentNo);

			if ( nIndex == null) {
				return null;
			}

			return this._waBaseCommentList.get(nIndex);
		},

		// 해당 commentNo에 해당하는 comment가 BaseCommentList에 있는지?
		_isExistInBaseCommentList : function(sCommentNo) {
			if ( sCommentNo == null || this._getBaseCommentInfo(sCommentNo) == null) {
				return false;
			}

			return true;
		},

		/**
		 * 해당 commentNo에 해당하는 comment가 BottomList에 있는지 여부
		 */
		isExistInBottomCommentList : function(sCommentNo) {
			if ( sCommentNo == null) {
				return false;
			}

			var bExist = false;

			this._waBottomCommentList.forEach(
				function(oEach, index, array) {
					if ( oEach.commentNo == sCommentNo) {
						bExist = true;
						J.$A.Break();
					}
				}
			)

			return bExist;
		},

		/**
		 * BaseList 또는 BottomList에서 CommentNo에 해당하는 commentInfo 반환
		 */
		getCommentInfoFromBaseAndBottom : function(sCommentNo) {
			var oComment = this._getBaseCommentInfo(sCommentNo);

			if ( oComment != null) {
				return oComment;
			}

			this._waBottomCommentList.forEach(
				function(each, index, array) {
					if ( each.commentNo == sCommentNo) {
						oComment = each;
						J.$A.Break();
					}
				}
			);

			return oComment;
		},

		/**
		 * commentNo에 해당하는 comment를 삭제(view에서 제거)할수 있는지 여부
		 */
		canRemoveTargetComment : function(sCommentNo) {
			var htComment = this.getCommentInfoFromBaseAndBottom(sCommentNo);
			var htNextComment = this._getNextSiblingCommentInfo(sCommentNo);

			// 해당 댓글 정보가 없거나, 삭제상태가 아니면 불가
			if ( htComment == null || !htComment.isDeleted ) {
				return false;
			}

			// maxDepth 보다 작고
			// 마지막 페이지가 아닌데, 보이는 영역 마지막 comment이면 삭제 불가
			// 다음 페이지에서 해당 comment의 답글 존재 가능성이 있기 때문.
			if ( htComment.replyLevel < this.config.option('maxDepth') && !this.config.instance.pagearea.isLastPage() && this._isLastBaseCommentNo(sCommentNo)) {
				return false;
			}

			// 해당 comment에 답글이 안달려있으면 삭제 가능
			if ( htNextComment != null && htNextComment.replyLevel > htComment.replyLevel ) {
				return false;
			}

			return true;
		},

		/**
		 * commentNo이전에 위치한 commentInfo를 반환
		 */
		getPreSiblingCommentInfo : function(sCommentNo) {
			var waTargetCommentList = this._findTargetCommentList(sCommentNo);
			var nIndex = this._getCommentIndex(waTargetCommentList, sCommentNo);

			if ( nIndex == null) {
				return null;
			}

			return waTargetCommentList.get(nIndex - 1);
		},

		/**
		 * commentNo 이후에 위치한 commentInfo를 반환
		 */
		_getNextSiblingCommentInfo : function(sCommentNo) {
			var waTargetCommentList = this._findTargetCommentList(sCommentNo);
			var nIndex = this._getCommentIndex(waTargetCommentList, sCommentNo);

			if ( nIndex == null) {
				return null;
			}

			return waTargetCommentList.get(nIndex + 1);
		},

		/**
		 * BaseCommentList의 개수를 반환
		 */
		getBaseCommentCount : function() {
			return this._waBaseCommentList.length();
		},

		/**
		 * BottomList의 가장하단에 연속하여 삭제 마크된 comment 수를 반환
		 * 전체 카운트 계산시 고려.
		 */
		findBottomSequentialDeletedCommentCountFromBase : function() {
			var nCount = 0;

			for (var nIndex = this._waBaseCommentList.length() ; nIndex > 0 ; nIndex--) {
				var htCommentInfo = this._waBaseCommentList.get(nIndex-1);
				if ( !htCommentInfo.isDeleted ) {
					break;
				}

				nCount++;
			}

			return nCount;
		}
	}).extend(J.Component);

	nhn.comment.commentListModel = new Comment.CommentListModel();
})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
 * @(#)nhn.comment.mobile.socialCommentArea.js 2012. 11. 05
 */
(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile,
		Util = Comment.Util;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';
	
	/**
	 * @description 소셜댓글 영역을 처리하는 클래스 
	 */
	Comment.SocialCommentArea = J.$Class({
		/** @lends nhn.comment.mobile.SocialCommentArea.prototype */
		
		/**
		 * @description 초기화 함수
		 * @constructs
		 * @class
		 * @extends jindo.Component
		 */
		$init : function() {
			this._welArea = null;
			
			this.indexInstance = Comment.SocialCommentArea.getInstance().length - 1;
			this.config = Comment.Config.getInstance()[this.indexInstance];
			
			this._initConfig();
		},
		
		/**
		 * @description 소셜댓글 설정 초기화
		 */
		_initConfig : function() {
			this.config.element({
				socialCommentWriteBoxArea : '.__comment_sns'
			});
			
			this.config.template({
				socialCommentWriteBoxArea :				
					'<div class="u_socail __comment_sns">'+
						'<span class="u_socail_ch"><input type="checkbox" name="check1" id="me2day_{=level}" value="미투데이 동시 등록하기" class="chb _me2day {if !isMe2day}disabled{/if} __comment_sns_checkbox()"><label for="me2day_{=level}" class="lbl_me2 c_line c_bak">미투데이 동시 등록하기</label></span>'+
						'<span class="u_socail_ch"><input type="checkbox" name="check2" id="facebook_{=level}" value="페이스북 동시 등록하기" class="chb _facebook {if !isFacebook}disabled{/if} __comment_sns_checkbox()"><label for="facebook_{=level}" class="lbl_facebook c_line c_bak">페이스북 동시 등록하기</label></span>'+
						'<span class="u_socail_ch"><input type="checkbox" name="check3" id="twitter_{=level}" value="트위터 동시 등록하기" class="chb _twitter {if !isTwitter}disabled{/if} __comment_sns_checkbox()"><label for="twitter_{=level}" class="lbl_twitter c_line c_bak">트위터 동시 등록하기</label></span>'+
						//'<span class="u_socail_ch"><input type="checkbox" name="check4" id="yozm_{=level}" value="다음 요즘 동시 등록하기" class="chb _yozm {if !isYozm}disabled{/if} __comment_sns_checkbox()"><label for="yozm_{=level}" class="lbl_yozm c_line c_bak">다음 요즘 동시 등록하기</label></span>'+ // 20130621
						'<span class="u_set"><a href="#" class="u_setting c_line c_bak __comment_sns_config()">SNS 설정</a></span>'+
					'</div>',

				socialCommentListArea :
					'{if \'true\'== isMe2day}<a href="{js jindo.$S((=config.option(\'urlList\').social.redirectSns)).format((=ticket),(=commentNo),\'ME2DAY\')}" {if !isSocialLinkOpen}onclick="return false;"{/if} target="_blank"><span class="ico_socail ico_me2">미투데이 동시 등록</span></a>{/if}' +
					'{if \'true\'== isFacebook}<a href="{js jindo.$S((=config.option(\'urlList\').social.redirectSns)).format((=ticket),(=commentNo),\'FACEBOOK\')}" {if !isSocialLinkOpen}onclick="return false;"{/if} target="_blank"><span class="ico_socail ico_facebook">페이스북 동시 등록</span></a>{/if}' + 
					'{if \'true\'== isTwitter}<a href="{js jindo.$S((=config.option(\'urlList\').social.redirectSns)).format((=ticket),(=commentNo),\'TWITTER\')}" {if !isSocialLinkOpen}onclick="return false;"{/if} target="_blank"><span class="ico_socail twitter">트위터 동시 등록</span></a>{/if}' +
					'{if \'true\'== isYozm}<a href="{js jindo.$S((=config.option(\'urlList\').social.redirectSns)).format((=ticket),(=commentNo),\'YOZM\')}" {if !isSocialLinkOpen}onclick="return false;"{/if} target="_blank"><span class="ico_socail ico_yozm">다음 요즘  동시 등록</span></a>{/if}'
					
			});
			
			this.config.option('nidManageSocialAuthUrl', 'https://nid.naver.com/mobile/user/help/externalAuth.nhn?&menu=nid4'); // 내정보 외부연동 관리 URL
			this.config.option('socialAuthUrl', 'http://nid.naver.com/oauth/idLink.nhn?');	// socialProvider 연동 URL
			this.config.option('useSocialComment', false);	// 소셜댓글 사용여부
			this.config.option('snsAuthStatus', {});		// 소셜댓글 연동 상태
			this.config.option('social', {					// 소셜댓글 nConfig 설정
				active : false,
				link_open : false,
				reply_active : false
			});
			
			var comment = this.config.option('comment');
			comment.push('isMe2day');
			comment.push('isFacebook');
			comment.push('isTwitter');
			comment.push('isYozm');
			comment.push('isSocialLinkOpen');
			this.config.option('comment', comment);
			
			var convention = this.config.option('convention');
			convention.isMe2day = 'is_me2day';
			convention.isFacebook = 'is_facebook';
			convention.isTwitter = 'is_twitter';
			convention.isYozm = 'is_yozm';
			this.config.option('convention', convention);
			
			// 소셜 인증 후 처리하는 함수 attach
			this.config.attach('afterSocialAuth', J.$Fn(this._changeSnsCheckBoxIcon, this).bind());
		},
		
		/**
		 * 소셜 인증 후 처리
		 * 
		 * @param {Hash Table} oOption 
		 */
		_changeSnsCheckBoxIcon : function(oOption) {
			var sSnsName = oOption.sns;
			// 체크박스와 label 가져와서
			var elCheckboxList = J.$$('.__comment_sns input._' + sSnsName);
			
			for ( var i = 0; i < elCheckboxList.length; ++i ) {
				var welCheckbox = J.$Element(elCheckboxList[i]);
				var welLabel = welCheckbox.next();
				welCheckbox.removeClass('disabled');
				welCheckbox.attr('checked','checked');// 체크 처리하고
				welLabel.removeClass('off');	// 아이콘 변경			
				welLabel.addClass('on');
			}			
		},
		
		/**
		 * @description 쓰기 영역에 소셜댓글 영역 HTML 생성
		 * @param bRoot {Boolean} 최상위 댓글 여부(댓글:true, 답글:false)
		 * @returns {String} 소셜댓글 영역 HTML
		 */
		createWriteBoxAreaHtml : function(bRoot) {
			var htSocialConfig = this.config.option('social');
			var bActive = bRoot ? htSocialConfig['active'] : htSocialConfig['reply_active'];	// 댓글/답글 레벨에 따라 소셜댓글 활성 여부를 체크
			// 사용 설정 안됐으면 그냥 반환
			if (!this.config.option('useSocialComment') || !bActive) {				
				return '';
			}
			
			// 소셜댓글 사용하면 HTML 생성해서 반환
					
			if ( !this.config.option('isLogin') ) {
				htSocialComment = new J.$H( { isMe2day:false, isFacebook:false, isTwitter:false, isYozm:false});
				htSocialComment.level = bRoot ? 1 : 2;
				return this.config.template('socialCommentWriteBoxArea').process(htSocialComment.$value());
			} else {
				var htSocialComment = this._getSnsAuthStatus();
				htSocialComment.level = bRoot ? 1 : 2;
				return this.config.template('socialCommentWriteBoxArea').process(htSocialComment);
				
			}
			
		},
		
		/**
		 * @description 댓글 목록 영역에 소셜댓글 아이콘 영역 HTML 생성
		 * @param htOption {HashTable} 댓글 데이터
		 * @returns {String} 소셜댓글 아이콘 영역 HTML
		 */
		createListAreaHtml : function(htOption) {
			var htSocialConfig = this.config.option('social');
			if (this.config.option('useSocialComment') && htSocialConfig['active']
					&& htOption.isMine && (htOption.isMe2day || htOption.isFacebook || htOption.isTwitter || htOption.isYozm)) {
				
				// 답글일 경우, 답글에 소셜댓글 활성화 여부 체크
				if (htOption.replyLevel > 1 && !htSocialConfig['reply_active']) {
					return '';
				}
				
				htOption.isSocialLinkOpen = htSocialConfig['link_open'];
				return this.config.template('socialCommentListArea').process(htOption);
			}
			
			return '';
		},
		
		/**
		 * @description 쓰기 영역에 이벤트 바인딩
		 * @param welTargetSnsArea {WrappingElement} 이벤트 바인딩할 소셜댓글 영역 element
		 */
		createWriteBoxBubbler : function(welTargetSnsArea) {
			if ( welTargetSnsArea == null ) {
				return;
			}
			
			this._oWriteBoxBubbler = new Util.Bubbler(welTargetSnsArea.$value()).attach({
				'__comment_sns_checkbox:click' : J.$Fn(this._onClickSnsCheckBox, this).bind(),
				'__comment_sns_config:click' : J.$Fn(this._onClickSnsConfigBtn, this).bind()
			});

			welTargetSnsArea.preventTapHighlight(true);
		},
		
		/**
		 * @description 소셜댓글 체크박스 체크 상태를 받은 파라미터에 붙여서 반환한다.
		 * @param welForm {WrappingElement} 글쓰기 폼
		 * @param htParam {HashTable} 파라미터 해시 테이블
		 * @returns {HashTable} htParam 받은 파라미터 다시 반환
		 */
		getParams : function(welForm, htParam) {
			if (this.config.option('useSocialComment')) {
				var welCheckboxArea = welForm.query(this.config.element('socialCommentWriteBoxArea'));
				if (welCheckboxArea) {
					// 체크된 SNS를 가져와서 파라미터에 넣는다.
					if (welCheckboxArea.query('input._me2day')) {
						htParam.add_post_me2day = welCheckboxArea.query('input._me2day').attr('checked') ? 'Y' : 'N';
					}
					if (welCheckboxArea.query('input._facebook')) {
						htParam.add_post_facebook = welCheckboxArea.query('input._facebook').attr('checked') ? 'Y' : 'N';
					}
					if (welCheckboxArea.query('input._twitter')) {
						htParam.add_post_twitter = welCheckboxArea.query('input._twitter').attr('checked') ? 'Y' : 'N';
					}
					if (welCheckboxArea.query('input._yozm')) {
						htParam.add_post_yozm = welCheckboxArea.query('input._yozm').attr('checked') ? 'Y' : 'N';
					}
				}
			}
			
			return htParam;
		},
		
		/**
		 * @description SNS 체크박스 클릭
		 * @param oEvent {WrappingEvent} 이벤트 객체
		 */
		_onClickSnsCheckBox : function(oEvent) {
			// 로그인 안했으면 로그인 창 띄우고 끝
			if (!this.config.option('isLogin')) {
				this.config.instance.auth.redirectLogin();
				
				oEvent.stop();
				return;
			}
			
			// 체크박스의 label로 지정된 SNS 아이콘
			var welInput = J.$Element(oEvent.element);
			var welLabel = J.$Element(welInput.next());
			
			if (welInput.tag.toLowerCase() == 'label') {
				welLabel = welInput;
				welInput = J.$Element(welInput.prev());
			}
			
			// 연동 안돼있으면 인증 팝업 띄우기			
			if (welInput.hasClass('disabled')) {
				var sSnsName = welLabel.attr('for').match(/(\w+)_\d+/)[1];	// id패턴 : SNS이름_숫자
				if (sSnsName == 'me2day') {
					// 미투데이는 인증 팝업을 제공하지 않음
					alert('미투데이 아이디 인증이 필요합니다.');
					oEvent.stopDefault();
					return;
				}
				
				//var sSvcUrlTpl = this.config.option('urlList')['social']['afterSocialAuth'];	// 인증 후처리용 URL
				//var sSvcUrl = sSvcUrlTpl.replace(/{SOCIAL_PROVIDER}/, sSnsName);
				var whtParams = J.$H({
					servicekey : 'COMMON_COMMENT',
					type : sSnsName,
					viewtype : 2,
					svcurl : this.config.option('objectUrl')
				});
				
				//네이버앱에서 팝업이 동작하지않아서 페이지 이동으로 변경
				location.href = this.config.option('socialAuthUrl') + whtParams.toQueryString();				
				
				oEvent.stopDefault();
				return;
			}
			
			if ( welLabel.hasClass('on') ) {
				welLabel.removeClass('on');
			} else {
				welLabel.addClass('on');
			}
			
			//oEvent.stopDefault();
		},
		
		/**
		 * @description 설정 링크에 회원쪽 페이지 호출 이벤트 처리
		 * @param oEvent {WrappingEvent} 이벤트 객체
		 */
		_onClickSnsConfigBtn : function(oEvent) {			
			// 로그인 안했으면 로그인 창 띄우고 끝
			if (!this.config.option('isLogin')) {
				this.config.instance.auth.redirectLogin();
				
				oEvent.stop();
				return;
			}
			
			Util.popUp(this.config.option('nidManageSocialAuthUrl'), 'socialComment');
			oEvent.stopDefault();
		},
		
		/**
		 * @description 서버에서 SNS 인증 상태 확인
		 * @returns {HashTable} SNS 인증 상태
		 */
		_getSnsAuthStatus : function() {
			var whtSocialComment = J.$H(this.config.option('snsAuthStatus'));
	    	if (whtSocialComment.length() == 0) {
	    		var htParams = {
    				ticket : this.config.option('ticket')
	    		};
	    			    		
	    		this.config.instance.ajax.call( {
	    			operation : 'snsAuthStatus',
	    			async : false,
	    			onSuccess : J.$Fn(function(oResponse){
	    				var oResult = oResponse['sns_auth_status'];
	    				if (oResult instanceof Array) {
	    					oResult = {};
	    				}
	    				this.config.option('snsAuthStatus', oResult);
	    			}, this).bind(),
	    			param : htParams
	    		});
	    	}
	    	
	    	return this.config.option('snsAuthStatus');
		}

	}).extend(J.Component);
	
	nhn.comment.socialCommentArea = new Comment.SocialCommentArea();
})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
 * @(#)nhn.comment.mobile.recommendDiscommendArea.js 2012. 11. 05
 */
(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile,
		Util = Comment.Util;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';
	
	/**
	 * @description 공감비공감 영역을 처리하는 클래스 
	 */
	Comment.RecommendDiscommendArea = J.$Class({
		/** @lends nhn.comment.mobile.RecommendDiscommendArea.prototype */
		
		/**
		 * @description 초기화 함수
		 * @constructs
		 * @class
		 * @extends jindo.Component
		 */
		$init : function() {
			this._welArea = null;
			
			this.indexInstance = Comment.RecommendDiscommendArea.getInstance().length - 1;
			this.config = Comment.Config.getInstance()[this.indexInstance];
			
			this._initConfig();
		},
		
		/**
		 * @description 공감 비공감 설정 초기화
		 */
		_initConfig : function() {
			this.config.element({
				recommendDiscommendBtnArea : '.__comment_recomm'
			});
			
			this.config.template({
				recommendCommand : '<a href="#" title="공감" class="__comment_rec" commentNo="{=commentNo}"><span class="u_hc">공감</span> <em>{=upCount}</em></a>',
				discommendCommand : '<a href="#" title="비공감" class="__comment_disc" commentNo="{=commentNo}"><span class="u_hc">비공감</span> <em>{=downCount}</em></a>'
					
			});
			
			this.config.option('useRecommendBtn', 0);	// 공감비공감 사용여부 0: 사용안함, 1: 공감만 사용, 2: 공감/비공감 사용
			
		},
		
		/**
		 * @description 댓글 목록 영역에 공감비공감 아이콘 영역 HTML 생성
		 * @param htOption {HashTable} 댓글 데이터
		 * @returns {String} 공감비공감 아이콘 영역 HTML
		 */
		createListAreaHtml : function(htOption) {
			if (htOption.replyLevel > this.config.option('useRecommendBtnLevel')) {
				return '';
			}
			
			var sHtml = this.config.template('recommendCommand').process(htOption);
			
			if (this.config.option('useRecommendBtn') == 0) {
				return '';
			}
			
			if (this.config.option('useRecommendBtn') > 1) {
				
				return this.config.template('recommendCommand').process(htOption) + this.config.template('discommendCommand').process(htOption);
			}
			
			return sHtml;
		},
		
		/**
		 * @description 리스트 영역에 이벤트 바인딩
		 * @param welTargetRecommendArea {WrappingElement} 이벤트 바인딩할 공감비공감 영역 element
		 */
		createListBubbler : function(welTargetRecommendArea) {
			if ( welTargetRecommendArea == null ) {
				return;
			}
					
			J.$Element(welTargetRecommendArea.$value()).delegate(
					"click", 
					".__comment_rec",
					J.$Fn(this._recommendCommand, this).bind()
			);
			
			J.$Element(welTargetRecommendArea.$value()).delegate(
					"click", 
					".__comment_disc",
					J.$Fn(this._discommendCommand, this).bind()
			);

			welTargetRecommendArea.preventTapHighlight(true);
		},
		
		//덧글 공감
		_recommendCommand : function(e) {
			e.stopDefault();
			this.vote('recommend', e.element);
		},
		
		//덧글 비공감
		_discommendCommand : function(e) {	
			e.stopDefault();
			this.vote('discommend', e.element);
		},
		
		//유저공감반영
		vote : function(operation, elClickedBtn) {
			var params = {};
			params.ticket = this.config.option('ticket');
			params.object_id = this.config.option('objectId');
			params.comment_no = J.$Element(elClickedBtn).attr("commentNo");
			if(operation == 'recommend'){
				params.recommend_up_yn = 'Y';
			}else{
				params.recommend_up_yn = 'N';
			}
			
			this.config.instance.ajax.call( {
				operation : 'vote',
				onSuccess : J.$Fn(this._processVote, this).bind(elClickedBtn),
				param : params
			});
			
		},
		
		//공감, 비공감 하고 나서 처리해야하는 부분.
		_processVote : function(elClickedBtn, result) {
			// 숫자 업데이트
			var wElClickedBtn = J.$Element(J.$$.getSingle("em", elClickedBtn));
			var count = Number(wElClickedBtn.text());
			
			wElClickedBtn.text(count + 1);
		}

	}).extend(J.Component);
	
	nhn.comment.recommendDiscommendArea = new Comment.RecommendDiscommendArea();
})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
 * @(#)nhn.comment.mobile.sortListArea.js 2012. 12. 05
 */
(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile,
		Util = Comment.Util;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';
	
	/**
	 * @description 리스트 정렬 영역을 처리하는 클래스 
	 */
	Comment.SortListArea = J.$Class({
		/** @lends nhn.comment.mobile.SortListArea.prototype */
		
		/**
		 * @description 초기화 함수
		 * @constructs
		 * @class
		 * @extends jindo.Component
		 */
		$init : function() {
			this._htSortTypeNameList = J.$H( { newest:'최신순', oldest:'등록순' , recommend:'공감순'} );
			
			this.indexInstance = Comment.SortListArea.getInstance().length - 1;
			this.config = Comment.Config.getInstance()[this.indexInstance];
			
			this._initConfig();
		},
		
		/**
		 * @description 리스트 정렬 영역 초기화
		 */
		_initConfig : function() {
			
			this._welSortAreaRoot = null;
			this.config.element({
				sortArea : '.__sort_area'
			});
			
			this.config.template({
				sortAreaRoot : '<div class="u_sort __sort_area"></div>',
				sortRadioButtonRoot : '<div class="u_sr"></div>',
				sortRadioButtonItem : '<a href="#" class="__sortList" id="{=sortId}">'+
									  '<input type="radio" name="radio" class="u_rio __sortListRadio({=sortId})" value="{=sortName}" id="{=sortId}" {if checked}checked="checked"{/if}>'+
									  '<label for="radio1" id="{=sortId}">{=sortName}</label></a>',
				sortSelectBoxRoot : '<select class="u_sl __sortList"></select>',
				sortSelectBoxItem : '<option value="{=sortId}" {if selected}selected="selected"{/if} >{=sortName}</option>'
			});
			
			this.config.option('useSortList', true); 			
			this.config.option('sortListUiType', 'radio'); 
			this.config.option('currentSortOption', 'newest' ); //해당 정렬 옵션을 기본으로 설정한다
			this.config.option('sortOptionList', ['newest', 'oldest']); //정렬 옵션 LIST {"newest", "oldest", "recommend", "highscore", "lowscore"}
	
		},
		
			
		/**
		 * @description 리스트 정렬 영역 생성
		 * @param 
		 * @returns 
		 */
		createArea : function() {
			
			this._welSortAreaRoot = J.$Element(this.config.template('sortAreaRoot').process());
			
			if ( !this.config.option('useSortList') ) {
				return this._welSortAreaRoot;
			}
			this._welSortAreaRoot.attr('id',this.config.element('focusTarget'));
			
			var sortOptionList = this.config.option('sortOptionList');
			
			if (this.config.option('sortListUiType') == 'select' ) {
				
				var welSortSelectRoot = J.$Element(this.config.template('sortSelectBoxRoot').process());
				
				for ( var i = 0; i < sortOptionList.length; ++i ) {
					var welSelectItem = J.$Element(this.config.template('sortSelectBoxItem').process({ sortId : sortOptionList[i], sortName : this._htSortTypeNameList.$(sortOptionList[i]), selected : this.config.option('currentSortOption') == sortOptionList[i] }));
					welSortSelectRoot.append(welSelectItem);
				}
				
				this._welSortAreaRoot.append(welSortSelectRoot);
				
			} else {					
				var welSortRadioButtonRoot = J.$Element(this.config.template('sortRadioButtonRoot').process());
				
				for ( var i = 0; i < sortOptionList.length; ++i ) {
					var welRadioButton = J.$Element(this.config.template('sortRadioButtonItem').process({ sortId : sortOptionList[i], sortName : this._htSortTypeNameList.$(sortOptionList[i]), checked : this.config.option('currentSortOption') == sortOptionList[i] }));
					welSortRadioButtonRoot.append(welRadioButton);
				}
				this._welSortAreaRoot.append(welSortRadioButtonRoot);	
			}
			
			return this._welSortAreaRoot;
		}, 
		
		/**
		 * @description 리스트 정렬 영역 갱신
		 * @param 
		 * @returns 
		 */
		resetArea : function() {
			if ( !this.config.option('useSortList') ) {
				return;
			}

			var welSortAreaRoot = this.getAreaElement();
			if( welSortAreaRoot == null) {
				return;
			}
			
			var sortOptionList = this.config.option('sortOptionList');
			
			if (this.config.option('sortListUiType') == 'select' ) {
				
				var welSortSelectRoot = J.$Element(this.config.template('sortSelectBoxRoot').process());
				
				for ( var i = 0; i < sortOptionList.length; ++i ) {
					var welSelectItem = J.$Element(this.config.template('sortSelectBoxItem').process({ sortId : sortOptionList[i], sortName : this._htSortTypeNameList.$(sortOptionList[i]), selected : this.config.option('currentSortOption') == sortOptionList[i] }));
					welSortSelectRoot.append(welSelectItem);
				}
				welSortAreaRoot.empty();
				welSortAreaRoot.append(welSortSelectRoot);
				
			} else {					
				var welSortRadioButtonRoot = J.$Element(this.config.template('sortRadioButtonRoot').process());
				
				for ( var i = 0; i < sortOptionList.length; ++i ) {
					var welRadioButton = J.$Element(this.config.template('sortRadioButtonItem').process({ sortId : sortOptionList[i], sortName : this._htSortTypeNameList.$(sortOptionList[i]), checked : this.config.option('currentSortOption') == sortOptionList[i] }));
					welSortRadioButtonRoot.append(welRadioButton);
				}
				welSortAreaRoot.empty();
				welSortAreaRoot.append(welSortRadioButtonRoot);	
			}
		}, 
		
		/**
		 * @description 이벤트를 바인딩한다.
		 */
		_createBubbler : function() {
			if (this.config.option('sortListUiType') == 'select' ) {
				this._oBubbler = new Util.Bubbler(this.getAreaElement().$value()).attach({
					'__sortList:change' : J.$Fn(this._onClickSelectSort, this).bind()
				});
			
			}else{			
			
				this._oBubbler = new Util.Bubbler(this.getAreaElement().$value()).attach({
					'__sortList:click' : J.$Fn(this._onClickRadioSort, this).bind()
				});
			}

			this.getAreaElement().preventTapHighlight(true);
		},
		
		getAreaElement : function() {
			return this._welSortAreaRoot;
		},
		
		/**
		 * @description 영역 생성 후..
		 */
		afterCreateArea : function() {
			this._createBubbler();
		},
		
		_onClickRadioSort : function(oEvent) {
			oEvent.stopDefault();
			var sortId = J.$Element(oEvent.element).attr('id');
			this.config.option('currentSortOption', sortId );
			this.config.instance.listarea.refresh(false);
			this.config.instance.listarea.setFocusList();
		},
		
		_onClickSelectSort : function(oEvent) {
			
			this.config.option('currentSortOption', oEvent.element.value );
			this.config.instance.listarea.refresh();
		}

		
	

	}).extend(J.Component);
	
	nhn.comment.sortListArea = new Comment.SortListArea();
})();
nhn = (typeof nhn !== "undefined") ? nhn : {};
nhn.comment = nhn.comment || {};
nhn.comment.mobile = nhn.comment.mobile || {};

/**
 * @(#)nhn.comment.mobile.listFooterArea.js 2012. 12. 05
 */
(function() {
	var J = window.nhn.comment.mobile.jindo || jindo,
		Comment = nhn.comment.mobile,
		Util = Comment.Util;

	nhn.comment.mobile.NAME = 'nhn.comment.mobile';
	nhn.comment.mobile.VERSION = '1.0.0.${svn.revision}';
	
	/**
	 * @description Listv1 타입에서 리스트 하단의 영역을 관리하는 클래스
	 */
	Comment.ListFooterArea = J.$Class({
		/** @lends nhn.comment.mobile.ListFooterArea.prototype */
		
		/**
		 * @description 초기화 함수
		 * @constructs
		 * @class
		 * @extends jindo.Component
		 */
		$init : function() {
			
			this.indexInstance = Comment.ListFooterArea.getInstance().length - 1;
			this.config = Comment.Config.getInstance()[this.indexInstance];
			
			this._initConfig();
		},
		
		/**
		 * @description 리스트 하단 영역 초기화
		 */
		_initConfig : function() {
			
			this.config.template({
				commentListFooterRoot :
					'<div class="u_comment_lst_count"></div>',
				commentListLink :
					'<a href="{=url}" ><span class="c_fnt"><em> {=count} </em> 개 댓글 전체보기</span></a>'
			});
			
			this.config.option('viewAllLinkUrl', "#");
	
		},
		
			
		/**
		 * @description 리스트 하단 영역 생성
		 * @param 
		 * @returns 
		 */
		createArea : function() {
			
			this.welRoot = J.$Element(this.config.template('commentListFooterRoot').process());
			
			return this.welRoot;
		},
		
		update : function(nTotalCount) {
			if ( this.welRoot == null ) {
				return;
			}
			var welLinkArea = J.$Element(this.config.template('commentListLink').process({ url : this.config.option('viewAllLinkUrl'), count : nTotalCount }));
			
			this.welRoot.empty();
			if ( nTotalCount > 0 ) {
				this.welRoot.append(welLinkArea);
			}
		},
		
		afterCreateArea : function() {
			
		}
		
	

	}).extend(J.Component);
	
	nhn.comment.listFooterArea = new Comment.ListFooterArea();
})();
